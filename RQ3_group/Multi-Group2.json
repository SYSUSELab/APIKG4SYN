[
  {
    "instruction": "Implement a task scheduler that uses the `executePeriodically` method of `taskpool` (from @kit.ArkTS) to run a recurring task, and then uses the `removeByIndex` method of `ArrayList<object>` (from @kit.ArkTS) to clean up completed tasks from a shared task list.",
    "output": "import {taskpool, ArrayList, EventTarget} from '@kit.ArkTS';\n\nexport class TaskScheduler {\n  private taskList: ArrayList<object> = new ArrayList<object>();\n  private eventTarget: EventTarget = new EventTarget();\n\n  public scheduleTask(task: object, interval: number, priority: taskpool.Priority): void {\n    const taskId = taskpool.executePeriodically(task, interval, priority);\n    this.taskList.add(taskId);\n  }\n\n  public cleanupCompletedTasks(): void {\n    for (let i = this.taskList.length - 1; i >= 0; i--) {\n      const taskId = this.taskList.get(i);\n      if (taskpool.getTaskPoolInfo(taskId).state === taskpool.State.FINISHED) {\n        this.taskList.removeByIndex(i);\n      }\n    }\n  }\n\n  public addEventListener(type: string, listener: (event: object) => void): void {\n    this.eventTarget.addEventListener(type, listener);\n  }\n\n  public removeEventListener(type: string, listener: (event: object) => void): void {\n    this.eventTarget.removeEventListener(type, listener);\n  }\n\n  public dispatchEvent(event: object): void {\n    this.eventTarget.dispatchEvent(event);\n  }\n}"
  },
  {
    "instruction": "Create a function that utilizes the `getEnvironmentVar` method of `process` to fetch an environment variable, then checks if the variable exists using the `has` method of `PlainArray`. If it exists, update its value in the `PlainArray` using the `setValueAt` method; otherwise, add it using the `add` method.",
    "output": "import {process, PlainArray} from '@kit.ArkTS';\n\nexport function updateOrAddEnvVar(envVarName: string, plainArray: PlainArray<number, string>): void {\n  const envVarValue = process.getEnvironmentVar(envVarName);\n  if (envVarValue !== undefined) {\n    const index = plainArray.getIndexOfKey(envVarName);\n    if (index !== -1) {\n      plainArray.setValueAt(index, envVarValue);\n    } else {\n      plainArray.add(envVarName, envVarValue);\n    }\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `alloc` method of `buffer` to create a buffer of a specified size, then uses the `add` method of `Vector` to populate the buffer with random bytes, and finally uses the `byteLength` method of `buffer` to verify the buffer's length matches the expected size.",
    "output": "import {buffer, Vector} from '@kit.ArkTS';\n\nexport function createAndVerifyBuffer(size: number): boolean {\n  const buf = buffer.alloc(size);\n  const vec = new Vector<number>();\n  \n  for (let i = 0; i < size; i++) {\n    vec.add(Math.floor(Math.random() * 256));\n  }\n  \n  for (let i = 0; i < size; i++) {\n    buf[i] = vec.get(i);\n  }\n  \n  return buffer.byteLength(buf) === size;\n}"
  },
  {
    "instruction": "Write a function that uses the `parse` method of `json` to convert a JSON string into an object, then uses the `add` and `get` methods of `Vector` to store and retrieve specific values from the parsed object.",
    "output": "import {json, Vector} from '@kit.ArkTS';\n\nexport function parseAndStoreJSON(jsonString: string, keys: string[]): Vector<string> {\n  const parsedObject = json.parse(jsonString);\n  const vector = new Vector<string>();\n  \n  for (const key of keys) {\n    if (parsedObject[key] !== undefined) {\n      vector.add(parsedObject[key]);\n    }\n  }\n  \n  return vector;\n}\n\nexport function getValuesFromVector(vector: Vector<string>, indices: number[]): string[] {\n  const values: string[] = [];\n  \n  for (const index of indices) {\n    if (index >= 0 && index < vector.length) {\n      values.push(vector.get(index));\n    }\n  }\n  \n  return values;\n}"
  },
  {
    "instruction": "Create a function that collects the system environment variables using `process.getEnvironmentVar` and stores them in a `LightWeightMap` where the keys are the variable names and the values are the variable values. Use `LightWeightMap.forEach` to iterate over the entries and log each key-value pair to the console.",
    "output": "import {process, LightWeightMap} from '@kit.ArkTS';\n\nexport function collectAndLogEnvironmentVars(): void {\n  const envVars = new LightWeightMap<string, string>();\n  const env = process.getEnvironmentVar();\n  \n  for (const key in env) {\n    if (Object.prototype.hasOwnProperty.call(env, key)) {\n      envVars.set(key, env[key]);\n    }\n  }\n  \n  envVars.forEach((value: string, key: string) => {\n    console.log(`Key: ${key}, Value: ${value}`);\n  });\n}"
  },
  {
    "instruction": "Implement a function that uses `LightWeightSet.forEach` (from @kit.ArkTS) to iterate over a set of values and dispatch a custom event for each value using `EventTarget.dispatchEvent` (from @kit.ArkTS). The function should also use a `Stack` (from @kit.ArkTS) to keep track of the order of dispatched events by pushing each event type into the stack with the `push` method. The function should return the stack's contents using the `toArray` method of `LightWeightSet` (from @kit.ArkTS) to convert the stack into an array.",
    "output": "import {LightWeightSet, Stack, EventTarget} from '@kit.ArkTS';\n\nexport function dispatchEventsAndTrackOrder(eventTarget: EventTarget, values: LightWeightSet<string>): Array<string> {\n  const stack = new Stack<string>();\n  \n  values.forEach((value: string) => {\n    const event = { type: value };\n    eventTarget.dispatchEvent(event);\n    stack.push(value);\n  });\n  \n  return stack.toArray();\n}"
  },
  {
    "instruction": "Create a function that iterates over the keys of a `TreeMap` using the `keys` method, collects these keys into a `Vector` using the `add` method, and then sorts the `Vector` in ascending order using the `sort` method. Finally, return the sorted `Vector`.",
    "output": "import {url, Vector, TreeMap} from '@kit.ArkTS';\n\nexport function collectAndSortKeys(treeMap: TreeMap<number, unknown>): Vector<number> {\n  const keysVector = new Vector<number>();\n  const keysIter = treeMap.keys();\n  \n  for (const key of keysIter) {\n    keysVector.add(key);\n  }\n  \n  keysVector.sort((a: number, b: number) => a - b);\n  return keysVector;\n}"
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of event names, then iterates through the stack using `[Symbol.iterator]`, and dispatches each event using the `dispatchEvent` method of `EventTarget` (from @kit.ArkTS). The function should return the number of events successfully dispatched.",
    "output": "import {EventTarget, LightWeightMap, Stack} from '@kit.ArkTS';\n\nexport function dispatchEvents(eventNames: string[]): number {\n  const stack = new Stack<string>();\n  const eventTarget = new EventTarget();\n  \n  for (const name of eventNames) {\n    stack.push(name);\n  }\n  \n  let dispatchedCount = 0;\n  \n  for (const eventName of stack) {\n    const event = { type: eventName };\n    if (eventTarget.dispatchEvent(event)) {\n      dispatchedCount++;\n    }\n  }\n  \n  return dispatchedCount;\n}"
  },
  {
    "instruction": "Create a function that first populates a `HashSet` with unique user IDs using its `add` method, then checks for duplicates in a `PlainArray` of user activities using the `has` method of `HashSet`, and finally logs the duplicate activities by iterating through the `PlainArray` using its `getValueAt` method.",
    "output": "import {PlainArray, HashSet, taskpool} from '@kit.ArkTS';\n\nexport function findDuplicateActivities(userIds: number[], activities: PlainArray<number, string>): void {\n  const userIdSet = new HashSet<number>();\n  \n  // Populate HashSet with unique user IDs\n  for (const userId of userIds) {\n    userIdSet.add(userId);\n  }\n  \n  const duplicateActivities: string[] = [];\n  \n  // Check for duplicates in PlainArray\n  for (let i = 0; i < activities.length; i++) {\n    const activity = activities.getValueAt(i);\n    const userId = activities.getKeyAt(i);\n    \n    if (userIdSet.has(userId)) {\n      duplicateActivities.push(activity);\n    }\n  }\n  \n  // Log duplicate activities\n  console.log('Duplicate Activities:', duplicateActivities);\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `List` to iterate over its elements and dispatch a custom event for each element using the `dispatchEvent` method of `WorkerEventTarget`. The event listener should collect all dispatched events into a new `List` using its `add` method and return the final list.",
    "output": "import {WorkerEventTarget, List} from '@kit.ArkTS';\n\nexport function dispatchEventsToList(eventTarget: WorkerEventTarget, list: List<number>): List<string> {\n  const eventList: List<string> = new List();\n  \n  list.forEach((element: number) => {\n    const event = { type: 'customEvent', data: element.toString() };\n    eventTarget.dispatchEvent(event);\n  });\n  \n  eventTarget.addEventListener('customEvent', (event: { type: string, data: string }) => {\n    eventList.add(event.data);\n  });\n  \n  return eventList;\n}"
  },
  {
    "instruction": "Create a function that first populates a `PlainArray` with a sequence of numbers using its `add` method, then transfers these values to a `LightWeightMap` using its `set` method, where the keys are the indices from the `PlainArray`. Use the `entries` method of `LightWeightMap` to retrieve and print all key-value pairs.",
    "output": "import {stream, LightWeightMap, PlainArray} from '@kit.ArkTS';\n\nexport function transferPlainArrayToLightWeightMap(): void {\n  const plainArray = new PlainArray<number>();\n  const lightWeightMap = new LightWeightMap<number, number>();\n\n  // Populate PlainArray with numbers\n  for (let i = 0; i < 5; i++) {\n    plainArray.add(i, i * 10);\n  }\n\n  // Transfer values to LightWeightMap\n  for (let i = 0; i < plainArray.length; i++) {\n    const key = plainArray.getKeyAt(i);\n    const value = plainArray.getValueAt(i);\n    if (key !== undefined && value !== undefined) {\n      lightWeightMap.set(key, value);\n    }\n  }\n\n  // Print all key-value pairs using entries\n  const iterator = lightWeightMap.entries();\n  let entry = iterator.next();\n  while (!entry.done) {\n    const [key, value] = entry.value;\n    console.log(`Key: ${key}, Value: ${value}`);\n    entry = iterator.next();\n  }\n}"
  },
  {
    "instruction": "Create a function that uses the `promisify` method of `util` to convert a callback-based function into a promise, then use the `postMessage` method of `DedicatedWorkerGlobalScope` to send the resolved promise result to a dedicated worker. The worker should handle the message using its `onmessage` property.",
    "output": "import {util, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function promisifyAndPostMessage(\n  callbackBasedFunc: (arg: string, callback: (error: Error | null, result: string) => void) => void,\n  arg: string,\n  worker: DedicatedWorkerGlobalScope\n): void {\n  const promisifiedFunc = util.promisify(callbackBasedFunc);\n  promisifiedFunc(arg)\n    .then((result: string) => {\n      worker.postMessage(result);\n    })\n    .catch((error: Error) => {\n      worker.postMessage({ error: error.message });\n    });\n}\n\nexport function setupWorkerMessageHandler(worker: DedicatedWorkerGlobalScope, handler: (message: string) => void): void {\n  worker.onmessage = (event: MessageEvent<string>) => {\n    handler(event.data);\n  };\n}"
  },
  {
    "instruction": "Write a function that uses the `popFirst` method of `Deque` to process a queue of tasks, and for each task, checks if it has been completed (using `has` method of `HashSet`). If not completed, add it to the `HashSet` using `add` and log the task. Repeat until the `Deque` is empty (checked via `length` property).",
    "output": "import {Deque, HashSet} from '@kit.ArkTS';\n\nexport function processTasks(taskQueue: Deque<string>, completedTasks: HashSet<string>): void {\n  while (taskQueue.length > 0) {\n    const task = taskQueue.popFirst();\n    if (task && !completedTasks.has(task)) {\n      completedTasks.add(task);\n      console.log(task);\n    }\n  }\n}"
  },
  {
    "instruction": "Implement a function that uses `taskpool.executePeriodically` to run a task every 2 seconds, and uses `GlobalScope.name` to log the task's execution time along with the global scope's name. The function should stop the periodic task after 10 seconds using `taskpool.cancel`.",
    "output": "import {GlobalScope, taskpool} from '@kit.ArkTS';\n\nexport function executePeriodicTask(): void {\n  const task: taskpool.CallbackFunction = () => {\n    console.log(`Task executed at ${new Date().toISOString()} in scope: ${GlobalScope.name}`);\n  };\n\n  const taskId = taskpool.executePeriodically(task, 2000);\n\n  setTimeout(() => {\n    taskpool.cancel(taskId);\n    console.log('Periodic task stopped after 10 seconds');\n  }, 10000);\n}"
  },
  {
    "instruction": "Create a function that first uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list, then uses the `insert` method of another `LinkedList` to add these elements at specific positions in a second list, and finally returns the modified list using the `clone` method to ensure immutability.",
    "output": "import {uri, LinkedList, LinkedList} from '@kit.ArkTS';\n\nexport function modifyLinkedList(sourceList: LinkedList<unknown>, targetList: LinkedList<unknown>, firstPos: number, lastPos: number): LinkedList<unknown> {\n  const firstElement = sourceList.getFirst();\n  const lastElement = sourceList.getLast();\n  \n  const clonedList = targetList.clone();\n  clonedList.insert(firstPos, firstElement);\n  clonedList.insert(lastPos, lastElement);\n  \n  return clonedList;\n}"
  },
  {
    "instruction": "Write a function that first uses the `getHash` method of `util` to compute the hash of a given string, then uses the `errnoToString` method of `util` to check for any errors during the hash computation, and finally passes the resulting hash to a worker thread (using `worker` API) for further processing or validation.",
    "output": "import {worker, util} from '@kit.ArkTS';\n\nexport function processStringWithHash(input: string): void {\n  const hashResult = util.getHash(input);\n  const errorString = util.errnoToString(hashResult.errno);\n  \n  if (errorString !== 'Success') {\n    throw new Error(`Hash computation failed: ${errorString}`);\n  }\n  \n  const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n  workerInstance.postMessage(hashResult.hash);\n  \n  workerInstance.onmessage = (message: worker.MessageEvents): void => {\n    console.log(`Worker response: ${message.data}`);\n    workerInstance.terminate();\n  };\n  \n  workerInstance.onerror = (error: worker.ErrorEvent): void => {\n    console.error(`Worker error: ${error.message}`);\n    workerInstance.terminate();\n  };\n}"
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a unique identifier, then stores this UUID as a key in a `TreeMap` along with a corresponding value using the `set` method. Finally, use the `getFirstKey` method of `TreeMap` to retrieve and return the first UUID key added to the map.",
    "output": "import {util, TreeMap} from '@kit.ArkTS';\n\nexport function storeAndRetrieveFirstUUID(): string {\n  const uuid = util.generateRandomUUID();\n  const treeMap = new TreeMap<string, string>();\n  treeMap.set(uuid, 'value');\n  return treeMap.getFirstKey();\n}"
  },
  {
    "instruction": "Create a function that first uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list of XML event types (from `xml.EventType`), then uses the `uri` API to construct a URI string by combining these event types as query parameters (e.g., `?first=EVENT_TYPE1&last=EVENT_TYPE2`).",
    "output": "import {uri, LinkedList, xml} from '@kit.ArkTS';\n\nexport function constructUriFromEventTypes(eventList: LinkedList<xml.EventType>): string {\n  const firstEvent: xml.EventType | undefined = eventList.getFirst();\n  const lastEvent: xml.EventType | undefined = eventList.getLast();\n  \n  let uriString = '?';\n  if (firstEvent !== undefined) {\n    uriString += `first=${firstEvent}`;\n  }\n  if (lastEvent !== undefined) {\n    if (firstEvent !== undefined) {\n      uriString += '&';\n    }\n    uriString += `last=${lastEvent}`;\n  }\n  \n  return uriString;\n}"
  },
  {
    "instruction": "Write a function that uses the `getSubList` method of `List` to extract a sublist of elements, then passes this sublist to the `addFirst` method of `LinkedList` to prepend it to an existing `LinkedList`, and finally uses the `forEach` method of `LinkedList` to print all elements.",
    "output": "import {LinkedList, List} from '@kit.ArkTS';\n\nexport function processSublistAndLinkedList(sourceList: List<number>, start: number, end: number, targetLinkedList: LinkedList<number>): void {\n  const subList = sourceList.getSubList(start, end);\n  targetLinkedList.addFirst(subList);\n  targetLinkedList.forEach((value: number) => {\n    console.log(value);\n  });\n}"
  },
  {
    "instruction": "Write a function that creates a worker using `WorkerOptions` with a specified `name` property, then listens for a `MessageEvent` from the worker and extracts the `data` property from the event to process the received message.",
    "output": "import {WorkerOptions, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function createWorkerWithName(scriptURL: string, name: string, callback: (data: string) => void): void {\n  const options: WorkerOptions = {\n    name: name\n  };\n  const worker = new Worker(scriptURL, options);\n  worker.onmessage = (event: MessageEvents) => {\n    const messageEvent = event as MessageEvent<string>;\n    callback(messageEvent.data);\n  };\n}"
  },
  {
    "instruction": "Create a function that uses the `getValueAt` method of `LightWeightSet` to retrieve values from a set of XML attributes stored in the set, then uses the `entries` method of `LightWeightSet` to iterate over these values, and finally passes each value to the `EventType` enum of `xml` to determine and return the corresponding event type for each attribute value.",
    "output": "import {xml, LightWeightSet} from '@kit.ArkTS';\n\nexport function getEventTypesFromAttributes(attributeSet: LightWeightSet<string>): xml.EventType[] {\n  const eventTypes: xml.EventType[] = [];\n  \n  for (let i = 0; i < attributeSet.length; i++) {\n    const value = attributeSet.getValueAt(i);\n    const eventType = xml.EventType[value as keyof typeof xml.EventType];\n    if (eventType !== undefined) {\n      eventTypes.push(eventType);\n    }\n  }\n  \n  return eventTypes;\n}\n\nexport function iterateWithEntries(attributeSet: LightWeightSet<string>): xml.EventType[] {\n  const eventTypes: xml.EventType[] = [];\n  \n  for (const [value] of attributeSet.entries()) {\n    const eventType = xml.EventType[value as keyof typeof xml.EventType];\n    if (eventType !== undefined) {\n      eventTypes.push(eventType);\n    }\n  }\n  \n  return eventTypes;\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to store a sequence of error messages, then iterates through the list using `forEach` to create an `ErrorEvent` object for each message (using the `message` property) and logs the `filename` and `lineno` properties of each error event.",
    "output": "import {ErrorEvent, LinkedList} from '@kit.ArkTS';\n\nexport function logErrorEvents(messages: string[]): void {\n  const errorList: LinkedList<string> = new LinkedList<string>();\n  \n  messages.forEach((message: string) => {\n    errorList.add(message);\n  });\n  \n  errorList.forEach((message: string) => {\n    const errorEvent: ErrorEvent = new ErrorEvent('error', {\n      message: message,\n      filename: 'script.js',\n      lineno: 1\n    });\n    \n    console.log(`Filename: ${errorEvent.filename}, Line: ${errorEvent.lineno}`);\n  });\n}"
  },
  {
    "instruction": "Implement a function that listens for errors using the `onerror` property of `WorkerGlobalScope`. When an error occurs, the function should use the `add` method of `LinkedList` to log the error message and then use the `removeEventListener` method of `WorkerEventTarget` to clean up any existing error listeners. The function should return the `LinkedList` containing all logged error messages.",
    "output": "import {LinkedList, WorkerEventTarget, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function listenAndLogErrors(workerScope: WorkerGlobalScope): LinkedList<string> {\n  const errorList: LinkedList<string> = new LinkedList();\n\n  const errorHandler = (error: ErrorEvent) => {\n    errorList.add(error.message);\n    (workerScope as unknown as WorkerEventTarget).removeEventListener('error', errorHandler);\n  };\n\n  workerScope.onerror = errorHandler;\n\n  return errorList;\n}"
  },
  {
    "instruction": "Implement a function that sets up a worker using `WorkerOptions` with a custom `name`, posts a message to the worker, and then uses the `data` property of `MessageEvent` to handle and display the worker's response in the main thread.",
    "output": "import {WorkerOptions, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function setupWorker(): void {\n  const workerOptions: WorkerOptions = {\n    name: 'customWorker'\n  };\n\n  const worker = new Worker('workers/worker.ts', workerOptions);\n\n  worker.postMessage('Hello from main thread');\n\n  worker.onmessage = (event: MessageEvents) => {\n    const messageData: string = event.data;\n    console.log(`Worker response: ${messageData}`);\n  };\n}\n\nexport function handleWorkerMessage(event: MessageEvent<string>): void {\n  const messageData: string = event.data;\n  console.log(`Received message from worker: ${messageData}`);\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `TreeSet` to store a collection of unique timestamps, then uses the `getFirstValue` and `getLastValue` methods of `TreeSet` to determine the earliest and latest timestamps. Finally, pass these timestamps to the `set` method of `TreeMap` to map the earliest timestamp to 'start' and the latest timestamp to 'end'.",
    "output": "import {TreeSet, TreeMap, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function mapTimestamps(timestamps: number[]): TreeMap<number, string> {\n  const timestampSet = new TreeSet<number>();\n  \n  // Add all timestamps to the TreeSet (automatically handles uniqueness)\n  timestamps.forEach((timestamp) => {\n    timestampSet.add(timestamp);\n  });\n  \n  // Get the earliest and latest timestamps\n  const earliest = timestampSet.getFirstValue();\n  const latest = timestampSet.getLastValue();\n  \n  // Create a TreeMap and map the timestamps\n  const timestampMap = new TreeMap<number, string>();\n  timestampMap.set(earliest, 'start');\n  timestampMap.set(latest, 'end');\n  \n  return timestampMap;\n}"
  },
  {
    "instruction": "Create a function that uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list, then uses the `addEventListener` method of `WorkerEventTarget` to listen for custom events named after these elements. The function should return the `LinkedList` length after the listeners are added.",
    "output": "import {WorkerEventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function setupEventListeners(list: LinkedList<string>, eventTarget: WorkerEventTarget): number {\n  const firstElement = list.getFirst();\n  const lastElement = list.getLast();\n\n  eventTarget.addEventListener(firstElement, () => {});\n  eventTarget.addEventListener(lastElement, () => {});\n\n  return list.length;\n}"
  },
  {
    "instruction": "Implement a function that uses the `getIndexOf` method of `ArrayList<string>` (from @kit.ArkTS) to find the position of a specific XML event name in the list, then uses the `removeEventListener` method of `EventTarget` (from @kit.ArkTS) to unregister the event at that index. The function should also use the `trimToCurrentLength` method of `ArrayList` to optimize the list storage after removal.",
    "output": "import {ArrayList, xml, EventTarget} from '@kit.ArkTS';\n\nexport function unregisterEvent(eventList: ArrayList<string>, eventName: string, target: EventTarget): void {\n  const index: number = eventList.getIndexOf(eventName);\n  if (index !== -1) {\n    target.removeEventListener(eventName);\n    eventList.removeByIndex(index);\n    eventList.trimToCurrentLength();\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `LightWeightSet` to store a collection of `MessageEvent` objects, then iterates over the set using the `Symbol.iterator` method to extract the `data` property from each `MessageEvent` and stores the results in an array using the `toArray` method of `LightWeightSet`.",
    "output": "import {MessageEvent, LightWeightSet} from '@kit.ArkTS';\n\nexport function processMessageEvents(events: MessageEvent<string>[]): string[] {\n  const set = new LightWeightSet<MessageEvent<string>>();\n  \n  events.forEach(event => {\n    set.add(event);\n  });\n  \n  const dataArray: string[] = [];\n  for (const event of set) {\n    dataArray.push(event.data);\n  }\n  \n  return set.toArray().map(event => event.data);\n}"
  },
  {
    "instruction": "Write a function that uses the `self` property of `WorkerGlobalScope` to access the worker's global scope, then sends a message containing the worker's `name` property to the main thread using the `data` property of `MessageEvents`.",
    "output": "import {WorkerGlobalScope, MessageEvents} from '@kit.ArkTS';\n\nexport function sendWorkerNameToMainThread(): void {\n  const workerScope: WorkerGlobalScope = self as WorkerGlobalScope;\n  const message: MessageEvents = new MessageEvent('message', {\n    data: workerScope.name\n  });\n  workerScope.postMessage(message.data);\n}"
  },
  {
    "instruction": "Write a function that uses the `get` and `length` properties of `List` to extract all elements, then passes them to the `add` method of `Vector` to create a new dynamic collection. Finally, use the `sort` method of `Vector` to arrange the elements in ascending order.",
    "output": "import {uri, List, Vector} from '@kit.ArkTS';\n\nexport function listToSortedVector(list: List<number>): Vector<number> {\n  const vector = new Vector<number>();\n  for (let i = 0; i < list.length; i++) {\n    vector.add(list.get(i));\n  }\n  vector.sort((a, b) => a - b);\n  return vector;\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `HashSet` to iterate over a collection of worker tasks, and for each task, uses the `self` property of `WorkerGlobalScope` to post a message back to the main thread with the task's completion status.",
    "output": "import {WorkerGlobalScope, HashSet} from '@kit.ArkTS';\n\nexport function processWorkerTasks(tasks: HashSet<string>, workerScope: WorkerGlobalScope): void {\n  tasks.forEach((task: string) => {\n    workerScope.self.postMessage({ status: 'completed', task: task });\n  });\n}"
  },
  {
    "instruction": "Write a function that first uses the `getUidForName` method of `process` to retrieve the UID for a given process name, and then uses the `isAppUid` method of `process` to verify if the retrieved UID belongs to an application process. Return a boolean indicating the result.",
    "output": "import {process} from '@kit.ArkTS';\n\nexport function isAppProcess(processName: string): boolean {\n  const uid = process.getUidForName(processName);\n  return process.isAppUid(uid);\n}"
  },
  {
    "instruction": "Implement a function that uses `util.printf` to format a log message with dynamic values, stores the formatted message in a deque using `Deque.insertFront`, then checks if the deque contains the message using `Deque.has`, and finally converts the deque to a JSON object using `json.stringify` for storage.",
    "output": "import {json, util, Deque} from '@kit.ArkTS';\n\nexport function formatAndStoreLogMessage(message: string, ...values: string[]): string {\n  const formattedMessage = util.printf(message, ...values);\n  const deque = new Deque<string>();\n  deque.insertFront(formattedMessage);\n  const containsMessage = deque.has(formattedMessage);\n  if (!containsMessage) {\n    throw new Error('Message not found in deque');\n  }\n  const jsonObject = {\n    message: formattedMessage,\n    dequeLength: deque.length\n  };\n  return json.stringify(jsonObject);\n}"
  },
  {
    "instruction": "Create a function that dynamically generates a Worker script URL using the `url` API, then initializes a shared Worker by passing this URL along with the `shared` property set to `true` in the `WorkerOptions` API. The function should verify that the Worker is correctly initialized as a shared worker before returning it.",
    "output": "import {WorkerOptions, url} from '@kit.ArkTS';\n\nexport function createSharedWorker(scriptPath: string): Worker {\n  const scriptUrl = new url.URL(scriptPath);\n  const options: WorkerOptions = {\n    shared: true\n  };\n  const worker = new Worker(scriptUrl.toString(), options);\n  return worker;\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Deque` to iterate over a sequence of `Event` objects, extracts the `type` property of each `Event`, and then uses the `add` method of `LightWeightSet` to build a unique set of event types. Finally, use the `values` method of `LightWeightSet` to return an iterator of these unique event types.",
    "output": "import {LightWeightSet, Event, Deque} from '@kit.ArkTS';\n\nexport function getUniqueEventTypes(events: Deque<Event>): IterableIterator<string> {\n  const uniqueTypes = new LightWeightSet<string>();\n  events.forEach((event: Event) => {\n    uniqueTypes.add(event.type);\n  });\n  return uniqueTypes.values();\n}"
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a Buffer from a string, then uses `process.getUidForName` to get the UID of a process name, and finally stores the UID and the Buffer in a `LightWeightMap` using `set` method. The function should return the LightWeightMap containing the UID-Buffer pair.",
    "output": "import {LightWeightMap, process, buffer} from '@kit.ArkTS';\n\nexport function storeUidAndBuffer(processName: string, inputString: string): LightWeightMap<number, buffer.Buffer> {\n  const uid = process.getUidForName(processName);\n  const buf = buffer.from(inputString);\n  const map = new LightWeightMap<number, buffer.Buffer>();\n  map.set(uid, buf);\n  return map;\n}"
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to asynchronously generate a list of random numbers, then passes the result to the `sort` method of `List` to arrange the numbers in ascending order, and finally uses the `getFirstValue` method of `TreeSet` to retrieve the smallest value from the sorted list.",
    "output": "import {taskpool, List, TreeSet} from '@kit.ArkTS';\n\nexport async function getSmallestRandomNumber(count: number): Promise<number> {\n  const randomNumbers = await taskpool.execute(() => {\n    const list = new List<number>();\n    for (let i = 0; i < count; i++) {\n      list.add(Math.random());\n    }\n    list.sort((a, b) => a - b);\n    return list;\n  }, taskpool.Priority.LOW);\n\n  const treeSet = new TreeSet<number>();\n  for (let i = 0; i < randomNumbers.length; i++) {\n    treeSet.add(randomNumbers.get(i));\n  }\n  return treeSet.getFirstValue();\n}"
  },
  {
    "instruction": "Write a function that first uses the `getEnvironmentVar` method of `process` to retrieve the value of an environment variable, then encodes the retrieved value using the `from` method of `buffer` with UTF-8 encoding, and finally checks if the encoded buffer is valid using the `isEncoding` method of `buffer`.",
    "output": "import {process, buffer} from '@kit.ArkTS';\n\nexport function checkEnvironmentVarEncoding(envVarName: string): boolean {\n  const envVarValue = process.getEnvironmentVar(envVarName);\n  if (envVarValue === undefined) {\n    return false;\n  }\n  const encodedBuffer = buffer.from(envVarValue, 'utf-8');\n  return buffer.isEncoding('utf-8');\n}"
  },
  {
    "instruction": "Create a function that first populates a `LightWeightMap` with product names (keys) and their prices (values) using the `set` method. Then, extract all product names using the `keys` method, store them in an `ArrayList` using the `add` method, and sort them alphabetically using the `sort` method of `ArrayList`. Return the sorted list of product names.",
    "output": "import {ArrayList, LightWeightMap} from '@kit.ArkTS';\n\nexport function getSortedProductNames(): ArrayList<string> {\n  const productMap = new LightWeightMap<string, number>();\n  productMap.set('Laptop', 999);\n  productMap.set('Phone', 699);\n  productMap.set('Tablet', 399);\n  productMap.set('Monitor', 199);\n  productMap.set('Keyboard', 99);\n\n  const productNames = new ArrayList<string>();\n  const keys = productMap.keys();\n  for (let key of keys) {\n    productNames.add(key);\n  }\n\n  productNames.sort((a, b) => a.localeCompare(b));\n  return productNames;\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a series of URIs from user input, then uses the `convertToArray` method of `LinkedList` to convert the list into an array, and finally passes this array to the `xml` API to generate an XML string where each URI is wrapped in a `<resource>` tag.",
    "output": "import {uri, LinkedList, xml} from '@kit.ArkTS';\n\nexport function generateXmlFromUris(): string {\n  const uriList: LinkedList<string> = new LinkedList<string>();\n  \n  // Example of adding URIs to the LinkedList (in a real scenario, these would come from user input)\n  uriList.add('https://example.com/resource1');\n  uriList.add('https://example.com/resource2');\n  uriList.add('https://example.com/resource3');\n  \n  const uriArray: string[] = uriList.convertToArray();\n  \n  const xmlObj = {\n    resources: {\n      resource: uriArray.map(uri => ({ _: uri }))\n    }\n  };\n  \n  return xml.convert(xmlObj);\n}"
  },
  {
    "instruction": "Implement a function that reads a JSON string representing a configuration object using `json.parse`, checks if a specific key exists in the parsed object using `json.has`, and if it does, updates the corresponding value in a `HashMap` using `HashMap.replace`. The function should return the updated HashMap.",
    "output": "import {HashMap, GlobalScope, json} from '@kit.ArkTS';\n\nexport function updateHashMapFromJson(jsonString: string, keyToCheck: string, hashMap: HashMap<string, string>): HashMap<string, string> {\n  const parsedObject = json.parse(jsonString);\n  if (json.has(parsedObject, keyToCheck)) {\n    const value = parsedObject[keyToCheck];\n    hashMap.replace(keyToCheck, value);\n  }\n  return hashMap;\n}"
  },
  {
    "instruction": "Create a function that uses the `self` property of `GlobalScope` to access the global context, then sends a message via `MessageEvent` with its `data` property set to the `name` property of `GlobalScope`. Ensure the message is handled by an event listener that validates the `data` property of the received `MessageEvent`.",
    "output": "import {MessageEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function sendGlobalScopeName(): void {\n  const globalScope: GlobalScope = GlobalScope.self;\n  const messageEvent: MessageEvent<string> = new MessageEvent('message', {\n    data: globalScope.name\n  });\n  globalScope.dispatchEvent(messageEvent);\n}\n\nexport function setupMessageListener(): void {\n  const globalScope: GlobalScope = GlobalScope.self;\n  globalScope.addEventListener('message', (event: MessageEvent<string>) => {\n    if (event.data === globalScope.name) {\n      console.log('Message validated successfully');\n    } else {\n      console.log('Message validation failed');\n    }\n  });\n}"
  },
  {
    "instruction": "Implement a function that uses `buffer.byteLength` to determine the size of a string in bytes, then creates a MessageEvent with the string as data, and verifies that the byte length of the event's data property matches the initially calculated size.",
    "output": "import {buffer, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function verifyStringByteLength(str: string): boolean {\n  const byteLength = buffer.byteLength(str, 'utf-8');\n  const event = new MessageEvent<string>('message', { data: str });\n  const eventDataByteLength = buffer.byteLength(event.data, 'utf-8');\n  return byteLength === eventDataByteLength;\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a series of error messages, then uses the `getFirst` method to retrieve the oldest error message and passes it to the `onerror` property of `GlobalScope` to handle the error globally.",
    "output": "import {Queue, GlobalScope} from '@kit.ArkTS';\n\nexport function handleErrorMessages(errorMessages: string[]): void {\n  const queue = new Queue<string>();\n  \n  for (const message of errorMessages) {\n    queue.add(message);\n  }\n  \n  if (queue.length > 0) {\n    const oldestError = queue.getFirst();\n    if (oldestError !== undefined) {\n      GlobalScope.onerror = (event: ErrorEvent) => {\n        console.error(`Global error handled: ${oldestError}`);\n      };\n    }\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `addAll` method of `LightWeightSet` to merge two sets of employee IDs, then transfers the merged set to a `HashMap` using its `setAll` method to associate each ID with a default department value 'Unassigned'. Finally, use the `keys` method of `HashMap` to retrieve and return the list of all employee IDs.",
    "output": "import {LightWeightSet, PostMessageOptions, HashMap} from '@kit.ArkTS';\n\nexport function mergeAndTransferEmployeeIds(set1: LightWeightSet<number>, set2: LightWeightSet<number>): Array<number> {\n  const mergedSet = new LightWeightSet<number>();\n  mergedSet.addAll(set1);\n  mergedSet.addAll(set2);\n\n  const employeeMap = new HashMap<number, string>();\n  employeeMap.setAll(mergedSet.toArray().map(id => [id, 'Unassigned']));\n\n  return Array.from(employeeMap.keys());\n}"
  },
  {
    "instruction": "Create a worker thread that listens for messages using the `onmessage` property of `ThreadWorkerGlobalScope`. When a message containing a URL is received, use the `url` API to validate the URL (e.g., check if it has a valid protocol). If the URL is valid, send a confirmation message back to the main thread using the `postMessage` method of `ThreadWorkerGlobalScope`; otherwise, send an error message.",
    "output": "import {ThreadWorkerGlobalScope, url} from '@kit.ArkTS';\n\nexport class URLValidatorWorker {\n  private workerScope: ThreadWorkerGlobalScope;\n\n  constructor(workerScope: ThreadWorkerGlobalScope) {\n    this.workerScope = workerScope;\n    this.setupMessageListener();\n  }\n\n  private setupMessageListener(): void {\n    this.workerScope.onmessage = (message: string) => {\n      this.handleMessage(message);\n    };\n  }\n\n  private handleMessage(message: string): void {\n    try {\n      const parsedUrl = new url.URL(message);\n      const isValid = this.validateURL(parsedUrl);\n      if (isValid) {\n        this.workerScope.postMessage(`Valid URL: ${message}`);\n      } else {\n        this.workerScope.postMessage(`Invalid URL: ${message}`);\n      }\n    } catch (error) {\n      this.workerScope.postMessage(`Error parsing URL: ${message}`);\n    }\n  }\n\n  private validateURL(parsedUrl: url.URL): boolean {\n    const validProtocols = ['http:', 'https:'];\n    return validProtocols.includes(parsedUrl.protocol);\n  }\n}\n\nconst worker = new URLValidatorWorker(self as ThreadWorkerGlobalScope);"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Stack` to iterate over a stack of worker names, then uses the `callGlobalCallObjectMethod` method of `ThreadWorkerGlobalScope` to invoke a global callback for each name. The function should also access the `self` property of `WorkerGlobalScope` to verify the current worker context before execution.",
    "output": "import {WorkerGlobalScope, Stack, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processWorkerNames(stack: Stack<string>, callback: (name: string) => void): void {\n  if (!(self instanceof WorkerGlobalScope)) {\n    throw new Error('This function must be executed within a worker context.');\n  }\n\n  const workerScope: ThreadWorkerGlobalScope = self as ThreadWorkerGlobalScope;\n  \n  stack.forEach((name: string) => {\n    workerScope.callGlobalCallObjectMethod(callback, name);\n  });\n}"
  },
  {
    "instruction": "Implement a function that uses the `uptime` method of `process` to get the system uptime, then uses the `push` method of `Stack` to store the uptime value. Next, use the `forEach` method of `Stack` to iterate over the stored values and log each one. Finally, use the `removeAllListener` method of `EventTarget` to clean up any event listeners that might have been added during the process.",
    "output": "import {process, Stack, EventTarget} from '@kit.ArkTS';\n\nexport function handleUptime(): void {\n  const uptimeValue: number = process.uptime();\n  const stack: Stack<number> = new Stack<number>();\n  stack.push(uptimeValue);\n  \n  stack.forEach((value: number) => {\n    console.log(`Uptime value: ${value}`);\n  });\n  \n  const eventTarget: EventTarget = new EventTarget();\n  eventTarget.removeAllListener();\n}"
  },
  {
    "instruction": "Implement a function that sets up a global error handler using `GlobalScope.onerror` to capture errors. For each error, create an `ErrorEvent` instance and extract its `filename`, `lineno`, and `colno` properties to generate a detailed error report, which is then stored in a global variable defined in `GlobalScope`.",
    "output": "import {ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nlet globalErrorReports: Array<{\n  filename: string;\n  lineno: number;\n  colno: number;\n  message: string;\n}> = [];\n\nGlobalScope.onerror = (event: ErrorEvent) => {\n  const errorReport = {\n    filename: event.filename,\n    lineno: event.lineno,\n    colno: event.colno,\n    message: event.message\n  };\n  globalErrorReports.push(errorReport);\n  return false;\n};\n\nexport function getGlobalErrorReports(): Array<{\n  filename: string;\n  lineno: number;\n  colno: number;\n  message: string;\n}> {\n  return globalErrorReports;\n}"
  },
  {
    "instruction": "Write a function that uses the `getKeyAt` method of `LightWeightMap` to retrieve all keys, then passes these keys to the `encode` method of `uri` to create a list of encoded URIs. Finally, use the `setAll` method of `LightWeightMap` to store the encoded URIs as values mapped to their original keys.",
    "output": "import {uri, LightWeightMap} from '@kit.ArkTS';\n\nexport function encodeAndStoreURIs(map: LightWeightMap<string, string>): void {\n  const newMap = new LightWeightMap<string, string>();\n  const keys: string[] = [];\n  \n  for (let i = 0; i < map.length; i++) {\n    const key = map.getKeyAt(i);\n    if (key !== undefined) {\n      keys.push(key);\n    }\n  }\n  \n  keys.forEach(key => {\n    const encodedURI = uri.encode(key);\n    newMap.set(key, encodedURI);\n  });\n  \n  map.setAll(newMap);\n}"
  },
  {
    "instruction": "Create a function that first populates a `LightWeightMap` with student names (keys) and their scores (values) using the `set` method. Then, use the `keys` method of `LightWeightMap` to extract all student names and pass them to a `HashSet` using the `add` method to ensure no duplicate names exist. Finally, return the size of the `HashSet` using the `length` property to verify the count of unique student names.",
    "output": "import {LightWeightMap, HashSet} from '@kit.ArkTS';\n\nexport function countUniqueStudentNames(): number {\n  const studentScores = new LightWeightMap<string, number>();\n  studentScores.set('Alice', 90);\n  studentScores.set('Bob', 85);\n  studentScores.set('Charlie', 88);\n  studentScores.set('Alice', 92); // Duplicate key\n\n  const uniqueNames = new HashSet<string>();\n  const studentNames = studentScores.keys();\n  for (const name of studentNames) {\n    uniqueNames.add(name);\n  }\n\n  return uniqueNames.length;\n}"
  },
  {
    "instruction": "Create a function that uses `buffer.concat` to merge two Buffers containing parts of a message, then constructs a MessageEvents object with the merged Buffer as data, and checks if the data property of the MessageEvents object matches the expected concatenated result.",
    "output": "import {buffer, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function mergeAndCheckBuffers(buffer1: buffer.Buffer, buffer2: buffer.Buffer, expected: buffer.Buffer): boolean {\n  const mergedBuffer = buffer.concat([buffer1, buffer2]);\n  const messageEvents = new MessageEvents('message', { data: mergedBuffer });\n  return Buffer.compare(messageEvents.data as buffer.Buffer, expected) === 0;\n}"
  },
  {
    "instruction": "Create a function that first uses the `convertToArray` method of `ArrayList<number>` (from @kit.ArkTS) to transform the list into an array, then uses the `EventType` enum from `xml` (from @kit.ArkTS) to filter the array for specific event types. Finally, use the `replaceAllElements` method of `ArrayList` to update the list with the filtered results.",
    "output": "import {ArrayList, xml, EventTarget} from '@kit.ArkTS';\n\nexport function filterEventTypes(list: ArrayList<number>, eventTypes: xml.EventType[]): void {\n  const array: number[] = list.convertToArray();\n  const filteredArray: number[] = array.filter((item: number) => {\n    return eventTypes.includes(item as xml.EventType);\n  });\n  list.replaceAllElements((_: number, index: number) => {\n    return filteredArray[index];\n  });\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Queue` to process each element in the queue, doubling its value, and then passes the modified elements to a stream processing function that filters out even numbers and logs the remaining odd numbers.",
    "output": "import {Queue, stream} from '@kit.ArkTS';\n\nexport function processQueue(queue: Queue<number>): void {\n  const doubledQueue = new Queue<number>();\n  queue.forEach((value: number) => {\n    doubledQueue.add(value * 2);\n  });\n\n  const readableStream = new stream.Readable<number>({\n    read(size: number): void {\n      while (doubledQueue.length > 0) {\n        const value = doubledQueue.pop();\n        if (value !== undefined) {\n          this.push(value);\n        }\n      }\n      this.push(null);\n    }\n  });\n\n  const transformStream = new stream.Transform<number, number>({\n    transform(chunk: number, encoding: string, callback: Function): void {\n      if (chunk % 2 !== 0) {\n        this.push(chunk);\n      }\n      callback();\n    }\n  });\n\n  readableStream.pipe(transformStream).on('data', (data: number) => {\n    console.log(data);\n  });\n}"
  },
  {
    "instruction": "Create a function that initializes an `ArrayList<number>` (from @kit.ArkTS) with random numbers using the `add` method, then uses the `getIndexOf` method to find the index of a specific target number. Pass this index to the `removeByIndex` method to remove the target number from the list, and finally use the `trimToCurrentLength` method to optimize the list's capacity.",
    "output": "import {ArrayList, stream} from '@kit.ArkTS';\n\nexport function processArrayList(target: number): void {\n  const list: ArrayList<number> = new ArrayList<number>();\n  \n  // Initialize the list with 10 random numbers between 1 and 100\n  for (let i = 0; i < 10; i++) {\n    list.add(Math.floor(Math.random() * 100) + 1);\n  }\n  \n  // Find the index of the target number\n  const index: number = list.getIndexOf(target);\n  \n  // Remove the target number if found\n  if (index !== -1) {\n    list.removeByIndex(index);\n  }\n  \n  // Optimize the list's capacity\n  list.trimToCurrentLength();\n}"
  },
  {
    "instruction": "Write a function that uses the `insertFront` method of `Deque` (from @kit.ArkTS) to build a list of strings in reverse order, then transfers all elements from the `Deque` to a `Stack` (from @kit.ArkTS) using the `popFirst` method of `Deque` and the `push` method of `Stack`. Finally, use the `peek` method of `Stack` to check if the top element matches a given target string.",
    "output": "import {url, Stack, Deque} from '@kit.ArkTS';\n\nexport function checkTopElementAfterReverseAndTransfer(strings: string[], target: string): boolean {\n  const deque = new Deque<string>();\n  const stack = new Stack<string>();\n\n  // Build the deque in reverse order\n  for (const str of strings) {\n    deque.insertFront(str);\n  }\n\n  // Transfer elements from deque to stack\n  while (deque.length > 0) {\n    const element = deque.popFirst();\n    if (element !== undefined) {\n      stack.push(element);\n    }\n  }\n\n  // Check if the top element matches the target\n  const topElement = stack.peek();\n  return topElement === target;\n}"
  },
  {
    "instruction": "Implement a function that captures an `ErrorEvent`, extracts its `error` and `message` properties, and sends them as the `data` property of a new `MessageEvent`. The function should then handle this `MessageEvent` by logging the `data` and triggering another `ErrorEvent` if the original `message` contains specific keywords.",
    "output": "import {MessageEvents, ErrorEvent, uri} from '@kit.ArkTS';\n\nexport function handleErrorEvent(errorEvent: ErrorEvent): void {\n  const errorData = {\n    error: errorEvent.error,\n    message: errorEvent.message\n  };\n\n  const messageEvent = new MessageEvents('errorData', {\n    data: errorData\n  });\n\n  handleMessageEvent(messageEvent);\n}\n\nexport function handleMessageEvent(messageEvent: MessageEvents): void {\n  const data = messageEvent.data;\n  console.log('Error data:', data);\n\n  if (data.message.includes('critical') || data.message.includes('fatal')) {\n    const newErrorEvent = new ErrorEvent('criticalError', {\n      error: data.error,\n      message: data.message\n    });\n    \n    throw newErrorEvent;\n  }\n}"
  },
  {
    "instruction": "Write a function that first populates a `HashMap` (from @kit.ArkTS) with key-value pairs using the `set` method, then extracts all keys using the `keys` method and stores them in a `List` (from @kit.ArkTS) using its `add` method. Finally, use the `getSubList` method of `List` to create a sublist of the first half of the keys.",
    "output": "import {List, HashMap, Stack} from '@kit.ArkTS';\n\nexport function processHashMapKeys(): List<string> {\n  const hashMap = new HashMap<string, string>();\n  hashMap.set('key1', 'value1');\n  hashMap.set('key2', 'value2');\n  hashMap.set('key3', 'value3');\n  hashMap.set('key4', 'value4');\n\n  const keys = hashMap.keys();\n  const keyList = new List<string>();\n  for (const key of keys) {\n    keyList.add(key);\n  }\n\n  const subListSize = Math.floor(keyList.length / 2);\n  return keyList.getSubList(0, subListSize);\n}"
  },
  {
    "instruction": "Implement a function that uses `util.promisify` to convert a callback-based function into a promise, then uses `EventTarget.addEventListener` to listen for a 'promise-resolved' event. The function should dispatch the event with the resolved value of the promise using `EventTarget.dispatchEvent`.",
    "output": "import {url, EventTarget, util} from '@kit.ArkTS';\n\nexport function promisifyAndDispatch(callbackBasedFunc: (arg: string, callback: (error: Error | null, result: string) => void) => void, arg: string, eventTarget: EventTarget): void {\n  const promisifiedFunc = util.promisify(callbackBasedFunc);\n  promisifiedFunc(arg)\n    .then((result: string) => {\n      const event = { type: 'promise-resolved', detail: result };\n      eventTarget.dispatchEvent(event);\n    })\n    .catch((error: Error) => {\n      console.error('Promise rejected:', error);\n    });\n}"
  },
  {
    "instruction": "Implement a function that uses the `promisify` method of `util` to convert a callback-based function into a promise-based one. Handle any potential errors by creating an `ErrorEvent` object with the error details. Then, store the error event in a `TreeMap` using the `set` method, and retrieve the first key-value pair using the `getFirstKey` and `get` methods of `TreeMap` to log the error details using the `printf` method of `util`.",
    "output": "import {util, ErrorEvent, TreeMap} from '@kit.ArkTS';\n\nexport function promisifyAndHandleError(callbackFunc: (arg: string, callback: (err: Error | null, result: string) => void) => void, arg: string): void {\n  const promisifiedFunc = util.promisify(callbackFunc);\n  const errorMap = new TreeMap<string, ErrorEvent>();\n\n  promisifiedFunc(arg)\n    .then((result: string) => {\n      console.log(result);\n    })\n    .catch((err: Error) => {\n      const errorEvent = new ErrorEvent({\n        error: err,\n        message: err.message,\n        filename: 'script.js',\n        lineno: 1,\n        colno: 1\n      });\n      errorMap.set('error1', errorEvent);\n      \n      const firstKey = errorMap.getFirstKey();\n      if (firstKey !== undefined) {\n        const firstErrorEvent = errorMap.get(firstKey);\n        if (firstErrorEvent !== undefined) {\n          util.printf('Error details: %s', firstErrorEvent.message);\n        }\n      }\n    });\n}"
  },
  {
    "instruction": "Create a worker thread that listens for incoming messages using the `onmessage` property of `ThreadWorkerGlobalScope`, processes the received data by calling a global method via `callGlobalCallObjectMethod`, and then sends the processed result back to the main thread using `postMessageWithSharedSendable` with the `transfer` property of `PostMessageOptions` to optimize performance.",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport const workerScript = (self: ThreadWorkerGlobalScope) => {\n  self.onmessage = (event: MessageEvent) => {\n    const data = event.data;\n    const processedData = self.callGlobalCallObjectMethod('processData', data);\n    \n    const options: PostMessageOptions = {\n      transfer: [processedData.buffer]\n    };\n    \n    self.postMessageWithSharedSendable(processedData, options);\n  };\n};"
  },
  {
    "instruction": "Create a function that initializes a worker using the `worker` API, dynamically sets the worker's name via the `name` property of `WorkerGlobalScope`, and then uses the `onerror` property of `WorkerGlobalScope` to handle and forward any runtime errors from the worker to the main thread for logging.",
    "output": "import {WorkerGlobalScope, worker} from '@kit.ArkTS';\n\nexport function initializeWorker(workerScriptURL: string, workerName: string): worker.ThreadWorker {\n  const workerInstance = new worker.ThreadWorker(workerScriptURL);\n\n  workerInstance.onmessage = (event: worker.MessageEvents): void => {\n    if (event.data === 'initialize') {\n      workerInstance.postMessage({ type: 'setName', name: workerName });\n    }\n  };\n\n  workerInstance.onerror = (error: Error): void => {\n    console.error(`Worker error: ${error.message}`);\n  };\n\n  workerInstance.postMessage('initialize');\n  return workerInstance;\n}\n\nexport function handleWorkerInitialization(workerScope: WorkerGlobalScope): void {\n  workerScope.onmessage = (event: MessageEvent): void => {\n    if (event.data.type === 'setName') {\n      workerScope.name = event.data.name;\n    }\n  };\n\n  workerScope.onerror = (error: ErrorEvent): void => {\n    workerScope.postMessage({ type: 'error', message: error.message });\n  };\n}"
  },
  {
    "instruction": "Implement a function where a worker thread generates a list of tasks, which are then inserted into a `Deque` using the `insertEnd` method. The main thread should use the `popLast` method to retrieve and execute tasks from the deque, and the worker thread should be notified of task completion using a callback mechanism.",
    "output": "import {Deque, worker} from '@kit.ArkTS';\n\nexport class Task {\n  constructor(public id: number, public data: string) {}\n}\n\nexport class TaskManager {\n  private deque: Deque<Task> = new Deque<Task>();\n  private workerThread: worker.ThreadWorker;\n\n  constructor() {\n    this.workerThread = new worker.ThreadWorker('entry/ets/workers/TaskWorker.js');\n    this.setupWorkerListeners();\n  }\n\n  private setupWorkerListeners(): void {\n    this.workerThread.onmessage = (message: worker.MessageEvents): void => {\n      if (message.data.type === 'newTask') {\n        const task = new Task(message.data.id, message.data.data);\n        this.deque.insertEnd(task);\n      }\n    };\n  }\n\n  public executeTasks(): void {\n    while (this.deque.length > 0) {\n      const task = this.deque.popLast();\n      if (task) {\n        console.log(`Executing task ${task.id}: ${task.data}`);\n        this.workerThread.postMessage({\n          type: 'taskCompleted',\n          id: task.id\n        });\n      }\n    }\n  }\n\n  public terminate(): void {\n    this.workerThread.terminate();\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a series of error messages, then dequeues them using `pop` and stores each message along with its line number (from `ErrorEvent.lineno`) in a `LightWeightMap`, where the key is the line number and the value is the error message. Finally, use `LightWeightMap.forEach` to print all key-value pairs.",
    "output": "import {LightWeightMap, Queue, ErrorEvent} from '@kit.ArkTS';\n\nexport function processErrorMessages(errorEvents: ErrorEvent[]): void {\n  const queue = new Queue<string>();\n  const map = new LightWeightMap<number, string>();\n\n  // Enqueue error messages\n  errorEvents.forEach((event: ErrorEvent) => {\n    queue.add(event.message);\n  });\n\n  // Dequeue and store in LightWeightMap\n  while (queue.length > 0) {\n    const message = queue.pop();\n    const event = errorEvents.find((e: ErrorEvent) => e.message === message);\n    if (event) {\n      map.set(event.lineno, message);\n    }\n  }\n\n  // Print all key-value pairs\n  map.forEach((value: string, key: number) => {\n    console.log(`Line ${key}: ${value}`);\n  });\n}"
  },
  {
    "instruction": "Write a function that uses the `convertToArray` method of `Vector` to transform a vector of URIs into an array, then iterates over the array using the `Symbol.iterator` method of `Vector` to validate each URI (assuming URI validation is implicit). Finally, use the `replaceAllElements` method of `Vector` to update the vector with only the valid URIs.",
    "output": "import {Vector, uri} from '@kit.ArkTS';\n\nexport function validateAndFilterURIs(vector: Vector<string>): Vector<string> {\n  const uriArray: string[] = vector.convertToArray();\n  const validURIs: string[] = [];\n\n  for (const uri of vector) {\n    try {\n      // Implicit validation by attempting to use the URI\n      validURIs.push(uri);\n    } catch (e) {\n      // Skip invalid URIs\n    }\n  }\n\n  vector.replaceAllElements((value: string, index: number) => {\n    return validURIs[index] || '';\n  });\n\n  return vector;\n}"
  },
  {
    "instruction": "Implement a utility that generates a random binary UUID using `util.generateRandomBinaryUUID`, adds it to a `LightWeightSet` via the `add` method, and then checks if the set contains the UUID using `has`. If found, print the UUID's string representation using `util.errnoToString` (assuming the UUID is treated as an error code for demonstration purposes).",
    "output": "import {util, Stack, LightWeightSet} from '@kit.ArkTS';\n\nexport function handleRandomUUID(): void {\n  const uuid: Uint8Array = util.generateRandomBinaryUUID();\n  const set: LightWeightSet<Uint8Array> = new LightWeightSet<Uint8Array>();\n  set.add(uuid);\n  if (set.has(uuid)) {\n    const uuidString: string = util.errnoToString(uuid);\n    console.log(uuidString);\n  }\n}"
  },
  {
    "instruction": "Write a function that uses `PlainArray.forEach` to iterate over key-value pairs, filters out entries where the value matches a condition, and then uses `HashMap.setAll` to merge the filtered entries into a new HashMap. The function must explicitly use `PlainArray.forEach` and `HashMap.setAll`.",
    "output": "import {PlainArray, EventTarget, HashMap} from '@kit.ArkTS';\n\nexport function filterAndMerge(plainArray: PlainArray<number, string>, condition: (value: string) => boolean): HashMap<number, string> {\n  const filteredEntries: PlainArray<number, string> = new PlainArray<number, string>();\n  \n  plainArray.forEach((value: string, key: number) => {\n    if (condition(value)) {\n      filteredEntries.add(key, value);\n    }\n  });\n  \n  const resultMap: HashMap<number, string> = new HashMap<number, string>();\n  resultMap.setAll(filteredEntries);\n  \n  return resultMap;\n}"
  },
  {
    "instruction": "Write a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the top element of the stack and then uses the `getHigherValue` method of `TreeSet` (from @kit.ArkTS) to find the smallest value in the set that is greater than the peeked value. If such a value exists, push it onto the stack using the `push` method of `Stack`.",
    "output": "import {Event, TreeSet, Stack} from '@kit.ArkTS';\n\nexport function pushHigherValue(stack: Stack<number>, treeSet: TreeSet<number>): void {\n  if (stack.isEmpty() || treeSet.isEmpty()) {\n    return;\n  }\n  const topValue = stack.peek();\n  const higherValue = treeSet.getHigherValue(topValue);\n  if (higherValue !== undefined) {\n    stack.push(higherValue);\n  }\n}"
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a buffer from a string, then uses `buffer.byteLength` to get its size, and finally passes the size to `process.getEnvironmentVar` to check if the environment variable 'MAX_BUFFER_SIZE' allows the buffer to be processed. If the buffer size exceeds the value of 'MAX_BUFFER_SIZE', use `process.exit` to terminate the process.",
    "output": "import {buffer, process, TreeSet} from '@kit.ArkTS';\n\nexport function checkBufferSize(inputString: string): void {\n  const buf = buffer.from(inputString, 'utf-8');\n  const size = buffer.byteLength(buf);\n  const maxBufferSizeStr = process.getEnvironmentVar('MAX_BUFFER_SIZE');\n  \n  if (maxBufferSizeStr) {\n    const maxBufferSize = parseInt(maxBufferSizeStr);\n    if (size > maxBufferSize) {\n      process.exit(1);\n    }\n  }\n}"
  },
  {
    "instruction": "Implement a function that sets up an `onmessageerror` handler using the `onmessageerror` property of `DedicatedWorkerGlobalScope` to catch any message errors. Then, use the `postMessage` method of `DedicatedWorkerGlobalScope` with the `transfer` property of `PostMessageOptions` to send a message to the worker, ensuring proper error handling and data transfer.",
    "output": "import {PostMessageOptions, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerMessageErrorHandler(workerScope: DedicatedWorkerGlobalScope): void {\n  workerScope.onmessageerror = (event: MessageEvent) => {\n    console.error('Message error occurred:', event);\n  };\n}\n\nexport function sendMessageToWorker(\n  workerScope: DedicatedWorkerGlobalScope,\n  message: ArrayBuffer,\n  transferList: ArrayBuffer[]\n): void {\n  const options: PostMessageOptions = {\n    transfer: transferList\n  };\n  workerScope.postMessage(message, options);\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `ArrayList<string>` to collect a list of file names, then passes this list to the `concat` method of `buffer` to merge the contents of all files into a single buffer. Finally, use the `toString` method of `Vector<Uint8Array>` to convert the buffer into a readable string.",
    "output": "import {ArrayList, Vector, buffer} from '@kit.ArkTS';\n\nexport function mergeFilesContents(fileNames: string[]): string {\n  const fileList: ArrayList<string> = new ArrayList();\n  \n  for (const fileName of fileNames) {\n    fileList.add(fileName);\n  }\n  \n  const buffers: Vector<Uint8Array> = new Vector();\n  \n  for (let i = 0; i < fileList.length; i++) {\n    const fileName = fileList.get(i);\n    // Assuming each file's content is read as Uint8Array\n    // Note: Actual file reading mechanism is not specified in the API\n    const fileContent = new Uint8Array(0); // Placeholder for actual file content\n    buffers.add(fileContent);\n  }\n  \n  const mergedBuffer = buffer.concat(buffers);\n  return buffers.toString();\n}"
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` to collect a sequence of numbers, then passes the deque to the `setAll` method of `TreeMap` to store the numbers as keys with their squares as values. Finally, use the `getFirstKey` and `getLastKey` methods of `TreeMap` to display the smallest and largest numbers in the sequence.",
    "output": "import {GlobalScope, Deque, TreeMap} from '@kit.ArkTS';\n\nexport function processSequence(numbers: number[]): void {\n  const deque = new Deque<number>();\n  const treeMap = new TreeMap<number, number>();\n\n  // Insert numbers into the deque\n  for (const num of numbers) {\n    deque.insertFront(num);\n    deque.insertEnd(num);\n  }\n\n  // Store numbers and their squares in the TreeMap\n  treeMap.setAll(deque);\n\n  // Get the smallest and largest numbers\n  const smallest = treeMap.getFirstKey();\n  const largest = treeMap.getLastKey();\n\n  console.log(`Smallest number: ${smallest}`);\n  console.log(`Largest number: ${largest}`);\n}"
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send a message to a worker thread, and includes the `transfer` property of `PostMessageOptions` to transfer ownership of an ArrayBuffer to the worker. Then, use the `onmessage` property of `DedicatedWorkerGlobalScope` to handle the response from the worker.",
    "output": "import {PostMessageOptions, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendMessageToWorker(worker: DedicatedWorkerGlobalScope, buffer: ArrayBuffer): void {\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  worker.postMessage(buffer, options);\n}\n\nexport function setupWorkerResponseHandler(worker: DedicatedWorkerGlobalScope, callback: (event: MessageEvent) => void): void {\n  worker.onmessage = callback;\n}"
  },
  {
    "instruction": "Implement a function that uses the `insert` method of `LinkedList` to build a list of integers, then transfers all elements from the `LinkedList` to a `TreeSet` using the `get` method of `LinkedList` and the `add` method of `TreeSet`. Finally, use the `values` method of `TreeSet` to return an iterator of the sorted unique elements.",
    "output": "import {Queue, LinkedList, TreeSet} from '@kit.ArkTS';\n\nexport function transferLinkedListToTreeSet(numbers: number[]): IterableIterator<number> {\n  const linkedList = new LinkedList<number>();\n  for (const num of numbers) {\n    linkedList.insert(num, linkedList.length);\n  }\n\n  const treeSet = new TreeSet<number>();\n  for (let i = 0; i < linkedList.length; i++) {\n    treeSet.add(linkedList.get(i));\n  }\n\n  return treeSet.values();\n}"
  },
  {
    "instruction": "Implement a function that reads a JSON file using `stream`, removes a specified key from the parsed object using `json.remove`, converts the modified object back to a JSON string using `json.stringify`, and writes the updated string back to the file using `stream`.",
    "output": "import {stream, json} from '@kit.ArkTS';\n\nexport function removeKeyFromJsonFile(filePath: string, keyToRemove: string): void {\n  const readableStream = new stream.Readable();\n  const writableStream = new stream.Writable();\n\n  let fileContent = '';\n  readableStream.on('data', (chunk: string) => {\n    fileContent += chunk;\n  });\n\n  readableStream.on('end', () => {\n    try {\n      const parsedJson = json.parse(fileContent);\n      json.remove(parsedJson, keyToRemove);\n      const updatedJsonString = json.stringify(parsedJson);\n\n      writableStream.write(updatedJsonString, () => {\n        writableStream.end();\n      });\n    } catch (error) {\n      console.error(`Error processing JSON: ${error}`);\n    }\n  });\n\n  readableStream.on('error', (error: Error) => {\n    console.error(`Error reading file: ${error}`);\n  });\n\n  writableStream.on('error', (error: Error) => {\n    console.error(`Error writing file: ${error}`);\n  });\n\n  readableStream.read(filePath);\n  writableStream.writeTo(filePath);\n}"
  },
  {
    "instruction": "Write a function that uses the `from` method of `buffer` to create a buffer from a string, then uses the `set` method of `HashMap` to store the buffer as a value with a specified key. Finally, use the `get` method of `HashMap` to retrieve the buffer and the `byteLength` method of `buffer` to return the size of the stored buffer.",
    "output": "import {HashMap, buffer, stream} from '@kit.ArkTS';\n\nexport function storeAndGetBufferSize(key: string, value: string): number {\n  const hashMap = new HashMap<string, buffer.Buffer>();\n  const buf = buffer.from(value, 'utf-8');\n  hashMap.set(key, buf);\n  const retrievedBuf = hashMap.get(key);\n  return retrievedBuf.byteLength;\n}"
  },
  {
    "instruction": "Implement a function that listens for a message event using `EventTarget.addEventListener`, processes the incoming `MessageEvent.data`, and then uses `EventTarget.removeEventListener` to clean up the listener after the message is received. The function should return the processed data from the `MessageEvent`.",
    "output": "import {EventTarget, MessageEvents, PostMessageOptions} from '@kit.ArkTS';\n\nexport function listenForMessage(target: EventTarget, callback: (data: string) => void): void {\n  const messageHandler = (event: MessageEvents) => {\n    const processedData = event.data;\n    target.removeEventListener('message', messageHandler);\n    callback(processedData);\n  };\n  target.addEventListener('message', messageHandler);\n}"
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `Stack` (from @kit.ArkTS) to iterate over its elements and for each element, creates an `Event` (from @kit.ArkTS) where the `type` property is set to the stack element's value and the `timeStamp` property is set to the current time. The function should then return an array of these events.",
    "output": "import {Event, Stack} from '@kit.ArkTS';\n\nexport function createEventsFromStack(stack: Stack<string>): Event[] {\n  const events: Event[] = [];\n  stack.forEach((element: string) => {\n    const event: Event = {\n      type: element,\n      timeStamp: new Date().getTime()\n    };\n    events.push(event);\n  });\n  return events;\n}"
  },
  {
    "instruction": "Implement a function where a worker thread (using the `worker` API) generates a large dataset, which is then passed to the main thread and stored in a `LightWeightSet` using the `addAll` method. The main thread should then use the `forEach` method of `LightWeightSet` to process each item in the set (e.g., logging or validation).",
    "output": "import {LightWeightSet, worker} from '@kit.ArkTS';\n\nexport function generateDataInWorker(): void {\n  const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n  \n  workerInstance.onmessage = (message: worker.MessageEvents): void => {\n    const data: number[] = message.data;\n    const lightWeightSet = new LightWeightSet<number>();\n    lightWeightSet.addAll(data);\n    \n    lightWeightSet.forEach((value: number): void => {\n      console.log(`Processing value: ${value}`);\n    });\n    \n    workerInstance.terminate();\n  };\n  \n  workerInstance.postMessage('generate');\n}\n\nexport class Worker {\n  constructor() {\n    worker.parentPort.onmessage = (message: worker.MessageEvents): void => {\n      if (message.data === 'generate') {\n        const largeDataset: number[] = this.generateLargeDataset();\n        worker.parentPort.postMessage(largeDataset);\n      }\n    };\n  }\n  \n  private generateLargeDataset(): number[] {\n    const dataset: number[] = [];\n    for (let i = 0; i < 1000; i++) {\n      dataset.push(i);\n    }\n    return dataset;\n  }\n}"
  },
  {
    "instruction": "Create a function that checks if the current execution context is the global scope by comparing `GlobalScope.self` with the global `this` object. If an error occurs during this check, use the `ErrorEvent` properties (`error`, `message`) to handle and display the error details.",
    "output": "import {ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function checkGlobalScope(): boolean {\n  try {\n    return GlobalScope.self === this;\n  } catch (error) {\n    const errorEvent = new ErrorEvent('error', {\n      error: error,\n      message: error instanceof Error ? error.message : 'Unknown error occurred'\n    });\n    \n    console.error(`Error occurred: ${errorEvent.message}`);\n    return false;\n  }\n}"
  },
  {
    "instruction": "Implement a function that uses the `self` property of `WorkerGlobalScope` to get the current worker context, then passes this context to a `LightWeightSet` instance using its `addAll` method to store multiple worker contexts. Finally, use the `toArray` method of `LightWeightSet` to convert the stored contexts into an array and return it.",
    "output": "import {WorkerGlobalScope, LightWeightSet} from '@kit.ArkTS';\n\nexport function storeWorkerContexts(): WorkerGlobalScope[] {\n  const workerContext = self;\n  const lightWeightSet = new LightWeightSet<WorkerGlobalScope>();\n  lightWeightSet.addAll([workerContext]);\n  return lightWeightSet.toArray();\n}"
  },
  {
    "instruction": "Write a function that uses the `set` method of `HashMap` to store key-value pairs representing user preferences, then converts the HashMap to a JSON string using `json.stringify`, and finally logs the JSON string to the console using `GlobalScope.self.console.log`.",
    "output": "import {HashMap, GlobalScope, json} from '@kit.ArkTS';\n\nexport function storeAndLogUserPreferences(): void {\n  const userPreferences = new HashMap<string, string>();\n  userPreferences.set('theme', 'dark');\n  userPreferences.set('language', 'en');\n  userPreferences.set('notifications', 'enabled');\n\n  const jsonString = json.stringify(userPreferences);\n  GlobalScope.self.console.log(jsonString);\n}"
  },
  {
    "instruction": "Implement a function that takes an array of `Event` objects, filters them based on their `type`, and then creates a `MessageEvent` for each filtered event where the `data` property contains the event's `timeStamp` and type in a structured format (e.g., JSON). Return an array of these message events.",
    "output": "import {Event, MessageEvent} from '@kit.ArkTS';\n\nexport function filterAndCreateMessageEvents(events: Event[], filterType: string): MessageEvent<{timeStamp: number, type: string}>[] {\n  const filteredEvents = events.filter((event) => event.type === filterType);\n  return filteredEvents.map((event) => {\n    const messageData = {\n      timeStamp: event.timeStamp,\n      type: event.type\n    };\n    return new MessageEvent(filterType, {data: messageData});\n  });\n}"
  },
  {
    "instruction": "Create a function that iterates over a `LightWeightMap` using the `[Symbol.iterator]` method to extract all error codes (keys) and then uses the `getKeyAt` and `getValueAt` methods to pair each error code with its corresponding `ErrorEvent`'s `filename` and `lineno` properties, storing the results in a new array.",
    "output": "import {ErrorEvent, LightWeightMap} from '@kit.ArkTS';\n\nexport function extractErrorCodesWithDetails(errorMap: LightWeightMap<number, ErrorEvent>): Array<{errorCode: number, filename: string, lineno: number}> {\n  const result: Array<{errorCode: number, filename: string, lineno: number}> = [];\n  \n  for (const [errorCode, _] of errorMap[Symbol.iterator]()) {\n    const index = errorMap.getIndexOfKey(errorCode);\n    if (index !== -1) {\n      const errorEvent = errorMap.getValueAt(index);\n      if (errorEvent) {\n        result.push({\n          errorCode,\n          filename: errorEvent.filename,\n          lineno: errorEvent.lineno\n        });\n      }\n    }\n  }\n  \n  return result;\n}"
  },
  {
    "instruction": "Implement a function that checks if a `TreeMap` is empty using `TreeMap.isEmpty`, and if it is, dispatches an 'empty' event using `EventTarget.dispatchEvent`. Otherwise, it should iterate over the `TreeMap` using `TreeMap.forEach` and dispatch a 'non-empty' event with each key-value pair as event data.",
    "output": "import {TreeMap, EventTarget} from '@kit.ArkTS';\n\nexport function checkAndDispatchTreeMapEvent(treeMap: TreeMap<unknown, unknown>, eventTarget: EventTarget): void {\n  if (treeMap.isEmpty()) {\n    eventTarget.dispatchEvent(new Event('empty'));\n  } else {\n    treeMap.forEach((value: unknown, key: unknown) => {\n      const eventData = { key, value };\n      const event = new CustomEvent('non-empty', { detail: eventData });\n      eventTarget.dispatchEvent(event);\n    });\n  }\n}"
  },
  {
    "instruction": "Write a function that creates an `ArrayList` (from @kit.ArkTS) of strings, uses its `subArrayList` method to extract a subset of elements, and then adds these elements to a `Queue` (from @kit.ArkTS) using its `add` method to process them in a first-in-first-out manner.",
    "output": "import {ArrayList, Queue} from '@kit.ArkTS';\n\nexport function processArrayListToQueue(): void {\n  const arrayList = new ArrayList<string>();\n  arrayList.add('Element1');\n  arrayList.add('Element2');\n  arrayList.add('Element3');\n  arrayList.add('Element4');\n  arrayList.add('Element5');\n\n  const subList = arrayList.subArrayList(1, 3);\n  const queue = new Queue<string>();\n\n  for (const element of subList) {\n    queue.add(element);\n  }\n}"
  },
  {
    "instruction": "Design a function that uses the `subVector` method of `Vector` to extract a range of elements from a vector of URIs, then applies the `sort` method to this sub-vector. Finally, use the `copyToArray` method of `Vector` to convert the sorted sub-vector into an array and return it alongside the original vector's `length` property for comparison.",
    "output": "import {Vector, uri} from '@kit.ArkTS';\n\nexport function processVector(originalVector: Vector<uri>, start: number, end: number): {sortedArray: Array<uri>, originalLength: number} {\n    const subVector = originalVector.subVector(start, end);\n    subVector.sort();\n    const sortedArray = subVector.copyToArray();\n    return {\n        sortedArray: sortedArray,\n        originalLength: originalVector.length\n    };\n}"
  },
  {
    "instruction": "Write a function that sets up a `WorkerEventTarget` instance to listen for multiple events using `addEventListener`. Use the `worker` API to send data to a worker thread, and upon receiving a response, use `removeEventListener` to clean up specific event listeners while keeping others active. Ensure the remaining listeners can still handle subsequent events.",
    "output": "import {WorkerEventTarget, worker} from '@kit.ArkTS';\n\nexport function setupWorkerEventListeners(workerTarget: WorkerEventTarget): void {\n  const messageHandler = (event: MessageEvent): void => {\n    console.log('Message received:', event.data);\n    workerTarget.removeEventListener('message', messageHandler);\n  };\n\n  const errorHandler = (event: ErrorEvent): void => {\n    console.error('Error occurred:', event.message);\n  };\n\n  workerTarget.addEventListener('message', messageHandler);\n  workerTarget.addEventListener('error', errorHandler);\n\n  worker.postMessage('Initial data');\n}"
  },
  {
    "instruction": "Create a function that takes a `LinkedList` of strings, uses the `convertToArray` method to transform it into an array, then uses `buffer.concat` to merge all strings into a single buffer after encoding each with `buffer.from` (using 'base64' encoding). Finally, return the length of the concatenated buffer using the `length` property of `LinkedList` to verify the count of original elements.",
    "output": "import {LinkedList, uri, buffer} from '@kit.ArkTS';\n\nexport function processLinkedList(list: LinkedList<string>): number {\n  const array: string[] = list.convertToArray();\n  const buffers: buffer.Buffer[] = [];\n  \n  for (const str of array) {\n    const encodedBuffer = buffer.from(str, 'base64');\n    buffers.push(encodedBuffer);\n  }\n  \n  const concatenatedBuffer = buffer.concat(buffers);\n  return list.length;\n}"
  },
  {
    "instruction": "Create a function that initializes an `ArrayList` with a set of strings and uses the `convertToArray` method to convert it into an array. Then, pass this array to a `Vector` object using its `constructor` method. Finally, use the `subVector` method of the `Vector` to extract a subset of elements and return them.",
    "output": "import {DedicatedWorkerGlobalScope, Vector, ArrayList} from '@kit.ArkTS';\n\nexport function processVector(): string[] {\n  // Initialize ArrayList with strings\n  const arrayList = new ArrayList<string>();\n  arrayList.add('Apple');\n  arrayList.add('Banana');\n  arrayList.add('Cherry');\n  arrayList.add('Date');\n  arrayList.add('Elderberry');\n\n  // Convert ArrayList to array\n  const array = arrayList.convertToArray();\n\n  // Pass array to Vector constructor\n  const vector = new Vector<string>(array);\n\n  // Extract subset using subVector\n  const subVector = vector.subVector(1, 4);\n\n  // Convert subVector to array and return\n  return subVector.convertToArray();\n}"
  },
  {
    "instruction": "Write a function that uses the `Event` API to track a series of timestamped events (using the `timeStamp` property) and then stores these timestamps in a `TreeSet` (using the `add` method). Finally, use the `getFirstValue` and `getLastValue` methods of `TreeSet` to determine the earliest and latest event timestamps.",
    "output": "import {TreeSet, Event} from '@kit.ArkTS';\n\nexport function trackAndAnalyzeEvents(events: Event[]): {first: number, last: number} {\n  const timestampSet = new TreeSet<number>();\n  \n  for (const event of events) {\n    timestampSet.add(event.timeStamp);\n  }\n  \n  const first = timestampSet.getFirstValue();\n  const last = timestampSet.getLastValue();\n  \n  return {first, last};\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of numbers from user input, then passes the resulting `LinkedList` to a `ThreadWorkerGlobalScope` worker thread using `postMessage`. The worker thread should use the `get` and `length` properties of `LinkedList` to calculate the sum of all elements and return the result via `onmessage`.",
    "output": "import {LinkedList, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function collectAndSumNumbers(): void {\n  const list = new LinkedList<number>();\n  \n  // Simulate user input by adding numbers to the LinkedList\n  list.add(1);\n  list.add(2);\n  list.add(3);\n  \n  const worker = new ThreadWorkerGlobalScope('workers/worker.ts');\n  \n  worker.onmessage = (message: {data: number}) => {\n    console.log(`Sum of numbers: ${message.data}`);\n    worker.close();\n  };\n  \n  worker.postMessage(list);\n}\n\n// worker.ts content (should be in a separate file)\n// import {LinkedList} from '@kit.ArkTS';\n// \n// const workerScope = new ThreadWorkerGlobalScope('self');\n// \n// workerScope.onmessage = (message: {data: LinkedList<number>}) => {\n//   const list = message.data;\n//   let sum = 0;\n//   for (let i = 0; i < list.length; i++) {\n//     sum += list.get(i);\n//   }\n//   workerScope.postMessage(sum);\n// };"
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to store a sequence of URIs, then iterates through the list using `Symbol.iterator` to convert each URI to a buffer using `buffer.from` (with UTF-8 encoding), and finally checks if all buffers are valid using `buffer.isBuffer`.",
    "output": "import {LinkedList, uri, buffer} from '@kit.ArkTS';\n\nexport function processURIs(uris: string[]): boolean {\n  const list = new LinkedList<string>();\n  \n  // Add URIs to the LinkedList\n  for (const uri of uris) {\n    list.add(uri);\n  }\n  \n  // Iterate through the LinkedList using Symbol.iterator\n  for (const uri of list) {\n    // Convert each URI to a buffer with UTF-8 encoding\n    const buf = buffer.from(uri, 'utf-8');\n    \n    // Check if the buffer is valid\n    if (!buffer.isBuffer(buf)) {\n      return false;\n    }\n  }\n  \n  return true;\n}"
  },
  {
    "instruction": "Implement a function that removes all event listeners using `WorkerEventTarget.removeAllListener`, then uses `json.remove` to delete a specified key from a JSON object. The function should return the modified JSON object after the key has been removed.",
    "output": "import {WorkerEventTarget, json} from '@kit.ArkTS';\n\nexport function removeKeyAndListeners(workerEventTarget: WorkerEventTarget, jsonObj: object, keyToRemove: string): object {\n  workerEventTarget.removeAllListener();\n  json.remove(jsonObj, keyToRemove);\n  return jsonObj;\n}"
  },
  {
    "instruction": "Create a function that initializes a `Queue` object, uses its `add` method to enqueue a series of tasks, then starts a new Worker using `WorkerOptions` (with a unique `name`) and passes the queue's first task (obtained via `Queue.getFirst`) to the worker for processing.",
    "output": "import {WorkerGlobalScope, WorkerOptions, Queue} from '@kit.ArkTS';\n\nexport function initializeQueueAndStartWorker(): void {\n  const queue = new Queue<string>();\n  queue.add('Task1');\n  queue.add('Task2');\n  queue.add('Task3');\n\n  const firstTask = queue.getFirst();\n  if (firstTask) {\n    const workerOptions: WorkerOptions = {\n      name: 'uniqueWorkerName'\n    };\n    const worker = new WorkerGlobalScope('workerScript.js', workerOptions);\n    worker.postMessage(firstTask);\n  }\n}"
  },
  {
    "instruction": "Write a function that processes a `Queue` of events (using the `pop` method) and collects the `timeStamp` values (using the `timeStamp` property of `Event`) into an array. Then, use the `forEach` method of `Queue` to log each timestamp in the array.",
    "output": "import {Event, Queue} from '@kit.ArkTS';\n\nexport function processEvents(queue: Queue<Event>): void {\n  const timeStamps: number[] = [];\n  while (queue.length > 0) {\n    const event = queue.pop();\n    if (event) {\n      timeStamps.push(event.timeStamp);\n    }\n  }\n  queue.forEach((event: Event) => {\n    console.log(event.timeStamp);\n  });\n}"
  },
  {
    "instruction": "Implement a function that uses the `entries` method of `HashMap` to iterate over key-value pairs of student IDs and their grades, then filters out students with failing grades (below 60) and stores their IDs in a `LightWeightSet` using its `add` method. Finally, use the `toArray` method of `LightWeightSet` to return the list of failing student IDs.",
    "output": "import {LightWeightSet, PostMessageOptions, HashMap} from '@kit.ArkTS';\n\nexport function getFailingStudentIds(studentGrades: HashMap<number, number>): number[] {\n  const failingStudents = new LightWeightSet<number>();\n  \n  for (const [id, grade] of studentGrades.entries()) {\n    if (grade < 60) {\n      failingStudents.add(id);\n    }\n  }\n  \n  return failingStudents.toArray();\n}"
  },
  {
    "instruction": "Write a function that uses `json.parse()` to parse a JSON string containing user data, then uses `util.format()` to format the parsed data into a readable string, and finally uses `util.printf()` to print the formatted string to the console.",
    "output": "import {util, json} from '@kit.ArkTS';\n\nexport function parseAndFormatUserData(jsonString: string): void {\n  const parsedData = json.parse(jsonString);\n  const formattedString = util.format('User Data: %j', parsedData);\n  util.printf(formattedString);\n}"
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of event names, then iterates through the stack using `Symbol.iterator`, and checks if each event name exists in a `LightWeightSet` (from @kit.ArkTS) using the `has` method. The function should return an array of events that are present in both the stack and the set.",
    "output": "import {LightWeightSet, Stack, EventTarget} from '@kit.ArkTS';\n\nexport function findCommonEvents(eventNames: string[], set: LightWeightSet<string>): string[] {\n  const stack = new Stack<string>();\n  const commonEvents: string[] = [];\n\n  // Push event names into the stack\n  for (const event of eventNames) {\n    stack.push(event);\n  }\n\n  // Iterate through the stack and check for common events\n  for (const event of stack) {\n    if (set.has(event)) {\n      commonEvents.push(event);\n    }\n  }\n\n  return commonEvents;\n}"
  },
  {
    "instruction": "Implement a delayed task execution system where `taskpool.executeDelayed` is used to schedule a task after a 3-second delay, and upon completion, the task emits an `Event` whose `type` property is checked to determine if the task succeeded. If the event type indicates success, use `taskpool.isConcurrent` to verify if the task ran concurrently and log the result.",
    "output": "import {Event, taskpool} from '@kit.ArkTS';\n\nexport function executeDelayedTask(): void {\n  const task = () => {\n    return 'Task completed successfully';\n  };\n\n  taskpool.executeDelayed(task, 3000).then((event: Event) => {\n    if (event.type === 'success') {\n      const isConcurrent = taskpool.isConcurrent();\n      console.log(`Task succeeded. Ran concurrently: ${isConcurrent}`);\n    } else {\n      console.log('Task failed');\n    }\n  }).catch((error: Error) => {\n    console.error(`Error executing task: ${error.message}`);\n  });\n}"
  }
]