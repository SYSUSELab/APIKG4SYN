[
  {
    "instruction": "Implement a function that receives a `MessageEvent`, parses its `data` property (assumed to be a JSON string) into an object using the `parse` method of `json`, then checks if the parsed object contains a specific key using the `has` method of `json`, and returns the result.",
    "output": "import {json, MessageEvent} from '@kit.ArkTS';\n\nexport function checkMessageEventForKey(event: MessageEvent<string>, key: string): boolean {\n  const parsedData = json.parse(event.data);\n  return json.has(parsedData, key);\n}"
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to asynchronously process a large dataset stored in a `Vector`. The function should first populate the `Vector` using its `add` method, then pass the `Vector` to `taskpool.execute` for parallel processing, and finally use the `Vector`'s `convertToArray` method to return the processed results as an array.",
    "output": "import {taskpool, Vector} from '@kit.ArkTS';\n\nexport async function processLargeDataset(): Promise<number[]> {\n  const vector = new Vector<number>();\n  \n  // Populate the vector with sample data\n  for (let i = 0; i < 1000; i++) {\n    vector.add(i);\n  }\n  \n  // Define the processing function\n  const processData = (data: Vector<number>): Vector<number> => {\n    const processedVector = new Vector<number>();\n    for (let i = 0; i < data.length; i++) {\n      processedVector.add(data.get(i) * 2); // Example processing: multiply each element by 2\n    }\n    return processedVector;\n  };\n  \n  // Execute the processing in parallel using taskpool\n  const task = new taskpool.Task(processData, vector);\n  const processedVector = await taskpool.execute(task) as Vector<number>;\n  \n  // Convert the processed vector to an array and return\n  return processedVector.convertToArray();\n}"
  },
  {
    "instruction": "Create a function where the main thread sends a URL string to a DedicatedWorkerGlobalScope using the `postMessage` method. The worker should use the `onmessage` property to receive the URL, process it, and then send back a response using the `postMessage` method, with the response data stored in the `data` property of a MessageEvent.",
    "output": "import {url, DedicatedWorkerGlobalScope, MessageEvent} from '@kit.ArkTS';\n\nexport function setupWorkerCommunication(worker: DedicatedWorkerGlobalScope, urlString: string): void {\n  worker.postMessage(urlString);\n}\n\nexport function processWorkerMessage(worker: DedicatedWorkerGlobalScope, callback: (data: string) => void): void {\n  worker.onmessage = (event: MessageEvent<string>) => {\n    const processedData = processUrl(event.data);\n    callback(processedData);\n  };\n}\n\nfunction processUrl(urlString: string): string {\n  // Placeholder for URL processing logic\n  return `Processed: ${urlString}`;\n}"
  },
  {
    "instruction": "Write a function that uses `Deque.insertFront` and `Deque.insertEnd` to build a deque of JSON objects, then converts the deque to a JSON string using `json.stringify` and validates if the string contains a specific key using `json.has`.",
    "output": "import {json, util, Deque} from '@kit.ArkTS';\n\nexport function buildAndValidateDeque(key: string): boolean {\n  const deque = new Deque<Record<string, string>>();\n  deque.insertFront({ frontKey: 'frontValue' });\n  deque.insertEnd({ endKey: 'endValue' });\n  \n  const jsonString = json.stringify(Array.from(deque));\n  const jsonObj = json.parse(jsonString);\n  \n  return json.has(jsonObj, key);\n}"
  },
  {
    "instruction": "Create a function that parses an XML string using `xml.EventType` to identify specific elements, extracts their text content into a Buffer using `buffer.concat`, and then stores these Buffers in a List<Buffer> using `List.insert` for further processing.",
    "output": "import {buffer, xml, List} from '@kit.ArkTS';\n\nexport function parseXmlAndStoreBuffers(xmlString: string): List<buffer.Buffer> {\n  const buffers: List<buffer.Buffer> = new List<buffer.Buffer>();\n  const parser = new xml.XmlPullParser(xmlString);\n  let currentBuffer: buffer.Buffer | null = null;\n  let eventType = parser.getEventType();\n\n  while (eventType !== xml.EventType.END_DOCUMENT) {\n    switch (eventType) {\n      case xml.EventType.START_TAG:\n        currentBuffer = buffer.Buffer.alloc(0);\n        break;\n      case xml.EventType.TEXT:\n        if (currentBuffer !== null) {\n          const text = parser.getText();\n          const textBuffer = buffer.Buffer.from(text, 'utf-8');\n          currentBuffer = buffer.Buffer.concat([currentBuffer, textBuffer]);\n        }\n        break;\n      case xml.EventType.END_TAG:\n        if (currentBuffer !== null && currentBuffer.length > 0) {\n          buffers.insert(buffers.length, currentBuffer);\n          currentBuffer = null;\n        }\n        break;\n    }\n    eventType = parser.next();\n  }\n  return buffers;\n}"
  },
  {
    "instruction": "Implement a function that takes an array of URLs (as strings), uses the `Deque` constructor to create a deque from the array, then iterates over the deque using `Symbol.iterator` to filter out invalid URLs (by leveraging the `url` API's parsing). The function should return the filtered deque and its `length` property as an object.",
    "output": "import {Deque, url} from '@kit.ArkTS';\n\nexport function filterValidUrls(urls: string[]): { filteredDeque: Deque<string>, length: number } {\n  const deque = new Deque(urls);\n  const filteredDeque = new Deque<string>();\n\n  for (const urlStr of deque) {\n    try {\n      new url.URL(urlStr);\n      filteredDeque.insertEnd(urlStr);\n    } catch (e) {\n      // Invalid URL, skip\n    }\n  }\n\n  return {\n    filteredDeque,\n    length: filteredDeque.length\n  };\n}"
  },
  {
    "instruction": "Create a worker thread using `ThreadWorkerGlobalScope` and set up an `onmessage` handler to receive a URL string. Inside the handler, use the `url` API to parse the URL and then use `ThreadWorkerGlobalScope.postMessage` to send the parsed components (like hostname, path, etc.) back to the main thread.",
    "output": "import {ErrorEvent, ThreadWorkerGlobalScope, url} from '@kit.ArkTS';\n\nconst workerPort: ThreadWorkerGlobalScope = workerPortGlobalScope;\n\nworkerPort.onmessage = (event: MessageEvent<string>) => {\n  try {\n    const parsedUrl = url.parse(event.data);\n    workerPort.postMessage({\n      hostname: parsedUrl.hostname,\n      path: parsedUrl.path,\n      protocol: parsedUrl.protocol,\n      search: parsedUrl.search\n    });\n  } catch (error) {\n    const errorEvent: ErrorEvent = {\n      error: error,\n      message: error.message,\n      filename: '',\n      lineno: 0,\n      colno: 0\n    };\n    workerPort.postMessage(errorEvent);\n  }\n};\n"
  },
  {
    "instruction": "Create a function that utilizes the `getEnvironmentVar` method of `process` to fetch an environment variable, then checks if the variable exists using the `has` method of `PlainArray`. If it exists, update its value in the `PlainArray` using the `setValueAt` method; otherwise, add it using the `add` method.",
    "output": "import {process, PlainArray} from '@kit.ArkTS';\n\nexport function updateOrAddEnvVar(envVarName: string, plainArray: PlainArray<number, string>): void {\n  const envVarValue = process.getEnvironmentVar(envVarName);\n  if (envVarValue !== undefined) {\n    const index = plainArray.getIndexOfKey(envVarName);\n    if (index !== -1) {\n      plainArray.setValueAt(index, envVarValue);\n    } else {\n      plainArray.add(envVarName, envVarValue);\n    }\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `parse` method of `json` to convert a JSON string into an object, then checks if a specific key exists in the object using the `has` method of `json`, and finally removes that key using the `remove` method of `json` if it exists.",
    "output": "import {stream, json} from '@kit.ArkTS';\n\nexport function processJson(jsonString: string, keyToCheck: string): object {\n  const parsedObject = json.parse(jsonString);\n  if (json.has(parsedObject, keyToCheck)) {\n    json.remove(parsedObject, keyToCheck);\n  }\n  return parsedObject;\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of messages from a worker thread, then uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send the collected messages back to the main thread. The function must also handle errors by using the `onmessageerror` property of `DedicatedWorkerGlobalScope` to log any message processing failures.",
    "output": "import {DedicatedWorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function collectAndSendMessages(workerScope: DedicatedWorkerGlobalScope): void {\n  const messageList: LinkedList<string> = new LinkedList();\n\n  workerScope.onmessage = (event: MessageEvent<string>) => {\n    try {\n      messageList.add(event.data);\n    } catch (error) {\n      console.error(`Error adding message to list: ${error}`);\n    }\n  };\n\n  workerScope.onmessageerror = (event: MessageEvent) => {\n    console.error(`Message processing error: ${event}`);\n  };\n\n  // Example of sending collected messages back to main thread\n  // In a real scenario, you might want to trigger this at a specific time or condition\n  workerScope.postMessage(Array.from(messageList));\n}"
  },
  {
    "instruction": "Write a function that uses the `worker` API to spawn a new worker thread, then uses the `buffer.from` method to create a buffer containing a string message, and finally sends this buffer to the worker thread using the `worker.postMessage` method.",
    "output": "import {worker, buffer} from '@kit.ArkTS';\n\nexport function spawnWorkerAndSendMessage(): void {\n  const workerInstance = new worker.ThreadWorker('workers/worker.ts');\n  const message: string = 'Hello from main thread!';\n  const messageBuffer: buffer.Buffer = buffer.from(message, 'utf-8');\n  workerInstance.postMessage(messageBuffer);\n}"
  },
  {
    "instruction": "Create a function that first checks if a `TreeSet` is empty using the `isEmpty` method, and if it is not, iterates over its values using the `Symbol.iterator` method to generate an XML string representation of the set's contents using the `xml` API. The XML should include each value as a child node with a specified tag name.",
    "output": "import {xml, TreeSet} from '@kit.ArkTS';\n\nexport function treeSetToXML(treeSet: TreeSet<string>, tagName: string): string {\n  if (treeSet.isEmpty()) {\n    return '';\n  }\n\n  const xmlBuilder = new xml.XmlBuilder();\n  const root = xmlBuilder.createElement('root');\n\n  for (const value of treeSet) {\n    const child = xmlBuilder.createElement(tagName);\n    child.setTextContent(value);\n    root.appendChild(child);\n  }\n\n  return xmlBuilder.build(root);\n}"
  },
  {
    "instruction": "Create a function that initializes an `ArrayList` with a set of strings and uses the `convertToArray` method to convert it into an array. Then, pass this array to a `Vector` object using its `constructor` method. Finally, use the `subVector` method of the `Vector` to extract a subset of elements and return them.",
    "output": "import {DedicatedWorkerGlobalScope, Vector, ArrayList} from '@kit.ArkTS';\n\nexport function processVector(): string[] {\n  // Initialize ArrayList with strings\n  const arrayList = new ArrayList<string>();\n  arrayList.add('Apple');\n  arrayList.add('Banana');\n  arrayList.add('Cherry');\n  arrayList.add('Date');\n  arrayList.add('Elderberry');\n\n  // Convert ArrayList to array\n  const array = arrayList.convertToArray();\n\n  // Pass array to Vector constructor\n  const vector = new Vector<string>(array);\n\n  // Extract subset using subVector\n  const subVector = vector.subVector(1, 4);\n\n  // Convert subVector to array and return\n  return subVector.convertToArray();\n}"
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a message to a worker thread, and then uses the `addEventListener` method of `WorkerEventTarget` in the worker thread to listen for and process the incoming message. The function should also handle errors by utilizing the `onerror` property of `GlobalScope`.",
    "output": "import {GlobalScope, WorkerEventTarget, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerCommunication() {\n  // Assuming this is running in the worker thread context\n  const workerScope: ThreadWorkerGlobalScope = self as ThreadWorkerGlobalScope;\n\n  // Set up error handler\n  workerScope.onerror = (error: ErrorEvent) => {\n    console.error(`Worker error: ${error.message}`);\n  };\n\n  // Listen for messages from main thread\n  workerScope.addEventListener('message', (event: MessageEvent) => {\n    console.log('Received message in worker:', event.data);\n    // Process the message here\n  });\n\n  // Example of sending a message back to main thread\n  workerScope.postMessage('Worker is ready');\n}"
  },
  {
    "instruction": "Write a function that uses the `self` property of `GlobalScope` to access the current global object, then passes it to a Worker thread using `WorkerGlobalScope`'s `name` property to identify the Worker. The function should then set up an error handler using the `onerror` property of both `GlobalScope` and `WorkerGlobalScope` to log errors from both contexts.",
    "output": "import {GlobalScope, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerWithErrorHandling(): void {\n  const globalObj: GlobalScope = GlobalScope.self;\n  \n  // Create a new worker with a name\n  const worker: WorkerGlobalScope = new WorkerGlobalScope();\n  worker.name = 'errorHandlingWorker';\n  \n  // Set up error handler for the global scope\n  globalObj.onerror = (event: ErrorEvent) => {\n    console.error(`Global error: ${event.message}`);\n  };\n  \n  // Set up error handler for the worker scope\n  worker.onerror = (event: ErrorEvent) => {\n    console.error(`Worker error: ${event.message}`);\n  };\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `Vector` to collect a sequence of numbers, then passes the resulting Vector to the `setAll` method of `TreeMap` to store the numbers as keys with their squares as values. Finally, use the `getHigherKey` method of `TreeMap` to find the smallest key greater than a given threshold.",
    "output": "import {Vector, TreeMap} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[], threshold: number): number | undefined {\n  const vector = new Vector<number>();\n  numbers.forEach(num => vector.add(num));\n\n  const treeMap = new TreeMap<number, number>();\n  treeMap.setAll(vector);\n\n  vector.forEach(key => {\n    treeMap.set(key, key * key);\n  });\n\n  return treeMap.getHigherKey(threshold);\n}"
  },
  {
    "instruction": "Create a function that initializes a worker with `WorkerOptions` where the `shared` property is set to true, then sends a message to the worker and uses the `data` property of `MessageEvents` to verify the response from the worker.",
    "output": "import {WorkerOptions, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function initializeWorker(): void {\n  const options: WorkerOptions = {\n    shared: true\n  };\n\n  const worker = new Worker('workers/worker.ts', options);\n\n  worker.postMessage('Test message');\n\n  worker.onmessage = (event: MessageEvents) => {\n    const response = event.data;\n    console.log('Response from worker:', response);\n  };\n\n  worker.onerror = (error) => {\n    console.error('Worker error:', error);\n  };\n}"
  },
  {
    "instruction": "Write a function that first uses the `getValueAt` method of `PlainArray` to retrieve all values, then adds these values to a `TreeSet` using its `add` method, and finally uses the `popFirst` method of `TreeSet` to remove and return the smallest value from the set.",
    "output": "import {PlainArray, TreeSet} from '@kit.ArkTS';\n\nexport function processPlainArrayToTreeSet(plainArray: PlainArray<number>): number | undefined {\n  const treeSet = new TreeSet<number>();\n  const length = plainArray.length;\n  \n  for (let i = 0; i < length; i++) {\n    const value = plainArray.getValueAt(i);\n    treeSet.add(value);\n  }\n  \n  return treeSet.popFirst();\n}"
  },
  {
    "instruction": "Implement a function where a worker thread receives messages via the `onmessage` property of `DedicatedWorkerGlobalScope`, processes the data (e.g., extracting URLs), and stores the results in a `Deque` using the `insertEnd` method. The function should then use the `forEach` method of `Deque` to log each processed item.",
    "output": "import {Deque, url, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processWorkerMessages(workerScope: DedicatedWorkerGlobalScope): void {\n  const deque = new Deque<string>();\n\n  workerScope.onmessage = (event: MessageEvent<string>) => {\n    const message = event.data;\n    // Process the data (e.g., extracting URLs)\n    const processedData = message; // Placeholder for actual processing\n    deque.insertEnd(processedData);\n\n    // Log each processed item using forEach\n    deque.forEach((item: string) => {\n      console.log(item);\n    });\n  };\n}"
  },
  {
    "instruction": "Implement a function that uses `WorkerEventTarget`'s `addEventListener` to listen for a custom event, and upon triggering, pushes the event data onto a `Stack` using `push`. Then, use the `peek` method to check the top value of the stack and `removeEventListener` to clean up the listener once the stack's `length` reaches a specified limit.",
    "output": "import {WorkerEventTarget, Stack} from '@kit.ArkTS';\n\nexport function listenAndPushEvents(eventTarget: WorkerEventTarget, eventName: string, limit: number): void {\n  const stack = new Stack<unknown>();\n\n  const eventListener = (event: Event) => {\n    const customEvent = event as CustomEvent;\n    stack.push(customEvent.detail);\n\n    if (stack.length >= limit) {\n      const topValue = stack.peek();\n      console.log(`Top value of stack: ${topValue}`);\n      eventTarget.removeEventListener(eventName, eventListener);\n    }\n  };\n\n  eventTarget.addEventListener(eventName, eventListener);\n}"
  },
  {
    "instruction": "Write a function that creates an `EventTarget` object and uses `addEventListener` to register a one-time event listener (i.e., the listener removes itself after execution). Use `dispatchEvent` to trigger the event, and verify the listener is automatically removed by attempting to trigger the event again and confirming the callback is not executed. Use `removeEventListener` to manually remove the listener if needed.",
    "output": "import {EventTarget} from '@kit.ArkTS';\n\nexport function testOneTimeEventListener(): void {\n  const eventTarget = new EventTarget();\n  let callbackCount = 0;\n\n  const listener = (): void => {\n    callbackCount++;\n    eventTarget.removeEventListener('test', listener);\n  };\n\n  eventTarget.addEventListener('test', listener);\n  eventTarget.dispatchEvent('test');\n  eventTarget.dispatchEvent('test');\n\n  if (callbackCount !== 1) {\n    throw new Error('One-time event listener did not work as expected');\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `entries` method of `LightWeightMap` to get an iterator of its key-value pairs, then iterates over them using `[Symbol.iterator]` to create an array of `Event` objects. Each `Event` should have its `type` set to the key and `timeStamp` set to the value. Finally, use the `isEmpty` method of `LightWeightMap` to check if the map was empty before processing and log a message accordingly.",
    "output": "import {Event, LightWeightMap} from '@kit.ArkTS';\n\nexport function processLightWeightMap(map: LightWeightMap<string, number>): Event[] {\n  const events: Event[] = [];\n  \n  if (map.isEmpty()) {\n    console.log('The LightWeightMap is empty.');\n    return events;\n  }\n  \n  const iterator = map.entries()[Symbol.iterator]();\n  let next = iterator.next();\n  \n  while (!next.done) {\n    const [key, value] = next.value;\n    const event: Event = {\n      type: key,\n      timeStamp: value\n    };\n    events.push(event);\n    next = iterator.next();\n  }\n  \n  return events;\n}"
  },
  {
    "instruction": "Implement a periodic task using `taskpool.executePeriodically` that generates data every 5 seconds. Use `MessageEvents.data` to emit the generated data to a listener, and provide a way to stop the periodic task using `taskpool.terminateTask` when a stop condition is met.",
    "output": "import {taskpool, MessageEvents} from '@kit.ArkTS';\n\nexport class PeriodicDataGenerator {\n  private taskId: number | undefined;\n  private messageEvents: MessageEvents = new MessageEvents();\n  private stopCondition: boolean = false;\n\n  public startGeneratingData(): void {\n    this.taskId = taskpool.executePeriodically(() => {\n      if (this.stopCondition) {\n        taskpool.terminateTask(this.taskId as number);\n        return;\n      }\n      const generatedData: string = `Data generated at ${new Date().toISOString()}`;\n      this.messageEvents.data = generatedData;\n    }, 5000);\n  }\n\n  public setStopCondition(condition: boolean): void {\n    this.stopCondition = condition;\n  }\n\n  public getMessageEvents(): MessageEvents {\n    return this.messageEvents;\n  }\n}"
  },
  {
    "instruction": "Create a function that uses the `has` method of `HashSet` to check if a specific worker name exists in a set of active workers, then uses the `name` property of `WorkerGlobalScope` to dynamically assign or verify the worker's identity before performing further operations.",
    "output": "import {WorkerGlobalScope, HashSet} from '@kit.ArkTS';\n\nexport function checkWorkerIdentity(activeWorkers: HashSet<string>, workerScope: WorkerGlobalScope): boolean {\n  const workerName = workerScope.name;\n  if (activeWorkers.has(workerName)) {\n    return true;\n  }\n  return false;\n}"
  },
  {
    "instruction": "Implement a function that uses the `xml` API to parse an XML document containing a list of items with attributes, then filters these items based on a condition. The filtered items' IDs (extracted from attributes) should be added to a `TreeSet` using the `add` method, and the final result should be the size of the set obtained using the `length` property.",
    "output": "import {xml, TreeSet} from '@kit.ArkTS';\n\nexport function filterAndCountItems(xmlString: string, condition: (item: Record<string, string>) => boolean): number {\n  const parser = new xml.XmlPullParser(xmlString);\n  const itemIds = new TreeSet<string>();\n\n  while (parser.next() !== xml.EventType.END_DOCUMENT) {\n    if (parser.getEventType() === xml.EventType.START_TAG) {\n      const tagName = parser.getName();\n      if (tagName === 'item') {\n        const attributes = parser.getAttributes();\n        if (condition(attributes)) {\n          const id = attributes['id'];\n          if (id) {\n            itemIds.add(id);\n          }\n        }\n      }\n    }\n  }\n\n  return itemIds.length;\n}"
  },
  {
    "instruction": "Implement a function that uses the `values` method of `LightWeightSet` to extract all values (item names), then passes these values to the `forEach` method of `HashMap` to count the occurrences of each item name in the map and return the counts as a new `HashMap`.",
    "output": "import {LightWeightSet, HashMap} from '@kit.ArkTS';\n\nexport function countOccurrences(lightWeightSet: LightWeightSet<string>, hashMap: HashMap<string, number>): HashMap<string, number> {\n  const resultMap = new HashMap<string, number>();\n  const values = lightWeightSet.values();\n  \n  values.forEach((value: string) => {\n    let count = 0;\n    hashMap.forEach((val: number, key: string) => {\n      if (key === value) {\n        count += val;\n      }\n    });\n    if (count > 0) {\n      resultMap.set(value, count);\n    }\n  });\n  \n  return resultMap;\n}"
  },
  {
    "instruction": "Implement a function that checks if the current process is 64-bit using the `is64Bit` method of `process`, then retrieves the thread priority using `getThreadPriority`, and finally constructs a URL (using URL API methods) to report these system characteristics to a monitoring service.",
    "output": "import {worker, process, url} from '@kit.ArkTS';\n\nexport function reportSystemCharacteristics(monitoringServiceUrl: string): string {\n  const is64Bit: boolean = process.is64Bit();\n  const threadPriority: number = process.getThreadPriority();\n  \n  const urlObj = new url.URL(monitoringServiceUrl);\n  urlObj.searchParams.append('is64Bit', is64Bit.toString());\n  urlObj.searchParams.append('threadPriority', threadPriority.toString());\n  \n  return urlObj.toString();\n}"
  },
  {
    "instruction": "Create a function that first uses the `add` method of `TreeSet` (from @kit.ArkTS) to collect a set of unique strings, then transfers these strings to a `Stack` (from @kit.ArkTS) using the `push` method. After transferring, use the `peek` method of `Stack` to check the top element and the `getLastValue` method of `TreeSet` to compare it with the largest value in the original set. Return `true` if they match, otherwise `false`.",
    "output": "import {Stack, LightWeightMap, TreeSet} from '@kit.ArkTS';\n\nexport function compareTopWithLargestValue(strings: string[]): boolean {\n  const treeSet = new TreeSet<string>();\n  const stack = new Stack<string>();\n\n  // Add all strings to the TreeSet to ensure uniqueness\n  for (const str of strings) {\n    treeSet.add(str);\n  }\n\n  // Transfer all unique strings from TreeSet to Stack\n  const values = treeSet.values();\n  for (const value of values) {\n    stack.push(value);\n  }\n\n  // Get the top element from Stack and the largest value from TreeSet\n  const topElement = stack.peek();\n  const largestValue = treeSet.getLastValue();\n\n  // Compare and return the result\n  return topElement === largestValue;\n}"
  },
  {
    "instruction": "Create a function that first uses the `sort` method of `List` to sort a list of XML node names alphabetically, then uses the `getFirst` and `getLast` methods of `List` to retrieve the first and last elements of the sorted list, and finally uses the `EventType` enum from `xml` to log these elements with a specific event type (e.g., `EventType.DEBUG`).",
    "output": "import {List, xml} from '@kit.ArkTS';\n\nexport function sortAndLogXmlNodeNames(nodeNames: List<string>): void {\n  nodeNames.sort((a: string, b: string) => a.localeCompare(b));\n  const firstNode: string = nodeNames.getFirst();\n  const lastNode: string = nodeNames.getLast();\n  console.log(`First node: ${firstNode}`, xml.EventType.DEBUG);\n  console.log(`Last node: ${lastNode}`, xml.EventType.DEBUG);\n}"
  },
  {
    "instruction": "Create a function that schedules a delayed task using `taskpool.executeDelayed` with a 5-second delay. Use `WorkerEventTarget.addEventListener` to listen for a cancellation signal (e.g., a user action). If the signal is received before the task starts, cancel the task using `taskpool.cancel` and log the cancellation status.",
    "output": "import {taskpool, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function scheduleDelayedTaskWithCancellation(eventTarget: WorkerEventTarget): void {\n  const task: taskpool.Task = new taskpool.Task(() => {\n    console.log('Task executed after delay');\n  });\n\n  const taskId: number = taskpool.executeDelayed(task, 5000);\n\n  const cancellationListener = () => {\n    const isCancelled: boolean = taskpool.cancel(taskId);\n    console.log(`Task cancellation status: ${isCancelled}`);\n    eventTarget.removeEventListener('cancel', cancellationListener);\n  };\n\n  eventTarget.addEventListener('cancel', cancellationListener);\n}"
  },
  {
    "instruction": "Write a function that uses the `getFirst` and `getLast` methods of `Deque` (from @kit.ArkTS) to retrieve the first and last elements of a deque, then passes these elements to the `add` and `insert` methods of `List` (from @kit.ArkTS) to create a new list where the first element of the deque is added to the end and the last element of the deque is inserted at the beginning.",
    "output": "import {WorkerGlobalScope, List, Deque} from '@kit.ArkTS';\n\nexport function processDequeToNewList(deque: Deque<number>): List<number> {\n  const firstElement = deque.getFirst();\n  const lastElement = deque.getLast();\n  \n  const newList = new List<number>();\n  newList.insert(0, lastElement);\n  newList.add(firstElement);\n  \n  return newList;\n}"
  },
  {
    "instruction": "Write a function that uses the `values` method of `TreeMap<string, boolean>` (from @kit.ArkTS) to collect all values, then checks if any of these values are `true` using the `has` method of `ArrayList<boolean>` (from @kit.ArkTS), and returns the result.",
    "output": "import {ArrayList, TreeMap} from '@kit.ArkTS';\n\nexport function hasTrueValue(map: TreeMap<string, boolean>): boolean {\n  const values: ArrayList<boolean> = map.values();\n  return values.has(true);\n}"
  },
  {
    "instruction": "Implement a function that checks if a `Stack` (from @kit.ArkTS) is empty using the `isEmpty` method, and if it is not empty, use the `peek` method to retrieve the top element and pass it as part of an `Event` object (from @kit.ArkTS) by setting its `type` property to a custom value based on the stack element.",
    "output": "import {Stack, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function checkStackAndPostEvent(stack: Stack<number>, eventType: string): Event | undefined {\n  if (!stack.isEmpty()) {\n    const topElement = stack.peek();\n    const event = new Event();\n    event.type = `${eventType}_${topElement}`;\n    return event;\n  }\n  return undefined;\n}"
  },
  {
    "instruction": "Create a function that retrieves the `name` property from `WorkerGlobalScope` and stores it in a `LightWeightSet` using the `add` method. Then, use the `forEach` method of `LightWeightSet` to iterate over all stored names and print them to the console.",
    "output": "import {WorkerGlobalScope, LightWeightSet} from '@kit.ArkTS';\n\nexport function retrieveAndStoreName(scope: WorkerGlobalScope): void {\n  const nameSet = new LightWeightSet<string>();\n  if (scope.name) {\n    nameSet.add(scope.name);\n  }\n  nameSet.forEach((value: string) => {\n    console.log(value);\n  });\n}"
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then transfers these numbers to a `PlainArray` (from @kit.ArkTS) using its `add` method. Finally, use the `getValueAt` method of `PlainArray` to retrieve and print the values in reverse order.",
    "output": "import {Stack, PlainArray} from '@kit.ArkTS';\n\nexport function transferStackToPlainArrayAndPrintReverse(numbers: number[]): void {\n  const stack = new Stack<number>();\n  numbers.forEach((num) => {\n    stack.push(num);\n  });\n\n  const plainArray = new PlainArray<number>();\n  let index = 0;\n  while (!stack.isEmpty()) {\n    const value = stack.pop();\n    plainArray.add(index, value);\n    index++;\n  }\n\n  for (let i = plainArray.length - 1; i >= 0; i--) {\n    console.log(plainArray.getValueAt(i));\n  }\n}"
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to asynchronously process a list of numbers by squaring each element, then stores the squared values in a `LightWeightSet` using its `addAll` method. Finally, use `LightWeightSet.toArray` to return the processed array.",
    "output": "import {taskpool, LightWeightSet} from '@kit.ArkTS';\n\nexport async function processNumbers(numbers: number[]): Promise<number[]> {\n  const squaredNumbers = await taskpool.execute(() => {\n    return numbers.map(num => num * num);\n  }, taskpool.Priority.LOW);\n\n  const lightWeightSet = new LightWeightSet<number>();\n  lightWeightSet.addAll(squaredNumbers);\n  \n  return lightWeightSet.toArray();\n}"
  },
  {
    "instruction": "Implement a function that filters a `LightWeightSet` of `MessageEvent` objects by a specific condition on their `data` properties. Use the `getValueAt` method of `LightWeightSet` to access each `MessageEvent`, check the `data` property, and then use the `removeAt` method to remove elements that do not meet the condition.",
    "output": "import {MessageEvent, LightWeightSet} from '@kit.ArkTS';\n\nexport function filterMessageEventsByData<T>(set: LightWeightSet<MessageEvent<T>>, condition: (data: T) => boolean): void {\n  for (let i = set.length - 1; i >= 0; i--) {\n    const event = set.getValueAt(i);\n    if (!condition(event.data)) {\n      set.removeAt(i);\n    }\n  }\n}"
  },
  {
    "instruction": "Create a worker event handler that uses the `addEventListener` method of `WorkerEventTarget` to listen for messages from the main thread. Upon receiving a message, the handler should use the `getFirst` and `getLast` methods of `Deque` to check if the first and last elements of the received array are equal, and then use the `postMessage` method of `ThreadWorkerGlobalScope` to send the result back to the main thread.",
    "output": "import {ThreadWorkerGlobalScope, WorkerEventTarget, Deque} from '@kit.ArkTS';\n\nexport function setupWorkerListener(workerScope: ThreadWorkerGlobalScope): void {\n  const eventTarget: WorkerEventTarget = workerScope as unknown as WorkerEventTarget;\n  \n  eventTarget.addEventListener('message', (event: MessageEvent<Array<number>>) => {\n    const deque = new Deque<number>();\n    const receivedArray = event.data;\n    \n    for (const item of receivedArray) {\n      deque.insertEnd(item);\n    }\n    \n    const firstElement = deque.getFirst();\n    const lastElement = deque.getLast();\n    const result = firstElement === lastElement;\n    \n    workerScope.postMessage(result);\n  });\n}"
  },
  {
    "instruction": "Create a function that uses the `convertToArray` method of `LinkedList` to transform a linked list of worker names into an array, then passes this array to the `self` property of `WorkerGlobalScope` to broadcast the list to all worker threads. The function should also use the `forEach` method of `LinkedList` to iterate over the names before conversion.",
    "output": "import {WorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function broadcastWorkerNames(workerNames: LinkedList<string>): void {\n  workerNames.forEach((name: string) => {\n    console.log(`Worker name: ${name}`);\n  });\n\n  const namesArray: string[] = workerNames.convertToArray();\n  WorkerGlobalScope.self = namesArray;\n}"
  },
  {
    "instruction": "Write a function that first uses the `getFirst` and `getLast` methods of `Deque<string>` (from @kit.ArkTS) to retrieve the oldest and newest log entries, then passes these entries to the `add` method of `ArrayList<string>` (from @kit.ArkTS) to compile a summary list of log boundaries.",
    "output": "import {xml, Deque, ArrayList} from '@kit.ArkTS';\n\nexport function compileLogBoundaries(logDeque: Deque<string>, summaryList: ArrayList<string>): void {\n  if (logDeque.length > 0) {\n    const oldestLog = logDeque.getFirst();\n    const newestLog = logDeque.getLast();\n    summaryList.add(oldestLog);\n    summaryList.add(newestLog);\n  }\n}"
  },
  {
    "instruction": "Implement a function that uses the `add` and `getSubList` methods of `List` to create and manipulate a list of error messages. Then, pass this list to a worker thread using the `postMessage` method of `DedicatedWorkerGlobalScope`. In the worker thread, use the `onmessageerror` property of `DedicatedWorkerGlobalScope` to handle any message errors and log them using the `message` property of `ErrorEvent`.",
    "output": "import {DedicatedWorkerGlobalScope, List, ErrorEvent} from '@kit.ArkTS';\n\nexport function createAndManipulateErrorList(): List<string> {\n  const errorList: List<string> = new List();\n  errorList.add('Error 1: Invalid input');\n  errorList.add('Error 2: Network failure');\n  errorList.add('Error 3: Timeout');\n  \n  const subList = errorList.getSubList(1, 2);\n  return subList;\n}\n\nexport function postToWorker(worker: DedicatedWorkerGlobalScope, errorList: List<string>): void {\n  worker.postMessage(errorList);\n}\n\nexport function setupWorkerErrorHandler(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessageerror = (event: ErrorEvent) => {\n    console.error(`Message error: ${event.message}`);\n  };\n}"
  },
  {
    "instruction": "Create a function that first uses the `getFirst` and `getLast` methods of `Deque` to retrieve the first and last elements of a deque containing XML event types (from the `EventType` enum of `xml`), then compares these event types and returns a boolean indicating whether they are the same.",
    "output": "import {uri, Deque, xml} from '@kit.ArkTS';\n\nexport function compareFirstAndLastEventTypes(deque: Deque<xml.EventType>): boolean {\n  const firstEvent = deque.getFirst();\n  const lastEvent = deque.getLast();\n  return firstEvent === lastEvent;\n}"
  },
  {
    "instruction": "Implement a function where a `ThreadWorkerGlobalScope` worker uses `callGlobalCallObjectMethod` to fetch data, stores it in a `Deque` using `insertFront`, and then posts the deque back to the main thread. The main thread should use the `popFirst` method of `Deque` to process each item and log it, while also using `taskpool.terminateTask` to clean up the worker after completion.",
    "output": "import {Deque, taskpool, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function workerFunction(workerGlobalScope: ThreadWorkerGlobalScope): void {\n  const data = workerGlobalScope.callGlobalCallObjectMethod('fetchData');\n  const deque = new Deque<unknown>();\n  deque.insertFront(data);\n  workerGlobalScope.postMessage(deque);\n}\n\nexport function mainThreadFunction(): void {\n  const worker = new ThreadWorkerGlobalScope('script/worker.js');\n  worker.onmessage = (message: { data: Deque<unknown> }) => {\n    const deque = message.data;\n    while (deque.length > 0) {\n      const item = deque.popFirst();\n      console.log(item);\n    }\n    taskpool.terminateTask(worker);\n  };\n}"
  },
  {
    "instruction": "Write a function that uses the `uptime` method of `process` to get the system uptime, then inserts this value into a `Deque` using its `insertFront` method. Next, use the `popFirst` method of `Deque` to retrieve the uptime value and pass it to the `replace` method of `HashMap` to update a predefined key (e.g., 'system_uptime').",
    "output": "import {Deque, HashMap, process} from '@kit.ArkTS';\n\nexport function updateSystemUptimeInHashMap(): void {\n  const uptimeValue: number = process.uptime();\n  const deque: Deque<number> = new Deque<number>();\n  deque.insertFront(uptimeValue);\n  const retrievedUptime: number | undefined = deque.popFirst();\n  \n  const hashMap: HashMap<string, number> = new HashMap<string, number>();\n  hashMap.set('system_uptime', 0);\n  \n  if (retrievedUptime !== undefined) {\n    hashMap.replace('system_uptime', retrievedUptime);\n  }\n}"
  },
  {
    "instruction": "Write a function that creates a `Queue` of events (using the `add` method) and then iterates through the queue (using `[Symbol.iterator]`) to filter out events with a specific `type` (using the `type` property of `Event`). Return the filtered events as a new `Queue`.",
    "output": "import {Event, Queue} from '@kit.ArkTS';\n\nexport function filterEventsByType(events: Event[], type: string): Queue<Event> {\n  const queue = new Queue<Event>();\n  events.forEach(event => queue.add(event));\n  \n  const filteredQueue = new Queue<Event>();\n  for (const event of queue) {\n    if (event.type === type) {\n      filteredQueue.add(event);\n    }\n  }\n  \n  return filteredQueue;\n}"
  },
  {
    "instruction": "Implement a function that checks if a `LightWeightMap` is empty using `LightWeightMap.isEmpty`. If the map is not empty, use `taskpool.executePeriodically` to log the map's `length` property every second until the map is cleared using `LightWeightMap.clear`.",
    "output": "import {taskpool, LightWeightMap} from '@kit.ArkTS';\n\nexport function checkAndLogMap(map: LightWeightMap<unknown, unknown>): void {\n  if (map.isEmpty()) {\n    console.log('Map is empty');\n  } else {\n    const taskId = taskpool.executePeriodically(() => {\n      console.log(`Map length: ${map.length}`);\n      if (map.isEmpty()) {\n        taskpool.cancel(taskId);\n      }\n    }, 1000);\n  }\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Queue` to process a list of worker names, checks if the current worker name matches the `name` property of `WorkerGlobalScope`, and removes all event listeners via the `removeAllListener` method of `WorkerEventTarget` if a match is found. The function should also use the `self` property of `WorkerGlobalScope` to verify the worker context.",
    "output": "import {WorkerEventTarget, Queue, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processWorkerNames(queue: Queue<string>, workerScope: WorkerGlobalScope): void {\n  queue.forEach((workerName: string) => {\n    if (workerName === workerScope.name) {\n      const eventTarget: WorkerEventTarget = workerScope.self as WorkerEventTarget;\n      eventTarget.removeAllListener();\n    }\n  });\n}"
  },
  {
    "instruction": "Implement a task management system where you use the `removeRangeFrom` method of `PlainArray` to clear completed tasks (identified by their keys). Then, use the `getTaskPoolInfo` method of `taskpool` to monitor the remaining tasks and log their statuses, ensuring the system only processes active tasks.",
    "output": "import {PlainArray, taskpool} from '@kit.ArkTS';\n\nexport class TaskManagementSystem {\n  private tasks: PlainArray<number, string>;\n\n  constructor() {\n    this.tasks = new PlainArray<number, string>();\n  }\n\n  public addTask(key: number, value: string): void {\n    this.tasks.add(key, value);\n  }\n\n  public clearCompletedTasks(completedKeys: number[]): void {\n    if (completedKeys.length === 0) return;\n    \n    completedKeys.sort((a, b) => a - b);\n    const firstKey = completedKeys[0];\n    const lastKey = completedKeys[completedKeys.length - 1];\n    \n    this.tasks.removeRangeFrom(firstKey, lastKey);\n  }\n\n  public async monitorTasks(): Promise<void> {\n    const taskPoolInfo = taskpool.getTaskPoolInfo();\n    console.log(`Task pool state: ${taskPoolInfo.state}`);\n    console.log(`Active tasks: ${this.tasks.length}`);\n    \n    for (let i = 0; i < this.tasks.length; i++) {\n      const key = this.tasks.getKeyAt(i);\n      const value = this.tasks.getValueAt(i);\n      console.log(`Task ${key}: ${value}`);\n    }\n  }\n\n  public getActiveTasks(): PlainArray<number, string> {\n    return this.tasks;\n  }\n}"
  },
  {
    "instruction": "Write a function that uses `WorkerEventTarget.addEventListener` to listen for a custom event, then parses the event data using `json.parse` and checks if a specific key exists in the parsed object using `json.has`. The function should return the parsed object if the key exists, otherwise return null.",
    "output": "import {WorkerEventTarget, json} from '@kit.ArkTS';\n\nexport function listenAndParseEvent(eventTarget: WorkerEventTarget, eventType: string, key: string): object | null {\n  let parsedData: object | null = null;\n  \n  const eventHandler = (event: { data: string }) => {\n    try {\n      const parsedObject = json.parse(event.data);\n      if (json.has(parsedObject, key)) {\n        parsedData = parsedObject;\n      } else {\n        parsedData = null;\n      }\n    } catch (e) {\n      parsedData = null;\n    }\n  };\n  \n  eventTarget.addEventListener(eventType, eventHandler);\n  \n  return parsedData;\n}"
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send a `PlainArray` object to a worker thread, ensuring the transfer of ownership by setting the `transfer` property of `PostMessageOptions`. The worker thread should then use the `getValueAt` and `length` properties of the received `PlainArray` to process and return the sum of all values.",
    "output": "import {PostMessageOptions, DedicatedWorkerGlobalScope, PlainArray} from '@kit.ArkTS';\n\nexport function sendPlainArrayToWorker(worker: DedicatedWorkerGlobalScope, plainArray: PlainArray<number>): void {\n  const buffer = new ArrayBuffer(plainArray.length * 4);\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  worker.postMessage(plainArray, options);\n}\n\nexport function processPlainArrayInWorker(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent<PlainArray<number>>) => {\n    const plainArray = event.data;\n    let sum = 0;\n    for (let i = 0; i < plainArray.length; i++) {\n      sum += plainArray.getValueAt(i);\n    }\n    worker.postMessage(sum);\n  };\n}"
  },
  {
    "instruction": "Write a function that first uses the `add` and `addFirst` methods of `LinkedList` to build a list of strings, then transfers the elements to a `Deque` using its `insertFront` and `insertEnd` methods, and finally uses the `getFirst` and `getLast` methods of `Deque` to retrieve and print the first and last elements.",
    "output": "import {uri, Deque, LinkedList} from '@kit.ArkTS';\n\nexport function transferAndPrintElements(): void {\n  // Create a LinkedList and add elements\n  const linkedList = new LinkedList<string>();\n  linkedList.add('First');\n  linkedList.add('Middle');\n  linkedList.addFirst('VeryFirst');\n  linkedList.add('Last');\n\n  // Create a Deque and transfer elements from LinkedList\n  const deque = new Deque<string>();\n  for (const element of linkedList) {\n    deque.insertEnd(element);\n  }\n\n  // Retrieve and print the first and last elements of the Deque\n  const firstElement = deque.getFirst();\n  const lastElement = deque.getLast();\n  console.log(`First element: ${firstElement}`);\n  console.log(`Last element: ${lastElement}`);\n}"
  },
  {
    "instruction": "Write a function that creates a `PostMessageOptions` object with the `transfer` property set to an array of resources, then uses this object to send a message via `postMessage`. The receiving end should extract the message content using the `data` property of the `MessageEvent` object and log it.",
    "output": "import {PostMessageOptions, MessageEvent} from '@kit.ArkTS';\n\nexport function sendMessageWithTransfer(message: string, transfer: ArrayBuffer[]): void {\n  const options: PostMessageOptions = {\n    transfer: transfer\n  };\n  postMessage(message, options);\n}\n\nexport function handleMessage(event: MessageEvent<string>): void {\n  console.log(event.data);\n}"
  },
  {
    "instruction": "Write a function that uses `WorkerEventTarget.addEventListener` to listen for a custom event in a worker thread, and upon receiving the event, uses `DedicatedWorkerGlobalScope.postMessage` to send a processed response back to the main thread. The function must also handle errors by using `WorkerEventTarget.removeEventListener` to clean up the listener if an error occurs.",
    "output": "import {WorkerEventTarget, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerListener(workerScope: DedicatedWorkerGlobalScope, eventName: string): void {\n  const eventHandler = (event: Event) => {\n    try {\n      const customEvent = event as CustomEvent;\n      const processedData = processEventData(customEvent.detail);\n      workerScope.postMessage(processedData);\n    } catch (error) {\n      workerScope.removeEventListener(eventName, eventHandler);\n    }\n  };\n\n  workerScope.addEventListener(eventName, eventHandler);\n}\n\nfunction processEventData(data: unknown): unknown {\n  // Implement your data processing logic here\n  return data;\n}"
  },
  {
    "instruction": "Write a function that uses the `peek` method of `Stack` to check the top element of the stack, then checks if this element exists in a `HashSet` using its `has` method. If it exists, remove the element from the stack using `pop` and from the `HashSet` using `remove`.",
    "output": "import {Stack, HashSet, stream} from '@kit.ArkTS';\n\nexport function checkAndRemove(stack: Stack<number>, hashSet: HashSet<number>): void {\n  if (stack.isEmpty()) {\n    return;\n  }\n  const topElement = stack.peek();\n  if (hashSet.has(topElement)) {\n    stack.pop();\n    hashSet.remove(topElement);\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to run a background task which fetches a URI string from `GlobalScope.self`, then processes the URI string to extract its components using the `uri` API (e.g., parsing the protocol and hostname). The parsed components should be returned as an object.",
    "output": "import {GlobalScope, taskpool, uri} from '@kit.ArkTS';\n\nexport interface UriComponents {\n  protocol: string;\n  hostname: string;\n}\n\nexport async function parseUriInBackground(): Promise<UriComponents> {\n  const task = new taskpool.Task(() => {\n    const uriString = GlobalScope.self as string;\n    const parsedUri = new uri.URI(uriString);\n    return {\n      protocol: parsedUri.protocol,\n      hostname: parsedUri.hostname\n    };\n  });\n\n  return await taskpool.execute(task);\n}"
  },
  {
    "instruction": "Create a function that uses the `executePeriodically` method of `taskpool` to periodically update a `List` of sensor readings. Each update should use the `add` method of `List` to append a new reading. The function should stop the periodic updates after 10 readings have been collected and then use the `convertToArray` method of `List` to return the readings as an array.",
    "output": "import {taskpool, Event, List} from '@kit.ArkTS';\n\nexport function collectSensorReadings(): Promise<number[]> {\n  return new Promise((resolve) => {\n    const readings = new List<number>();\n    let count = 0;\n    \n    const task = taskpool.executePeriodically(() => {\n      const reading = Math.random(); // Simulate sensor reading\n      readings.add(reading);\n      count++;\n      \n      if (count >= 10) {\n        taskpool.cancel(task);\n        resolve(readings.convertToArray());\n      }\n    }, 1000); // Update every 1 second\n  });\n}"
  },
  {
    "instruction": "Create a function that first uses the `getValueAt` method of `PlainArray` to retrieve a specific value by index, then passes this value to the `insert` method of `Vector` to add it at a specified position, and finally uses the `toString` method of `Vector` to display the updated vector contents.",
    "output": "import {worker, PlainArray, Vector} from '@kit.ArkTS';\n\nexport function processPlainArrayToVector(plainArray: PlainArray<number>, vector: Vector<number>, plainArrayIndex: number, vectorIndex: number): string {\n  const value = plainArray.getValueAt(plainArrayIndex);\n  vector.insert(vectorIndex, value);\n  return vector.toString();\n}"
  },
  {
    "instruction": "Write a function that uses the `getUidForName` method of `process` to retrieve the UID for a given process name, then stores the UID and process name as a key-value pair in a `PlainArray` using its `add` method. Finally, use the `getValueAt` method of `PlainArray` to verify the stored UID matches the expected value.",
    "output": "import {process, PlainArray} from '@kit.ArkTS';\n\nexport function storeAndVerifyProcessUid(processName: string, expectedUid: number): boolean {\n  const uid = process.getUidForName(processName);\n  const plainArray = new PlainArray<string>();\n  plainArray.add(uid, processName);\n  const storedUid = plainArray.getKeyAt(0);\n  return storedUid === expectedUid;\n}"
  },
  {
    "instruction": "Create a function that utilizes the `peek` method of `Stack` to check the top element of a stack containing shared data, then uses the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope` to send this element to another worker thread for processing. Ensure the function also checks if the stack is empty using the `isEmpty` property of `Stack` before proceeding.",
    "output": "import {WorkerGlobalScope, Stack, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function checkAndSendTopElement(stack: Stack<number>, workerScope: ThreadWorkerGlobalScope): void {\n  if (!stack.isEmpty) {\n    const topElement = stack.peek();\n    workerScope.postMessageWithSharedSendable(topElement);\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `self` property of `GlobalScope` to access the current global context, then passes this context to the `EventType` enum of `xml` to dynamically determine and log the type of event being handled (e.g., 'click', 'load').",
    "output": "import {GlobalScope, xml} from '@kit.ArkTS';\n\nexport function logEventType(): void {\n  const globalContext = GlobalScope.self;\n  const eventType = xml.EventType;\n  console.log(`Current event type: ${eventType}`);\n}"
  },
  {
    "instruction": "Write a function that uses the `name` property of `WorkerGlobalScope` to identify the current worker, then passes this name to the `self` property of another `WorkerGlobalScope` instance to verify if the worker is communicating with itself.",
    "output": "import {WorkerGlobalScope, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function verifyWorkerSelfCommunication(workerScope: WorkerGlobalScope): boolean {\n  const currentWorkerName = workerScope.name;\n  const otherWorkerSelf = workerScope.self;\n  return currentWorkerName === otherWorkerSelf.name;\n}"
  },
  {
    "instruction": "Implement a function that first generates a random binary UUID using `generateRandomBinaryUUID` from `util`, then transfers it to a `PostMessageOptions` object (setting the `transfer` property). The function should then push this object into a `Stack` (using `push` from @kit.ArkTS) and return the stack's `length` property to indicate the number of transferred UUIDs.",
    "output": "import {PostMessageOptions, Stack, util} from '@kit.ArkTS';\n\nexport function transferRandomUUIDToStack(): number {\n  const binaryUUID: ArrayBuffer = util.generateRandomBinaryUUID();\n  const postMessageOptions: PostMessageOptions = {\n    transfer: [binaryUUID]\n  };\n  const stack = new Stack<PostMessageOptions>();\n  stack.push(postMessageOptions);\n  return stack.length;\n}"
  },
  {
    "instruction": "Implement a task management system where the `getTaskPoolInfo` method of `taskpool` is used to monitor active tasks, and based on the information retrieved, the `cancel` method of `taskpool` is called to terminate specific tasks, with the task IDs being passed as URIs for identification.",
    "output": "import {uri, taskpool, taskpool} from '@kit.ArkTS';\n\nexport function monitorAndCancelTasks(taskIds: string[]): void {\n  const taskPoolInfo = taskpool.getTaskPoolInfo();\n  \n  if (taskPoolInfo && taskPoolInfo.activeTasks) {\n    taskPoolInfo.activeTasks.forEach((taskInfo: {uri: string}) => {\n      if (taskIds.includes(taskInfo.uri)) {\n        taskpool.cancel(taskInfo.uri);\n      }\n    });\n  }\n}"
  },
  {
    "instruction": "Create a function that parses a JSON string of product data (using `json.parse`) into an object, then iterates over its properties using `LightWeightMap.forEach` to populate a LightWeightMap with the product IDs as keys and their prices as values.",
    "output": "import {json, LightWeightMap} from '@kit.ArkTS';\n\nexport function parseAndPopulate(jsonString: string): LightWeightMap<string, number> {\n  const parsedData = json.parse(jsonString) as Record<string, {id: string, price: number}>;\n  const productMap = new LightWeightMap<string, number>();\n\n  Object.values(parsedData).forEach((product) => {\n    productMap.set(product.id, product.price);\n  });\n\n  return productMap;\n}"
  },
  {
    "instruction": "Write a function that uses the `uri` API to parse a given URI string and then logs the parsed components (like protocol, host, path) using the `Event` API's `type` property to categorize the log entry and `timeStamp` property to record the time of parsing.",
    "output": "import {uri, Event} from '@kit.ArkTS';\n\nexport function parseAndLogUri(uriString: string): void {\n  try {\n    const parsedUri = uri.parse(uriString);\n    const event: Event = {\n      type: 'URI_PARSE',\n      timeStamp: Date.now()\n    };\n\n    console.log(`[${event.type}] [${event.timeStamp}] Protocol: ${parsedUri.protocol}`);\n    console.log(`[${event.type}] [${event.timeStamp}] Host: ${parsedUri.host}`);\n    console.log(`[${event.type}] [${event.timeStamp}] Path: ${parsedUri.path}`);\n  } catch (error) {\n    const errorEvent: Event = {\n      type: 'URI_PARSE_ERROR',\n      timeStamp: Date.now()\n    };\n    console.error(`[${errorEvent.type}] [${errorEvent.timeStamp}] Error parsing URI: ${error}`);\n  }\n}"
  },
  {
    "instruction": "Implement a function that takes a base URL string and a Worker name as input, uses the `url` API to resolve the full path for the worker script, then creates a Worker instance using `WorkerOptions` with the resolved URL and the provided name. The function should return the Worker instance after proper initialization.",
    "output": "import {WorkerOptions, url} from '@kit.ArkTS';\n\nexport function createWorker(baseUrl: string, workerName: string): Worker {\n  const resolvedUrl = url.resolve(baseUrl, workerName);\n  const options: WorkerOptions = {\n    name: workerName\n  };\n  return new Worker(resolvedUrl, options);\n}"
  },
  {
    "instruction": "Write a function that first uses `util.promiseWrapper()` to wrap an asynchronous operation, then uses `json.has()` to check if the resolved result contains a specific property, and finally uses `util.errnoToString()` to convert any error code into a human-readable error message.",
    "output": "import {util, json} from '@kit.ArkTS';\n\nexport async function checkPropertyInAsyncResult(asyncOperation: () => Promise<object>, property: string): Promise<string> {\n  try {\n    const wrappedOperation = util.promiseWrapper(asyncOperation);\n    const result = await wrappedOperation();\n    if (json.has(result, property)) {\n      return `Property '${property}' exists in the result.`;\n    } else {\n      return `Property '${property}' does not exist in the result.`;\n    }\n  } catch (error) {\n    if (typeof error === 'number') {\n      return util.errnoToString(error);\n    } else {\n      return 'An unknown error occurred.';\n    }\n  }\n}"
  },
  {
    "instruction": "Create a function that sets up a message handler using `WorkerEventTarget.addEventListener` to listen for incoming messages. When a message is received (accessed via `MessageEvents.data`), use `WorkerEventTarget.removeEventListener` to remove the handler after processing the first message, ensuring it only reacts once.",
    "output": "import {WorkerEventTarget, MessageEvents} from '@kit.ArkTS';\n\nexport function setupOneTimeMessageHandler(workerTarget: WorkerEventTarget, callback: (data: string) => void): void {\n  const handler = (event: MessageEvents) => {\n    callback(event.data);\n    workerTarget.removeEventListener('message', handler);\n  };\n  workerTarget.addEventListener('message', handler);\n}"
  },
  {
    "instruction": "Write a function that captures error events using the `message` and `error` properties of `ErrorEvent`, then stores these error details in a `Vector` using its `add` method. Finally, use the `convertToArray` method of `Vector` to return the collected errors as an array.",
    "output": "import {ErrorEvent, Vector} from '@kit.ArkTS';\n\nexport function captureAndStoreErrors(errorEvents: ErrorEvent[]): ErrorEvent[] {\n  const errorVector: Vector<ErrorEvent> = new Vector<ErrorEvent>();\n  \n  for (const event of errorEvents) {\n    errorVector.add(event);\n  }\n  \n  return errorVector.convertToArray();\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a set of key-value pairs representing task priorities (keys) and task names (values). Then, use the `execute` method of `taskpool` to execute each task with the corresponding priority from the `PlainArray`, ensuring the priorities are correctly passed to the `Priority` enum of `taskpool`.",
    "output": "import {PlainArray, taskpool, MessageEvents} from '@kit.ArkTS';\n\nexport function executeTasksWithPriority(): void {\n  const taskArray: PlainArray<string> = new PlainArray<string>();\n  \n  // Add tasks with their priorities\n  taskArray.add(1, 'Task1');\n  taskArray.add(2, 'Task2');\n  taskArray.add(3, 'Task3');\n  \n  // Execute each task with corresponding priority\n  for (let i = 0; i < taskArray.length; i++) {\n    const priority = taskArray.getKeyAt(i);\n    const taskName = taskArray.getValueAt(i);\n    \n    const task = () => {\n      console.log(`Executing ${taskName} with priority ${priority}`);\n    };\n    \n    // Map the priority number to taskpool.Priority enum\n    let taskPriority: taskpool.Priority;\n    switch (priority) {\n      case 1:\n        taskPriority = taskpool.Priority.HIGH;\n        break;\n      case 2:\n        taskPriority = taskpool.Priority.MEDIUM;\n        break;\n      case 3:\n        taskPriority = taskpool.Priority.LOW;\n        break;\n      default:\n        taskPriority = taskpool.Priority.MEDIUM;\n    }\n    \n    taskpool.execute(task, taskPriority);\n  }\n}"
  },
  {
    "instruction": "Write a function that captures a user interaction event (using `Event.type` and `Event.timeStamp`), converts the event data to a JSON string (using `json.stringify`), and then appends this string to a URI query parameter (using `uri` to construct the final URL).",
    "output": "import {Event, json, uri} from '@kit.ArkTS';\n\nexport function captureAndConstructUrl(event: Event, baseUrl: string): string {\n  const eventData = {\n    type: event.type,\n    timeStamp: event.timeStamp\n  };\n  const jsonString = json.stringify(eventData);\n  const encodedJson = encodeURIComponent(jsonString);\n  return `${baseUrl}?event=${encodedJson}`;\n}"
  },
  {
    "instruction": "Write a function that uses the `worker` API to send a message containing a key-value pair to a worker thread, then uses the `LightWeightMap` API's `set` method to store the received data (accessed via `MessageEvents.data`) in a LightWeightMap instance, and finally retrieves the value using the `get` method and returns it.",
    "output": "import {worker, LightWeightMap, MessageEvents} from '@kit.ArkTS';\n\nexport function sendAndStoreInWorker(key: string, value: string): string {\n  const workerInstance = new worker.ThreadWorker('workers/worker.ts');\n  const lightWeightMap = new LightWeightMap<string, string>();\n  \n  workerInstance.postMessage({key, value});\n  \n  workerInstance.onmessage = (event: MessageEvents) => {\n    const receivedData = event.data;\n    lightWeightMap.set(receivedData.key, receivedData.value);\n  };\n  \n  const retrievedValue = lightWeightMap.get(key);\n  workerInstance.terminate();\n  \n  return retrievedValue;\n}"
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of XML event types (from `xml.EventType`), then iterates through the stack using the `[Symbol.iterator]` method of `Stack` to process each event type and log its details.",
    "output": "import {xml, Stack} from '@kit.ArkTS';\n\nexport function processXmlEventTypes(): void {\n  const eventStack: Stack<xml.EventType> = new Stack<xml.EventType>();\n  \n  // Push some example XML event types into the stack\n  eventStack.push(xml.EventType.START_DOCUMENT);\n  eventStack.push(xml.EventType.START_ELEMENT);\n  eventStack.push(xml.EventType.END_ELEMENT);\n  eventStack.push(xml.EventType.END_DOCUMENT);\n  \n  // Iterate through the stack using Symbol.iterator\n  for (const eventType of eventStack) {\n    console.log(`Processing XML Event Type: ${eventType}`);\n  }\n}"
  },
  {
    "instruction": "Create a function that utilizes the `generateRandomUUID` method of `util` (from @kit.ArkTS) to produce a UUID, pushes it onto a `Stack` (from @kit.ArkTS) using the `push` method, and then checks if the stack is empty using the `isEmpty` property before performing a `peek` operation to verify the last inserted UUID.",
    "output": "import {url, Stack, util} from '@kit.ArkTS';\n\nexport function handleUUIDStack(): void {\n  const stack = new Stack<string>();\n  const uuid = util.generateRandomUUID();\n  stack.push(uuid);\n  if (!stack.isEmpty) {\n    const lastUUID = stack.peek();\n    console.log(`Last inserted UUID: ${lastUUID}`);\n  }\n}"
  },
  {
    "instruction": "Implement a function that uses the `removeEventListener` method of `WorkerEventTarget` to stop listening for a specific event, and then uses the `transfer` property of `PostMessageOptions` to send a confirmation message to another worker, indicating the listener has been removed.",
    "output": "import {PostMessageOptions, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function removeListenerAndConfirm(\n  eventTarget: WorkerEventTarget,\n  eventType: string,\n  listener: EventListener,\n  targetWorker: Worker,\n  transferBuffer: ArrayBuffer\n): void {\n  eventTarget.removeEventListener(eventType, listener);\n  \n  const options: PostMessageOptions = {\n    transfer: [transferBuffer]\n  };\n  \n  targetWorker.postMessage('Listener removed', options);\n}"
  },
  {
    "instruction": "Implement a utility that takes a JSON object (using `json.has` to check for required fields), validates its structure, and then triggers a custom event (using `Event.type`) with the validated data, including a timestamp (using `Event.timeStamp`) for tracking.",
    "output": "import {Event, json, uri} from '@kit.ArkTS';\n\nexport function validateAndTriggerEvent(data: object, requiredFields: string[], eventType: string): void {\n  // Validate required fields\n  for (const field of requiredFields) {\n    if (!json.has(data, field)) {\n      throw new Error(`Missing required field: ${field}`);\n    }\n  }\n\n  // Create event with validated data and timestamp\n  const event: Event = {\n    type: eventType,\n    timeStamp: Date.now(),\n    data: data\n  };\n\n  // Trigger custom event (simulated since actual event triggering mechanism isn't specified)\n  // In a real implementation, this would use the system's event dispatching mechanism\n  console.log(`Event triggered: ${JSON.stringify(event)}`);\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LightWeightSet` to iterate over its elements and apply a transformation, then uses the `setValueAt` method of `PlainArray` to update the values at corresponding keys, and finally uses the `getSubList` method of `List` to extract a subset of the transformed data.",
    "output": "import {List, LightWeightSet, PlainArray} from '@kit.ArkTS';\n\nexport function transformAndExtractSubset(\n  lightWeightSet: LightWeightSet<number>,\n  plainArray: PlainArray<number, string>,\n  list: List<string>,\n  start: number,\n  end: number\n): List<string> {\n  // Step 1: Use forEach to iterate over LightWeightSet and apply transformation\n  lightWeightSet.forEach((value: number) => {\n    const transformedValue = `transformed_${value}`;\n    // Step 2: Use setValueAt to update PlainArray values at corresponding keys\n    plainArray.setValueAt(value, transformedValue);\n  });\n\n  // Step 3: Use getSubList to extract a subset from the List\n  const subList = list.getSubList(start, end);\n  return subList;\n}"
  },
  {
    "instruction": "Write a function that uses `json.parse` to convert a JSON string into an object, then checks if a specific property exists in the object using `json.has`, and finally logs the `type` and `timeStamp` properties of an `Event` object that records the time of this operation.",
    "output": "import {json, Event} from '@kit.ArkTS';\n\nexport function parseAndCheckJson(jsonString: string, property: string): void {\n  const obj = json.parse(jsonString);\n  const hasProperty = json.has(obj, property);\n  \n  const event: Event = {\n    timeStamp: new Date().getTime(),\n    type: 'JSON_PARSE_AND_CHECK'\n  };\n  \n  console.log(`Event type: ${event.type}, timeStamp: ${event.timeStamp}`);\n}"
  },
  {
    "instruction": "Write a function that uses `process.getEnvironmentVar` to retrieve the current environment variables, then parses the resulting string using `xml.EventType` to identify and extract specific environment-related events (e.g., 'LOAD', 'ERROR') for logging purposes.",
    "output": "import {process, url, xml} from '@kit.ArkTS';\n\nexport function parseEnvironmentEvents(): void {\n  const envVars: string = process.getEnvironmentVar();\n  const parser: xml.XmlPullParser = new xml.XmlPullParser(envVars);\n  \n  let eventType: xml.EventType = parser.getEventType();\n  \n  while (eventType !== xml.EventType.END_DOCUMENT) {\n    switch (eventType) {\n      case xml.EventType.START_TAG:\n        const tagName: string = parser.getName();\n        if (tagName === 'LOAD' || tagName === 'ERROR') {\n          console.log(`Environment Event: ${tagName}`);\n        }\n        break;\n      case xml.EventType.TEXT:\n        const text: string = parser.getText();\n        console.log(`Event Text: ${text}`);\n        break;\n    }\n    eventType = parser.next();\n  }\n}"
  },
  {
    "instruction": "Write a function that first checks if a `TreeMap` is empty using the `isEmpty` method, and if not, retrieves the last key using the `getLastKey` method, then uses the `remove` method to delete this key-value pair, and finally passes the removed value to the `set` method of another `TreeMap` instance to store it under a new key.",
    "output": "import {url, TreeMap} from '@kit.ArkTS';\n\nexport function transferLastKeyValue(sourceMap: TreeMap<string, string>, targetMap: TreeMap<string, string>, newKey: string): void {\n  if (!sourceMap.isEmpty()) {\n    const lastKey = sourceMap.getLastKey();\n    if (lastKey !== undefined) {\n      const value = sourceMap.get(lastKey);\n      if (value !== undefined) {\n        sourceMap.remove(lastKey);\n        targetMap.set(newKey, value);\n      }\n    }\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `getFirstKey` method of `TreeMap` to retrieve the smallest key, then passes this key to the `add` method of `Queue` to enqueue it. Finally, use the `pop` method of `Queue` to dequeue and return the value.",
    "output": "import {TreeMap, url, Queue} from '@kit.ArkTS';\n\nexport function processTreeMapAndQueue(treeMap: TreeMap<number, unknown>, queue: Queue<number>): number | undefined {\n  const firstKey = treeMap.getFirstKey();\n  if (firstKey !== undefined) {\n    queue.add(firstKey);\n    return queue.pop();\n  }\n  return undefined;\n}"
  },
  {
    "instruction": "Write a function that uses the `addAll` method of `LightWeightSet` to merge two sets of product IDs, then passes the merged set to the `TreeSet` constructor to create a sorted collection. Finally, use the `getFirstValue` and `getLastValue` methods of `TreeSet` to find the smallest and largest product IDs in the sorted set.",
    "output": "import {LightWeightSet, TreeSet} from '@kit.ArkTS';\n\nexport function mergeAndSortProductIds(set1: LightWeightSet<number>, set2: LightWeightSet<number>): { smallest: number, largest: number } {\n  const mergedSet = new LightWeightSet<number>();\n  mergedSet.addAll(set1);\n  mergedSet.addAll(set2);\n  \n  const sortedSet = new TreeSet<number>(mergedSet);\n  const smallest = sortedSet.getFirstValue();\n  const largest = sortedSet.getLastValue();\n  \n  return { smallest, largest };\n}"
  },
  {
    "instruction": "Write a function that uses the `stream` API to read data from a file and then passes the read data as a message using the `PostMessageOptions` API, ensuring the data is transferred efficiently by setting the `transfer` property appropriately.",
    "output": "import {stream, PostMessageOptions} from '@kit.ArkTS';\n\nexport function readFileAndPostMessage(filePath: string, target: Worker): void {\n  const readableStream = stream.createReadableStream(filePath);\n  const buffer = new ArrayBuffer(1024);\n  \n  readableStream.read(buffer).then((bytesRead: number) => {\n    if (bytesRead > 0) {\n      const options: PostMessageOptions = {\n        transfer: [buffer]\n      };\n      target.postMessage(buffer, options);\n    }\n  }).catch((error: Error) => {\n    console.error(`Error reading file: ${error.message}`);\n  });\n}"
  },
  {
    "instruction": "Write a function that uses `process.getUidForName` to retrieve the UID of a given process name, then checks if the process is running in 64-bit mode using `process.is64Bit`, and finally terminates the process using `process.kill` if it is not 64-bit.",
    "output": "import {worker, process} from '@kit.ArkTS';\n\nexport function checkAndKillNon64BitProcess(processName: string): void {\n    const uid = process.getUidForName(processName);\n    if (uid === -1) {\n        return;\n    }\n    const is64Bit = process.is64Bit(uid);\n    if (!is64Bit) {\n        process.kill(uid);\n    }\n}"
  },
  {
    "instruction": "Create a worker thread that uses the `callGlobalCallObjectMethod` of `ThreadWorkerGlobalScope` to invoke a global function in the main thread, passing a shared object. The main thread should modify the object and send it back to the worker thread using the `postMessage` method of `DedicatedWorkerGlobalScope`. The worker thread should then use the `onmessage` property of `ThreadWorkerGlobalScope` to receive the modified object and log its contents.",
    "output": "import {DedicatedWorkerGlobalScope, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createWorkerThread(): void {\n  const worker: ThreadWorkerGlobalScope = new ThreadWorkerGlobalScope('script/worker.ts');\n\n  worker.onmessage = (event: MessageEvent): void => {\n    const modifiedObject = event.data;\n    console.log('Modified object received in worker:', modifiedObject);\n    worker.close();\n  };\n\n  const sharedObject = { key: 'initial value' };\n  worker.callGlobalCallObjectMethod('modifyObject', sharedObject);\n}\n\nexport function modifyObject(obj: Record<string, string>): void {\n  obj.key = 'modified value';\n  const workerScope: DedicatedWorkerGlobalScope = self as unknown as DedicatedWorkerGlobalScope;\n  workerScope.postMessage(obj);\n}"
  },
  {
    "instruction": "Write a function that takes a `List` of URLs and a `Queue` of URL indices. Use the `get` method of `List` to retrieve each URL based on the indices obtained from the `pop` method of `Queue`. Store the retrieved URLs in a new `List` using the `add` method and return the final list of URLs.",
    "output": "import {List, url, Queue} from '@kit.ArkTS';\n\nexport function retrieveUrls(urlList: List<string>, indexQueue: Queue<number>): List<string> {\n  const resultList: List<string> = new List();\n  while (indexQueue.length > 0) {\n    const index = indexQueue.pop();\n    if (index !== undefined) {\n      const url = urlList.get(index);\n      if (url !== undefined) {\n        resultList.add(url);\n      }\n    }\n  }\n  return resultList;\n}"
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a buffer from a string, then uses `buffer.byteLength` to get its size, and finally inserts this size into a `Deque` using `Deque.insertFront`. The function should return the Deque.",
    "output": "import {buffer, Deque} from '@kit.ArkTS';\n\nexport function createBufferAndGetSize(inputString: string): Deque<number> {\n  const buf = buffer.from(inputString);\n  const size = buffer.byteLength(buf);\n  const deque = new Deque<number>();\n  deque.insertFront(size);\n  return deque;\n}"
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of event names, then iterates through the stack using `[Symbol.iterator]`, and dispatches each event using the `dispatchEvent` method of `EventTarget` (from @kit.ArkTS). The function should return the number of events successfully dispatched.",
    "output": "import {EventTarget, LightWeightMap, Stack} from '@kit.ArkTS';\n\nexport function dispatchEvents(eventNames: string[]): number {\n  const stack = new Stack<string>();\n  const eventTarget = new EventTarget();\n  \n  for (const name of eventNames) {\n    stack.push(name);\n  }\n  \n  let dispatchedCount = 0;\n  \n  for (const eventName of stack) {\n    const event = { type: eventName };\n    if (eventTarget.dispatchEvent(event)) {\n      dispatchedCount++;\n    }\n  }\n  \n  return dispatchedCount;\n}"
  },
  {
    "instruction": "Create a function that uses the `keys` method of `TreeMap` to retrieve all keys, then uses the `forEach` method of `TreeSet` to iterate over these keys and add them to a `TreeSet`. Finally, use the `length` property of both `TreeMap` and `TreeSet` to verify that all keys were successfully transferred and are unique.",
    "output": "import {TreeSet, TreeMap, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function transferKeysToTreeSet(treeMap: TreeMap<number, string>): TreeSet<number> {\n  const treeSet = new TreeSet<number>();\n  const keys = treeMap.keys();\n  keys.forEach((key: number) => {\n    treeSet.add(key);\n  });\n  \n  if (treeMap.length === treeSet.length) {\n    console.log('All keys were successfully transferred and are unique.');\n  } else {\n    console.log('Key transfer failed or keys were not unique.');\n  }\n  \n  return treeSet;\n}"
  },
  {
    "instruction": "Create a function that uses the `get` and `set` methods of `Vector<number>` to manipulate a sequence of numerical data, then passes the modified vector to the `sort` method of `ArrayList<number>` to organize the data in ascending order. Ensure the sorted data is then converted to an array using the `convertToArray` method of `ArrayList`.",
    "output": "import {ArrayList, Vector, buffer} from '@kit.ArkTS';\n\nexport function manipulateAndSortVector(data: number[]): number[] {\n  // Create a Vector instance and populate it with the input data\n  let vec = new Vector<number>();\n  for (let num of data) {\n    vec.add(num);\n  }\n\n  // Manipulate the Vector using get and set methods\n  for (let i = 0; i < vec.length; i++) {\n    let value = vec.get(i);\n    vec.set(i, value * 2); // Example manipulation: double each value\n  }\n\n  // Create an ArrayList and populate it with the Vector's data\n  let arrList = new ArrayList<number>();\n  for (let i = 0; i < vec.length; i++) {\n    arrList.add(vec.get(i));\n  }\n\n  // Sort the ArrayList in ascending order\n  arrList.sort((a: number, b: number) => a - b);\n\n  // Convert the sorted ArrayList to an array and return\n  return arrList.convertToArray();\n}"
  },
  {
    "instruction": "Create a function that first checks if the current process is a 64-bit system using the `is64Bit` method of `process`, then uses this boolean result to determine whether to call the `abort` method of `process` (if false) or the `exit` method (if true). Before exiting, log the `self` property of `WorkerGlobalScope` to identify the worker context.",
    "output": "import {WorkerGlobalScope, process} from '@kit.ArkTS';\n\nexport function checkAndExit(): void {\n  const is64Bit: boolean = process.is64Bit();\n  console.log(WorkerGlobalScope.self);\n  if (!is64Bit) {\n    process.abort();\n  } else {\n    process.exit();\n  }\n}"
  },
  {
    "instruction": "Create a function that first uses the `getFirst` method of `Queue` to retrieve the first element, then checks if the `length` property of `Queue` is greater than 1. If true, use the `pop` method to remove the first element and pass it to a stream processing function that converts the element to a string and logs it.",
    "output": "import {Queue, stream} from '@kit.ArkTS';\n\nexport function processQueueElement(queue: Queue<unknown>): void {\n  const firstElement = queue.getFirst();\n  if (queue.length > 1) {\n    const poppedElement = queue.pop();\n    const elementAsString = String(poppedElement);\n    console.log(elementAsString);\n  }\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `List` to iterate over a list of XML attributes, then uses the `insert` method of `List` to add a new attribute at a specific position, and finally uses the `EventType` enum from `xml` to log the modified list with a specific event type (e.g., `EventType.WARNING`).",
    "output": "import {List, xml} from '@kit.ArkTS';\n\nexport function modifyAttributes(attributes: List<string>, newAttribute: string, position: number): void {\n  attributes.forEach((attribute: string, index: number) => {\n    console.log(`Attribute at index ${index}: ${attribute}`);\n  });\n\n  attributes.insert(position, newAttribute);\n\n  console.log(`Modified attributes: ${attributes.convertToArray()}`);\n  console.log(`Event type: ${xml.EventType.WARNING}`);\n}"
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to run a background task that fetches XML data, then uses the `EventType` enum from `xml` to filter specific events from the parsed data, and finally logs the filtered events' `type` and `timeStamp` properties from the `Event` API.",
    "output": "import {Event, taskpool, xml} from '@kit.ArkTS';\n\nexport function fetchAndFilterXmlEvents(xmlData: string, eventTypes: xml.EventType[]): void {\n  const task = () => {\n    const parser = new xml.XmlPullParser(xmlData);\n    const events: Event[] = [];\n    \n    while (parser.next()) {\n      const eventType = parser.getEventType();\n      if (eventTypes.includes(eventType)) {\n        const event: Event = {\n          type: eventType,\n          timeStamp: Date.now()\n        };\n        events.push(event);\n      }\n    }\n    \n    events.forEach(event => {\n      console.log(`Event type: ${event.type}, timestamp: ${event.timeStamp}`);\n    });\n    \n    return events;\n  };\n  \n  taskpool.execute(task, taskpool.Priority.LOW).then(() => {\n    console.log('Task completed');\n  }).catch((error) => {\n    console.error('Task failed:', error);\n  });\n}"
  },
  {
    "instruction": "Write a function that uses the `alloc` method of `buffer` to create a buffer of a specified size, then populates it with values from a `LinkedList` (using the `get` method to retrieve values). The function should then use the `compare` method of `buffer` to compare this buffer with another buffer created from a different LinkedList. The function should return the comparison result.",
    "output": "import {LinkedList, buffer} from '@kit.ArkTS';\n\nexport function compareBuffersFromLinkedLists(list1: LinkedList<number>, list2: LinkedList<number>, size: number): number {\n  const buf1 = buffer.alloc(size);\n  const buf2 = buffer.alloc(size);\n\n  for (let i = 0; i < size; i++) {\n    const val1 = list1.get(i);\n    const val2 = list2.get(i);\n    \n    if (val1 !== undefined) {\n      buf1[i] = val1;\n    }\n    \n    if (val2 !== undefined) {\n      buf2[i] = val2;\n    }\n  }\n\n  return buffer.compare(buf1, buf2);\n}"
  },
  {
    "instruction": "Create a function that sends a structured message using `postMessage` with a `PostMessageOptions` object where the `transfer` property specifies certain resources. The receiver should validate the `data` property of the `MessageEvent` to ensure it matches the expected format, and if valid, use the transferred resources to perform a specific action.",
    "output": "import {PostMessageOptions, MessageEvent} from '@kit.ArkTS';\n\nexport function sendStructuredMessage(target: Worker, data: {type: string, payload: object}, transferList: ArrayBuffer[]): void {\n  const options: PostMessageOptions = {\n    transfer: transferList\n  };\n  target.postMessage(data, options);\n}\n\nexport function validateAndUseMessage(event: MessageEvent<{type: string, payload: object}>): void {\n  const expectedType = 'expectedType';\n  if (event.data && event.data.type === expectedType) {\n    // Perform specific action with the transferred resources\n    console.log('Valid message received:', event.data.payload);\n  } else {\n    console.error('Invalid message format');\n  }\n}"
  },
  {
    "instruction": "Create a function that generates an `ErrorEvent` with custom `message`, `filename`, `lineno`, and `colno` properties, then triggers an `Event` with the `type` property set to 'error' and the `timeStamp` property recording when the error occurred. The function should return the combined error and event details as a formatted string.",
    "output": "import {xml, ErrorEvent, Event} from '@kit.ArkTS';\n\nexport function generateErrorEvent(message: string, filename: string, lineno: number, colno: number): string {\n  const errorEvent = new ErrorEvent('error', {\n    message: message,\n    filename: filename,\n    lineno: lineno,\n    colno: colno\n  });\n\n  const event = new Event('error');\n  event.timeStamp = Date.now();\n\n  return `ErrorEvent Details: message=${errorEvent.message}, filename=${errorEvent.filename}, lineno=${errorEvent.lineno}, colno=${errorEvent.colno}; Event Details: type=${event.type}, timeStamp=${event.timeStamp}`;\n}"
  },
  {
    "instruction": "Write a function that iterates over the keys of a `TreeMap` using the `Symbol.iterator` method, collects all keys greater than a given threshold using the `getHigherKey` method, and then uses the `setAll` method to add these keys with their corresponding values to a new `TreeMap` instance.",
    "output": "import {url, TreeMap} from '@kit.ArkTS';\n\nexport function filterAndSetHigherKeys<K, V>(originalMap: TreeMap<K, V>, threshold: K): TreeMap<K, V> {\n  const newMap = new TreeMap<K, V>();\n  const higherKeys: K[] = [];\n  \n  for (const key of originalMap[Symbol.iterator]()) {\n    const higherKey = originalMap.getHigherKey(key);\n    if (higherKey !== undefined && higherKey > threshold) {\n      higherKeys.push(higherKey);\n    }\n  }\n  \n  for (const key of higherKeys) {\n    const value = originalMap.get(key);\n    if (value !== undefined) {\n      newMap.set(key, value);\n    }\n  }\n  \n  return newMap;\n}"
  },
  {
    "instruction": "Create a function that utilizes the `onerror` property of `GlobalScope` to set up a global error handler, which then uses the `EventType` enum from `xml` to categorize and log different types of errors (e.g., 'network', 'syntax') based on the error event.",
    "output": "import {GlobalScope, xml} from '@kit.ArkTS';\n\nexport function setupGlobalErrorHandler(): void {\n  if (GlobalScope.onerror) {\n    GlobalScope.onerror = (event: ErrorEvent) => {\n      let errorType: xml.EventType;\n      \n      if (event.message.includes('network')) {\n        errorType = xml.EventType.NETWORK_ERROR;\n      } else if (event.message.includes('syntax')) {\n        errorType = xml.EventType.SYNTAX_ERROR;\n      } else {\n        errorType = xml.EventType.UNKNOWN_ERROR;\n      }\n      \n      console.log(`Error Type: ${errorType}, Message: ${event.message}`);\n      return true;\n    };\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `List` to collect a sequence of messages from `MessageEvents.data`, then uses the `sort` method of `List` to organize the messages alphabetically, and finally returns the sorted list.",
    "output": "import {List, MessageEvents} from '@kit.ArkTS';\n\nexport function collectAndSortMessages(events: MessageEvents[]): List<string> {\n  const messageList: List<string> = new List();\n  \n  for (const event of events) {\n    messageList.add(event.data);\n  }\n  \n  messageList.sort((a: string, b: string) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  \n  return messageList;\n}"
  }
]