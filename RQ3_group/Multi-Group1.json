[
  {
    "instruction": "Write a function that first uses the `TreeSet` API's `add` method to populate a set with a list of file paths, then iterates over the sorted set using the `Symbol.iterator` method. For each file path, use the `uri` API to extract the file extension and store it in another `TreeSet`. Return the final set of unique file extensions sorted alphabetically.",
    "output": "import {TreeSet, uri} from '@kit.ArkTS';\n\nexport function getUniqueFileExtensions(filePaths: string[]): TreeSet<string> {\n  const filePathSet = new TreeSet<string>();\n  filePaths.forEach((path) => {\n    filePathSet.add(path);\n  });\n\n  const extensionSet = new TreeSet<string>();\n  for (const path of filePathSet) {\n    const parsedUri = uri.parse(path);\n    const pathStr = parsedUri.path;\n    if (pathStr) {\n      const lastDotIndex = pathStr.lastIndexOf('.');\n      if (lastDotIndex !== -1) {\n        const extension = pathStr.substring(lastDotIndex + 1);\n        extensionSet.add(extension);\n      }\n    }\n  }\n\n  return extensionSet;\n}"
  },
  {
    "instruction": "Write a function that generates a random UUID using `util.generateRandomUUID`, converts it to a buffer using `buffer.from`, and then checks if the buffer is valid using `buffer.isBuffer`.",
    "output": "import {Deque, buffer, util} from '@kit.ArkTS';\n\nexport function generateAndCheckUUID(): boolean {\n  const uuid = util.generateRandomUUID();\n  const buf = buffer.from(uuid);\n  return buffer.isBuffer(buf);\n}"
  },
  {
    "instruction": "Write a function that uses the `addEventListener` method of `WorkerEventTarget` to listen for a custom event, and upon triggering, collects the event data into a `List` using its `add` method. Then, use the `sort` method of `List` to organize the collected data and return the sorted list.",
    "output": "import {WorkerEventTarget, List} from '@kit.ArkTS';\n\nexport function listenAndSortEvents(eventTarget: WorkerEventTarget, eventName: string): List<unknown> {\n  const eventList: List<unknown> = new List<unknown>();\n\n  eventTarget.addEventListener(eventName, (event: { data: unknown }) => {\n    eventList.add(event.data);\n  });\n\n  eventList.sort((a: unknown, b: unknown) => {\n    if (a === b) {\n      return 0;\n    }\n    return a > b ? 1 : -1;\n  });\n\n  return eventList;\n}"
  },
  {
    "instruction": "Implement a function that retrieves the CPU time of a process using `process.getPastCpuTime`, checks the thread priority using `process.getThreadPriority`, and then combines these metrics into a performance report sent through `MessageEvents.data`.",
    "output": "import {process, MessageEvents} from '@kit.ArkTS';\n\nexport function getProcessPerformanceReport(): void {\n  const cpuTime: number = process.getPastCpuTime();\n  const threadPriority: number = process.getThreadPriority(process.pid);\n  \n  const performanceReport: { cpuTime: number, threadPriority: number } = {\n    cpuTime,\n    threadPriority\n  };\n  \n  const messageEvent: MessageEvents = new MessageEvents('performanceReport');\n  messageEvent.data = JSON.stringify(performanceReport);\n}"
  },
  {
    "instruction": "Write a function that uses the `from` method of `buffer` to create a Buffer from a given string, then passes this Buffer as the `data` property of a `MessageEvent` object, and finally checks if the Buffer encoding is valid using the `isEncoding` method of `buffer`.",
    "output": "import {MessageEvent, buffer, url} from '@kit.ArkTS';\n\nexport function createAndCheckBufferEncoding(inputString: string, encoding: buffer.BufferEncoding): boolean {\n  const buf = buffer.from(inputString, encoding);\n  const messageEvent = new MessageEvent('data', { data: buf });\n  return buffer.isEncoding(encoding);\n}"
  },
  {
    "instruction": "Create a function that iterates over the entries of a `HashMap` using the `[Symbol.iterator]` method, filters out entries with specific values using the `hasValue` method, and then transfers the filtered entries to a new `MessageEvent` object with the `transfer` property of `PostMessageOptions` set to true.",
    "output": "import {MessageEvent, HashMap, PostMessageOptions} from '@kit.ArkTS';\n\nexport function filterAndTransferHashMap<K, V>(map: HashMap<K, V>, valuesToFilter: V[]): MessageEvent<[K, V][]> {\n  const filteredEntries: [K, V][] = [];\n  \n  for (const [key, value] of map[Symbol.iterator]()) {\n    if (!valuesToFilter.some(v => v === value)) {\n      filteredEntries.push([key, value]);\n    }\n  }\n  \n  const options: PostMessageOptions = {\n    transfer: true\n  };\n  \n  return new MessageEvent('filteredData', {\n    data: filteredEntries,\n    ...options\n  });\n}"
  },
  {
    "instruction": "Write a function that uses `process.getUidForName` to retrieve the UID for a given process name, then stores the UID and process name as a key-value pair in a `LightWeightMap` using its `set` method. Finally, use `LightWeightMap.getValueAt` to verify the stored UID matches the original retrieval.",
    "output": "import {process, LightWeightMap} from '@kit.ArkTS';\n\nexport function storeAndVerifyUid(processName: string): boolean {\n  const uid = process.getUidForName(processName);\n  const map = new LightWeightMap<string, number>();\n  map.set(processName, uid);\n  const storedUid = map.getValueAt(map.getIndexOfKey(processName));\n  return storedUid === uid;\n}"
  },
  {
    "instruction": "Write a function that uses the `keys` method of `TreeMap` to retrieve all keys, then passes them to the `add` method of `List` to create a new list. Finally, use the `sort` method of `List` to sort the keys in ascending order.",
    "output": "import {TreeMap, List} from '@kit.ArkTS';\n\nexport function sortTreeMapKeys<K, V>(treeMap: TreeMap<K, V>): List<K> {\n  const keys = treeMap.keys();\n  const list = new List<K>();\n  for (let key of keys) {\n    list.add(key);\n  }\n  list.sort();\n  return list;\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to store a sequence of event names, then iterates through the list using `forEach` and dispatches each event using the `dispatchEvent` method of `WorkerEventTarget`. The function should return the number of events successfully dispatched.",
    "output": "import {WorkerEventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function dispatchEvents(eventNames: string[], target: WorkerEventTarget): number {\n  const list = new LinkedList<string>();\n  eventNames.forEach(name => list.add(name));\n  \n  let dispatchedCount = 0;\n  list.forEach(name => {\n    try {\n      target.dispatchEvent(name);\n      dispatchedCount++;\n    } catch (e) {\n      // Ignore errors and continue with next event\n    }\n  });\n  \n  return dispatchedCount;\n}"
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a message containing an array of numbers to a worker thread, and then uses the `transfer` property of `PostMessageOptions` to transfer ownership of a shared array buffer to the worker thread for efficient processing.",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport function sendDataToWorker(worker: ThreadWorkerGlobalScope, data: number[], buffer: ArrayBuffer): void {\n  worker.postMessage(data);\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  worker.postMessage(buffer, options);\n}"
  },
  {
    "instruction": "Write a function that first uses the `getHash` method of `util` to compute the hash of a given string, then uses the `errnoToString` method of `util` to check for any errors during the hash computation, and finally passes the resulting hash to a worker thread (using `worker` API) for further processing or validation.",
    "output": "import {worker, util} from '@kit.ArkTS';\n\nexport function processStringWithHash(input: string): void {\n  const hashResult = util.getHash(input);\n  const errorString = util.errnoToString(hashResult.errno);\n  \n  if (errorString !== 'Success') {\n    throw new Error(`Hash computation failed: ${errorString}`);\n  }\n  \n  const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n  workerInstance.postMessage(hashResult.hash);\n  \n  workerInstance.onmessage = (message: worker.MessageEvents): void => {\n    console.log(`Worker response: ${message.data}`);\n    workerInstance.terminate();\n  };\n  \n  workerInstance.onerror = (error: worker.ErrorEvent): void => {\n    console.error(`Worker error: ${error.message}`);\n    workerInstance.terminate();\n  };\n}"
  },
  {
    "instruction": "Create a function that collects error details (message, filename, lineno) into an `ErrorEvent` object, then uses the `insert` method of `LinkedList` to add the error event at a specific index. Finally, use the `get` method of `LinkedList` to retrieve and display the error event's `message` and `colno` properties.",
    "output": "import {ErrorEvent, LinkedList} from '@kit.ArkTS';\n\nexport function collectAndDisplayError() {\n  const errorList = new LinkedList<ErrorEvent>();\n  \n  // Create an ErrorEvent object\n  const errorEvent = new ErrorEvent('error', {\n    message: 'An error occurred',\n    filename: 'app.ets',\n    lineno: 10,\n    colno: 5,\n    error: null\n  });\n  \n  // Insert the error event at index 0\n  errorList.insert(0, errorEvent);\n  \n  // Retrieve the error event at index 0\n  const retrievedError = errorList.get(0);\n  \n  // Display the message and colno properties\n  if (retrievedError) {\n    console.log(`Message: ${retrievedError.message}`);\n    console.log(`Column Number: ${retrievedError.colno}`);\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `concat` method of `buffer` to merge two buffers into one, then uses the `forEach` method of `LinkedList` to iterate over the merged buffer's bytes and calculate their sum. Store the result in a variable and return it.",
    "output": "import {LinkedList, buffer} from '@kit.ArkTS';\n\nexport function mergeBuffersAndCalculateSum(buffer1: buffer.Buffer, buffer2: buffer.Buffer): number {\n  const mergedBuffer = buffer.concat([buffer1, buffer2]);\n  const linkedList = new LinkedList<number>();\n  \n  for (const byte of mergedBuffer) {\n    linkedList.add(byte);\n  }\n  \n  let sum = 0;\n  linkedList.forEach((byte: number) => {\n    sum += byte;\n  });\n  \n  return sum;\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of URIs (as strings), then uses the `convertToArray` method of `LinkedList` to convert the list into an array, and finally passes this array to the `forEach` method of another `LinkedList` to iterate and log each URI.",
    "output": "import {uri, LinkedList, LinkedList} from '@kit.ArkTS';\n\nexport function processURIs(uris: string[]): void {\n  const list = new LinkedList<string>();\n  uris.forEach(uri => list.add(uri));\n  const uriArray = list.convertToArray();\n  const anotherList = new LinkedList<string>();\n  anotherList.forEach = function(callback: (value: string) => void): void {\n    for (const item of uriArray) {\n      callback(item);\n    }\n  };\n  anotherList.forEach((uri: string) => {\n    console.log(uri);\n  });\n}"
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of messages, then iterates over the stack using the `[Symbol.iterator]` method to extract each message, and finally passes them to the `transfer` property of `PostMessageOptions` (from @kit.ArkTS) to prepare the messages for cross-thread communication.",
    "output": "import {Stack, PostMessageOptions} from '@kit.ArkTS';\n\nexport function prepareMessagesForTransfer(messages: ArrayBuffer[]): PostMessageOptions {\n  const stack = new Stack<ArrayBuffer>();\n  \n  for (const message of messages) {\n    stack.push(message);\n  }\n  \n  const transferMessages: ArrayBuffer[] = [];\n  for (const message of stack) {\n    transferMessages.push(message);\n  }\n  \n  const postMessageOptions: PostMessageOptions = {\n    transfer: transferMessages\n  };\n  \n  return postMessageOptions;\n}"
  },
  {
    "instruction": "Implement a function that checks if the current process is 64-bit using `process.is64Bit`, then stores the result (true/false) in a `LightWeightMap` with the key 'is64Bit'. Use `LightWeightMap.get` to retrieve the value and return it as the function's output.",
    "output": "import {process, LightWeightMap} from '@kit.ArkTS';\n\nexport function checkIs64Bit(): boolean {\n  const is64Bit = process.is64Bit();\n  const map = new LightWeightMap();\n  map.set('is64Bit', is64Bit);\n  return map.get('is64Bit');\n}"
  },
  {
    "instruction": "Implement a function that uses the `dispatchEvent` method of `WorkerEventTarget` to emit an event containing a data object. Then, use the `addEventListener` method of `WorkerEventTarget` to listen for this event and process the data object by adding its values to a `TreeSet` using the `add` method, and then mapping these values to their squares in a `TreeMap` using the `set` method.",
    "output": "import {TreeSet, TreeMap, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function emitAndProcessEvent(eventTarget: WorkerEventTarget, data: number[]): void {\n  // Create a custom event with the data\n  const event = {\n    type: 'customEvent',\n    data: data\n  };\n\n  // Dispatch the event\n  eventTarget.dispatchEvent(event);\n}\n\nexport function setupEventListener(eventTarget: WorkerEventTarget): {treeSet: TreeSet<number>, treeMap: TreeMap<number, number>} {\n  const treeSet = new TreeSet<number>();\n  const treeMap = new TreeMap<number, number>();\n\n  eventTarget.addEventListener('customEvent', (event: {data: number[]}) => {\n    // Process data: add to TreeSet\n    event.data.forEach((value: number) => {\n      treeSet.add(value);\n    });\n\n    // Map values to their squares in TreeMap\n    treeSet.forEach((value: number) => {\n      treeMap.set(value, value * value);\n    });\n  });\n\n  return {treeSet, treeMap};\n}"
  },
  {
    "instruction": "Implement a function that initializes a `LightWeightMap` with keys as error codes (numbers) and values as `ErrorEvent` objects. Use `LightWeightMap.entries` to retrieve all entries, then enqueue each error code using `Queue.add`. Dequeue the codes and for each, use `LightWeightMap.get` to fetch the corresponding `ErrorEvent` and print its `message` and `lineno` properties.",
    "output": "import {LightWeightMap, Queue, ErrorEvent} from '@kit.ArkTS';\n\nexport function processErrorEvents(): void {\n  const errorMap = new LightWeightMap<number, ErrorEvent>();\n  const errorQueue = new Queue<number>();\n\n  // Initialize LightWeightMap with error codes and ErrorEvent objects\n  const errorEvent1: ErrorEvent = { colno: 0, error: null, filename: 'file1', lineno: 10, message: 'Error 1 occurred' };\n  const errorEvent2: ErrorEvent = { colno: 0, error: null, filename: 'file2', lineno: 20, message: 'Error 2 occurred' };\n  const errorEvent3: ErrorEvent = { colno: 0, error: null, filename: 'file3', lineno: 30, message: 'Error 3 occurred' };\n\n  errorMap.set(1, errorEvent1);\n  errorMap.set(2, errorEvent2);\n  errorMap.set(3, errorEvent3);\n\n  // Retrieve all entries and enqueue error codes\n  const entries = errorMap.entries();\n  for (const entry of entries) {\n    errorQueue.add(entry[0]);\n  }\n\n  // Dequeue codes and print corresponding ErrorEvent properties\n  while (errorQueue.length > 0) {\n    const code = errorQueue.pop();\n    const errorEvent = errorMap.get(code);\n    if (errorEvent) {\n      console.log(`Message: ${errorEvent.message}, Line Number: ${errorEvent.lineno}`);\n    }\n  }\n}"
  },
  {
    "instruction": "Implement a function that retrieves all keys from a HashMap using `HashMap.keys`, checks if each key exists in a PlainArray using `PlainArray.has`, and then dispatches an event with the results using `EventTarget.dispatchEvent`. The function must explicitly use `HashMap.keys`, `PlainArray.has`, and `EventTarget.dispatchEvent`.",
    "output": "import {PlainArray, EventTarget, HashMap} from '@kit.ArkTS';\n\nexport function checkKeysInPlainArray(hashMap: HashMap<number, unknown>, plainArray: PlainArray<unknown>, eventTarget: EventTarget): void {\n  const keys = hashMap.keys();\n  const results: boolean[] = [];\n  \n  for (const key of keys) {\n    results.push(plainArray.has(key));\n  }\n  \n  const event = {\n    type: 'checkKeysResults',\n    results: results\n  };\n  \n  eventTarget.dispatchEvent(event);\n}"
  },
  {
    "instruction": "Create a function that schedules a delayed task using `taskpool.executeDelayed` and monitors its state. If the task is still in `State.RUNNING` after a certain timeout, cancel it using `taskpool.cancel` and send a cancellation message via `MessageEvents.data` to notify the user.",
    "output": "import {taskpool, MessageEvents} from '@kit.ArkTS';\n\nexport function scheduleDelayedTask(task: taskpool.CallbackFunction, delay: number, timeout: number): void {\n  const taskId = taskpool.executeDelayed(task, delay);\n  \n  setTimeout(() => {\n    const state = taskpool.getTaskPoolInfo(taskId).state;\n    if (state === taskpool.State.RUNNING) {\n      taskpool.cancel(taskId);\n      const messageEvent = new MessageEvents('cancel');\n      messageEvent.data = 'Task was canceled due to timeout';\n    }\n  }, timeout);\n}"
  },
  {
    "instruction": "Write a function that uses the `add` and `getFirst` methods of `LinkedList` to build a list of numbers, then passes the list to a worker thread using the `postMessage` method of `ThreadWorkerGlobalScope` to perform a parallel computation (e.g., sum or average) and return the result.",
    "output": "import {ThreadWorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function buildListAndCompute(): void {\n  const list = new LinkedList<number>();\n  list.add(1);\n  list.add(2);\n  list.add(3);\n  list.add(4);\n  list.add(5);\n\n  const worker = new ThreadWorkerGlobalScope();\n  worker.onmessage = (message: {data: number}) => {\n    console.log(`Result from worker: ${message.data}`);\n    worker.close();\n  };\n\n  worker.postMessage({data: list});\n}\n\nexport function workerFunction(): void {\n  const workerScope = new ThreadWorkerGlobalScope();\n  workerScope.onmessage = (message: {data: LinkedList<number>}) => {\n    const list = message.data;\n    let sum = 0;\n    let count = 0;\n    for (const num of list) {\n      sum += num;\n      count++;\n    }\n    const average = sum / count;\n    workerScope.postMessage({data: average});\n  };\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `List` to iterate over a list of XML attributes, then uses the `insert` method of `List` to add a new attribute at a specific position, and finally uses the `EventType` enum from `xml` to log the modified list with a specific event type (e.g., `EventType.WARNING`).",
    "output": "import {List, xml} from '@kit.ArkTS';\n\nexport function modifyAttributes(attributes: List<string>, newAttribute: string, position: number): void {\n  attributes.forEach((attribute: string, index: number) => {\n    console.log(`Attribute at index ${index}: ${attribute}`);\n  });\n\n  attributes.insert(position, newAttribute);\n\n  console.log(`Modified attributes: ${attributes.convertToArray()}`);\n  console.log(`Event type: ${xml.EventType.WARNING}`);\n}"
  },
  {
    "instruction": "Create a function that parses a JSON string of product data (using `json.parse`) into an object, then iterates over its properties using `LightWeightMap.forEach` to populate a LightWeightMap with the product IDs as keys and their prices as values.",
    "output": "import {json, LightWeightMap} from '@kit.ArkTS';\n\nexport function parseAndPopulate(jsonString: string): LightWeightMap<string, number> {\n  const parsedData = json.parse(jsonString) as Record<string, {id: string, price: number}>;\n  const productMap = new LightWeightMap<string, number>();\n\n  Object.values(parsedData).forEach((product) => {\n    productMap.set(product.id, product.price);\n  });\n\n  return productMap;\n}"
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then transfers them to an `ArrayList<number>` (from @kit.ArkTS) using the `add` method, and finally sorts the numbers using the `sort` method of `ArrayList`.",
    "output": "import {ArrayList, Stack, taskpool} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[]): ArrayList<number> {\n  const stack = new Stack<number>();\n  const arrayList = new ArrayList<number>();\n\n  // Push numbers into the stack\n  for (const num of numbers) {\n    stack.push(num);\n  }\n\n  // Transfer numbers from stack to ArrayList\n  while (!stack.isEmpty()) {\n    arrayList.add(stack.pop());\n  }\n\n  // Sort the ArrayList\n  arrayList.sort((a, b) => a - b);\n\n  return arrayList;\n}"
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `LightWeightMap` to iterate over its entries and create an array of `Event` objects, where each `Event`'s `type` is set to the key from the `LightWeightMap` entry and the `timeStamp` is set to the corresponding value. Then, use the `length` property of `LightWeightMap` to determine the number of events created.",
    "output": "import {Event, LightWeightMap} from '@kit.ArkTS';\n\nexport function createEventsFromMap(lightWeightMap: LightWeightMap<string, number>): Event[] {\n  const events: Event[] = [];\n  lightWeightMap.forEach((value: number, key: string) => {\n    const event = new Event();\n    event.type = key;\n    event.timeStamp = value;\n    events.push(event);\n  });\n  const numberOfEvents = lightWeightMap.length;\n  return events;\n}"
  },
  {
    "instruction": "Implement a function that concatenates multiple buffers using `buffer.concat`, verifies if the result is a valid buffer using `buffer.isBuffer`, and then triggers an event where the concatenated buffer's length is stored in `Event.type` as a string.",
    "output": "import {buffer, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function concatenateAndTriggerEvent(buffers: buffer[]): Event {\n  const concatenatedBuffer = buffer.concat(buffers);\n  const isValidBuffer = buffer.isBuffer(concatenatedBuffer);\n  \n  if (!isValidBuffer) {\n    throw new Error('Invalid buffer');\n  }\n  \n  const event = new Event();\n  event.type = concatenatedBuffer.length.toString();\n  \n  return event;\n}"
  },
  {
    "instruction": "Implement a function where the worker thread uses the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope` to send a shared object to the main thread, and the main thread uses the `onmessage` property of `ThreadWorkerGlobalScope` to receive and process the shared object. The function should also ensure proper cleanup by using the `removeAllListener` method of `WorkerEventTarget` to remove all event listeners after processing is complete.",
    "output": "import {GlobalScope, WorkerEventTarget, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerCommunication(workerScope: ThreadWorkerGlobalScope): void {\n  // Worker thread sending a shared object to main thread\n  const sharedObject = { data: 'Shared data' };\n  workerScope.postMessageWithSharedSendable(sharedObject);\n\n  // Main thread receiving and processing the shared object\n  workerScope.onmessage = (event: MessageEvent): void => {\n    const receivedData = event.data;\n    console.log('Received shared object:', receivedData);\n\n    // Cleanup: remove all event listeners\n    workerScope.removeAllListener();\n  };\n}"
  },
  {
    "instruction": "Implement a function that uses the `entries` method of `HashMap` to retrieve key-value pairs, then uses the `forEach` method of `PlainArray` to process each pair and create a new `PlainArray` where each entry's value is doubled. The function should return the new `PlainArray`.",
    "output": "import {HashMap, worker, PlainArray} from '@kit.ArkTS';\n\nexport function doubleHashMapValues(map: HashMap<number, number>): PlainArray<number> {\n  const entries = map.entries();\n  const result = new PlainArray<number>();\n  \n  entries.forEach((entry: [number, number]) => {\n    const [key, value] = entry;\n    result.add(key, value * 2);\n  });\n  \n  return result;\n}"
  },
  {
    "instruction": "Implement a function that uses `WorkerEventTarget.addEventListener` to listen for multiple 'message' events. For each event, extract the `data` from `MessageEvents` and accumulate it in an array. After a specific condition is met (e.g., receiving 5 messages), use `WorkerEventTarget.removeAllListener` to stop further event processing and return the accumulated data array.",
    "output": "import {WorkerEventTarget, MessageEvents} from '@kit.ArkTS';\n\nexport function listenAndAccumulateMessages(workerTarget: WorkerEventTarget, maxMessages: number): Promise<Array<unknown>> {\n  return new Promise((resolve) => {\n    const messages: Array<unknown> = [];\n    const messageHandler = (event: MessageEvents) => {\n      messages.push(event.data);\n      if (messages.length >= maxMessages) {\n        workerTarget.removeAllListener('message');\n        resolve(messages);\n      }\n    };\n    workerTarget.addEventListener('message', messageHandler);\n  });\n}"
  },
  {
    "instruction": "Write a function that initializes a `Queue` (using the `constructor`), adds multiple events to it (using the `add` method), and then uses the `getFirst` method to retrieve the first event. Check if the first event's `type` matches a given value (using the `type` property of `Event`). Return `true` if it matches, otherwise `false`.",
    "output": "import {Event, Queue} from '@kit.ArkTS';\n\nexport function checkFirstEventType(events: Event[], expectedType: string): boolean {\n  const queue = new Queue<Event>();\n  events.forEach(event => queue.add(event));\n  const firstEvent = queue.getFirst();\n  return firstEvent?.type === expectedType;\n}"
  },
  {
    "instruction": "Write a function that uses the `values` method of `TreeSet` to retrieve all values, then stores them in a `LightWeightMap` using the `set` method, where the keys are the indices of the values. Finally, use the `getValueAt` method of `LightWeightMap` to retrieve and return the value at a specified index.",
    "output": "import {LightWeightMap, TreeSet, uri} from '@kit.ArkTS';\n\nexport function storeAndRetrieveValue(treeSet: TreeSet<number>, index: number): number | undefined {\n  const lightWeightMap = new LightWeightMap<number, number>();\n  const values = treeSet.values();\n  let i = 0;\n  for (const value of values) {\n    lightWeightMap.set(i, value);\n    i++;\n  }\n  return lightWeightMap.getValueAt(index);\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `ArrayList` to iterate over a list of student scores, filters out scores below a threshold using the `remove` method of `HashSet`, and then calculates the average of the remaining scores by converting the `HashSet` back to an `ArrayList` (using `convertToArray` method) and applying the `reduce` method (hypothetical) or manual summation.",
    "output": "import {HashSet, PlainArray, ArrayList} from '@kit.ArkTS';\n\nexport function calculateAverageAboveThreshold(scores: ArrayList<number>, threshold: number): number {\n  const filteredScores = new HashSet<number>();\n  \n  // Iterate over scores and add those above threshold to HashSet\n  scores.forEach((score: number) => {\n    if (score >= threshold) {\n      filteredScores.add(score);\n    }\n  });\n  \n  // Convert HashSet back to ArrayList\n  const filteredArrayList = new ArrayList<number>();\n  filteredScores.forEach((score: number) => {\n    filteredArrayList.add(score);\n  });\n  \n  // Calculate average\n  let sum = 0;\n  filteredArrayList.forEach((score: number) => {\n    sum += score;\n  });\n  \n  return filteredArrayList.length > 0 ? sum / filteredArrayList.length : 0;\n}"
  },
  {
    "instruction": "Write a function that uses `buffer.alloc` to create a new Buffer of a specified size, fills it with data, then compares it with another Buffer using `buffer.compare`, and sends the comparison result (a number) via `MessageEvents.data`.",
    "output": "import {buffer, MessageEvents} from '@kit.ArkTS';\n\nexport function compareBuffers(size: number, fillValue: number, otherBuffer: buffer.Buffer): MessageEvents {\n  const newBuffer = buffer.alloc(size, fillValue);\n  const comparisonResult = buffer.compare(newBuffer, otherBuffer);\n  const messageEvent = new MessageEvents('data');\n  messageEvent.data = comparisonResult;\n  return messageEvent;\n}"
  },
  {
    "instruction": "Implement a function that uses the `removeAt` method of `LightWeightSet` to delete elements at specific indices from a set of transaction IDs, then transfer the remaining elements to a `TreeSet` using its `constructor`. Use the `popFirst` and `popLast` methods of `TreeSet` to remove and return the smallest and largest transaction IDs from the sorted set.",
    "output": "import {LightWeightSet, TreeSet} from '@kit.ArkTS';\n\nexport function processTransactionIDs(transactionIDs: LightWeightSet<number>, indicesToRemove: number[]): { smallest: number | undefined, largest: number | undefined } {\n  // Remove elements at specified indices\n  indicesToRemove.sort((a, b) => b - a); // Sort in descending order to avoid index shifting\n  for (const index of indicesToRemove) {\n    if (index >= 0 && index < transactionIDs.length) {\n      transactionIDs.removeAt(index);\n    }\n  }\n\n  // Transfer remaining elements to TreeSet\n  const treeSet = new TreeSet<number>();\n  for (let i = 0; i < transactionIDs.length; i++) {\n    const value = transactionIDs.getValueAt(i);\n    if (value !== undefined) {\n      treeSet.add(value);\n    }\n  }\n\n  // Pop smallest and largest values\n  const smallest = treeSet.popFirst();\n  const largest = treeSet.popLast();\n\n  return { smallest, largest };\n}"
  },
  {
    "instruction": "Write a function that uses the `name` property of `GlobalScope` to retrieve the current context name, then passes this name as a parameter to the `url` API to construct a complete URL string. The function should return the constructed URL.",
    "output": "import {GlobalScope, url} from '@kit.ArkTS';\n\nexport function constructUrl(): string {\n  const contextName = GlobalScope.name;\n  const completeUrl = url.URL(contextName);\n  return completeUrl.toString();\n}"
  },
  {
    "instruction": "Write a function that first uses the `getEnvironmentVar` method of `process` to retrieve the value of an environment variable, then encodes the retrieved value using the `from` method of `buffer` with UTF-8 encoding, and finally checks if the encoded buffer is valid using the `isEncoding` method of `buffer`.",
    "output": "import {process, buffer} from '@kit.ArkTS';\n\nexport function checkEnvironmentVarEncoding(envVarName: string): boolean {\n  const envVarValue = process.getEnvironmentVar(envVarName);\n  if (envVarValue === undefined) {\n    return false;\n  }\n  const encodedBuffer = buffer.from(envVarValue, 'utf-8');\n  return buffer.isEncoding('utf-8');\n}"
  },
  {
    "instruction": "Create a function that initializes an `ArrayList<number>` (from @kit.ArkTS) with random numbers using the `add` method, then uses the `getIndexOf` method to find the index of a specific target number. Pass this index to the `removeByIndex` method to remove the target number from the list, and finally use the `trimToCurrentLength` method to optimize the list's capacity.",
    "output": "import {ArrayList, stream} from '@kit.ArkTS';\n\nexport function processArrayList(target: number): void {\n  const list: ArrayList<number> = new ArrayList<number>();\n  \n  // Initialize the list with 10 random numbers between 1 and 100\n  for (let i = 0; i < 10; i++) {\n    list.add(Math.floor(Math.random() * 100) + 1);\n  }\n  \n  // Find the index of the target number\n  const index: number = list.getIndexOf(target);\n  \n  // Remove the target number if found\n  if (index !== -1) {\n    list.removeByIndex(index);\n  }\n  \n  // Optimize the list's capacity\n  list.trimToCurrentLength();\n}"
  },
  {
    "instruction": "Create a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the top element of the stack, and if it meets a condition (e.g., even number), sends it to a worker thread (using `worker.postMessage`) for further processing (e.g., squaring the number). The result should be logged using `worker.onmessage`.",
    "output": "import {Stack, worker} from '@kit.ArkTS';\n\nexport function processTopElement(stack: Stack<number>, condition: (num: number) => boolean): void {\n  if (stack.isEmpty()) {\n    return;\n  }\n  \n  const topElement = stack.peek();\n  \n  if (condition(topElement)) {\n    const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n    \n    workerInstance.postMessage(topElement);\n    \n    workerInstance.onmessage = (value: number) => {\n      console.log(`Processed result: ${value}`);\n      workerInstance.terminate();\n    };\n  }\n}"
  },
  {
    "instruction": "Create a function that initializes a worker thread using `worker.ThreadWorker` (from @kit.ArkTS) and sets up an error handler using the `onerror` property of `WorkerGlobalScope`. The error handler should log any errors encountered in the worker thread to the console.",
    "output": "import {WorkerGlobalScope, worker} from '@kit.ArkTS';\n\nexport function initializeWorkerThread(scriptURL: string): worker.ThreadWorker {\n  const workerInstance = new worker.ThreadWorker(scriptURL);\n  \n  workerInstance.onerror = (error: ErrorEvent) => {\n    console.error(`Error in worker thread: ${error.message}`);\n  };\n  \n  return workerInstance;\n}"
  },
  {
    "instruction": "Create a function that first checks if a `Vector` is empty using the `isEmpty` method, and if not, retrieves the first element using `getFirstElement` and the last element using `getLastElement`. Then, use these elements to create a new `Event` object where the `type` property is a concatenation of the first and last element's types from the `Vector`.",
    "output": "import {Vector, Event} from '@kit.ArkTS';\n\nexport function createEventFromVector(vector: Vector<unknown>): Event | null {\n  if (vector.isEmpty()) {\n    return null;\n  }\n\n  const firstElement = vector.getFirstElement();\n  const lastElement = vector.getLastElement();\n  const eventType = `${typeof firstElement}_${typeof lastElement}`;\n\n  const event: Event = {\n    type: eventType,\n    timeStamp: new Date().getTime()\n  };\n\n  return event;\n}"
  },
  {
    "instruction": "Create a function that initializes a `Queue` object, uses its `add` method to enqueue a series of tasks, then starts a new Worker using `WorkerOptions` (with a unique `name`) and passes the queue's first task (obtained via `Queue.getFirst`) to the worker for processing.",
    "output": "import {WorkerGlobalScope, WorkerOptions, Queue} from '@kit.ArkTS';\n\nexport function initializeQueueAndStartWorker(): void {\n  const queue = new Queue<string>();\n  queue.add('Task1');\n  queue.add('Task2');\n  queue.add('Task3');\n\n  const firstTask = queue.getFirst();\n  if (firstTask) {\n    const workerOptions: WorkerOptions = {\n      name: 'uniqueWorkerName'\n    };\n    const worker = new WorkerGlobalScope('workerScript.js', workerOptions);\n    worker.postMessage(firstTask);\n  }\n}"
  },
  {
    "instruction": "Write a function that uses `json.stringify` to convert an object containing user data into a JSON string, then passes this string to `DedicatedWorkerGlobalScope.postMessage` to send it to a worker thread for processing.",
    "output": "import {json, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendUserDataToWorker(userData: object, workerScope: DedicatedWorkerGlobalScope): void {\n  const jsonString = json.stringify(userData);\n  workerScope.postMessage(jsonString);\n}"
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `TreeSet` (from @kit.ArkTS) to iterate over a set of values and push each value onto a `Stack` (from @kit.ArkTS) using its `push` method. Then, use the `pop` method of `Stack` to reverse the order of the values and store them back into the `TreeSet` using its `clear` and `add` methods.",
    "output": "import {Event, TreeSet, Stack} from '@kit.ArkTS';\n\nexport function reverseTreeSetValues(treeSet: TreeSet<number>): void {\n  const stack = new Stack<number>();\n  \n  treeSet.forEach((value: number) => {\n    stack.push(value);\n  });\n  \n  treeSet.clear();\n  \n  while (!stack.isEmpty()) {\n    const value = stack.pop();\n    treeSet.add(value);\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `List` to collect a sequence of numbers, then passes the resulting list to the `sort` method of `List` to sort the numbers in ascending order. Finally, use the `insertEnd` method of `Deque` to enqueue the sorted numbers into a deque for further processing.",
    "output": "import {List, WorkerEventTarget, Deque} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[]): Deque<number> {\n  const list = new List<number>();\n  \n  // Add numbers to the list\n  numbers.forEach((num) => {\n    list.add(num);\n  });\n  \n  // Sort the list in ascending order\n  list.sort((a, b) => a - b);\n  \n  // Create a deque and insert the sorted numbers at the end\n  const deque = new Deque<number>();\n  for (const num of list) {\n    deque.insertEnd(num);\n  }\n  \n  return deque;\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of strings, then converts the LinkedList to an array using `convertToArray`, and finally uses the `concat` method of `buffer` to merge all strings into a single buffer. The function should return the merged buffer.",
    "output": "import { LinkedList } from '@kit.ArkTS';\nimport { buffer } from '@kit.ArkTS';\n\nexport function mergeStringsToBuffer(strings: string[]): buffer.Buffer {\n  const list = new LinkedList<string>();\n  strings.forEach((str) => {\n    list.add(str);\n  });\n  const stringArray = list.convertToArray();\n  const buffers = stringArray.map((str) => buffer.from(str));\n  return buffer.concat(buffers);\n}"
  },
  {
    "instruction": "Create a function that dynamically generates a Worker script URL using the `url` API, then initializes a shared Worker by passing this URL along with the `shared` property set to `true` in the `WorkerOptions` API. The function should verify that the Worker is correctly initialized as a shared worker before returning it.",
    "output": "import {WorkerOptions, url} from '@kit.ArkTS';\n\nexport function createSharedWorker(scriptPath: string): Worker {\n  const scriptUrl = new url.URL(scriptPath);\n  const options: WorkerOptions = {\n    shared: true\n  };\n  const worker = new Worker(scriptUrl.toString(), options);\n  return worker;\n}"
  },
  {
    "instruction": "Create a function that checks if the `self` property of `GlobalScope` matches the current context, and if an error occurs (captured via `onerror`), it uses the `error` property of `ErrorEvent` to determine the type of error and take appropriate action based on the error type.",
    "output": "import {ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function checkGlobalScopeContext(globalScope: GlobalScope): boolean {\n  try {\n    return globalScope.self === globalScope;\n  } catch (error) {\n    globalScope.onerror = (event: ErrorEvent) => {\n      const errorType = event.error;\n      if (errorType instanceof TypeError) {\n        console.error('TypeError occurred:', errorType.message);\n      } else if (errorType instanceof ReferenceError) {\n        console.error('ReferenceError occurred:', errorType.message);\n      } else {\n        console.error('Unknown error occurred:', errorType);\n      }\n    };\n    return false;\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a message containing an array of numbers to a worker thread, and then uses the `transfer` property of `PostMessageOptions` to transfer ownership of a shared buffer to the worker thread for efficient data processing.",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport function sendDataToWorker(worker: ThreadWorkerGlobalScope, data: number[], buffer: ArrayBuffer): void {\n  worker.postMessage(data);\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  worker.postMessage(buffer, options);\n}"
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a Buffer from a string with 'utf-8' encoding, then passes this Buffer to a MessageEvent constructor to create an event, and finally accesses the event's data property to verify the original string content.",
    "output": "import {buffer, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function verifyStringContent(originalString: string): boolean {\n  const buf = buffer.from(originalString, 'utf-8');\n  const event = new MessageEvent<string>('message', { data: buf.toString('utf-8') });\n  return event.data === originalString;\n}"
  },
  {
    "instruction": "Write a function that uses the `read` method of `stream` to read data from a file, then uses the `parse` method of `uri` to extract and validate the URL components from the read data. The function should return the extracted domain name if the URI is valid, or an error otherwise.",
    "output": "import {stream, uri} from '@kit.ArkTS';\n\nexport function extractDomainFromFile(filePath: string): string | Error {\n  try {\n    const readableStream = new stream.Readable();\n    const data = readableStream.read(filePath);\n    const parsedUri = uri.parse(data);\n    \n    if (!parsedUri || !parsedUri.host) {\n      return new Error('Invalid URI: No domain found');\n    }\n    \n    return parsedUri.host;\n  } catch (error) {\n    return new Error(`Error reading or parsing URI: ${error.message}`);\n  }\n}"
  },
  {
    "instruction": "Create a worker thread that initializes a `Queue` object, uses its `forEach` method to iterate over the elements, and sends each element to the main thread using the `postMessage` method of `ThreadWorkerGlobalScope`. The main thread should then use the `onmessage` property of `ThreadWorkerGlobalScope` to receive and log each element.",
    "output": "import {ThreadWorkerGlobalScope, Queue} from '@kit.ArkTS';\n\nconst worker: ThreadWorkerGlobalScope = new ThreadWorkerGlobalScope();\nconst queue: Queue<number> = new Queue<number>();\n\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\n\nqueue.forEach((element: number) => {\n  worker.postMessage(element);\n});\n\nworker.onmessage = (message: MessageEvent<number>) => {\n  console.log(`Received element: ${message.data}`);\n};\n"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LinkedList` to iterate over a list of events, checks each event's `type` property, and then uses the `onerror` property of `GlobalScope` to handle any events of type 'error', logging their `timeStamp` and details.",
    "output": "import {Event, GlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function handleErrorEvents(events: LinkedList<Event>): void {\n  events.forEach((event: Event) => {\n    if (event.type === 'error') {\n      GlobalScope.onerror = (ev: Event) => {\n        console.log(`Error timestamp: ${ev.timeStamp}, details: ${JSON.stringify(ev)}`);\n        return true;\n      };\n      GlobalScope.onerror(event);\n    }\n  });\n}"
  },
  {
    "instruction": "Create a function that utilizes the `getStartRealtime` method of `process` to measure the application's startup time, then uses the `uptime` method of `process` to calculate the total runtime, and finally sends both metrics to a worker thread (using worker API methods) for performance analysis and logging.",
    "output": "import {worker, process, url} from '@kit.ArkTS';\n\nexport function measureAndSendMetrics(): void {\n  const startupTime: number = process.getStartRealtime();\n  const runtime: number = process.uptime();\n  \n  const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n  \n  workerInstance.postMessage({\n    startupTime,\n    runtime\n  });\n}\n\nexport class WorkerScript {\n  constructor() {\n    worker.parentPort.onmessage = (event: MessageEvent<{startupTime: number, runtime: number}>): void => {\n      const { startupTime, runtime } = event.data;\n      this.analyzePerformance(startupTime, runtime);\n    };\n  }\n\n  private analyzePerformance(startupTime: number, runtime: number): void {\n    // Perform analysis and logging here\n    console.log(`Startup Time: ${startupTime}ms`);\n    console.log(`Runtime: ${runtime}s`);\n  }\n}"
  },
  {
    "instruction": "Write a function that takes a `List` of URLs and a `Queue` of URL indices. Use the `get` method of `List` to retrieve each URL based on the indices obtained from the `pop` method of `Queue`. Store the retrieved URLs in a new `List` using the `add` method and return the final list of URLs.",
    "output": "import {List, url, Queue} from '@kit.ArkTS';\n\nexport function retrieveUrls(urlList: List<string>, indexQueue: Queue<number>): List<string> {\n  const resultList: List<string> = new List();\n  while (indexQueue.length > 0) {\n    const index = indexQueue.pop();\n    if (index !== undefined) {\n      const url = urlList.get(index);\n      if (url !== undefined) {\n        resultList.add(url);\n      }\n    }\n  }\n  return resultList;\n}"
  },
  {
    "instruction": "Write a function that uses the `worker` API to spawn a new worker thread, then uses the `buffer.from` method to create a buffer containing a string message, and finally sends this buffer to the worker thread using the `worker.postMessage` method.",
    "output": "import {worker, buffer} from '@kit.ArkTS';\n\nexport function spawnWorkerAndSendMessage(): void {\n  const workerInstance = new worker.ThreadWorker('workers/worker.ts');\n  const message: string = 'Hello from main thread!';\n  const messageBuffer: buffer.Buffer = buffer.from(message, 'utf-8');\n  workerInstance.postMessage(messageBuffer);\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a set of key-value pairs, then converts the values to an array using the `convertToArray` method of `ArrayList` and sorts them in ascending order using the `sort` method of `ArrayList`.",
    "output": "import {PlainArray, ArrayList} from '@kit.ArkTS';\n\nexport function processAndSortKeyValuePairs(): number[] {\n  const plainArray = new PlainArray<number>();\n  plainArray.add(1, 10);\n  plainArray.add(2, 30);\n  plainArray.add(3, 20);\n  plainArray.add(4, 40);\n\n  const arrayList = new ArrayList<number>();\n  for (let i = 0; i < plainArray.length; i++) {\n    arrayList.add(plainArray.getValueAt(i));\n  }\n\n  const valuesArray = arrayList.convertToArray();\n  arrayList.sort((a: number, b: number) => a - b);\n\n  return arrayList.convertToArray();\n}"
  },
  {
    "instruction": "Write a function that uses the `convertToArray` method of `Vector` to transform a vector of URIs into an array, then iterates over the array using the `Symbol.iterator` method of `Vector` to validate each URI (assuming URI validation is implicit). Finally, use the `replaceAllElements` method of `Vector` to update the vector with only the valid URIs.",
    "output": "import {Vector, uri} from '@kit.ArkTS';\n\nexport function validateAndFilterURIs(vector: Vector<string>): Vector<string> {\n  const uriArray: string[] = vector.convertToArray();\n  const validURIs: string[] = [];\n\n  for (const uri of vector) {\n    try {\n      // Implicit validation by attempting to use the URI\n      validURIs.push(uri);\n    } catch (e) {\n      // Skip invalid URIs\n    }\n  }\n\n  vector.replaceAllElements((value: string, index: number) => {\n    return validURIs[index] || '';\n  });\n\n  return vector;\n}"
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of randomly generated UUIDs (using `generateRandomUUID` from `util`), then iterates over the stack using `[Symbol.iterator]` to filter out invalid UUIDs (using `parseUUID` from `util`). The valid UUIDs should be returned as an array.",
    "output": "import {PostMessageOptions, Stack, util} from '@kit.ArkTS';\n\nexport function filterValidUUIDs(count: number): string[] {\n  const stack = new Stack<string>();\n  \n  for (let i = 0; i < count; i++) {\n    const uuid = util.generateRandomUUID();\n    stack.push(uuid);\n  }\n  \n  const validUUIDs: string[] = [];\n  \n  for (const uuid of stack) {\n    try {\n      util.parseUUID(uuid);\n      validUUIDs.push(uuid);\n    } catch (e) {\n      continue;\n    }\n  }\n  \n  return validUUIDs;\n}"
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a sequence of numbers to a worker thread, where the worker thread uses the `insertFront` and `popLast` methods of `Deque` to reverse the sequence and then sends the reversed sequence back to the main thread using `postMessage`.",
    "output": "import {ThreadWorkerGlobalScope, WorkerEventTarget, Deque} from '@kit.ArkTS';\n\nexport function reverseSequenceWithWorker(sequence: number[]): void {\n  const worker = new ThreadWorkerGlobalScope('workers/worker.ts');\n  \n  worker.onmessage = (event: MessageEvent<number[]>) => {\n    console.log('Reversed sequence:', event.data);\n    worker.close();\n  };\n  \n  worker.postMessage(sequence);\n}\n\nexport function workerThreadLogic(): void {\n  const workerScope = self as unknown as ThreadWorkerGlobalScope;\n  \n  workerScope.onmessage = (event: MessageEvent<number[]>) => {\n    const deque = new Deque<number>();\n    \n    for (const num of event.data) {\n      deque.insertFront(num);\n    }\n    \n    const reversedSequence: number[] = [];\n    while (deque.length > 0) {\n      reversedSequence.push(deque.popLast());\n    }\n    \n    workerScope.postMessage(reversedSequence);\n  };\n}"
  },
  {
    "instruction": "Create a function that takes a JSON string containing an array of UUIDs, uses `json.parse` to convert it into an array, then filters out invalid UUIDs by checking each one with `util.parseUUID`, and finally returns the filtered array of valid UUIDs.",
    "output": "import {json, util} from '@kit.ArkTS';\n\nexport function filterValidUUIDs(jsonString: string): string[] {\n  try {\n    const uuids: string[] = json.parse(jsonString);\n    if (!Array.isArray(uuids)) {\n      return [];\n    }\n    return uuids.filter((uuid: string) => {\n      try {\n        util.parseUUID(uuid);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    });\n  } catch (e) {\n    return [];\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `HashSet` to collect a set of unique numbers, then converts the HashSet to an array using the `convertToArray` method of `Vector`, and finally sorts the array using the `sort` method of `Vector` to display the numbers in ascending order.",
    "output": "import {Vector, HashSet} from '@kit.ArkTS';\n\nexport function collectAndSortUniqueNumbers(numbers: number[]): number[] {\n  const uniqueSet = new HashSet<number>();\n  numbers.forEach(num => {\n    uniqueSet.add(num);\n  });\n  \n  const vector = new Vector<number>();\n  uniqueSet.forEach(value => {\n    vector.add(value);\n  });\n  \n  const array = vector.convertToArray();\n  vector.sort((a, b) => a - b);\n  \n  return array;\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Queue` to process each element in the queue, doubling its value, and then passes the modified elements to a stream processing function that filters out even numbers and logs the remaining odd numbers.",
    "output": "import {Queue, stream} from '@kit.ArkTS';\n\nexport function processQueue(queue: Queue<number>): void {\n  const doubledQueue = new Queue<number>();\n  queue.forEach((value: number) => {\n    doubledQueue.add(value * 2);\n  });\n\n  const readableStream = new stream.Readable<number>({\n    read(size: number): void {\n      while (doubledQueue.length > 0) {\n        const value = doubledQueue.pop();\n        if (value !== undefined) {\n          this.push(value);\n        }\n      }\n      this.push(null);\n    }\n  });\n\n  const transformStream = new stream.Transform<number, number>({\n    transform(chunk: number, encoding: string, callback: Function): void {\n      if (chunk % 2 !== 0) {\n        this.push(chunk);\n      }\n      callback();\n    }\n  });\n\n  readableStream.pipe(transformStream).on('data', (data: number) => {\n    console.log(data);\n  });\n}"
  },
  {
    "instruction": "Design a function that uses the `sort` method of `List` to organize a list of numerical values, and then passes the sorted list to the `convertToArray` method of `List` to transform it into an array format for further processing or display.",
    "output": "import {stream, GlobalScope, List} from '@kit.ArkTS';\n\nexport function sortAndConvertToArray(numbers: List<number>): number[] {\n  numbers.sort((a: number, b: number) => a - b);\n  return numbers.convertToArray();\n}"
  },
  {
    "instruction": "Write a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the top element of the stack and then uses the `getHigherValue` method of `TreeSet` (from @kit.ArkTS) to find the smallest value in the set that is greater than the peeked value. If such a value exists, push it onto the stack using the `push` method of `Stack`.",
    "output": "import {Event, TreeSet, Stack} from '@kit.ArkTS';\n\nexport function pushHigherValue(stack: Stack<number>, treeSet: TreeSet<number>): void {\n  if (stack.isEmpty() || treeSet.isEmpty()) {\n    return;\n  }\n  const topValue = stack.peek();\n  const higherValue = treeSet.getHigherValue(topValue);\n  if (higherValue !== undefined) {\n    stack.push(higherValue);\n  }\n}"
  },
  {
    "instruction": "Implement a task where a `LinkedList` of objects is manipulated using the `removeByIndex` and `insert` methods, then the modified list is converted to an array using the `convertToArray` method and sent to a worker thread using `postMessage` of `ThreadWorkerGlobalScope`. The worker should validate the array (e.g., check for duplicates) and return the validation result, which is then handled by the `onmessage` property of the worker scope.",
    "output": "import {ThreadWorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport class LinkedListHandler {\n  private linkedList: LinkedList<number>;\n\n  constructor() {\n    this.linkedList = new LinkedList<number>();\n  }\n\n  public addElements(elements: number[]): void {\n    for (const element of elements) {\n      this.linkedList.add(element);\n    }\n  }\n\n  public removeByIndex(index: number): void {\n    this.linkedList.removeByIndex(index);\n  }\n\n  public insert(index: number, element: number): void {\n    this.linkedList.insert(index, element);\n  }\n\n  public convertToArray(): number[] {\n    return this.linkedList.convertToArray();\n  }\n}\n\nexport function createWorker(): ThreadWorkerGlobalScope {\n  const worker = new ThreadWorkerGlobalScope();\n\n  worker.onmessage = (message: { data: number[] }): void => {\n    const array = message.data;\n    const hasDuplicates = new Set(array).size !== array.length;\n    worker.postMessage({ isValid: !hasDuplicates });\n  };\n\n  return worker;\n}\n\nexport function main(): void {\n  const handler = new LinkedListHandler();\n  handler.addElements([1, 2, 3, 4, 5]);\n  handler.removeByIndex(2);\n  handler.insert(2, 10);\n  const array = handler.convertToArray();\n\n  const worker = createWorker();\n  worker.postMessage(array);\n\n  worker.onmessage = (message: { data: { isValid: boolean } }): void => {\n    console.log(`Validation result: ${message.data.isValid}`);\n    worker.close();\n  };\n}"
  },
  {
    "instruction": "Write a function that uses `EventTarget.addEventListener` to listen for a custom event, then dispatches the event using `EventTarget.dispatchEvent` with a `MessageEvent` containing some data in its `data` property. The function should then extract and return the `data` from the `MessageEvent`.",
    "output": "import {EventTarget, MessageEvents, PostMessageOptions} from '@kit.ArkTS';\n\nexport function listenAndDispatchEvent(): string {\n  const eventTarget = new EventTarget();\n  const eventType = 'customEvent';\n  let receivedData: string = '';\n\n  const eventListener = (event: MessageEvents) => {\n    receivedData = event.data;\n  };\n\n  eventTarget.addEventListener(eventType, eventListener);\n\n  const message = 'Hello, World!';\n  const messageEvent = new MessageEvents(eventType, {\n    data: message\n  });\n\n  eventTarget.dispatchEvent(messageEvent);\n  eventTarget.removeEventListener(eventType, eventListener);\n\n  return receivedData;\n}"
  },
  {
    "instruction": "Create a worker that uses `DedicatedWorkerGlobalScope.onmessage` to receive data from the main thread, processes the data, and then uses `WorkerEventTarget.dispatchEvent` to trigger a custom event with the result. The main thread should use `WorkerEventTarget.addEventListener` to listen for this custom event and log the result.",
    "output": "import {WorkerEventTarget, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createWorker() {\n  const worker = new DedicatedWorkerGlobalScope('worker.js');\n  \n  worker.onmessage = (event: MessageEvent<string>) => {\n    const processedData = event.data.toUpperCase();\n    const customEvent = new CustomEvent('processed', { detail: processedData });\n    worker.dispatchEvent(customEvent);\n  };\n  \n  return worker;\n}\n\nexport function setupMainThreadListener(worker: DedicatedWorkerGlobalScope) {\n  worker.addEventListener('processed', (event: CustomEvent) => {\n    console.log('Processed data:', event.detail);\n  });\n}"
  },
  {
    "instruction": "Create a function that captures an `Event` object, extracts its `timeStamp` property, and uses the `getHigherValue` method of `TreeSet` to find the closest higher timestamp from a predefined set of timestamps stored in the `TreeSet`.",
    "output": "import {TreeSet, Event, process} from '@kit.ArkTS';\n\nexport function findClosestHigherTimestamp(event: Event, timestampSet: TreeSet<number>): number | undefined {\n  const eventTimestamp = event.timeStamp;\n  return timestampSet.getHigherValue(eventTimestamp);\n}"
  },
  {
    "instruction": "Create a function that first uses the `convertToArray` method of `LinkedList` to transform a linked list of numbers into an array, then uses the `addEventListener` method of `WorkerEventTarget` to listen for a custom event that triggers the calculation of the sum of the array elements. The function should return the sum once the event is dispatched.",
    "output": "import {WorkerEventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function calculateSumFromLinkedList(linkedList: LinkedList<number>, eventTarget: WorkerEventTarget): Promise<number> {\n  return new Promise((resolve) => {\n    const array = linkedList.convertToArray();\n    \n    const eventListener = () => {\n      const sum = array.reduce((acc, curr) => acc + curr, 0);\n      resolve(sum);\n      eventTarget.removeEventListener('calculate', eventListener);\n    };\n    \n    eventTarget.addEventListener('calculate', eventListener);\n  });\n}"
  },
  {
    "instruction": "Create a function that first uses `LightWeightSet.toArray` to convert a LightWeightSet of task priorities (from `taskpool.Priority`) into an array, then uses `xml` parsing to format this array into an XML string representation of the priorities for logging purposes.",
    "output": "import {LightWeightSet, xml, taskpool} from '@kit.ArkTS';\n\nexport function convertPrioritiesToXml(prioritySet: LightWeightSet<taskpool.Priority>): string {\n  const priorityArray: Array<taskpool.Priority> = prioritySet.toArray();\n  const xmlBuilder = new xml.XmlSerializer();\n  \n  xmlBuilder.startElement('Priorities');\n  for (const priority of priorityArray) {\n    xmlBuilder.startElement('Priority');\n    xmlSerializer.text(priority.toString());\n    xmlBuilder.endElement();\n  }\n  xmlBuilder.endElement();\n  \n  return xmlBuilder.toString();\n}"
  },
  {
    "instruction": "Write a function that initializes a `LightWeightSet` with a set of values using the `addAll` method, then creates a Worker with `WorkerOptions` where the name is dynamically generated from the `LightWeightSet`'s `length` property, and finally uses the `WorkerGlobalScope`'s `onerror` property to handle any errors during worker execution.",
    "output": "import {WorkerGlobalScope, LightWeightSet, WorkerOptions} from '@kit.ArkTS';\n\nexport function initializeWorkerWithLightWeightSet(values: string[]): void {\n  const lightWeightSet = new LightWeightSet<string>();\n  lightWeightSet.addAll(values);\n\n  const workerName = `worker_${lightWeightSet.length}`;\n  const workerOptions: WorkerOptions = {\n    name: workerName,\n    shared: false\n  };\n\n  const worker = new WorkerGlobalScope(workerOptions);\n  worker.onerror = (error: ErrorEvent) => {\n    console.error(`Worker error: ${error.message}`);\n  };\n}"
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then iterates over the stack using the `Symbol.iterator` method to calculate the sum of all elements, and finally uses the `write` method of `stream` (from @kit.ArkTS) to output the result.",
    "output": "import {stream, Stack} from '@kit.ArkTS';\n\nexport function calculateAndOutputSum(numbers: number[]): void {\n  const stack = new Stack<number>();\n  \n  // Push all numbers into the stack\n  numbers.forEach((num) => {\n    stack.push(num);\n  });\n  \n  // Calculate the sum of all elements in the stack\n  let sum = 0;\n  for (const num of stack) {\n    sum += num;\n  }\n  \n  // Output the result using stream.write\n  stream.write(sum.toString());\n}"
  },
  {
    "instruction": "Create a function that utilizes the `convertToArray` method of `List` to transform the list into an array, then uses the `copyToArray` method of `Vector` to merge this array with an existing vector. Ensure the combined collection is printed using the `toString` method of `Vector`.",
    "output": "import {uri, List, Vector} from '@kit.ArkTS';\n\nexport function mergeListWithVector(list: List<number>, vector: Vector<number>): void {\n  const arrayFromList: number[] = list.convertToArray();\n  vector.copyToArray(arrayFromList);\n  console.log(vector.toString());\n}"
  },
  {
    "instruction": "Create a function that uses the `get` and `length` properties of `Vector` to extract a subset of elements, then pass this subset to the `add` method of `HashSet` to ensure all elements are unique. Use the `dispatchEvent` method of `EventTarget` to trigger an event with the unique elements as part of the event data.",
    "output": "import {Vector, HashSet, EventTarget} from '@kit.ArkTS';\n\nexport function extractUniqueElementsAndDispatch(vector: Vector<number>, start: number, end: number, eventTarget: EventTarget, eventType: string): void {\n  const subset = new Vector<number>();\n  for (let i = start; i < end && i < vector.length; i++) {\n    const element = vector.get(i);\n    subset.add(element);\n  }\n\n  const hashSet = new HashSet<number>();\n  for (const element of subset) {\n    hashSet.add(element);\n  }\n\n  const uniqueElements = Array.from(hashSet.values());\n  const event = {\n    type: eventType,\n    data: uniqueElements\n  };\n  eventTarget.dispatchEvent(event);\n}"
  },
  {
    "instruction": "Write a function that uses the `getHash` method of `util` to compute the hash of a given string, then checks if the hash exists as a value in a `TreeMap` using the `hasValue` method. If the hash is found, use the `get` method of `TreeMap` to retrieve and return the corresponding key; otherwise, return the hash as a string.",
    "output": "import {util, TreeMap} from '@kit.ArkTS';\n\nexport function findKeyByHash(input: string, map: TreeMap<string, string>): string {\n  const hash = util.getHash(input);\n  if (map.hasValue(hash)) {\n    const keys = map.keys();\n    for (const key of keys) {\n      const value = map.get(key);\n      if (value === hash) {\n        return key;\n      }\n    }\n  }\n  return hash;\n}"
  },
  {
    "instruction": "Write a function that creates a DedicatedWorker and sets up an `onmessage` handler in the worker's global scope to process incoming messages. If an error occurs during message processing, use the `ErrorEvent` properties (`message`, `filename`, `lineno`, `colno`, and `error`) to log detailed error information and then call the `close` method of `DedicatedWorkerGlobalScope` to terminate the worker.",
    "output": "import {ErrorEvent, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createWorker(): void {\n  const worker = new Worker('worker.ts');\n  worker.onmessage = (event: MessageEvent) => {\n    try {\n      // Process the incoming message\n      console.log('Message received in worker:', event.data);\n    } catch (error) {\n      const errorEvent = new ErrorEvent('error', {\n        message: error.message,\n        filename: 'worker.ts',\n        lineno: error.lineNumber,\n        colno: error.columnNumber,\n        error: error\n      });\n      \n      console.error('Error in worker:', errorEvent.message);\n      console.error('Filename:', errorEvent.filename);\n      console.error('Line number:', errorEvent.lineno);\n      console.error('Column number:', errorEvent.colno);\n      console.error('Error object:', errorEvent.error);\n      \n      // Terminate the worker\n      worker.terminate();\n    }\n  };\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `Vector` to collect a sequence of numbers, then passes the resulting Vector to the `setAll` method of `TreeMap` to store the numbers as keys with their squares as values. Finally, use the `getHigherKey` method of `TreeMap` to find the smallest key greater than a given threshold.",
    "output": "import {Vector, TreeMap} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[], threshold: number): number | undefined {\n  const vector = new Vector<number>();\n  numbers.forEach(num => vector.add(num));\n\n  const treeMap = new TreeMap<number, number>();\n  treeMap.setAll(vector);\n\n  vector.forEach(key => {\n    treeMap.set(key, key * key);\n  });\n\n  return treeMap.getHigherKey(threshold);\n}"
  },
  {
    "instruction": "Implement a function that uses the `promisify` method of `util` to convert a callback-based function into a promise, then handles any errors using the `error` and `message` properties of `ErrorEvent`. The resulting promise should be processed in a worker thread (using the `worker` API) to perform additional asynchronous operations.",
    "output": "import {worker, ErrorEvent, util} from '@kit.ArkTS';\n\nexport function promisifyAndHandleErrors(callbackBasedFunc: (arg: string, callback: (err: ErrorEvent | null, result: string) => void) => void): Promise<string> {\n  const promisifiedFunc = util.promisify(callbackBasedFunc);\n  \n  return new Promise((resolve, reject) => {\n    const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n    \n    workerInstance.onmessage = (message: string) => {\n      resolve(message);\n      workerInstance.terminate();\n    };\n    \n    workerInstance.onerror = (error: ErrorEvent) => {\n      reject({ error: error.error, message: error.message });\n      workerInstance.terminate();\n    };\n    \n    promisifiedFunc('input').then((result: string) => {\n      workerInstance.postMessage(result);\n    }).catch((err: ErrorEvent) => {\n      reject({ error: err.error, message: err.message });\n      workerInstance.terminate();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to run a background task (defined by `CallbackFunction`) and then uses `WorkerEventTarget.addEventListener` to listen for a custom event dispatched by the background task. The event should carry the result of the background computation, and the listener should log this result.",
    "output": "import {WorkerEventTarget, taskpool} from '@kit.ArkTS';\n\nexport function runBackgroundTaskAndListen(callback: taskpool.CallbackFunction, eventName: string): void {\n  const workerEventTarget = new WorkerEventTarget();\n  \n  workerEventTarget.addEventListener(eventName, (event: CustomEvent) => {\n    console.log('Result from background task:', event.detail);\n  });\n  \n  taskpool.execute(callback).then((result) => {\n    workerEventTarget.dispatchEvent(new CustomEvent(eventName, { detail: result }));\n  });\n}"
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a URI string to a worker thread, and then uses the `addEventListener` method of `EventTarget` in the main thread to listen for and handle the response message from the worker thread.",
    "output": "import {uri, EventTarget, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendUriToWorker(worker: ThreadWorkerGlobalScope, uriString: string): void {\n  worker.postMessage(uriString);\n}\n\nexport function listenForWorkerResponse(eventTarget: EventTarget, callback: (event: MessageEvent) => void): void {\n  eventTarget.addEventListener('message', callback);\n}"
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then transfers these numbers to a `List` (from @kit.ArkTS) using its `add` method. Finally, use the `sort` method of `List` to arrange the numbers in ascending order.",
    "output": "import {List, HashMap, Stack} from '@kit.ArkTS';\n\nexport function transferAndSortNumbers(numbers: number[]): List<number> {\n  const stack = new Stack<number>();\n  const list = new List<number>();\n\n  // Push numbers into the stack\n  for (const num of numbers) {\n    stack.push(num);\n  }\n\n  // Transfer numbers from stack to list\n  while (!stack.isEmpty()) {\n    list.add(stack.pop());\n  }\n\n  // Sort the list in ascending order\n  list.sort((a, b) => a - b);\n\n  return list;\n}"
  },
  {
    "instruction": "Create a function that collects the system environment variables using `process.getEnvironmentVar`, then iterates over the collected variables using `LightWeightMap.forEach` to filter and store only those variables with values longer than 10 characters in a new `LightWeightMap` instance. Use `LightWeightMap.length` to return the count of filtered variables.",
    "output": "import {process, LightWeightMap} from '@kit.ArkTS';\n\nexport function filterEnvVars(): number {\n  const envVars = process.getEnvironmentVar();\n  const filteredVars = new LightWeightMap<string, string>();\n  \n  envVars.forEach((value: string, key: string) => {\n    if (value.length > 10) {\n      filteredVars.set(key, value);\n    }\n  });\n  \n  return filteredVars.length;\n}"
  },
  {
    "instruction": "Create a function that schedules a delayed task using `taskpool.executeDelayed` with a specified delay, and upon completion, uses `PostMessageOptions.transfer` to transfer ownership of a large data object to the main thread to avoid unnecessary copying.",
    "output": "import {taskpool, PostMessageOptions} from '@kit.ArkTS';\n\nexport function scheduleDelayedTaskWithTransfer(delay: number, largeData: ArrayBuffer, callback: (data: ArrayBuffer) => void): void {\n  const task = () => {\n    return largeData;\n  };\n\n  taskpool.executeDelayed(task, delay).then((result: ArrayBuffer) => {\n    const options: PostMessageOptions = {\n      transfer: [result]\n    };\n    callback(result);\n  });\n}"
  },
  {
    "instruction": "Write a function that listens for an error event using the `onerror` property of `GlobalScope` and logs the event's `type` and `timeStamp` properties from the `Event` object passed to the handler.",
    "output": "import {GlobalScope, Event} from '@kit.ArkTS';\n\nexport function setupErrorListener(): void {\n  if (typeof GlobalScope !== 'undefined') {\n    GlobalScope.onerror = (event: Event) => {\n      console.log(`Error event type: ${event.type}, timestamp: ${event.timeStamp}`);\n    };\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `removeByRange` method of `ArrayList` (from @kit.ArkTS) to remove a subset of elements from a list, then uses the `trimToCurrentLength` method to optimize the list's capacity, and finally passes the trimmed list to a stream processing function (from @kit.ArkTS) that calculates and returns the sum of the remaining elements.",
    "output": "import {ArrayList, stream} from '@kit.ArkTS';\n\nexport function processArrayList(list: ArrayList<number>, start: number, end: number): number {\n  list.removeByRange(start, end);\n  list.trimToCurrentLength();\n  \n  let sum = 0;\n  for (const item of list) {\n    sum += item;\n  }\n  \n  return sum;\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Deque` to iterate over a sequence of `Event` objects, extracts the `type` property of each `Event`, and then uses the `add` method of `LightWeightSet` to build a unique set of event types. Finally, use the `values` method of `LightWeightSet` to return an iterator of these unique event types.",
    "output": "import {LightWeightSet, Event, Deque} from '@kit.ArkTS';\n\nexport function getUniqueEventTypes(events: Deque<Event>): IterableIterator<string> {\n  const uniqueTypes = new LightWeightSet<string>();\n  events.forEach((event: Event) => {\n    uniqueTypes.add(event.type);\n  });\n  return uniqueTypes.values();\n}"
  },
  {
    "instruction": "Implement a function that concatenates multiple buffers using `buffer.concat`, then uses the resulting buffer to set the `data` property of a `MessageEvents` object. After processing the message, create an `Event` and print both its `timeStamp` and `type` properties to track when and what type of event occurred.",
    "output": "import {buffer, MessageEvents, Event} from '@kit.ArkTS';\n\nexport function concatenateAndProcessBuffers(buffers: buffer[]): void {\n  const concatenatedBuffer: buffer = buffer.concat(buffers);\n  const messageEvent: MessageEvents = new MessageEvents('message');\n  messageEvent.data = concatenatedBuffer;\n  \n  const event: Event = new Event('processed');\n  console.log(`Event timeStamp: ${event.timeStamp}`);\n  console.log(`Event type: ${event.type}`);\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `ArrayList<number>` to iterate over a list of numbers, and for each number, checks if it is even using a worker thread (via `WorkerGlobalScope.self`). The results (even or odd) should be stored in another `ArrayList<string>` using its `add` method.",
    "output": "import {WorkerGlobalScope, stream, ArrayList} from '@kit.ArkTS';\n\nexport function checkEvenNumbers(numbers: ArrayList<number>): ArrayList<string> {\n  const results: ArrayList<string> = new ArrayList();\n  \n  numbers.forEach((num: number) => {\n    const workerScope: WorkerGlobalScope = WorkerGlobalScope.self;\n    workerScope.onmessage = (event: MessageEvent<number>) => {\n      const isEven = event.data % 2 === 0;\n      results.add(isEven ? 'even' : 'odd');\n    };\n    workerScope.postMessage(num);\n  });\n  \n  return results;\n}"
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Vector` to iterate over its elements, applies a transformation using the `Transformer` type alias from `json` to each element, and then uses the `replaceAllElements` method of `Vector` to update the vector with the transformed values.",
    "output": "import {json, Vector} from '@kit.ArkTS';\n\nexport function transformVectorElements<T>(vector: Vector<T>, transformer: json.Transformer<T>): void {\n  const transformedElements: T[] = [];\n  vector.forEach((element: T) => {\n    const transformedElement = transformer(element);\n    transformedElements.push(transformedElement);\n  });\n  vector.replaceAllElements(transformedElements);\n}"
  },
  {
    "instruction": "Create a function that first uses `json.stringify` to convert an object into a JSON string, then dispatches the string as part of a custom event using `WorkerEventTarget.dispatchEvent`. The function should also set up an event listener using `WorkerEventTarget.addEventListener` to log the dispatched event data.",
    "output": "import {WorkerEventTarget, json} from '@kit.ArkTS';\n\nexport function handleCustomEvent(obj: object): void {\n  const jsonString = json.stringify(obj);\n  const event = { type: 'customEvent', data: jsonString };\n  const workerEventTarget = new WorkerEventTarget();\n  \n  workerEventTarget.addEventListener('customEvent', (eventData: { data: string }) => {\n    console.log(`Dispatched event data: ${eventData.data}`);\n  });\n  \n  workerEventTarget.dispatchEvent(event);\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of messages from a worker thread, then uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send the collected messages back to the main thread. The function must also handle errors by using the `onmessageerror` property of `DedicatedWorkerGlobalScope` to log any message processing failures.",
    "output": "import {DedicatedWorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function collectAndSendMessages(workerScope: DedicatedWorkerGlobalScope): void {\n  const messageList: LinkedList<string> = new LinkedList();\n\n  workerScope.onmessage = (event: MessageEvent<string>) => {\n    try {\n      messageList.add(event.data);\n    } catch (error) {\n      console.error(`Error adding message to list: ${error}`);\n    }\n  };\n\n  workerScope.onmessageerror = (event: MessageEvent) => {\n    console.error(`Message processing error: ${event}`);\n  };\n\n  // Example of sending collected messages back to main thread\n  // In a real scenario, you might want to trigger this at a specific time or condition\n  workerScope.postMessage(Array.from(messageList));\n}"
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a set of key-value pairs representing task priorities (keys) and task names (values). Then, use the `execute` method of `taskpool` to execute each task with the corresponding priority from the `PlainArray`, ensuring the priorities are correctly passed to the `Priority` enum of `taskpool`.",
    "output": "import {PlainArray, taskpool, MessageEvents} from '@kit.ArkTS';\n\nexport function executeTasksWithPriority(): void {\n  const taskArray: PlainArray<string> = new PlainArray<string>();\n  \n  // Add tasks with their priorities\n  taskArray.add(1, 'Task1');\n  taskArray.add(2, 'Task2');\n  taskArray.add(3, 'Task3');\n  \n  // Execute each task with corresponding priority\n  for (let i = 0; i < taskArray.length; i++) {\n    const priority = taskArray.getKeyAt(i);\n    const taskName = taskArray.getValueAt(i);\n    \n    const task = () => {\n      console.log(`Executing ${taskName} with priority ${priority}`);\n    };\n    \n    // Map the priority number to taskpool.Priority enum\n    let taskPriority: taskpool.Priority;\n    switch (priority) {\n      case 1:\n        taskPriority = taskpool.Priority.HIGH;\n        break;\n      case 2:\n        taskPriority = taskpool.Priority.MEDIUM;\n        break;\n      case 3:\n        taskPriority = taskpool.Priority.LOW;\n        break;\n      default:\n        taskPriority = taskpool.Priority.MEDIUM;\n    }\n    \n    taskpool.execute(task, taskPriority);\n  }\n}"
  },
  {
    "instruction": "Write a function that uses the `promisify` method of `util` to convert a callback-based function (e.g., a simulated network request) into a promise-based one, then uses the `callbackWrapper` method of `util` to handle the promise result, and finally uses the `format` method of `util` to format the result or error message for display.",
    "output": "import {util, url} from '@kit.ArkTS';\n\nexport function simulateNetworkRequest(callback: (error: Error | null, data: string) => void): void {\n  setTimeout(() => {\n    const random = Math.random();\n    if (random > 0.5) {\n      callback(null, 'Network request succeeded');\n    } else {\n      callback(new Error('Network request failed'), '');\n    }\n  }, 1000);\n}\n\nexport async function promisifyAndHandleRequest(): Promise<string> {\n  const promisifiedRequest = util.promisify(simulateNetworkRequest);\n  \n  try {\n    const result = await util.callbackWrapper(promisifiedRequest)();\n    return util.format('Success: %s', result);\n  } catch (error) {\n    return util.format('Error: %s', error.message);\n  }\n}"
  },
  {
    "instruction": "Write a function that uses `ThreadWorkerGlobalScope.postMessage` to send a message to a worker thread, and then uses `WorkerEventTarget.addEventListener` to listen for a response event from the worker thread. The function should process the response data and log it.",
    "output": "import {WorkerEventTarget, ThreadWorkerGlobalScope, process} from '@kit.ArkTS';\n\nexport function communicateWithWorker(worker: ThreadWorkerGlobalScope, target: WorkerEventTarget): void {\n  const message = { data: 'Hello, Worker!' };\n  worker.postMessage(message);\n\n  target.addEventListener('message', (event: MessageEvent) => {\n    const response = event.data;\n    console.log('Received response from worker:', response);\n  });\n}"
  },
  {
    "instruction": "Write a function that creates a Worker using the `WorkerOptions` API with a specified `name` property, then constructs a URL using the `url` API to pass as the script path to the Worker. The function should return the Worker instance after both configurations are applied.",
    "output": "import {WorkerOptions, url} from '@kit.ArkTS';\n\nexport function createWorker(scriptPath: string, workerName: string): Worker {\n  const workerOptions: WorkerOptions = {\n    name: workerName\n  };\n  const scriptUrl = new url.URL(scriptPath);\n  return new Worker(scriptUrl.toString(), workerOptions);\n}"
  },
  {
    "instruction": "Create a function that first checks if the current process is a 64-bit system using the `is64Bit` method of `process`, then uses this boolean result to determine whether to call the `abort` method of `process` (if false) or the `exit` method (if true). Before exiting, log the `self` property of `WorkerGlobalScope` to identify the worker context.",
    "output": "import {WorkerGlobalScope, process} from '@kit.ArkTS';\n\nexport function checkAndExit(): void {\n  const is64Bit: boolean = process.is64Bit();\n  console.log(WorkerGlobalScope.self);\n  if (!is64Bit) {\n    process.abort();\n  } else {\n    process.exit();\n  }\n}"
  },
  {
    "instruction": "Implement a function that calculates the uptime of a process using `process.uptime`, retrieves the CPU time used by the process using `process.getPastCpuTime`, and then determines the process's efficiency by comparing the CPU time to the uptime, printing the result using `console.log`.",
    "output": "import {worker, process} from '@kit.ArkTS';\n\nexport function calculateProcessEfficiency(): void {\n  const uptime: number = process.uptime();\n  const cpuTime: number = process.getPastCpuTime();\n  const efficiency: number = (cpuTime / uptime) * 100;\n  console.log(`Process Efficiency: ${efficiency.toFixed(2)}%`);\n}"
  },
  {
    "instruction": "Write a function that uses the `from` method of `buffer` to create a buffer from a string, then uses the `set` method of `HashMap` to store the buffer as a value with a specified key. Finally, use the `get` method of `HashMap` to retrieve the buffer and the `byteLength` method of `buffer` to return the length of the stored buffer.",
    "output": "import {HashMap, buffer, LightWeightMap} from '@kit.ArkTS';\n\nexport function storeAndGetBufferLength(key: string, value: string): number {\n  const hashMap = new HashMap<string, buffer.Buffer>();\n  const buf = buffer.from(value);\n  hashMap.set(key, buf);\n  const retrievedBuf = hashMap.get(key);\n  return retrievedBuf.byteLength;\n}"
  },
  {
    "instruction": "Write a function that uses the `convertToArray` method of `ArrayList` to transform a list of numbers into an array, then uses the `stringify` method of `json` to serialize the array into a JSON string, and finally uses the `transfer` property of `PostMessageOptions` to send the serialized data to another thread.",
    "output": "import {json, ArrayList, PostMessageOptions} from '@kit.ArkTS';\n\nexport function sendDataToThread(numbers: ArrayList<number>): void {\n  const array: number[] = numbers.convertToArray();\n  const jsonString: string = json.stringify(array);\n  const options: PostMessageOptions = {\n    transfer: []\n  };\n  postMessage(jsonString, options);\n}"
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `Stack` (from @kit.ArkTS) to traverse all elements, passes each element to a `worker` thread (from @kit.ArkTS) for transformation (e.g., converting strings to uppercase), and then uses the `push` method of a new `Stack` to store the transformed results. The new stack should be returned.",
    "output": "import {worker, Stack} from '@kit.ArkTS';\n\nexport function transformStackElements(inputStack: Stack<string>): Stack<string> {\n  const outputStack = new Stack<string>();\n  \n  inputStack.forEach((element: string) => {\n    const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n    \n    workerInstance.onmessage = (transformedElement: string) => {\n      outputStack.push(transformedElement);\n      workerInstance.terminate();\n    };\n    \n    workerInstance.postMessage(element);\n  });\n  \n  return outputStack;\n}"
  }
]