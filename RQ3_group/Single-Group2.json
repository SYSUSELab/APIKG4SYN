[
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { checkTreeSetContainsAll } from '../main/ets/functions/ArkTS_TreeSet_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {TreeSet} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('checkTreeSetContainsAll_function_test', () => {\n    it('should_return_true_when_all_elements_present', 0, () => {\n      const treeSet = new TreeSet<number>();\n      treeSet.add(1);\n      treeSet.add(2);\n      treeSet.add(3);\n      expect(checkTreeSetContainsAll(treeSet, [1, 2])).assertTrue();\n    });\n\n    it('should_return_false_when_some_elements_missing', 0, () => {\n      const treeSet = new TreeSet<number>();\n      treeSet.add(1);\n      treeSet.add(2);\n      expect(checkTreeSetContainsAll(treeSet, [1, 3])).assertFalse();\n    });\n\n    it('should_return_false_when_array_longer_than_treeSet', 0, () => {\n      const treeSet = new TreeSet<number>();\n      treeSet.add(1);\n      expect(checkTreeSetContainsAll(treeSet, [1, 2])).assertFalse();\n    });\n\n    it('should_return_true_when_array_empty', 0, () => {\n      const treeSet = new TreeSet<number>();\n      treeSet.add(1);\n      expect(checkTreeSetContainsAll(treeSet, [])).assertTrue();\n    });\n\n    it('should_return_true_when_treeSet_and_array_empty', 0, () => {\n      const treeSet = new TreeSet<number>();\n      expect(checkTreeSetContainsAll(treeSet, [])).assertTrue();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that checks if an event is of a specific type and occurred after a given timestamp **using the `type` and `timeStamp` properties**.",
    "output": "import {Event} from '@kit.ArkTS';\n\nexport function logEventDetails(event: Event): void {\n  console.log(`Event Type: ${event.type}, Timestamp: ${event.timeStamp}`);\n}"
  },
  {
    "instruction": "Write a function that takes a Base64 encoded string, decodes it to a Uint8Array using the `decodeSync` method, then encodes it back to a Base64 string using the `encodeToStringSync` method and returns the result.",
    "output": "import {util} from '@kit.ArkTS';\ntype Base64Helper = util.Base64Helper;\n\nexport function decodeAndEncodeBase64(base64Str: string): string {\n  const decodedArray: Uint8Array = util.Base64.decodeSync(base64Str);\n  const encodedStr: string = util.Base64.encodeToStringSync(decodedArray, util.Base64.Type.NORMAL);\n  return encodedStr;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { appendAndGetAll } from '../main/ets/functions/ArkTS_URLParams_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {url} from '@kit.ArkTS';\n\ntype URLParams = url.URLParams;\n\nexport default function localUnitTest() { \n  describe('appendAndGetAll_function_test', () => {\n    it('should_return_added_value', 0, () => {\n      const params = new url.URLParams();\n      const result = appendAndGetAll(params, 'key1', 'value1');\n      expect(result).assertEqual(['value1']);\n    });\n\n    it('should_return_multiple_values_for_same_key', 0, () => {\n      const params = new url.URLParams();\n      appendAndGetAll(params, 'key1', 'value1');\n      const result = appendAndGetAll(params, 'key1', 'value2');\n      expect(result).assertEqual(['value1', 'value2']);\n    });\n\n    it('should_return_empty_array_for_non_existent_key', 0, () => {\n      const params = new url.URLParams();\n      const result = params.getAll('nonexistent');\n      expect(result).assertEqual([]);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createAndLogEvent } from '../main/ets/functions/ArkTS_Event_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {Event} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('createAndLogEvent_function_test', () => {\n    it('should_create_event_with_correct_type_and_timestamp', 0, () => {\n      const eventType = 'click';\n      const timestamp = 123456789;\n      const event = new Event(eventType);\n      createAndLogEvent(eventType, timestamp);\n      expect(event.type).assertEqual(eventType);\n    });\n\n    it('should_create_event_with_correct_type', 0, () => {\n      const eventType = 'scroll';\n      const event = new Event(eventType);\n      createAndLogEvent(eventType, 0);\n      expect(event.type).assertEqual(eventType);\n    });\n\n    it('should_not_allow_timestamp_modification', 0, () => {\n      const timestamp = 987654321;\n      const event = new Event('test');\n      let modified = false;\n      try {\n        createAndLogEvent('test', 123);\n        modified = true;\n      } catch (e) {\n        // Expected to throw error\n      }\n      expect(modified).assertFalse();\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { decodeBuffer } from '../main/ets/functions/ArkTS_StringDecoder_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype StringDecoder = util.StringDecoder;\n\nexport default function localUnitTest() { \n  describe('decodeBuffer_function_test', () => {\n    it('should_decode_utf8_buffer', 0, () => {\n      const decoder = new util.StringDecoder('utf8');\n      const buffer = new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f]); // 'hello' in UTF-8\n      const result = decodeBuffer(decoder, buffer);\n      expect(result).assertEqual('hello');\n    });\n\n    it('should_decode_empty_buffer', 0, () => {\n      const decoder = new util.StringDecoder('utf8');\n      const buffer = new Uint8Array([]);\n      const result = decodeBuffer(decoder, buffer);\n      expect(result).assertEqual('');\n    });\n\n    it('should_decode_partial_utf8_sequence', 0, () => {\n      const decoder = new util.StringDecoder('utf8');\n      // Partial UTF-8 sequence (first byte of a 2-byte character)\n      const buffer = new Uint8Array([0xc3]);\n      const result = decodeBuffer(decoder, buffer);\n      // Should return empty string since it's a partial sequence\n      expect(result).assertEqual('');\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { normalizeAndCheckAbsolute } from '../main/ets/functions/ArkTS_URI_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {uri} from '@kit.ArkTS';\ntype URI = uri.URI;\n\nexport default function localUnitTest() { \n  describe('normalizeAndCheckAbsolute_function_test', () => {\n    it('should_return_true_for_absolute_uri', 0, () => {\n      const mockUri: URI = {\n        normalize: function(): URI {\n          return {\n            checkIsAbsolute: function(): boolean { return true; },\n          } as URI;\n        }\n      };\n      expect(normalizeAndCheckAbsolute(mockUri)).assertTrue();\n    });\n\n    it('should_return_false_for_relative_uri', 0, () => {\n      const mockUri: URI = {\n        normalize: function(): URI {\n          return {\n            checkIsAbsolute: function(): boolean { return false; },\n          } as URI;\n        }\n      };\n      expect(normalizeAndCheckAbsolute(mockUri)).assertFalse();\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { isValidUri } from '../main/ets/functions/ArkTS_uri_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {uri} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('isValidUri_function_test', () => {\n    it('should_return_true_for_valid_http_uri', 0, () => {\n        expect(isValidUri('http://example.com')).assertTrue();\n    });\n    it('should_return_true_for_valid_https_uri', 0, () => {\n        expect(isValidUri('https://example.com')).assertTrue();\n    });\n    it('should_return_true_for_valid_uri_with_path', 0, () => {\n        expect(isValidUri('http://example.com/path/to/resource')).assertTrue();\n    });\n    it('should_return_true_for_valid_uri_with_query', 0, () => {\n        expect(isValidUri('http://example.com?query=param')).assertTrue();\n    });\n    it('should_return_true_for_valid_uri_with_fragment', 0, () => {\n        expect(isValidUri('http://example.com#fragment')).assertTrue();\n    });\n    it('should_return_false_for_invalid_uri_missing_scheme', 0, () => {\n        expect(isValidUri('example.com')).assertFalse();\n    });\n    it('should_return_false_for_invalid_uri_malformed', 0, () => {\n        expect(isValidUri('http://')).assertFalse();\n    });\n    it('should_return_false_for_empty_string', 0, () => {\n        expect(isValidUri('')).assertFalse();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `Blob` object and returns its size in kilobytes (rounded to 2 decimal places) **using the `size` property and a simple calculation**.",
    "output": "import {buffer} from '@kit.ArkTS';\ntype Blob = buffer.Blob;\n\nexport function getBlobSizeInKB(blob: Blob): number {\n  const sizeInBytes = blob.size;\n  const sizeInKB = sizeInBytes / 1024;\n  return parseFloat(sizeInKB.toFixed(2));\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { initializeAndReadStream } from '../main/ets/functions/ArkTS_Readable_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {stream} from '@kit.ArkTS';\ntype Readable = stream.Readable;\n\nexport default function localUnitTest() { \n  describe('initializeAndReadStream_function_test', () => {\n    it('should_call_callback_after_initialization_and_read', 0, () => {\n      let callbackCalled = false;\n      const mockStream: Readable = {\n        doInitialize: (callback: () => void) => {\n          callback();\n        },\n        doRead: (size: number) => {},\n        isPaused: () => false\n      } as Readable;\n      \n      initializeAndReadStream(mockStream, 10, () => {\n        callbackCalled = true;\n      });\n      \n      expect(callbackCalled).assertTrue();\n    });\n    \n    it('should_check_if_stream_is_paused', 0, () => {\n      let isPausedValue = false;\n      const mockStream: Readable = {\n        doInitialize: (callback: () => void) => {\n          callback();\n        },\n        doRead: (size: number) => {},\n        isPaused: () => isPausedValue\n      } as Readable;\n      \n      initializeAndReadStream(mockStream, 10, () => {\n        isPausedValue = mockStream.isPaused();\n      });\n      \n      expect(isPausedValue).assertFalse();\n    });\n    \n    it('should_call_doRead_with_correct_size', 0, () => {\n      let readSize = 0;\n      const mockStream: Readable = {\n        doInitialize: (callback: () => void) => {\n          callback();\n        },\n        doRead: (size: number) => {\n          readSize = size;\n        },\n        isPaused: () => false\n      } as Readable;\n      \n      initializeAndReadStream(mockStream, 15, () => {});\n      \n      expect(readSize).assertEqual(15);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { measureTaskExecutionTime } from '../main/ets/functions/ArkTS_LongTask_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\ntype LongTask = taskpool.LongTask;\n\nexport default function localUnitTest() { \n  describe('measureTaskExecutionTime_function_test', () => {\n    it('should_execute_long_task_and_log_time', 0, () => {\n      // The function doesn't return anything, so we're mainly testing that it executes without errors\n      measureTaskExecutionTime();\n      expect(true).assertTrue();\n    }); \n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `Blob` object and checks if its type is 'text/plain' **using the `type` property and a conditional check**.",
    "output": "import {buffer} from '@kit.ArkTS';\ntype Blob = buffer.Blob;\n\nexport function isTextPlain(blob: Blob): boolean {\n  return blob.type === 'text/plain';\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { replaceValueInVector } from '../main/ets/functions/ArkTS_Vector_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {Vector} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('replaceValueInVector_function_test', () => {\n    it('should_replace_all_occurrences_of_oldValue', 0, () => {\n      const vector = new Vector<number>();\n      vector.add(1);\n      vector.add(2);\n      vector.add(1);\n      vector.add(3);\n      replaceValueInVector(vector, 1, 10);\n      expect(vector.getIndexOf(10)).assertEqual(0);\n      expect(vector.getIndexOf(10, 1)).assertEqual(2);\n      expect(vector.getIndexOf(1)).assertEqual(-1);\n    });\n\n    it('should_not_modify_vector_if_oldValue_not_found', 0, () => {\n      const vector = new Vector<string>();\n      vector.add('a');\n      vector.add('b');\n      vector.add('c');\n      replaceValueInVector(vector, 'd', 'x');\n      expect(vector.getIndexOf('a')).assertEqual(0);\n      expect(vector.getIndexOf('b')).assertEqual(1);\n      expect(vector.getIndexOf('c')).assertEqual(2);\n      expect(vector.getIndexOf('x')).assertEqual(-1);\n    });\n\n    it('should_handle_empty_vector', 0, () => {\n      const vector = new Vector<boolean>();\n      replaceValueInVector(vector, true, false);\n      expect(vector.isEmpty()).assertTrue();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `ReadableOptions` object and a target encoding string, then checks if the object's `encoding` property matches the target. If it does, return 'Match'; otherwise, set the `encoding` to the target and return 'Updated'.",
    "output": "import {stream} from '@kit.ArkTS';\ntype ReadableOptions = stream.ReadableOptions;\n\nexport function checkAndUpdateEncoding(options: ReadableOptions, targetEncoding: string): string {\n  if (options.encoding === targetEncoding) {\n    return 'Match';\n  } else {\n    options.encoding = targetEncoding;\n    return 'Updated';\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { sortScopeComparableArray } from '../main/ets/functions/ArkTS_ScopeComparable_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\ntype ScopeComparable = util.ScopeComparable;\n\nexport default function localUnitTest() { \n  describe('sortScopeComparableArray_test', () => {\n    it('should_sort_empty_array', 0, () => {\n      const arr: ScopeComparable[] = [];\n      expect(sortScopeComparableArray(arr)).assertEqual([]);\n    });\n\n    it('should_sort_single_element_array', 0, () => {\n      const mockComparable: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => false\n      };\n      const arr: ScopeComparable[] = [mockComparable];\n      expect(sortScopeComparableArray(arr)).assertEqual(arr);\n    });\n\n    it('should_sort_already_sorted_array', 0, () => {\n      const mockComparable1: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => false\n      };\n      const mockComparable2: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      const arr: ScopeComparable[] = [mockComparable1, mockComparable2];\n      expect(sortScopeComparableArray(arr)).assertEqual(arr);\n    });\n\n    it('should_sort_unsorted_array', 0, () => {\n      const mockComparable1: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      const mockComparable2: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => false\n      };\n      const arr: ScopeComparable[] = [mockComparable1, mockComparable2];\n      const expected: ScopeComparable[] = [mockComparable2, mockComparable1];\n      expect(sortScopeComparableArray(arr)).assertEqual(expected);\n    });\n\n    it('should_sort_multiple_elements_array', 0, () => {\n      const mockComparable1: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      const mockComparable2: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => false\n      };\n      const mockComparable3: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      const arr: ScopeComparable[] = [mockComparable1, mockComparable3, mockComparable2];\n      const expected: ScopeComparable[] = [mockComparable2, mockComparable1, mockComparable3];\n      expect(sortScopeComparableArray(arr)).assertEqual(expected);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes an XML document and logs all elements of a specific `EventType` using the `getElementsByTagName` method and the `EventType` enum.",
    "output": "import {xml} from '@kit.ArkTS';\n\nexport enum EventType {\n  TYPE1 = 'TYPE1',\n  TYPE2 = 'TYPE2',\n  TYPE3 = 'TYPE3'\n}\n\nexport function logElementsByEventType(xmlDoc: xml.XmlDocument, eventType: EventType): void {\n  const elements: xml.XmlElement[] = xmlDoc.getElementsByTagName(eventType.toString());\n  for (let i = 0; i < elements.length; i++) {\n    console.log(elements[i].toString());\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createAndCompareTaskGroups } from '../main/ets/functions/ArkTS_TaskGroup_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\ntype TaskGroup = taskpool.TaskGroup;\n\nexport default function localUnitTest() { \n  describe('createAndCompareTaskGroups_test', () => {\n    it('should_return_group_with_longer_name', 0, () => {\n      const result: TaskGroup = createAndCompareTaskGroups();\n      expect(result.name).assertEqual('GroupTwoLongerName');\n    });\n    \n    it('should_have_added_task_to_group1', 0, () => {\n      const group1: TaskGroup = new taskpool.TaskGroup('GroupOne');\n      const task1 = new taskpool.Task(() => {});\n      group1.addTask(task1);\n      expect(group1.name).assertEqual('GroupOne');\n    });\n    \n    it('should_have_added_task_to_group2', 0, () => {\n      const group2: TaskGroup = new taskpool.TaskGroup('GroupTwoLongerName');\n      const task2 = new taskpool.Task(() => {});\n      group2.addTask(task2);\n      expect(group2.name).assertEqual('GroupTwoLongerName');\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that creates a DedicatedWorker and sets up a message handler to receive data, then posts a response back to the main thread and closes the worker. Use the `onmessage` property, `postMessage` method, and `close` method.",
    "output": "import {DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\ninterface WorkerMessageEvent {\n  data: string;\n}\n\nexport function setupWorker(): void {\n  const worker: DedicatedWorkerGlobalScope = globalThis.worker as DedicatedWorkerGlobalScope;\n  \n  worker.onmessage = (event: WorkerMessageEvent): void => {\n    const receivedData: string = event.data;\n    worker.postMessage({ response: `Processed: ${receivedData}` });\n    worker.close();\n  };\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { listenAndLogMessageEvent } from '../main/ets/functions/ArkTS_MessageEvent_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport { MessageEvent, EventTarget } from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('listenAndLogMessageEvent_test', () => {\n    it('should_log_event_data_and_remove_listener', 0, () => {\n      const eventTarget = new EventTarget();\n      const eventName = 'testEvent';\n      const testData = 'testData';\n      \n      // Mock console.log to verify it was called with the correct data\n      const originalConsoleLog = console.log;\n      let loggedData: any = null;\n      console.log = (data: any) => {\n        loggedData = data;\n      };\n      \n      // Create a mock event\n      const event = new MessageEvent(eventName, { data: testData });\n      \n      // Add the listener\n      listenAndLogMessageEvent<string>(eventTarget, eventName);\n      \n      // Dispatch the event\n      eventTarget.dispatchEvent(event);\n      \n      // Verify the data was logged\n      expect(loggedData).assertEqual(testData);\n      \n      // Verify the listener was removed by trying to dispatch again\n      loggedData = null;\n      eventTarget.dispatchEvent(event);\n      expect(loggedData).assertEqual(null);\n      \n      // Restore console.log\n      console.log = originalConsoleLog;\n    }); \n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { addAndGetIndex } from '../main/ets/functions/ArkTS_LightWeightSet_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {LightWeightSet} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('addAndGetIndex_function_test', () => {\n    it('should_return_index_of_added_value', 0, () => {\n        const set = new LightWeightSet<number>();\n        const value = 42;\n        const index = addAndGetIndex(set, value);\n        expect(index).assertEqual(0);\n    });\n    \n    it('should_return_existing_index_for_duplicate_value', 0, () => {\n        const set = new LightWeightSet<string>();\n        const value = 'test';\n        set.add(value);\n        const index = addAndGetIndex(set, value);\n        expect(index).assertEqual(0);\n    });\n    \n    it('should_return_correct_index_for_multiple_values', 0, () => {\n        const set = new LightWeightSet<boolean>();\n        set.add(true);\n        set.add(false);\n        const index = addAndGetIndex(set, false);\n        expect(index).assertEqual(1);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { checkAndAdd } from '../main/ets/functions/ArkTS_LruBuffer_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype LruBuffer = util.LruBuffer;\n\nexport default function localUnitTest() { \n  describe('checkAndAdd_function_test', () => {\n    it('should_add_key_and_return_length_when_key_not_present', 0, () => {\n      const buffer: LruBuffer<string, number> = new util.LruBuffer(5);\n      const initialLength = buffer.length;\n      const result = checkAndAdd(buffer, 'key1', 100);\n      expect(result).assertEqual(initialLength + 1);\n    });\n\n    it('should_not_add_key_and_return_same_length_when_key_present', 0, () => {\n      const buffer: LruBuffer<string, number> = new util.LruBuffer(5);\n      buffer.put('key1', 100);\n      const initialLength = buffer.length;\n      const result = checkAndAdd(buffer, 'key1', 200);\n      expect(result).assertEqual(initialLength);\n    });\n\n    it('should_handle_empty_buffer_correctly', 0, () => {\n      const buffer: LruBuffer<string, number> = new util.LruBuffer(5);\n      const initialLength = buffer.length;\n      const result = checkAndAdd(buffer, 'key1', 100);\n      expect(result).assertEqual(initialLength + 1);\n    });\n\n    it('should_handle_full_buffer_correctly', 0, () => {\n      const buffer: LruBuffer<string, number> = new util.LruBuffer(2);\n      buffer.put('key1', 100);\n      buffer.put('key2', 200);\n      const initialLength = buffer.length;\n      const result = checkAndAdd(buffer, 'key3', 300);\n      expect(result).assertEqual(initialLength);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that creates an uninitialized buffer of a given size using the `allocUninitialized` method, encodes a provided string into it using a specified encoding (e.g., 'utf8') with the `from` method, and verifies if the encoding is valid using the `isEncoding` method.",
    "output": "import {buffer} from '@kit.ArkTS';\n\nexport function compareAndConcat(buf1: buffer.Buffer | Uint8Array, buf2: buffer.Buffer | Uint8Array): buffer.Buffer {\n  const comparisonResult = buffer.compare(buf1, buf2);\n  if (comparisonResult !== 0) {\n    // Convert both to Buffer if they aren't already\n    const b1 = buf1 instanceof buffer.Buffer ? buf1 : buffer.from(buf1);\n    const b2 = buf2 instanceof buffer.Buffer ? buf2 : buffer.from(buf2);\n    return buffer.concat([b1, b2]);\n  }\n  return buffer.from([]);\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { checkAndTerminateProcess } from '../main/ets/functions/ArkTS_ProcessManager_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {process} from '@kit.ArkTS';\ntype ProcessManager = process.ProcessManager;\n\nclass MockProcessManager implements ProcessManager {\n  isAppUid(uid: number): boolean {\n    return false;\n  }\n  kill(signal: number, pid: number): boolean {\n    return false;\n  }\n}\n\nexport default function localUnitTest() { \n  describe('checkAndTerminateProcess_function_test', () => {\n    it('should_return_true_when_uid_is_app_and_kill_succeeds', 0, () => {\n      const mockProcessManager = new MockProcessManager();\n      mockProcessManager.isAppUid = (uid: number) => true;\n      mockProcessManager.kill = (signal: number, pid: number) => true;\n      process.ProcessManager = (() => mockProcessManager) as unknown as { new(): ProcessManager };\n      expect(checkAndTerminateProcess(1000, 1234, 9)).assertEqual(true);\n    });\n\n    it('should_return_false_when_uid_is_not_app', 0, () => {\n      const mockProcessManager = new MockProcessManager();\n      mockProcessManager.isAppUid = (uid: number) => false;\n      mockProcessManager.kill = (signal: number, pid: number) => true;\n      process.ProcessManager = (() => mockProcessManager) as unknown as { new(): ProcessManager };\n      expect(checkAndTerminateProcess(2000, 1234, 9)).assertEqual(false);\n    });\n\n    it('should_return_false_when_kill_fails', 0, () => {\n      const mockProcessManager = new MockProcessManager();\n      mockProcessManager.isAppUid = (uid: number) => true;\n      mockProcessManager.kill = (signal: number, pid: number) => false;\n      process.ProcessManager = (() => mockProcessManager) as unknown as { new(): ProcessManager };\n      expect(checkAndTerminateProcess(1000, 1234, 9)).assertEqual(false);\n    });\n\n    it('should_return_false_when_error_occurs', 0, () => {\n      const mockProcessManager = new MockProcessManager();\n      mockProcessManager.isAppUid = (uid: number) => { throw new Error('Test error'); };\n      mockProcessManager.kill = (signal: number, pid: number) => true;\n      process.ProcessManager = (() => mockProcessManager) as unknown as { new(): ProcessManager };\n      expect(checkAndTerminateProcess(1000, 1234, 9)).assertEqual(false);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that parses an XML string with namespace support disabled (`ignoreNameSpace`) and logs the attribute values using a custom callback function (`attributeValueCallbackFunction`).",
    "output": "import {JSON} from '@kit.ArkTS';\ntype ParseOptions = JSON.ParseOptions;\n\nexport function parseXmlWithCallback(xmlString: string, callback: (value: string) => void): void {\n  const options: ParseOptions = {\n    attributeValueCallbackFunction: callback\n  };\n  JSON.parse(xmlString, options);\n}"
  },
  {
    "instruction": "Write a function that initializes an `LruBuffer` with a given capacity, inserts a list of key-value pairs using the `put` method, and then removes all entries with keys present in a given removal list using the `remove` method. Finally, return the remaining buffer size using the `length` property.",
    "output": "import {util} from '@kit.ArkTS';\ntype LruBuffer = util.LruBuffer;\n\nexport function processLruBuffer<K, V>(capacity: number, entries: Array<[K, V]>, keysToRemove: K[]): number {\n  const lruBuffer: LruBuffer<K, V> = new util.LruBuffer(capacity);\n  \n  for (const [key, value] of entries) {\n    lruBuffer.put(key, value);\n  }\n  \n  for (const key of keysToRemove) {\n    lruBuffer.remove(key);\n  }\n  \n  return lruBuffer.length;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { logErrorDetails } from '../main/ets/functions/ArkTS_ErrorEvent_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {ErrorEvent} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('logErrorDetails_function_test', () => {\n    it('should_log_correct_error_details', 0, () => {\n      const mockEvent = {\n        message: 'Test error message',\n        filename: 'testFile.ets',\n        lineno: 42\n      } as ErrorEvent;\n      \n      expect(logErrorDetails(mockEvent)).assertUndefined();\n    });\n    \n    it('should_handle_empty_message', 0, () => {\n      const mockEvent = {\n        message: '',\n        filename: 'emptyMessage.ets',\n        lineno: 0\n      } as ErrorEvent;\n      expect(logErrorDetails(mockEvent)).assertUndefined();\n    });\n    \n    it('should_handle_missing_filename', 0, () => {\n      const mockEvent = {\n        message: 'Missing filename test',\n        filename: '',\n        lineno: 100\n      } as ErrorEvent;\n      expect(logErrorDetails(mockEvent)).assertUndefined();\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { readStreamToString } from '../main/ets/functions/ArkTS_stream_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {stream} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('readStreamToString_function_test', () => {\n    it('should_concatenate_chunks_to_string', 0, async () => {\n      const mockStream = new stream.Readable();\n      mockStream.push('chunk1');\n      mockStream.push('chunk2');\n      mockStream.push(null); // Signal end of stream\n      const result = await readStreamToString(mockStream);\n      expect(result).assertEqual('chunk1chunk2');\n    });\n\n    it('should_handle_empty_stream', 0, async () => {\n      const mockStream = new stream.Readable();\n      mockStream.push(null); // Signal end of stream\n      const result = await readStreamToString(mockStream);\n      expect(result).assertEqual('');\n    });\n\n    it('should_reject_on_stream_error', 0, async () => {\n      const mockStream = new stream.Readable();\n      const errorMessage = 'Stream error';\n      let caughtError: Error | null = null;\n      try {\n        // Create a custom error event\n        const error = new Error(errorMessage);\n        // Push data first to ensure stream is active\n        mockStream.push('data');\n        // Push error by destroying stream with error\n        mockStream.destroy(error);\n        await readStreamToString(mockStream);\n      } catch (err) {\n        caughtError = err as Error;\n      }\n      expect(caughtError?.message).assertEqual(errorMessage);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { setupWorker } from '../main/ets/functions/ArkTS_WorkerGlobalScope_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {WorkerGlobalScope} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('setupWorker_function_test', () => {\n    it('should_log_worker_name', 0, () => {\n      const mockWorkerScope: WorkerGlobalScope = {\n        name: 'testWorker',\n        onerror: null\n      };\n      \n      // Spy on console.log to verify it's called with the correct message\n      const logSpy = jest.spyOn(console, 'log');\n      setupWorker(mockWorkerScope);\n      expect(logSpy).toHaveBeenCalledWith('Worker name: testWorker');\n      logSpy.mockRestore();\n    });\n\n    it('should_set_error_handler', 0, () => {\n      const mockWorkerScope: WorkerGlobalScope = {\n        name: 'testWorker',\n        onerror: null\n      };\n      \n      setupWorker(mockWorkerScope);\n      expect(mockWorkerScope.onerror).toBeDefined();\n      \n      // Verify the error handler logs the error message\n      const errorSpy = jest.spyOn(console, 'error');\n      const testError = new ErrorEvent('test', { message: 'Test error' });\n      mockWorkerScope.onerror(testError);\n      expect(errorSpy).toHaveBeenCalledWith('Worker error: Test error');\n      errorSpy.mockRestore();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that processes a stream of data with `ReadableOptions`, first setting the encoding to 'ascii' and then converting the data to uppercase **using the `encoding` property and a data transformation method**.",
    "output": "import {stream} from '@kit.ArkTS';\ntype ReadableOptions = stream.ReadableOptions;\n\nexport function readFileWithEncoding(filePath: string, encoding: string): void {\n  const options: ReadableOptions = {\n    encoding: encoding\n  };\n  \n  const readableStream = stream.createReadStream(filePath, options);\n  \n  readableStream.on('data', (data: string) => {\n    console.log(data);\n  });\n  \n  readableStream.on('error', (error: Error) => {\n    console.error(`Error reading file: ${error.message}`);\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { formatAndLogError } from '../main/ets/functions/ArkTS_util_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('formatAndLogError_function_test', () => {\n    it('should_log_correct_error_string', 0, () => {\n      // Mock the util methods to verify they are called correctly\n      let loggedMessage = '';\n      const originalErrnoToString = util.errnoToString;\n      const originalPrintf = util.printf;\n      \n      // Setup mocks\n      util.errnoToString = (errno: number): string => {\n        return `MockErrorString_${errno}`;\n      };\n      util.printf = (format: string, args: Array<string>): void => {\n        loggedMessage = format.replace('%s', args[0]);\n      };\n      \n      // Test with a specific errno\n      const testErrno = 2;\n      formatAndLogError(testErrno);\n      \n      // Verify the logged message matches expected format\n      expect(loggedMessage).assertEqual(`Error: MockErrorString_${testErrno}`);\n      \n      // Restore original implementations\n      util.errnoToString = originalErrnoToString;\n      util.printf = originalPrintf;\n    });\n    \n    it('should_handle_zero_errno', 0, () => {\n      let loggedMessage = '';\n      const originalErrnoToString = util.errnoToString;\n      const originalPrintf = util.printf;\n      \n      util.errnoToString = (errno: number): string => {\n        return `MockErrorString_${errno}`;\n      };\n      util.printf = (format: string, args: Array<string>): void => {\n        loggedMessage = format.replace('%s', args[0]);\n      };\n      \n      formatAndLogError(0);\n      expect(loggedMessage).assertEqual('Error: MockErrorString_0');\n      \n      util.errnoToString = originalErrnoToString;\n      util.printf = originalPrintf;\n    });\n    \n    it('should_handle_negative_errno', 0, () => {\n      let loggedMessage = '';\n      const originalErrnoToString = util.errnoToString;\n      const originalPrintf = util.printf;\n      \n      util.errnoToString = (errno: number): string => {\n        return `MockErrorString_${errno}`;\n      };\n      util.printf = (format: string, args: Array<string>): void => {\n        loggedMessage = format.replace('%s', args[0]);\n      };\n      \n      formatAndLogError(-1);\n      expect(loggedMessage).assertEqual('Error: MockErrorString_-1');\n      \n      util.errnoToString = originalErrnoToString;\n      util.printf = originalPrintf;\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that uses the `constructor` to create an `XmlPullParser` object, parses an XML string with the `parseXml` method, and prints all attribute names of the first encountered element using the `parse` method.",
    "output": "import {xml} from '@kit.ArkTS';\nimport {util} from '@kit.ArkTS';\ntype XmlPullParser = xml.XmlPullParser;\n\nexport function parseXmlAndPrintAttributes(xmlString: string): void {\n  const encoder: util.TextEncoder = new util.TextEncoder();\n  const buffer: ArrayBuffer = encoder.encode(xmlString).buffer;\n  const parser: XmlPullParser = new xml.XmlPullParser(buffer, 'utf8');\n  \n  const parseOptions: xml.ParseOptions = {\n    supportDoctype: true,\n    ignoreNameSpace: true\n  };\n  \n  parser.parseXml(parseOptions);\n  \n  let eventType: number = parser.getEvent();\n  while (eventType !== xml.EventType.END_DOCUMENT) {\n    if (eventType === xml.EventType.START_TAG) {\n      const attributes: number = parser.getAttributeCount();\n      for (let i: number = 0; i < attributes; i++) {\n        const attrName: string = parser.getAttributeName(i);\n        console.log(attrName);\n      }\n      break;\n    }\n    eventType = parser.next();\n  }\n}"
  },
  {
    "instruction": "Write a function that registers multiple event listeners for different events on a `WorkerEventTarget` object and then removes one of them while keeping the others, using the `addEventListener` and `removeEventListener` methods.",
    "output": "import {WorkerEventTarget} from '@kit.ArkTS';\n\nexport function manageEventListeners(target: WorkerEventTarget): void {\n  const listener1 = (event: object): void => {\n    console.log('Event 1 triggered');\n  };\n  const listener2 = (event: object): void => {\n    console.log('Event 2 triggered');\n  };\n  const listener3 = (event: object): void => {\n    console.log('Event 3 triggered');\n  };\n\n  target.addEventListener('event1', listener1);\n  target.addEventListener('event2', listener2);\n  target.addEventListener('event3', listener3);\n\n  target.removeEventListener('event2', listener2);\n}"
  },
  {
    "instruction": "Write a function that creates a `PostMessageOptions` object, sets the `transfer` property to an array of transferable objects, and then verifies that the `transfer` property contains the correct objects.",
    "output": "import {PostMessageOptions} from '@kit.ArkTS';\n\nexport function createPostMessageOptions(transferables: ArrayBuffer[]): PostMessageOptions {\n  const options: PostMessageOptions = {\n    transfer: transferables\n  };\n  return options;\n}\n\nexport function verifyTransferProperty(options: PostMessageOptions, expectedTransfer: ArrayBuffer[]): boolean {\n  if (!options.transfer) {\n    return false;\n  }\n  if (options.transfer.length !== expectedTransfer.length) {\n    return false;\n  }\n  for (let i = 0; i < options.transfer.length; i++) {\n    if (options.transfer[i] !== expectedTransfer[i]) {\n      return false;\n    }\n  }\n  return true;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { logAndAddTask } from '../main/ets/functions/ArkTS_TaskGroup_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\n\ntype TaskGroup = taskpool.TaskGroup;\n\nexport default function localUnitTest() { \n  describe('logAndAddTask_function_test', () => {\n    it('should_log_name_and_add_task', 0, () => {\n      const mockTaskGroup: TaskGroup = {\n        name: 'testGroup',\n        addTask: (task: taskpool.Task) => {\n          expect(task).assertEqual(mockTask);\n        }\n      } as TaskGroup;\n      \n      const mockTask: taskpool.Task = {} as taskpool.Task;\n      const mockTaskName = 'testTask';\n      \n      logAndAddTask(mockTaskGroup, mockTaskName, mockTask);\n      expect(mockTaskGroup.name).assertEqual('testGroup');\n    }); \n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { getFirstHalfBlob } from '../main/ets/functions/ArkTS_Blob_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {buffer} from '@kit.ArkTS';\n\ntype Blob = buffer.Blob;\n\nexport default function localUnitTest() { \n  describe('getFirstHalfBlob_function_test', () => {\n    it('should_return_correct_half_blob', 0, () => {\n      const testData = new Uint8Array([1, 2, 3, 4, 5, 6]);\n      const testBlob = new buffer.Blob([testData.buffer]);\n      const resultBlob = getFirstHalfBlob(testBlob);\n      expect(resultBlob.size).assertEqual(3);\n    });\n\n    it('should_return_empty_blob_for_empty_input', 0, () => {\n      const testBlob = new buffer.Blob([]);\n      const resultBlob = getFirstHalfBlob(testBlob);\n      expect(resultBlob.size).assertEqual(0);\n    });\n\n    it('should_return_correct_type', 0, () => {\n      const testData = new Uint8Array([1, 2, 3, 4]);\n      const testBlob = new buffer.Blob([testData.buffer], { type: 'text/plain' });\n      const resultBlob = getFirstHalfBlob(testBlob);\n      expect(resultBlob.type).assertEqual('text/plain');\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that removes all event listeners from a WorkerEventTarget object after first verifying a specific listener was registered, using the `removeEventListener` and `removeAllListener` methods.",
    "output": "import {WorkerEventTarget} from '@kit.ArkTS';\n\nexport function removeListenersAfterVerification(target: WorkerEventTarget, type: string, callback: (event: object) => void): void {\n  if (!target) {\n    throw new Error('WorkerEventTarget is not provided');\n  }\n\n  try {\n    target.removeEventListener(type, callback);\n    target.removeAllListener();\n  } catch (error) {\n    if (error.code === 10200004) {\n      throw new Error('The Worker instance is not running');\n    } else if (error.code === 401) {\n      throw new Error('Parameter error');\n    } else {\n      throw new Error('Unknown error occurred');\n    }\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { modifyDeque } from '../main/ets/functions/ArkTS_Deque_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {Deque} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('modifyDeque_function_test', () => {\n    it('should_return_correct_length_after_modification', 0, () => {\n      const deque = new Deque<number>();\n      deque.insertFront(1);\n      deque.insertFront(2);\n      deque.insertFront(3);\n      const initialLength = deque.length;\n      const newLength = modifyDeque(deque, 4);\n      expect(newLength).assertEqual(initialLength);\n    });\n\n    it('should_return_zero_for_empty_deque', 0, () => {\n      const deque = new Deque<number>();\n      const newLength = modifyDeque(deque, 1);\n      expect(newLength).assertEqual(0);\n    });\n\n    it('should_return_one_for_single_element_deque', 0, () => {\n      const deque = new Deque<number>();\n      deque.insertFront(1);\n      const newLength = modifyDeque(deque, 2);\n      expect(newLength).assertEqual(1);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `TreeSet` object, removes its first and last values, and returns the remaining set **using the `popFirst`, `popLast`, and `length` properties**.",
    "output": "import {TreeSet} from '@kit.ArkTS';\n\nexport function removeFirstAndLast<T>(set: TreeSet<T>): TreeSet<T> {\n  if (set.length > 0) {\n    set.popFirst();\n  }\n  if (set.length > 0) {\n    set.popLast();\n  }\n  return set;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { decodeUint8ArrayToString } from '../main/ets/functions/ArkTS_TextDecoder_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\ntype TextDecoder = util.TextDecoder;\n\nexport default function localUnitTest() { \n  describe('decodeUint8ArrayToString_test', () => {\n    it('should_decode_empty_uint8array', 0, () => {\n        const input = new Uint8Array([]);\n        expect(decodeUint8ArrayToString(input)).assertEqual('');\n    });\n    it('should_decode_ascii_chars', 0, () => {\n        const input = new Uint8Array([72, 101, 108, 108, 111]); // 'Hello'\n        expect(decodeUint8ArrayToString(input)).assertEqual('Hello');\n    });\n    it('should_decode_utf8_chars', 0, () => {\n        const input = new Uint8Array([226, 130, 172]); // 'â‚¬'\n        expect(decodeUint8ArrayToString(input)).assertEqual('â‚¬');\n    });\n    it('should_decode_multibyte_utf8_chars', 0, () => {\n        const input = new Uint8Array([240, 159, 152, 128]); // 'ðŸ˜€'\n        expect(decodeUint8ArrayToString(input)).assertEqual('ðŸ˜€');\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { processMessageEvent } from '../main/ets/functions/ArkTS_MessageEvent_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {MessageEvent} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('processMessageEvent_function_test', () => {\n    it('should_convert_string_to_uppercase', 0, () => {\n      const event = { data: 'hello' } as MessageEvent<string>;\n      const result = processMessageEvent(event);\n      expect(result).assertEqual('HELLO');\n    });\n\n    it('should_return_void_for_non_string_data', 0, () => {\n      const event = { data: { key: 'value' } } as MessageEvent<object>;\n      const result = processMessageEvent(event);\n      expect(result === undefined).assertTrue();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `List` object and checks if it contains any duplicate values. If duplicates are found, remove all but the first occurrence of each value. Use the `has`, `getIndexOf`, and `remove` methods.",
    "output": "import {List} from '@kit.ArkTS';\n\nexport function removeDuplicates<T>(list: List<T>): void {\n  const seen = new Set<T>();\n  let i = 0;\n  while (i < list.length) {\n    const element = list.get(i);\n    if (seen.has(element)) {\n      list.remove(element);\n    } else {\n      seen.add(element);\n      i++;\n    }\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createWorker } from '../main/ets/functions/ArkTS_ThreadWorker_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {worker} from '@kit.ArkTS';\ntype ThreadWorker = worker.ThreadWorker;\n\nexport default function localUnitTest() { \n  describe('threadworker_processing_test', () => {\n    it('should_process_message_correctly', 0, () => {\n      const workerInstance: ThreadWorker = createWorker();\n      const testMessage = 'Test Message';\n      \n      workerInstance.onmessage = (processedMessage: Object): void => {\n        expect(processedMessage).assertEqual(`${testMessage} - Processed by Worker`);\n      };\n      \n      workerInstance.postMessage(testMessage);\n    }); \n  });\n}"
  },
  {
    "instruction": "Write a function that configures a `DecodeToStringOptions` object by enabling the `stream` property and then verifies its status by logging 'Configuration successful' if the property is enabled. Use the `stream` property for both configuration and verification.",
    "output": "import {util} from '@kit.ArkTS';\ntype DecodeToStringOptions = util.DecodeToStringOptions;\n\nexport function configureAndVerifyDecodeOptions(): void {\n  const options: DecodeToStringOptions = {};\n  options.stream = true;\n  \n  if (options.stream) {\n    console.log('Configuration successful');\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { removeDuplicatesAndSort } from '../main/ets/functions/ArkTS_List_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {List} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('removeDuplicatesAndSort_function_test', () => {\n    it('should_remove_duplicates_and_sort_numbers', 0, () => {\n      const list = new List<number>();\n      list.add(3);\n      list.add(1);\n      list.add(2);\n      list.add(3);\n      list.add(1);\n      const result = removeDuplicatesAndSort(list);\n      const expected = new List<number>();\n      expected.add(1);\n      expected.add(2);\n      expected.add(3);\n      expect(result.convertToArray()).assertEqual(expected.convertToArray());\n    });\n\n    it('should_remove_duplicates_and_sort_strings', 0, () => {\n      const list = new List<string>();\n      list.add('banana');\n      list.add('apple');\n      list.add('cherry');\n      list.add('banana');\n      list.add('apple');\n      const result = removeDuplicatesAndSort(list);\n      const expected = new List<string>();\n      expected.add('apple');\n      expected.add('banana');\n      expected.add('cherry');\n      expect(result.convertToArray()).assertEqual(expected.convertToArray());\n    });\n\n    it('should_handle_empty_list', 0, () => {\n      const list = new List<number>();\n      const result = removeDuplicatesAndSort(list);\n      expect(result.convertToArray()).assertEqual([]);\n    });\n\n    it('should_handle_single_element_list', 0, () => {\n      const list = new List<number>();\n      list.add(42);\n      const result = removeDuplicatesAndSort(list);\n      const expected = new List<number>();\n      expected.add(42);\n      expect(result.convertToArray()).assertEqual(expected.convertToArray());\n    });\n\n    it('should_handle_all_duplicates', 0, () => {\n      const list = new List<number>();\n      list.add(5);\n      list.add(5);\n      list.add(5);\n      const result = removeDuplicatesAndSort(list);\n      const expected = new List<number>();\n      expected.add(5);\n      expect(result.convertToArray()).assertEqual(expected.convertToArray());\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { sortAndRemoveFirstLast } from '../main/ets/functions/ArkTS_List_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {List} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('sortAndRemoveFirstLast_function_test', () => {\n    it('should_return_empty_list_when_input_empty', 0, () => {\n      const list = new List<number>();\n      const result = sortAndRemoveFirstLast(list);\n      expect(result.length).assertEqual(0);\n    });\n\n    it('should_return_empty_list_when_input_has_one_element', 0, () => {\n      const list = new List<number>();\n      list.add(5);\n      const result = sortAndRemoveFirstLast(list);\n      expect(result.length).assertEqual(0);\n    });\n\n    it('should_return_list_without_first_and_last_elements_when_input_has_multiple_elements', 0, () => {\n      const list = new List<number>();\n      list.add(5);\n      list.add(1);\n      list.add(3);\n      list.add(2);\n      list.add(4);\n      const result = sortAndRemoveFirstLast(list);\n      expect(result.length).assertEqual(3);\n      expect(result[0]).assertEqual(2);\n      expect(result[1]).assertEqual(3);\n      expect(result[2]).assertEqual(4);\n    });\n\n    it('should_return_empty_list_when_input_has_two_elements', 0, () => {\n      const list = new List<number>();\n      list.add(5);\n      list.add(1);\n      const result = sortAndRemoveFirstLast(list);\n      expect(result.length).assertEqual(0);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { extractRootElementName } from '../main/ets/functions/ArkTS_XmlPullParser_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {xml} from '@kit.ArkTS';\ntype XmlPullParser = xml.XmlPullParser;\n\nexport default function localUnitTest() { \n  describe('extractRootElementName_function_test', () => {\n    it('should_return_root_element_name', 0, () => {\n      const xmlString = '<root><child>content</child></root>';\n      expect(extractRootElementName(xmlString)).assertEqual('root');\n    });\n    \n    it('should_return_root_element_name_with_namespace', 0, () => {\n      const xmlString = '<ns:root xmlns:ns=\"http://example.com\"><child>content</child></ns:root>';\n      expect(extractRootElementName(xmlString)).assertEqual('root');\n    });\n    \n    it('should_return_root_element_name_with_doctype', 0, () => {\n      const xmlString = '<!DOCTYPE root><root><child>content</child></root>';\n      expect(extractRootElementName(xmlString)).assertEqual('root');\n    });\n    \n    it('should_return_empty_string_for_empty_xml', 0, () => {\n      const xmlString = '';\n      expect(extractRootElementName(xmlString)).assertEqual('');\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { decodeStream } from '../main/ets/functions/ArkTS_TextDecoder_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\ntype TextDecoder = util.TextDecoder;\n\nexport default function localUnitTest() { \n  describe('decodeStream_function_test', () => {\n    it('should_decode_utf8_chunks_correctly', 0, () => {\n      const chunks = [\n        new Uint8Array([72, 101, 108, 108, 111]), // 'Hello'\n        new Uint8Array([32, 119, 111, 114, 108, 100]) // ' world'\n      ];\n      const result = decodeStream(chunks);\n      expect(result).assertEqual('Hello world');\n    });\n\n    it('should_handle_empty_chunks', 0, () => {\n      const chunks: Uint8Array[] = [];\n      const result = decodeStream(chunks);\n      expect(result).assertEqual('');\n    });\n\n    it('should_handle_single_chunk', 0, () => {\n      const chunks = [new Uint8Array([72, 105])]; // 'Hi'\n      const result = decodeStream(chunks);\n      expect(result).assertEqual('Hi');\n    });\n\n    it('should_throw_error_for_non_utf8_encoding', 0, () => {\n      // Mock TextDecoder to simulate non-utf-8 encoding\n      const originalTextDecoder = util.TextDecoder;\n      util.TextDecoder = class {\n        encoding = 'ascii';\n        decodeWithStream(chunk: Uint8Array, options: {stream: boolean}): string {\n          return '';\n        }\n      } as unknown as typeof TextDecoder;\n\n      expect(() => decodeStream([new Uint8Array([72, 105])])).assertThrowError('Decoder encoding must be UTF-8');\n\n      // Restore original TextDecoder\n      util.TextDecoder = originalTextDecoder;\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { replaceValueInVector } from '../main/ets/functions/ArkTS_Vector_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {Vector} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('replaceValueInVector_function_test', () => {\n    it('should_replace_all_occurrences_of_oldValue', 0, () => {\n      const vector = new Vector<number>();\n      vector.add(1);\n      vector.add(2);\n      vector.add(1);\n      replaceValueInVector(vector, 1, 3);\n      expect(vector.getIndexOf(3)).assertEqual(0);\n      expect(vector.getIndexOf(3, 1)).assertEqual(2);\n      expect(vector.getIndexOf(1)).assertEqual(-1);\n    });\n\n    it('should_not_modify_vector_if_oldValue_not_found', 0, () => {\n      const vector = new Vector<string>();\n      vector.add('a');\n      vector.add('b');\n      replaceValueInVector(vector, 'c', 'd');\n      expect(vector.getIndexOf('a')).assertEqual(0);\n      expect(vector.getIndexOf('b')).assertEqual(1);\n      expect(vector.getIndexOf('d')).assertEqual(-1);\n    });\n\n    it('should_handle_empty_vector', 0, () => {\n      const vector = new Vector<boolean>();\n      replaceValueInVector(vector, true, false);\n      expect(vector.isEmpty()).assertTrue();\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { initializeTaskGroup } from '../main/ets/functions/ArkTS_TaskGroup_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\ntype TaskGroup = taskpool.TaskGroup;\n\nexport default function localUnitTest() { \n  describe('initializeTaskGroup_function_test', () => {\n    it('should_create_taskGroup_with_name_and_task', 0, () => {\n      const task = new taskpool.Task(() => {});\n      const taskGroup = initializeTaskGroup('testGroup', task);\n      expect(taskGroup).assertInstanceOf(TaskGroup);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { parseXMLWithoutNamespace } from '../main/ets/functions/ArkTS_ParseOptions_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {json} from '@kit.ArkTS';\ntype ParseOptions = json.ParseOptions;\n\nexport default function localUnitTest() { \n  describe('parseXMLWithoutNamespace_function_test', () => {\n    it('should_call_callback_with_tag_values', 0, () => {\n      const xmlString = '<root><item>value1</item><item>value2</item></root>';\n      const receivedValues: string[] = [];\n      const callback = (tagValue: string) => {\n        receivedValues.push(tagValue);\n      };\n      parseXMLWithoutNamespace(xmlString, callback);\n      expect(receivedValues).assertContain('value1');\n      expect(receivedValues).assertContain('value2');\n    });\n\n    it('should_handle_empty_xml', 0, () => {\n      const xmlString = '';\n      let callbackCalled = false;\n      const callback = (tagValue: string) => {\n        callbackCalled = true;\n      };\n      parseXMLWithoutNamespace(xmlString, callback);\n      expect(callbackCalled).assertFalse();\n    });\n\n    it('should_handle_xml_with_namespace_ignored', 0, () => {\n      const xmlString = '<ns:root><ns:item>value</ns:item></ns:root>';\n      const receivedValues: string[] = [];\n      const callback = (tagValue: string) => {\n        receivedValues.push(tagValue);\n      };\n      parseXMLWithoutNamespace(xmlString, callback);\n      expect(receivedValues).assertContain('value');\n    });\n\n    it('should_handle_nested_tags', 0, () => {\n      const xmlString = '<root><parent><child>childValue</child></parent></root>';\n      const receivedValues: string[] = [];\n      const callback = (tagValue: string) => {\n        receivedValues.push(tagValue);\n      };\n      parseXMLWithoutNamespace(xmlString, callback);\n      expect(receivedValues).assertContain('childValue');\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { updateOrAddKeyValuePair } from '../main/ets/functions/ArkTS_PlainArray_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {PlainArray} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('updateOrAddKeyValuePair_function_test', () => {\n    it('should_update_value_when_key_exists', 0, () => {\n      const plainArray = new PlainArray<number>();\n      plainArray.add(1, 10);\n      updateOrAddKeyValuePair(plainArray, 1, 20);\n      expect(plainArray.get(1)).assertEqual(20);\n    });\n\n    it('should_add_key_value_pair_when_key_does_not_exist', 0, () => {\n      const plainArray = new PlainArray<string>();\n      updateOrAddKeyValuePair(plainArray, 2, 'value');\n      expect(plainArray.get(2)).assertEqual('value');\n    });\n\n    it('should_handle_empty_plainArray', 0, () => {\n      const plainArray = new PlainArray<boolean>();\n      updateOrAddKeyValuePair(plainArray, 3, true);\n      expect(plainArray.get(3)).assertEqual(true);\n    });\n\n    it('should_update_multiple_values_correctly', 0, () => {\n      const plainArray = new PlainArray<number>();\n      plainArray.add(1, 10);\n      plainArray.add(2, 20);\n      updateOrAddKeyValuePair(plainArray, 1, 100);\n      updateOrAddKeyValuePair(plainArray, 2, 200);\n      expect(plainArray.get(1)).assertEqual(100);\n      expect(plainArray.get(2)).assertEqual(200);\n    });\n\n    it('should_add_multiple_key_value_pairs_correctly', 0, () => {\n      const plainArray = new PlainArray<string>();\n      updateOrAddKeyValuePair(plainArray, 1, 'one');\n      updateOrAddKeyValuePair(plainArray, 2, 'two');\n      expect(plainArray.get(1)).assertEqual('one');\n      expect(plainArray.get(2)).assertEqual('two');\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `PostMessageOptions` object, modifies its `transfer` property to include a new transferable object, and checks if the modification was successful.",
    "output": "import {PostMessageOptions} from '@kit.ArkTS';\n\nexport function modifyTransferOptions(options: PostMessageOptions, newTransfer: Object[]): boolean {\n  if (!options.transfer) {\n    options.transfer = [];\n  }\n  const originalLength = options.transfer.length;\n  options.transfer = [...options.transfer, ...newTransfer];\n  return options.transfer.length === originalLength + newTransfer.length;\n}"
  },
  {
    "instruction": "Write a function that takes an XML string, parses it using the `parseXml` method, and extracts the root element name using the `parse` method.",
    "output": "import {xml} from '@kit.ArkTS';\ntype XmlPullParser = xml.XmlPullParser;\n\nexport function extractRootElementName(xmlString: string): string {\n  const parser: XmlPullParser = new xml.XmlPullParser();\n  const parseOptions: xml.ParseOptions = {\n    input: xmlString,\n    supportDoctype: true,\n    ignoreNameSpace: true\n  };\n  parser.parse(parseOptions);\n  return parser.getName();\n}"
  },
  {
    "instruction": "Write a function that takes an `LruBuffer` object, retrieves its current capacity using the `getCapacity` method, and updates it to a new capacity using the `updateCapacity` method.",
    "output": "import {util} from '@kit.ArkTS';\ntype LruBuffer = util.LruBuffer;\n\nexport function updateLruBufferCapacity(buffer: LruBuffer, newCapacity: number): void {\n  const currentCapacity = buffer.getCapacity();\n  buffer.updateCapacity(newCapacity);\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { insertAtMiddle } from '../main/ets/functions/ArkTS_ArrayList_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {ArrayList} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('insertAtMiddle_function_test', () => {\n    it('should_insert_value_at_middle_of_empty_list', 0, () => {\n        const list = new ArrayList<number>();\n        insertAtMiddle(list, 5);\n        expect(list.length).assertEqual(1);\n        expect(list[0]).assertEqual(5);\n    });\n\n    it('should_insert_value_at_middle_of_odd_length_list', 0, () => {\n        const list = new ArrayList<number>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        insertAtMiddle(list, 5);\n        expect(list.length).assertEqual(4);\n        expect(list[1]).assertEqual(5);\n    });\n\n    it('should_insert_value_at_middle_of_even_length_list', 0, () => {\n        const list = new ArrayList<number>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        insertAtMiddle(list, 5);\n        expect(list.length).assertEqual(5);\n        expect(list[2]).assertEqual(5);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { getValueOrDefault } from '../main/ets/functions/ArkTS_LightWeightMap_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {LightWeightMap} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('getValueOrDefault_function_test', () => {\n    it('should_return_value_when_key_exists', 0, () => {\n      const map = new LightWeightMap<string, number>();\n      map.set('key1', 42);\n      expect(getValueOrDefault(map, 'key1', 0)).assertEqual(42);\n    });\n\n    it('should_return_default_when_key_does_not_exist', 0, () => {\n      const map = new LightWeightMap<string, number>();\n      expect(getValueOrDefault(map, 'nonexistent', 100)).assertEqual(100);\n    });\n\n    it('should_return_default_when_key_exists_but_value_is_undefined', 0, () => {\n      const map = new LightWeightMap<string, number | undefined>();\n      map.set('key1', undefined);\n      expect(getValueOrDefault(map, 'key1', 100)).assertEqual(100);\n    });\n\n    it('should_work_with_different_types', 0, () => {\n      const map = new LightWeightMap<number, string>();\n      map.set(1, 'value1');\n      expect(getValueOrDefault(map, 1, 'default')).assertEqual('value1');\n      expect(getValueOrDefault(map, 2, 'default')).assertEqual('default');\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that initializes a `StringDecoder` object, writes multiple buffers of encoded data to it using the `write` method, and finally returns the concatenated decoded string using the `end` method.",
    "output": "import {util} from '@kit.ArkTS';\ntype StringDecoder = util.StringDecoder;\n\nexport function decodeBuffers(encoding: string, buffers: Uint8Array[]): string {\n  const decoder = new StringDecoder(encoding);\n  let result = '';\n  for (const buffer of buffers) {\n    result += decoder.write(buffer);\n  }\n  result += decoder.end();\n  return result;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { getFirstElement } from '../main/ets/functions/ArkTS_GenericsTask_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\ntype GenericsTask = taskpool.GenericsTask;\n\nexport default function localUnitTest() { \n  describe('getFirstElement_function_test', () => {\n    it('should_return_first_element', 0, () => {\n        expect(getFirstElement()).assertEqual(1);\n    }); \n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { checkStreamingStatus } from '../main/ets/functions/ArkTS_DecodeWithStreamOptions_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype DecodeWithStreamOptions = util.DecodeWithStreamOptions;\n\nexport default function localUnitTest() { \n  describe('checkStreamingStatus_function_test', () => {\n    it('should_log_streaming_active_when_stream_enabled', 0, () => {\n      const options: DecodeWithStreamOptions = { stream: true };\n      checkStreamingStatus(options);\n      expect(true).assertTrue();\n    });\n\n    it('should_log_streaming_inactive_when_stream_disabled', 0, () => {\n      const options: DecodeWithStreamOptions = { stream: false };\n      checkStreamingStatus(options);\n      expect(true).assertTrue();\n    });\n\n    it('should_log_streaming_inactive_when_stream_undefined', 0, () => {\n      const options: DecodeWithStreamOptions = {};\n      checkStreamingStatus(options);\n      expect(true).assertTrue();\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { decodeAndEncodeBase64 } from '../main/ets/functions/ArkTS_Base64Helper_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\ntype Base64Helper = util.Base64Helper;\n\nexport default function localUnitTest() { \n  describe('decodeAndEncodeBase64_function_test', () => {\n    it('should_return_same_base64_string', 0, () => {\n        const input = 'SGVsbG8gV29ybGQ='; // 'Hello World' in Base64\n        const output = decodeAndEncodeBase64(input);\n        expect(output).assertEqual(input);\n    });\n\n    it('should_handle_empty_string', 0, () => {\n        const input = '';\n        const output = decodeAndEncodeBase64(input);\n        expect(output).assertEqual(input);\n    });\n\n    it('should_handle_special_characters', 0, () => {\n        const input = 'Pz8/Pw=='; // '????' in Base64\n        const output = decodeAndEncodeBase64(input);\n        expect(output).assertEqual(input);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that initializes a `Readable` stream, reads data from it, and checks if the stream is paused **using the `doInitialize`, `doRead`, and `isPaused` methods**.",
    "output": "import {stream} from '@kit.ArkTS';\ntype Readable = stream.Readable;\n\nexport function initializeAndReadStream(stream: Readable, size: number, callback: () => void): void {\n  stream.doInitialize(() => {\n    stream.doRead(size);\n    const paused = stream.isPaused();\n    callback();\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { decodeAndEncodeBase64 } from '../main/ets/functions/ArkTS_Base64Helper_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\ntype Base64Helper = util.Base64Helper;\n\nexport default function localUnitTest() { \n  describe('decodeAndEncodeBase64_function_test', () => {\n    it('should_return_same_string_for_valid_base64', 0, () => {\n        const input = 'SGVsbG8gV29ybGQ='; // 'Hello World' in Base64\n        const output = decodeAndEncodeBase64(input);\n        expect(output).assertEqual(input);\n    });\n\n    it('should_handle_empty_string', 0, () => {\n        const input = '';\n        const output = decodeAndEncodeBase64(input);\n        expect(output).assertEqual(input);\n    });\n\n    it('should_handle_special_characters', 0, () => {\n        const input = 'Pz8/Pw=='; // '????' in Base64\n        const output = decodeAndEncodeBase64(input);\n        expect(output).assertEqual(input);\n    });\n\n    it('should_handle_binary_data', 0, () => {\n        const input = 'AAECAwQFBgcICQ==';\n        const output = decodeAndEncodeBase64(input);\n        expect(output).assertEqual(input);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `StringDecoder` object, writes a buffer of encoded data to it using the `write` method, and then finalizes the decoded string using the `end` method.",
    "output": "import {util} from '@kit.ArkTS';\ntype StringDecoder = util.StringDecoder;\n\nexport function decodeString(decoder: StringDecoder, buffer: string | Uint8Array): string {\n  decoder.write(buffer);\n  return decoder.end();\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { isValidEventType } from '../main/ets/functions/ArkTS_EventType_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {xml} from '@kit.ArkTS';\ntype EventType = xml.EventType;\n\nexport default function localUnitTest() { \n  describe('isValidEventType_function_test', () => {\n    it('should_return_true_for_valid_ELEMENT_START', 0, () => {\n        expect(isValidEventType('elementStart' as EventType)).assertTrue();\n    });\n    it('should_return_true_for_valid_ELEMENT_END', 0, () => {\n        expect(isValidEventType('elementEnd' as EventType)).assertTrue();\n    });\n    it('should_return_true_for_valid_TEXT', 0, () => {\n        expect(isValidEventType('text' as EventType)).assertTrue();\n    });\n    it('should_return_true_for_valid_CDATA', 0, () => {\n        expect(isValidEventType('cdata' as EventType)).assertTrue();\n    });\n    it('should_return_true_for_valid_COMMENT', 0, () => {\n        expect(isValidEventType('comment' as EventType)).assertTrue();\n    });\n    it('should_return_true_for_valid_DOCUMENT_START', 0, () => {\n        expect(isValidEventType('documentStart' as EventType)).assertTrue();\n    });\n    it('should_return_true_for_valid_DOCUMENT_END', 0, () => {\n        expect(isValidEventType('documentEnd' as EventType)).assertTrue();\n    });\n    it('should_return_false_for_invalid_event_type', 0, () => {\n        expect(isValidEventType('INVALID_EVENT_TYPE' as EventType)).assertFalse();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `TreeSet` object, adds a new value to it, and then returns the smallest value greater than the newly added value using the `add` and `getHigherValue` methods.",
    "output": "import {TreeSet} from '@kit.ArkTS';\n\nexport function addAndGetHigherValue<T>(treeSet: TreeSet<T>, value: T): T | undefined {\n  treeSet.add(value);\n  return treeSet.getHigherValue(value);\n}"
  },
  {
    "instruction": "Write a function that takes a string, encodes it to a Base64 string using the `encodeToString` method, and then decodes it back to the original string using the `decode` method (handling asynchronous operations).",
    "output": "import {util} from '@kit.ArkTS';\ntype Base64 = util.Base64;\n\nexport async function encodeAndDecodeString(input: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const uint8Array = encoder.encode(input);\n  const encodedString = await Base64.encodeToString(uint8Array);\n  const decodedUint8Array = await Base64.decode(encodedString);\n  const decoder = new TextDecoder();\n  return decoder.decode(decodedUint8Array);\n}"
  },
  {
    "instruction": "Write a function that takes a `Writable` object, writes a string to it using the `write` method, checks if the stream is still writable using the `writable` property, and then ends the stream using the `end` method.",
    "output": "import {stream} from '@kit.ArkTS';\ntype Writable = stream.Writable;\n\nexport function writeToStream(writable: Writable, data: string): void {\n  const success = writable.write(data);\n  if (success && writable.writable) {\n    writable.end();\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createAndTransform } from '../main/ets/functions/ArkTS_Transform_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {stream} from '@kit.ArkTS';\ntype Transform = stream.Transform;\n\nexport default function localUnitTest() { \n  describe('transform_operations_test', () => {\n    it('should_transform_chunk_to_uppercase', 0, () => {\n      const transform = createAndTransform();\n      let result = '';\n      transform.on('data', (data: string) => {\n        result += data;\n      });\n      transform.write('hello');\n      transform.end();\n      expect(result).assertEqual('HELLOFlushed data');\n    });\n\n    it('should_flush_data_in_reverse_order', 0, () => {\n      const transform = createAndTransform();\n      let result = '';\n      transform.on('data', (data: string) => {\n        result += data;\n      });\n      transform.write('test');\n      transform.write('case');\n      transform.end();\n      expect(result).assertEqual('TESTCASEFlushed data');\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { parseUrlComponents } from '../main/ets/functions/ArkTS_URL_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {url} from '@kit.ArkTS';\n\ntype URL = url.URL;\n\nexport default function localUnitTest() { \n  describe('parseUrlComponents_function_test', () => {\n    it('should_return_correct_components_for_absolute_url', 0, () => {\n      const result = parseUrlComponents('https://example.com/path?query=1');\n      expect(result.hostname).assertEqual('example.com');\n      expect(result.pathname).assertEqual('/path');\n      expect(result.searchParams.get('query')).assertEqual('1');\n    });\n\n    it('should_return_correct_components_for_relative_url_with_base', 0, () => {\n      const baseUrl = 'https://example.com';\n      const result = parseUrlComponents('/path?query=1', baseUrl);\n      expect(result.hostname).assertEqual('example.com');\n      expect(result.pathname).assertEqual('/path');\n      expect(result.searchParams.get('query')).assertEqual('1');\n    });\n\n    it('should_return_empty_pathname_for_root_url', 0, () => {\n      const result = parseUrlComponents('https://example.com');\n      expect(result.hostname).assertEqual('example.com');\n      expect(result.pathname).assertEqual('');\n      expect(result.searchParams.toString()).assertEqual('');\n    });\n\n    it('should_return_empty_searchParams_for_url_without_query', 0, () => {\n      const result = parseUrlComponents('https://example.com/path');\n      expect(result.hostname).assertEqual('example.com');\n      expect(result.pathname).assertEqual('/path');\n      expect(result.searchParams.toString()).assertEqual('');\n    });\n\n    it('should_handle_multiple_query_parameters', 0, () => {\n      const result = parseUrlComponents('https://example.com/path?query1=1&query2=2');\n      expect(result.hostname).assertEqual('example.com');\n      expect(result.pathname).assertEqual('/path');\n      expect(result.searchParams.get('query1')).assertEqual('1');\n      expect(result.searchParams.get('query2')).assertEqual('2');\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `Vector` object, checks if it contains a specific value using the `has` method, and if found, replaces all elements with a new value using the `replaceAllElements` method.",
    "output": "import {Vector} from '@kit.ArkTS';\n\nexport function replaceIfFound<T>(vector: Vector<T>, searchValue: T, newValue: T): void {\n  if (vector.has(searchValue)) {\n    vector.replaceAllElements(() => newValue);\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { simulateLongTask, CustomLongTask } from '../main/ets/functions/ArkTS_LongTask_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\ntype LongTask = taskpool.LongTask;\n\nexport default function localUnitTest() { \n  describe('simulateLongTask_function_test', () => {\n    it('should_resolve_after_specified_duration', 0, async () => {\n      const duration = 100;\n      const startTime = Date.now();\n      await simulateLongTask(duration);\n      const endTime = Date.now();\n      expect(endTime - startTime).assertLarger(duration - 1);\n    }); \n  });\n\n  describe('CustomLongTask_class_test', () => {\n    it('should_complete_after_specified_duration', 0, async () => {\n      const duration = 200;\n      const task = new CustomLongTask(duration);\n      const startTime = Date.now();\n      await task.run();\n      const endTime = Date.now();\n      expect(endTime - startTime).assertLarger(duration - 1);\n    }); \n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `Uint8Array` and decodes it into a string using the `TextDecoder` API. Use the `encoding` property to specify UTF-8 and the `decode` method to perform the decoding.",
    "output": "import {util} from '@kit.ArkTS';\ntype TextDecoder = util.TextDecoder;\n\nexport function decodeUint8ArrayToString(input: Uint8Array): string {\n  const decoder = new TextDecoder('utf-8');\n  return decoder.decode(input);\n}"
  },
  {
    "instruction": "Write a function that configures a Worker to use shared memory and logs its name, using both the `shared` and `name` properties of `WorkerOptions`.",
    "output": "import {worker, WorkerOptions} from '@kit.ArkTS';\n\nexport function createWorkerWithOptions(name: string, shared: boolean): worker.Worker {\n  const options: WorkerOptions = {\n    name: name,\n    shared: shared\n  };\n  return new worker.Worker('', options);\n}"
  },
  {
    "instruction": "Write a function that takes a `PlainArray` object and removes all elements with a given key **using the `getIndexOfKey` and `removeAt` methods**.",
    "output": "import {PlainArray} from '@kit.ArkTS';\n\nexport function removeElementsByKey<T>(plainArray: PlainArray<T>, key: number): void {\n  const index = plainArray.getIndexOfKey(key);\n  if (index !== -1) {\n    plainArray.removeAt(index);\n  }\n}"
  },
  {
    "instruction": "Write a function that concatenates data from two readable streams and writes the combined result to a writable stream. Use the `pipe` method and the `end` event.",
    "output": "import {stream} from '@kit.ArkTS';\n\nexport function concatenateStreams(readable1: stream.Readable, readable2: stream.Readable, writable: stream.Writable): void {\n  const passThrough = new stream.Transform();\n\n  readable1.pipe(passThrough, { end: false });\n  readable2.pipe(passThrough, { end: true });\n\n  passThrough.pipe(writable);\n}"
  },
  {
    "instruction": "Write a function that takes a URL string, parses it using the `parseURL` method, modifies its `searchParams` property to add a new query parameter ('page=1'), and then converts the modified URL back to a string using the `toString` method.",
    "output": "import {url} from '@kit.ArkTS';\ntype URL = url.URL;\n\nexport function modifyURL(originalURL: string): string {\n  const parsedURL: URL = url.URL.parseURL(originalURL);\n  parsedURL.searchParams.set('page', '1');\n  return parsedURL.toString();\n}"
  },
  {
    "instruction": "Write a function that takes a `Blob` object and checks if its type is 'text/plain'. If true, extract and return the text content **using the `type` property and the `text` method**.",
    "output": "import {buffer} from '@kit.ArkTS';\ntype Blob = buffer.Blob;\n\nexport async function checkAndExtractText(blob: Blob): Promise<string | null> {\n  if (blob.type === 'text/plain') {\n    return await blob.text();\n  }\n  return null;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { logErrorEvent } from '../main/ets/functions/ArkTS_ErrorEvent_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {ErrorEvent} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('logErrorEvent_function_test', () => {\n    it('should_log_correct_error_message', 0, () => {\n      const mockEvent = {\n        message: 'Test error message',\n        lineno: 42,\n        filename: '',\n        colno: 0,\n        error: null,\n        type: '',\n        timeStamp: 0\n      } as ErrorEvent;\n      \n      expect(() => logErrorEvent(mockEvent)).not().assertThrowError();\n    });\n    \n    it('should_handle_empty_message', 0, () => {\n      const mockEvent = {\n        message: '',\n        lineno: 0,\n        filename: '',\n        colno: 0,\n        error: null,\n        type: '',\n        timeStamp: 0\n      } as ErrorEvent;\n      expect(() => logErrorEvent(mockEvent)).not().assertThrowError();\n    });\n    \n    it('should_handle_negative_line_number', 0, () => {\n      const mockEvent = {\n        message: 'Negative line error',\n        lineno: -1,\n        filename: '',\n        colno: 0,\n        error: null,\n        type: '',\n        timeStamp: 0\n      } as ErrorEvent;\n      expect(() => logErrorEvent(mockEvent)).not().assertThrowError();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that listens for a `MessageEvent` and logs the `data` property of the event, then removes the event listener using the `removeEventListener` method.",
    "output": "import {MessageEvent} from '@kit.ArkTS';\n\nexport function listenAndLogMessageEvent<T>(eventTarget: EventTarget, eventName: string): void {\n  const listener = (event: MessageEvent<T>) => {\n    console.log(event.data);\n    eventTarget.removeEventListener(eventName, listener);\n  };\n  eventTarget.addEventListener(eventName, listener);\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { writeToStream } from '../main/ets/functions/ArkTS_Writable_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {stream} from '@kit.ArkTS';\n\ntype Writable = stream.Writable;\n\nexport default function localUnitTest() { \n  describe('writeToStream_function_test', () => {\n    it('should_return_true_when_writable', 0, () => {\n      const mockWritable: Writable = {\n        writable: true,\n        write: (data: string) => true\n      } as Writable;\n      expect(writeToStream(mockWritable, 'test data')).assertTrue();\n    });\n\n    it('should_return_false_when_not_writable', 0, () => {\n      const mockWritable: Writable = {\n        writable: false,\n        write: (data: string) => true\n      } as Writable;\n      expect(writeToStream(mockWritable, 'test data')).assertFalse();\n    });\n\n    it('should_return_false_when_write_fails', 0, () => {\n      const mockWritable: Writable = {\n        writable: true,\n        write: (data: string) => false\n      } as Writable;\n      expect(writeToStream(mockWritable, 'test data')).assertFalse();\n    });\n  });\n}"
  },
  {
    "instruction": "Create a function that checks if the `encoding` property of a `ReadableOptions` object is 'ascii' and throws an error if it is, otherwise logs the current encoding value.",
    "output": "import {stream} from '@kit.ArkTS';\ntype ReadableOptions = stream.ReadableOptions;\n\nexport function checkEncoding(options: ReadableOptions): void {\n  if (options.encoding === 'ascii') {\n    throw new Error('Encoding cannot be ascii');\n  } else {\n    console.log(`Current encoding: ${options.encoding}`);\n  }\n}"
  },
  {
    "instruction": "Write a function that takes a `Stack` object and removes all occurrences of a given value **using the `pop`, `push`, and `peek` methods**.",
    "output": "import {Stack} from '@kit.ArkTS';\n\nexport function removeAllOccurrences<T>(stack: Stack<T>, value: T): void {\n  const tempStack = new Stack<T>();\n  while (stack.peek() !== undefined) {\n    const top = stack.pop();\n    if (top !== value) {\n      tempStack.push(top);\n    }\n  }\n  while (tempStack.peek() !== undefined) {\n    stack.push(tempStack.pop());\n  }\n}"
  },
  {
    "instruction": "Write a function that takes a `ScopeHelper` object and a value, then expands the scope to include the value if it is outside the current bounds. Use the `contains`, `expand`, and `clamp` methods.",
    "output": "import {util} from '@kit.ArkTS';\ntype ScopeHelper = util.ScopeHelper;\n\nexport function expandScope(scope: ScopeHelper, value: number): ScopeHelper {\n  if (!scope.contains(value)) {\n    return scope.expand(value);\n  }\n  return scope;\n}"
  },
  {
    "instruction": "Write a function that creates a new buffer of a specified size using `alloc`, fills it with a given string using the specified encoding (`BufferEncoding`), and checks if the result is a valid buffer using `isBuffer`.",
    "output": "import {buffer} from '@kit.ArkTS';\n\nexport function createAndValidateBuffer(size: number, fill: string, encoding: buffer.BufferEncoding): boolean {\n  const buf = buffer.alloc(size, fill, encoding);\n  return buffer.isBuffer(buf);\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { logMessageWithPrefix } from '../main/ets/functions/ArkTS_MessageEvent_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {MessageEvent} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('logMessageWithPrefix_function_test', () => {\n    it('should_log_message_with_prefix', 0, () => {\n      const mockEvent: MessageEvent<string> = { data: 'test message' } as MessageEvent<string>;\n      const prefix = 'PREFIX: ';\n      \n      // Since console.log is not testable directly, we'll verify the function doesn't throw\n      expect(() => logMessageWithPrefix(mockEvent, prefix)).not().assertThrowError();\n    });\n    \n    it('should_handle_empty_message', 0, () => {\n      const mockEvent: MessageEvent<string> = { data: '' } as MessageEvent<string>;\n      const prefix = 'PREFIX: ';\n      \n      expect(() => logMessageWithPrefix(mockEvent, prefix)).not().assertThrowError();\n    });\n    \n    it('should_handle_empty_prefix', 0, () => {\n      const mockEvent: MessageEvent<string> = { data: 'test message' } as MessageEvent<string>;\n      const prefix = '';\n      \n      expect(() => logMessageWithPrefix(mockEvent, prefix)).not().assertThrowError();\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { formatAndLogError } from '../main/ets/functions/ArkTS_util_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('formatAndLogError_function_test', () => {\n    it('should_log_correct_error_string', 0, () => {\n      // Mock the util methods to verify they are called correctly\n      let loggedMessage = '';\n      const originalErrnoToString = util.errnoToString;\n      const originalPrintf = util.printf;\n      \n      // Setup mocks\n      util.errnoToString = (errno: number): string => {\n        return `MockErrorString_${errno}`;\n      };\n      util.printf = (format: string, args: string[]): void => {\n        loggedMessage = format.replace('%s', args[0]);\n      };\n      \n      // Test with a specific errno\n      const testErrno = 2;\n      formatAndLogError(testErrno);\n      \n      // Verify the logged message matches expected format\n      expect(loggedMessage).assertEqual(`Error: MockErrorString_${testErrno}`);\n      \n      // Restore original methods\n      util.errnoToString = originalErrnoToString;\n      util.printf = originalPrintf;\n    });\n    \n    it('should_handle_zero_errno', 0, () => {\n      let loggedMessage = '';\n      const originalErrnoToString = util.errnoToString;\n      const originalPrintf = util.printf;\n      \n      util.errnoToString = (errno: number): string => {\n        return `MockErrorString_${errno}`;\n      };\n      util.printf = (format: string, args: string[]): void => {\n        loggedMessage = format.replace('%s', args[0]);\n      };\n      \n      formatAndLogError(0);\n      expect(loggedMessage).assertEqual('Error: MockErrorString_0');\n      \n      util.errnoToString = originalErrnoToString;\n      util.printf = originalPrintf;\n    });\n    \n    it('should_handle_negative_errno', 0, () => {\n      let loggedMessage = '';\n      const originalErrnoToString = util.errnoToString;\n      const originalPrintf = util.printf;\n      \n      util.errnoToString = (errno: number): string => {\n        return `MockErrorString_${errno}`;\n      };\n      util.printf = (format: string, args: string[]): void => {\n        loggedMessage = format.replace('%s', args[0]);\n      };\n      \n      formatAndLogError(-1);\n      expect(loggedMessage).assertEqual('Error: MockErrorString_-1');\n      \n      util.errnoToString = originalErrnoToString;\n      util.printf = originalPrintf;\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createUppercaseTransformStream } from '../main/ets/functions/ArkTS_stream_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {stream} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('createUppercaseTransformStream_test', () => {\n    it('should_convert_data_to_uppercase', 0, () => {\n      const writable = new stream.Writable({\n        write(chunk: string, encoding: string, callback: Function) {\n          expect(chunk).assertEqual('TEST');\n          callback();\n        }\n      });\n      \n      const transform = createUppercaseTransformStream(writable);\n      transform.write('test', 'utf8', () => {});\n    });\n\n    it('should_pipe_data_to_writable_stream', 0, () => {\n      let receivedData = '';\n      const writable = new stream.Writable({\n        write(chunk: string, encoding: string, callback: Function) {\n          receivedData += chunk;\n          callback();\n        }\n      });\n      \n      const transform = createUppercaseTransformStream(writable);\n      transform.write('hello', 'utf8', () => {});\n      transform.write(' world', 'utf8', () => {});\n      transform.end(() => {});\n      expect(receivedData).assertEqual('HELLO WORLD');\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `Stack` object and returns the sum of all its elements **using the `Symbol.iterator` and `length` properties**.",
    "output": "import {Stack} from '@kit.ArkTS';\n\nexport function sumStackElements(stack: Stack<number>): number {\n  let sum = 0;\n  for (const element of stack) {\n    sum += element;\n  }\n  return sum;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createPostMessageOptionsWithTransfer, verifyTransferProperty } from '../main/ets/functions/ArkTS_PostMessageOptions_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {PostMessageOptions} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('createPostMessageOptionsWithTransfer_function_test', () => {\n    it('should_set_transfer_property_correctly', 0, () => {\n      const transferables: ArrayBuffer[] = [new ArrayBuffer(8), new ArrayBuffer(16)];\n      const options = createPostMessageOptionsWithTransfer(transferables);\n      expect(verifyTransferProperty(options, transferables)).assertTrue();\n    });\n    \n    it('should_handle_empty_transfer_array', 0, () => {\n      const transferables: ArrayBuffer[] = [];\n      const options = createPostMessageOptionsWithTransfer(transferables);\n      expect(verifyTransferProperty(options, transferables)).assertTrue();\n    });\n  });\n  \n  describe('verifyTransferProperty_function_test', () => {\n    it('should_return_true_for_matching_transfer_arrays', 0, () => {\n      const transferables: ArrayBuffer[] = [new ArrayBuffer(8)];\n      const options: PostMessageOptions = { transfer: transferables };\n      expect(verifyTransferProperty(options, transferables)).assertTrue();\n    });\n    \n    it('should_return_false_for_non_matching_transfer_arrays', 0, () => {\n      const transferables1: ArrayBuffer[] = [new ArrayBuffer(8)];\n      const transferables2: ArrayBuffer[] = [new ArrayBuffer(16)];\n      const options: PostMessageOptions = { transfer: transferables1 };\n      expect(verifyTransferProperty(options, transferables2)).assertFalse();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that initializes a `State` object and updates its value using the `set` method, then logs the current state using the `get` method.",
    "output": "import {taskpool} from '@kit.ArkTS';\ntype State = taskpool.State;\n\nexport function initializeAndLogState(): void {\n  const state = new State();\n  state.set(1);\n  console.log(`Current state: ${state.get()}`);\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { insertBeforeFirstOccurrence, replaceSpecifiedAspect } from '../main/ets/functions/ArkTS_Aspect_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype Aspect = util.Aspect;\n\nexport default function localUnitTest() { \n  describe('insertBeforeFirstOccurrence_function_test', () => {\n    it('should_insert_before_specified_aspect', 0, () => {\n      const aspectMock: Aspect = {\n        addBefore: (targetClass: Object, methodName: string, isStatic: boolean, advice: Function) => {\n          const originalMethod = () => 'original';\n          const specifiedAspect = () => 'specified';\n          const before = () => 'before';\n          const result = advice(originalMethod, 'test');\n          expect(result).assertEqual('original');\n          const resultWithSpecified = advice(specifiedAspect, 'test');\n          expect(resultWithSpecified).assertEqual('specified');\n        }\n      } as Aspect;\n      \n      const targetClass = {};\n      const methodName = 'testMethod';\n      const isStatic = false;\n      const before = () => 'before';\n      const specifiedAspect = () => 'specified';\n      \n      insertBeforeFirstOccurrence(aspectMock, targetClass, methodName, isStatic, before, specifiedAspect);\n    }); \n  });\n\n  describe('replaceSpecifiedAspect_function_test', () => {\n    it('should_replace_specified_aspect', 0, () => {\n      const aspectMock: Aspect = {\n        replace: (targetClass: Object, methodName: string, isStatic: boolean, advice: Function) => {\n          const originalMethod = () => 'original';\n          const specifiedAspect = () => 'specified';\n          const instead = () => 'instead';\n          const result = advice(originalMethod, 'test');\n          expect(result).assertEqual('original');\n          const resultWithSpecified = advice(specifiedAspect, 'test');\n          expect(resultWithSpecified).assertEqual('instead');\n        }\n      } as Aspect;\n      \n      const targetClass = {};\n      const methodName = 'testMethod';\n      const isStatic = false;\n      const instead = () => 'instead';\n      const specifiedAspect = () => 'specified';\n      \n      replaceSpecifiedAspect(aspectMock, targetClass, methodName, isStatic, instead, specifiedAspect);\n    }); \n  });\n}"
  },
  {
    "instruction": "Write a function that merges two `Deque` objects into one by alternating elements from each deque **using the `popFirst`, `insertEnd`, and `length` properties**.",
    "output": "import {Deque} from '@kit.ArkTS';\n\ninterface IndexResult {\n  firstIndex: number;\n  lastIndex: number;\n}\n\nexport function findValueInDeque<T>(deque: Deque<T>, value: T): IndexResult | null {\n  if (!deque.has(value)) {\n    return null;\n  }\n\n  let firstIndex = -1;\n  let lastIndex = -1;\n  let currentIndex = 0;\n\n  deque.forEach((element: T) => {\n    if (element === value) {\n      if (firstIndex === -1) {\n        firstIndex = currentIndex;\n      }\n      lastIndex = currentIndex;\n    }\n    currentIndex++;\n  });\n\n  return {firstIndex, lastIndex};\n}"
  },
  {
    "instruction": "Write a function that takes a `LightWeightSet` object, adds a new element to it, and checks if the element was successfully added using the `add` and `has` methods.",
    "output": "import {LightWeightSet} from '@kit.ArkTS';\n\nexport function addAndCheckElement<T>(set: LightWeightSet<T>, element: T): boolean {\n  const added = set.add(element);\n  const hasElement = set.has(element);\n  return added && hasElement;\n}"
  },
  {
    "instruction": "Implement a function that compares two events and returns the one with the earlier timestamp using the `timeStamp` property.",
    "output": "import {Event} from '@kit.ArkTS';\n\nexport function getEarlierEvent(event1: Event, event2: Event): Event {\n  return event1.timeStamp < event2.timeStamp ? event1 : event2;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createAndExecuteSequenceRunner } from '../main/ets/functions/ArkTS_SequenceRunner_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\ntype SequenceRunner = taskpool.SequenceRunner;\n\nexport default function localUnitTest() { \n  describe('createAndExecuteSequenceRunner_test', () => {\n    it('should_execute_tasks_and_return_results', 0, async () => {\n      const tasks = [\n        new taskpool.Task(() => 'task1'),\n        new taskpool.Task(() => 'task2'),\n        new taskpool.Task(() => 'task3')\n      ];\n      const results = await createAndExecuteSequenceRunner('testRunner', taskpool.Priority.MEDIUM, tasks);\n      expect(results).assertDeepEquals(['task1', 'task2', 'task3']);\n    });\n\n    it('should_handle_empty_tasks_array', 0, async () => {\n      const tasks: taskpool.Task[] = [];\n      const results = await createAndExecuteSequenceRunner('testRunner', taskpool.Priority.MEDIUM, tasks);\n      expect(results).assertDeepEquals([]);\n    });\n\n    it('should_handle_single_task', 0, async () => {\n      const tasks = [\n        new taskpool.Task(() => 'singleTask')\n      ];\n      const results = await createAndExecuteSequenceRunner('testRunner', taskpool.Priority.MEDIUM, tasks);\n      expect(results).assertDeepEquals(['singleTask']);\n    });\n\n    it('should_handle_different_priorities', 0, async () => {\n      const tasks = [\n        new taskpool.Task(() => 'lowPriorityTask')\n      ];\n      const results = await createAndExecuteSequenceRunner('testRunner', taskpool.Priority.LOW, tasks);\n      expect(results).assertDeepEquals(['lowPriorityTask']);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { updateWrittenProperty } from '../main/ets/functions/ArkTS_EncodeIntoUint8ArrayInfo_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype EncodeIntoUint8ArrayInfo = util.EncodeIntoUint8ArrayInfo;\n\nexport default function localUnitTest() { \n  describe('updateWrittenProperty_test', () => {\n    it('should_update_written_to_equal_read', 0, () => {\n      const input: EncodeIntoUint8ArrayInfo = { read: 5, written: 0 };\n      const expected: EncodeIntoUint8ArrayInfo = { read: 5, written: 5 };\n      expect(updateWrittenProperty(input)).assertEqual(expected);\n    });\n\n    it('should_handle_zero_read_value', 0, () => {\n      const input: EncodeIntoUint8ArrayInfo = { read: 0, written: 10 };\n      const expected: EncodeIntoUint8ArrayInfo = { read: 0, written: 0 };\n      expect(updateWrittenProperty(input)).assertEqual(expected);\n    });\n\n    it('should_handle_negative_read_value', 0, () => {\n      const input: EncodeIntoUint8ArrayInfo = { read: -3, written: 2 };\n      const expected: EncodeIntoUint8ArrayInfo = { read: -3, written: -3 };\n      expect(updateWrittenProperty(input)).assertEqual(expected);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a JSON object and checks if it contains a specific key using the `has` method, then converts the object to a string representation using the `stringify` method.",
    "output": "import {json} from '@kit.ArkTS';\n\nexport function checkAndStringify(obj: object, key: string): string {\n  if (json.has(obj, key)) {\n    return json.stringify(obj);\n  }\n  return json.stringify({});\n}"
  },
  {
    "instruction": "Write a function that creates two `LongTask` objects, chains them to run sequentially, and logs their completion status using the `then` and `onComplete` methods.",
    "output": "import {taskpool} from '@kit.ArkTS';\ntype LongTask = taskpool.LongTask;\n\nexport function chainLongTasks(): void {\n  const task1: LongTask = new taskpool.LongTask(() => {\n    console.log('LongTask1 is running');\n  });\n\n  const task2: LongTask = new taskpool.LongTask(() => {\n    console.log('LongTask2 is running');\n  });\n\n  task1.execute().then(() => {\n    console.log('LongTask1 completed');\n    return task2.execute();\n  }).then(() => {\n    console.log('LongTask2 completed');\n  }).catch((error) => {\n    console.log('Error occurred:', error);\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createAndSumTypedArray } from '../main/ets/functions/ArkTS_TypedArray_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {buffer} from '@kit.ArkTS';\n\ntype TypedArray = buffer.TypedArray;\n\nexport default function localUnitTest() { \n  describe('createAndSumTypedArray_test', () => {\n    it('should_return_sum_for_empty_array', 0, () => {\n        expect(createAndSumTypedArray(0)).assertEqual(0);\n    });\n    \n    it('should_return_sum_for_single_element', 0, () => {\n        const result = createAndSumTypedArray(1);\n        expect(result).assertAboveOrEqual(1);\n        expect(result).assertBelowOrEqual(100);\n    });\n    \n    it('should_return_sum_for_multiple_elements', 0, () => {\n        const result = createAndSumTypedArray(10);\n        expect(result).assertAboveOrEqual(10); // Minimum possible sum (10 elements * 1)\n        expect(result).assertBelowOrEqual(1000); // Maximum possible sum (10 elements * 100)\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { checkAndAddTask } from '../main/ets/functions/ArkTS_TaskGroup_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\n\ntype TaskGroup = taskpool.TaskGroup;\n\nexport default function localUnitTest() { \n  describe('checkAndAddTask_function_test', () => {\n    it('should_add_task_when_names_match', 0, () => {\n      let taskAdded = false;\n      const mockTaskGroup: TaskGroup = {\n        name: 'group1',\n        addTask: (task: taskpool.Task) => {\n          taskAdded = true;\n          expect(task).assertUndefined();\n        }\n      } as TaskGroup;\n      const mockTask = new taskpool.Task(() => {});\n      \n      checkAndAddTask(mockTaskGroup, 'group1', mockTask);\n      expect(taskAdded).assertTrue();\n    });\n    \n    it('should_not_add_task_when_names_do_not_match', 0, () => {\n      let taskAdded = false;\n      const mockTaskGroup: TaskGroup = {\n        name: 'group1',\n        addTask: (task: taskpool.Task) => {\n          taskAdded = true;\n        }\n      } as TaskGroup;\n      const mockTask = new taskpool.Task(() => {});\n      \n      checkAndAddTask(mockTaskGroup, 'group2', mockTask);\n      expect(taskAdded).assertFalse();\n    });\n  });\n}"
  }
]