[
  {
    "instruction": "Write a function that takes a `Vector` object and returns a new `Vector` containing only the elements that are present in both the original vector and another given vector. Use the `has`, `clone`, and `add` methods.",
    "output": "import {Vector} from '@kit.ArkTS';\n\nexport function removeDuplicates<T>(vector: Vector<T>): void {\n  const seen = new Set<T>();\n  let i = 0;\n  while (i < vector.length) {\n    const element = vector.getIndexOf(i);\n    if (seen.has(element)) {\n      vector.removeByIndex(i);\n    } else {\n      seen.add(element);\n      i++;\n    }\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { updateURLParams } from '../main/ets/functions/ArkTS_URLParams_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {url} from '@kit.ArkTS';\ntype URLParams = url.URLParams;\n\nexport default function localUnitTest() { \n  describe('updateURLParams_function_test', () => {\n    it('should_append_key_value_and_return_updated_query_string', 0, () => {\n      const params = new url.URLParams();\n      const key = 'testKey';\n      const value = 'testValue';\n      const result = updateURLParams(params, key, value);\n      expect(result).assertEqual('testKey=testValue');\n    });\n\n    it('should_handle_existing_key_and_return_updated_query_string', 0, () => {\n      const params = new url.URLParams();\n      params.append('existingKey', 'existingValue');\n      const key = 'existingKey';\n      const value = 'newValue';\n      const result = updateURLParams(params, key, value);\n      expect(result).assertEqual('existingKey=existingValue&existingKey=newValue');\n    });\n\n    it('should_handle_empty_key_and_return_updated_query_string', 0, () => {\n      const params = new url.URLParams();\n      const key = '';\n      const value = 'testValue';\n      const result = updateURLParams(params, key, value);\n      expect(result).assertEqual('=testValue');\n    });\n\n    it('should_handle_empty_value_and_return_updated_query_string', 0, () => {\n      const params = new url.URLParams();\n      const key = 'testKey';\n      const value = '';\n      const result = updateURLParams(params, key, value);\n      expect(result).assertEqual('testKey=');\n    });\n  });\n}"
  },
  {
    "instruction": "Create a function that initializes a `DecodeWithStreamOptions` object, sets the `stream` property to `false`, and then verifies that the property value is correctly updated.",
    "output": "import {util} from '@kit.ArkTS';\ntype DecodeWithStreamOptions = util.DecodeWithStreamOptions;\n\nexport function initializeAndVerifyDecodeWithStreamOptions(): boolean {\n  const options: DecodeWithStreamOptions = {};\n  options.stream = false;\n  return options.stream === false;\n}"
  },
  {
    "instruction": "Write a function that schedules a task to run after a delay of 2 seconds and then cancels it before execution using the `executeDelayed` and `cancel` methods.",
    "output": "import {taskpool} from '@kit.ArkTS';\n\nexport function scheduleAndCancelTask(): void {\n  const task: taskpool.Task = new taskpool.Task(() => {\n    console.log('Task executed');\n  });\n\n  taskpool.executeDelayed(2000, task).then(() => {\n    console.log('Task completed');\n  }).catch((err: Error) => {\n    console.error(`Error executing task: ${err.message}`);\n  });\n\n  taskpool.cancel(task);\n}"
  },
  {
    "instruction": "Write a function that takes a `TypedArray` object and creates a new `TypedArray` with only the even-indexed elements **using the `filter` method and the `map` method**.",
    "output": "import {buffer} from '@kit.ArkTS';\ntype TypedArray = buffer.TypedArray;\n\nexport function filterEvenIndexedElements(arr: TypedArray): TypedArray {\n  return arr.filter((_, index) => index % 2 === 0);\n}"
  },
  {
    "instruction": "Write a function that takes a `TaskInfo` object and generates a summary string in the format 'Task [taskId]: [name] - [state]', using the `taskId`, `name`, and `state` properties.",
    "output": "import {taskpool} from '@kit.ArkTS';\ntype TaskInfo = taskpool.TaskInfo;\n\nexport function generateTaskSummary(taskInfo: TaskInfo): string {\n  return `Task ${taskInfo.taskId}: ${taskInfo.name} - ${taskInfo.state}`;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { isSortedAscending } from '../main/ets/functions/ArkTS_ScopeComparable_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype ScopeComparable = util.ScopeComparable;\n\nexport default function localUnitTest() { \n  describe('isSortedAscending_function_test', () => {\n    it('should_return_true_for_empty_array', 0, () => {\n        expect(isSortedAscending([])).assertTrue();\n    });\n\n    it('should_return_true_for_single_element_array', 0, () => {\n        const mockComparable: ScopeComparable = {\n            compareTo: (other: ScopeComparable) => false\n        };\n        expect(isSortedAscending([mockComparable])).assertTrue();\n    });\n\n    it('should_return_true_for_sorted_array', 0, () => {\n        const mockComparables: ScopeComparable[] = [\n            { compareTo: (other: ScopeComparable) => false },\n            { compareTo: (other: ScopeComparable) => false }\n        ];\n        expect(isSortedAscending(mockComparables)).assertTrue();\n    });\n\n    it('should_return_false_for_unsorted_array', 0, () => {\n        const mockComparables: ScopeComparable[] = [\n            { compareTo: (other: ScopeComparable) => true },\n            { compareTo: (other: ScopeComparable) => false }\n        ];\n        expect(isSortedAscending(mockComparables)).assertFalse();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `DecodeToStringOptions` object and checks if the `stream` property is enabled. If it is, log 'Streaming is enabled'; otherwise, log 'Streaming is disabled'. Use the `stream` property for this check.",
    "output": "import {util} from '@kit.ArkTS';\ntype DecodeToStringOptions = util.DecodeToStringOptions;\n\nexport function checkStreamingStatus(options: DecodeToStringOptions): void {\n  if (options.stream) {\n    console.log('Streaming is enabled');\n  } else {\n    console.log('Streaming is disabled');\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { compareAndConcat } from '../main/ets/functions/ArkTS_buffer_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {buffer} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('compareAndConcat_function_test', () => {\n    it('should_return_concatenated_buffer_when_buffers_are_different', 0, () => {\n      const buf1 = new Uint8Array([1, 2, 3]);\n      const buf2 = new Uint8Array([4, 5, 6]);\n      const result = compareAndConcat(buf1, buf2);\n      const expected = new Uint8Array([1, 2, 3, 4, 5, 6]);\n      expect(buffer.compare(result, expected)).assertEqual(0);\n    });\n\n    it('should_return_single_buffer_when_buffers_are_equal', 0, () => {\n      const buf1 = new Uint8Array([1, 2, 3]);\n      const buf2 = new Uint8Array([1, 2, 3]);\n      const result = compareAndConcat(buf1, buf2);\n      expect(buffer.compare(result, buf1)).assertEqual(0);\n    });\n\n    it('should_handle_empty_buffers_correctly', 0, () => {\n      const buf1 = new Uint8Array([]);\n      const buf2 = new Uint8Array([]);\n      const result = compareAndConcat(buf1, buf2);\n      expect(buffer.compare(result, buf1)).assertEqual(0);\n    });\n\n    it('should_handle_mixed_buffer_types_correctly', 0, () => {\n      const buf1 = new Uint8Array([1, 2, 3]);\n      const buf2 = new Uint8Array(buffer.from([4, 5, 6]));\n      const result = compareAndConcat(buf1, buf2);\n      const expected = new Uint8Array([1, 2, 3, 4, 5, 6]);\n      expect(buffer.compare(result, expected)).assertEqual(0);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { clampToBounds } from '../main/ets/functions/ArkTS_ScopeHelper_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\ntype ScopeHelper = util.ScopeHelper;\n\nexport default function localUnitTest() { \n  describe('clampToBounds_function_test', () => {\n    it('should_return_value_within_bounds', 0, () => {\n      const scope: ScopeHelper = new util.ScopeHelper(5, 10);\n      expect(clampToBounds(scope, 7)).assertEqual(7);\n    });\n    \n    it('should_clamp_value_below_lower_bound', 0, () => {\n      const scope: ScopeHelper = new util.ScopeHelper(5, 10);\n      expect(clampToBounds(scope, 3)).assertEqual(5);\n    });\n    \n    it('should_clamp_value_above_upper_bound', 0, () => {\n      const scope: ScopeHelper = new util.ScopeHelper(5, 10);\n      expect(clampToBounds(scope, 12)).assertEqual(10);\n    });\n    \n    it('should_return_value_at_lower_bound', 0, () => {\n      const scope: ScopeHelper = new util.ScopeHelper(5, 10);\n      expect(clampToBounds(scope, 5)).assertEqual(5);\n    });\n    \n    it('should_return_value_at_upper_bound', 0, () => {\n      const scope: ScopeHelper = new util.ScopeHelper(5, 10);\n      expect(clampToBounds(scope, 10)).assertEqual(10);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { sortArrayInWorker } from '../main/ets/functions/ArkTS_worker_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {worker} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('sortArrayInWorker_function_test', () => {\n    it('should_return_sorted_array', 0, async () => {\n      const inputArray = [3, 1, 4, 2];\n      const expectedOutput = [1, 2, 3, 4];\n      const result = await sortArrayInWorker(inputArray);\n      expect(result).assertEqual(expectedOutput);\n    });\n\n    it('should_return_empty_array_for_empty_input', 0, async () => {\n      const inputArray: number[] = [];\n      const expectedOutput: number[] = [];\n      const result = await sortArrayInWorker(inputArray);\n      expect(result).assertEqual(expectedOutput);\n    });\n\n    it('should_return_same_array_for_single_element', 0, async () => {\n      const inputArray = [5];\n      const expectedOutput = [5];\n      const result = await sortArrayInWorker(inputArray);\n      expect(result).assertEqual(expectedOutput);\n    });\n\n    it('should_handle_negative_numbers', 0, async () => {\n      const inputArray = [-3, -1, -4, -2];\n      const expectedOutput = [-4, -3, -2, -1];\n      const result = await sortArrayInWorker(inputArray);\n      expect(result).assertEqual(expectedOutput);\n    });\n\n    it('should_handle_mixed_numbers', 0, async () => {\n      const inputArray = [0, -1, 1, -2, 2];\n      const expectedOutput = [-2, -1, 0, 1, 2];\n      const result = await sortArrayInWorker(inputArray);\n      expect(result).assertEqual(expectedOutput);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { pipeStringToStream } from '../main/ets/functions/ArkTS_stream_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {stream} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('pipeStringToStream_function_test', () => {\n    it('should_pipe_string_to_stream_and_close_streams', 0, () => {\n      const testString = 'Hello, World!';\n      let receivedData = '';\n      let writableClosed = false;\n      let readableClosed = false;\n      \n      const writableStream = new stream.Writable({\n        write(chunk: string, encoding: string, callback: Function) {\n          receivedData += chunk;\n          callback();\n        },\n        close() {\n          writableClosed = true;\n        }\n      });\n      \n      pipeStringToStream(testString, writableStream);\n      \n      setTimeout(() => {\n        expect(receivedData).assertEqual(testString);\n        expect(writableClosed).assertTrue();\n      }, 100);\n    });\n    \n    it('should_handle_empty_string', 0, () => {\n      const testString = '';\n      let receivedData = '';\n      let writableClosed = false;\n      \n      const writableStream = new stream.Writable({\n        write(chunk: string, encoding: string, callback: Function) {\n          receivedData += chunk;\n          callback();\n        },\n        close() {\n          writableClosed = true;\n        }\n      });\n      \n      pipeStringToStream(testString, writableStream);\n      \n      setTimeout(() => {\n        expect(receivedData).assertEqual(testString);\n        expect(writableClosed).assertTrue();\n      }, 100);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `MessageEvents` object, checks if the `data` property is not empty, and if so, appends a predefined string to it using the `data` property and string concatenation.",
    "output": "import {MessageEvents} from '@kit.ArkTS';\n\nexport function logAndClearData(event: MessageEvents): void {\n  console.log(event.data);\n  event.data = undefined;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { readAndWriteInt32BEToLE } from '../main/ets/functions/ArkTS_Buffer_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {buffer} from '@kit.ArkTS';\n\ntype Buffer = buffer.Buffer;\n\nexport default function localUnitTest() { \n  describe('readAndWriteInt32BEToLE_function_test', () => {\n    it('should_read_and_write_correct_value', 0, () => {\n      const buf: Buffer = buffer.from([0x12, 0x34, 0x56, 0x78, 0x00, 0x00, 0x00, 0x00]);\n      const result = readAndWriteInt32BEToLE(buf, 0, 4);\n      expect(result.readInt32LE(4)).assertEqual(0x78563412);\n    });\n\n    it('should_handle_negative_value', 0, () => {\n      const buf: Buffer = buffer.from([0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00]);\n      const result = readAndWriteInt32BEToLE(buf, 0, 4);\n      expect(result.readInt32LE(4)).assertEqual(-2);\n    });\n\n    it('should_handle_zero_value', 0, () => {\n      const buf: Buffer = buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n      const result = readAndWriteInt32BEToLE(buf, 0, 4);\n      expect(result.readInt32LE(4)).assertEqual(0);\n    });\n\n    it('should_handle_max_positive_value', 0, () => {\n      const buf: Buffer = buffer.from([0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00]);\n      const result = readAndWriteInt32BEToLE(buf, 0, 4);\n      expect(result.readInt32LE(4)).assertEqual(2147483647);\n    });\n\n    it('should_handle_min_negative_value', 0, () => {\n      const buf: Buffer = buffer.from([0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n      const result = readAndWriteInt32BEToLE(buf, 0, 4);\n      expect(result.readInt32LE(4)).assertEqual(-2147483648);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createAndStartTask } from '../main/ets/functions/ArkTS_Task_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\ntype Task = taskpool.Task;\n\nexport default function localUnitTest() { \n  describe('createAndStartTask_function_test', () => {\n    it('should_create_task_with_correct_name', 0, () => {\n      const taskName = 'testTask';\n      const testFunc = () => {};\n      const task = createAndStartTask(taskName, testFunc, []);\n      expect(task.name).assertEqual(taskName);\n    });\n\n    it('should_create_task_with_correct_function', 0, () => {\n      const taskName = 'testTask';\n      const testFunc = () => {};\n      const task = createAndStartTask(taskName, testFunc, []);\n      expect(task.function).assertEqual(testFunc);\n    });\n\n    it('should_create_task_with_correct_args', 0, () => {\n      const taskName = 'testTask';\n      const testFunc = () => {};\n      const args = [1, 2, 3];\n      const task = createAndStartTask(taskName, testFunc, args);\n      expect(task.args).assertEqual(args);\n    });\n\n    it('should_return_task_instance', 0, () => {\n      const taskName = 'testTask';\n      const testFunc = () => {};\n      const task = createAndStartTask(taskName, testFunc, []);\n      expect(task instanceof Task).assertTrue();\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { removeDuplicatesAndSort } from '../main/ets/functions/ArkTS_List_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {List} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('removeDuplicatesAndSort_function_test', () => {\n    it('should_remove_duplicates_and_sort_numbers', 0, () => {\n      const list = new List<number>();\n      list.add(3);\n      list.add(1);\n      list.add(2);\n      list.add(3);\n      list.add(1);\n      const result = removeDuplicatesAndSort(list);\n      const expected = new List<number>();\n      expected.add(1);\n      expected.add(2);\n      expected.add(3);\n      expect(result.convertToArray()).assertEqual(expected.convertToArray());\n    });\n\n    it('should_remove_duplicates_and_sort_strings', 0, () => {\n      const list = new List<string>();\n      list.add('banana');\n      list.add('apple');\n      list.add('cherry');\n      list.add('banana');\n      list.add('apple');\n      const result = removeDuplicatesAndSort(list);\n      const expected = new List<string>();\n      expected.add('apple');\n      expected.add('banana');\n      expected.add('cherry');\n      expect(result.convertToArray()).assertEqual(expected.convertToArray());\n    });\n\n    it('should_handle_empty_list', 0, () => {\n      const list = new List<number>();\n      const result = removeDuplicatesAndSort(list);\n      expect(result.convertToArray()).assertEqual([]);\n    });\n\n    it('should_handle_single_element_list', 0, () => {\n      const list = new List<number>();\n      list.add(42);\n      const result = removeDuplicatesAndSort(list);\n      const expected = new List<number>();\n      expected.add(42);\n      expect(result.convertToArray()).assertEqual(expected.convertToArray());\n    });\n\n    it('should_handle_all_duplicates', 0, () => {\n      const list = new List<number>();\n      list.add(5);\n      list.add(5);\n      list.add(5);\n      const result = removeDuplicatesAndSort(list);\n      const expected = new List<number>();\n      expected.add(5);\n      expect(result.convertToArray()).assertEqual(expected.convertToArray());\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { logEventDetails } from '../main/ets/functions/ArkTS_Event_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {Event} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('logEventDetails_function_test', () => {\n    it('should_log_correct_event_type_and_timestamp', 0, () => {\n      const mockEvent: Event = {\n        type: 'click',\n        timeStamp: 123456789\n      };\n      expect(() => { logEventDetails(mockEvent); }).assertUndefined();\n    });\n\n    it('should_handle_empty_event_type', 0, () => {\n      const mockEvent: Event = {\n        type: '',\n        timeStamp: 0\n      };\n      expect(() => { logEventDetails(mockEvent); }).assertUndefined();\n    });\n\n    it('should_handle_negative_timestamp', 0, () => {\n      const mockEvent: Event = {\n        type: 'scroll',\n        timeStamp: -1\n      };\n      expect(() => { logEventDetails(mockEvent); }).assertUndefined();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes an `EncodeIntoUint8ArrayInfo` object and checks if the `read` property is greater than the `written` property, returning a boolean result.",
    "output": "import {util} from '@kit.ArkTS';\ntype EncodeIntoUint8ArrayInfo = util.EncodeIntoUint8ArrayInfo;\n\nexport function isReadGreaterThanWritten(info: EncodeIntoUint8ArrayInfo): boolean {\n  return info.read > info.written;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { getValueOrDefault } from '../main/ets/functions/ArkTS_LightWeightMap_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {LightWeightMap} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('getValueOrDefault_function_test', () => {\n    it('should_return_value_when_key_exists', 0, () => {\n      const map = new LightWeightMap<string, number>();\n      map.set('key1', 42);\n      expect(getValueOrDefault(map, 'key1', 0)).assertEqual(42);\n    });\n\n    it('should_return_default_when_key_does_not_exist', 0, () => {\n      const map = new LightWeightMap<string, number>();\n      expect(getValueOrDefault(map, 'nonexistent', 100)).assertEqual(100);\n    });\n\n    it('should_return_default_when_key_exists_but_value_is_undefined', 0, () => {\n      const map = new LightWeightMap<string, number | undefined>();\n      map.set('key1', undefined);\n      expect(getValueOrDefault(map, 'key1', 100)).assertEqual(100);\n    });\n\n    it('should_work_with_different_types', 0, () => {\n      const map = new LightWeightMap<number, string>();\n      map.set(1, 'value1');\n      expect(getValueOrDefault(map, 1, 'default')).assertEqual('value1');\n      expect(getValueOrDefault(map, 2, 'default')).assertEqual('default');\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { updateEncoding } from '../main/ets/functions/ArkTS_ReadableOptions_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {stream} from '@kit.ArkTS';\ntype ReadableOptions = stream.ReadableOptions;\n\nexport default function localUnitTest() { \n  describe('updateEncoding_function_test', () => {\n    it('should_update_encoding_to_utf8', 0, () => {\n      const options: ReadableOptions = { encoding: 'base64' };\n      updateEncoding(options, 'utf-8');\n      expect(options.encoding).assertEqual('utf-8');\n    });\n\n    it('should_update_encoding_to_base64', 0, () => {\n      const options: ReadableOptions = { encoding: 'utf-8' };\n      updateEncoding(options, 'base64');\n      expect(options.encoding).assertEqual('base64');\n    });\n\n    it('should_throw_error_for_invalid_encoding', 0, () => {\n      const options: ReadableOptions = { encoding: 'utf-8' };\n      expect(() => updateEncoding(options, 'invalid')).assertThrowError('Invalid encoding. Only utf-8 or base64 are allowed.');\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that initializes a `State` object and updates its value based on a given condition **using the `@State` decorator and the `set` method**.",
    "output": "import {taskpool} from '@kit.ArkTS';\ntype State = taskpool.State;\n\nexport function initializeAndUpdateState(initialState: State, condition: boolean): State {\n  @State state: State = initialState;\n  \n  if (condition) {\n    state.set(State.RUNNING);\n  } else {\n    state.set(State.FINISHED);\n  }\n  \n  return state;\n}"
  },
  {
    "instruction": "Write a function that creates a new `Duplex` stream, sets the default encoding using the `setDefaultEncoding` method, writes a string using the `write` method, and ends the stream using the `end` method while verifying the stream is finished using the `writableFinished` property.",
    "output": "import {stream} from '@kit.ArkTS';\ntype Duplex = stream.Duplex;\n\nexport function createAndManageDuplexStream(): void {\n  const duplexStream: Duplex = new stream.Duplex();\n  duplexStream.setDefaultEncoding('utf8');\n  duplexStream.write('Hello, world!', 'utf8');\n  duplexStream.end();\n  console.log(`Stream finished: ${duplexStream.writableFinished}`);\n}"
  },
  {
    "instruction": "Write a function that decodes a stream of `Uint8Array` chunks into a single string using the `TextDecoder` constructor and the `decodeWithStream` method. The encoding should be 'utf-16' and the `fatal` property should be true.",
    "output": "import {util} from '@kit.ArkTS';\ntype TextDecoder = util.TextDecoder;\n\nexport function decodeStream(chunks: Uint8Array[]): string {\n  const decoder = new TextDecoder('utf-16', {fatal: true});\n  let result = '';\n  for (const chunk of chunks) {\n    result += decoder.decodeWithStream(chunk);\n  }\n  return result;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { reverseDeque } from '../main/ets/functions/ArkTS_Deque_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {Deque} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('reverseDeque_function_test', () => {\n    it('should_reverse_empty_deque', 0, () => {\n        const deque = new Deque<number>();\n        reverseDeque(deque);\n        expect(deque.length).assertEqual(0);\n    });\n\n    it('should_reverse_single_element_deque', 0, () => {\n        const deque = new Deque<number>();\n        deque.insertFront(1);\n        reverseDeque(deque);\n        expect(deque.popLast()).assertEqual(1);\n        expect(deque.length).assertEqual(0);\n    });\n\n    it('should_reverse_multiple_elements_deque', 0, () => {\n        const deque = new Deque<number>();\n        deque.insertFront(1);\n        deque.insertFront(2);\n        deque.insertFront(3);\n        reverseDeque(deque);\n        expect(deque.popLast()).assertEqual(1);\n        expect(deque.popLast()).assertEqual(2);\n        expect(deque.popLast()).assertEqual(3);\n        expect(deque.length).assertEqual(0);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `Priority` object, adds five elements to it, removes the highest priority element, and then logs the new highest priority element **using the `add`, `remove`, and `peek` methods**.",
    "output": "import {taskpool} from '@kit.ArkTS';\ntype Priority = taskpool.Priority;\n\nexport function handlePriority(priority: Priority): void {\n  priority.add(1);\n  priority.add(2);\n  priority.add(3);\n  priority.add(4);\n  priority.add(5);\n  priority.remove();\n  console.log(priority.peek());\n}"
  },
  {
    "instruction": "Implement a function that parses an XML string while ignoring doctype declarations (`supportDoctype: false`) and collects all token values using the `tokenValueCallbackFunction` property.",
    "output": "import {xml} from '@kit.ArkTS';\ntype ParseOptions = xml.ParseOptions;\n\nexport function parseXmlString(xmlString: string, tokenValueCallback: (eventType: xml.EventType, value: xml.ParseInfo) => boolean): void {\n  const options: ParseOptions = {\n    supportDoctype: false,\n    tokenValueCallbackFunction: tokenValueCallback\n  };\n  xml.parse(xmlString, options);\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { appendSegmentIfHierarchicalAndAbsolute } from '../main/ets/functions/ArkTS_URI_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {uri} from '@kit.ArkTS';\ntype URI = uri.URI;\n\nexport default function localUnitTest() { \n  describe('appendSegmentIfHierarchicalAndAbsolute_function_test', () => {\n    it('should_append_segment_for_hierarchical_and_absolute_uri', 0, () => {\n      const uriObj: URI = {\n        checkHierarchical: () => true,\n        checkIsAbsolute: () => true,\n        addSegment: (segment: string) => ({ ...uriObj, path: segment })\n      } as URI;\n      const result = appendSegmentIfHierarchicalAndAbsolute(uriObj, 'newSegment');\n      expect(result).not().assertEqual(uriObj);\n    });\n\n    it('should_not_append_segment_for_non_hierarchical_uri', 0, () => {\n      const uriObj: URI = {\n        checkHierarchical: () => false,\n        checkIsAbsolute: () => true,\n        addSegment: (segment: string) => ({ ...uriObj, path: segment })\n      } as URI;\n      const result = appendSegmentIfHierarchicalAndAbsolute(uriObj, 'newSegment');\n      expect(result).assertEqual(uriObj);\n    });\n\n    it('should_not_append_segment_for_non_absolute_uri', 0, () => {\n      const uriObj: URI = {\n        checkHierarchical: () => true,\n        checkIsAbsolute: () => false,\n        addSegment: (segment: string) => ({ ...uriObj, path: segment })\n      } as URI;\n      const result = appendSegmentIfHierarchicalAndAbsolute(uriObj, 'newSegment');\n      expect(result).assertEqual(uriObj);\n    });\n\n    it('should_not_append_segment_for_non_hierarchical_and_non_absolute_uri', 0, () => {\n      const uriObj: URI = {\n        checkHierarchical: () => false,\n        checkIsAbsolute: () => false,\n        addSegment: (segment: string) => ({ ...uriObj, path: segment })\n      } as URI;\n      const result = appendSegmentIfHierarchicalAndAbsolute(uriObj, 'newSegment');\n      expect(result).assertEqual(uriObj);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that initializes a `Writable` stream, writes a string to it using the `write` method, and checks if the stream is still writable using the `writable` property.",
    "output": "import {stream} from '@kit.ArkTS';\ntype Writable = stream.Writable;\n\nexport function writeToStream(): void {\n  const writableStream = new Writable();\n  const data: string = 'Hello, World!';\n  const isWritten: boolean = writableStream.write(data);\n  const isWritable: boolean = writableStream.writable;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { encodeStringToUint8Array } from '../main/ets/functions/ArkTS_TextEncoder_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\ntype TextEncoder = util.TextEncoder;\n\nexport default function localUnitTest() { \n  describe('encodeStringToUint8Array_test', () => {\n    it('should_return_correct_bytes_written', 0, () => {\n        const dest = new Uint8Array(10);\n        const input = 'hello';\n        const bytesWritten = encodeStringToUint8Array(input, dest);\n        expect(bytesWritten).assertEqual(5);\n    });\n\n    it('should_return_zero_for_empty_string', 0, () => {\n        const dest = new Uint8Array(10);\n        const input = '';\n        const bytesWritten = encodeStringToUint8Array(input, dest);\n        expect(bytesWritten).assertEqual(0);\n    });\n\n    it('should_return_zero_for_insufficient_dest_space', 0, () => {\n        const dest = new Uint8Array(2);\n        const input = 'hello';\n        const bytesWritten = encodeStringToUint8Array(input, dest);\n        expect(bytesWritten).assertEqual(2);\n    });\n\n    it('should_handle_unicode_characters', 0, () => {\n        const dest = new Uint8Array(10);\n        const input = '😊';\n        const bytesWritten = encodeStringToUint8Array(input, dest);\n        expect(bytesWritten).assertEqual(4);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { getValueOrDefault } from '../main/ets/functions/ArkTS_LightWeightMap_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {LightWeightMap} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('getValueOrDefault_function_test', () => {\n    it('should_return_value_when_key_exists', 0, () => {\n      const map = new LightWeightMap<string, number>();\n      map.set('key1', 42);\n      expect(getValueOrDefault(map, 'key1', 0)).assertEqual(42);\n    });\n\n    it('should_return_default_when_key_does_not_exist', 0, () => {\n      const map = new LightWeightMap<string, number>();\n      map.set('key1', 42);\n      expect(getValueOrDefault(map, 'key2', 0)).assertEqual(0);\n    });\n\n    it('should_handle_empty_map', 0, () => {\n      const map = new LightWeightMap<string, number>();\n      expect(getValueOrDefault(map, 'key1', 0)).assertEqual(0);\n    });\n\n    it('should_work_with_different_types', 0, () => {\n      const map = new LightWeightMap<number, string>();\n      map.set(1, 'value1');\n      expect(getValueOrDefault(map, 1, 'default')).assertEqual('value1');\n      expect(getValueOrDefault(map, 2, 'default')).assertEqual('default');\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { intersectScopes } from '../main/ets/functions/ArkTS_Scope_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype Scope = util.Scope;\n\nexport default function localUnitTest() { \n  describe('intersectScopes_function_test', () => {\n    it('should_return_intersection_of_two_scopes', 0, () => {\n      const scope1: Scope = new util.Scope(1, 10);\n      const scope2: Scope = new util.Scope(5, 15);\n      const result: Scope = intersectScopes(scope1, scope2);\n      expect(result.toString()).assertEqual('Scope{lower=5, upper=10}');\n    });\n\n    it('should_return_empty_scope_when_no_intersection', 0, () => {\n      const scope1: Scope = new util.Scope(1, 5);\n      const scope2: Scope = new util.Scope(10, 15);\n      const result: Scope = intersectScopes(scope1, scope2);\n      expect(result.toString()).assertEqual('Scope{lower=5, upper=5}');\n    });\n\n    it('should_return_same_scope_when_scopes_are_equal', 0, () => {\n      const scope1: Scope = new util.Scope(5, 10);\n      const scope2: Scope = new util.Scope(5, 10);\n      const result: Scope = intersectScopes(scope1, scope2);\n      expect(result.toString()).assertEqual('Scope{lower=5, upper=10}');\n    });\n\n    it('should_return_partial_intersection_when_one_scope_is_within_another', 0, () => {\n      const scope1: Scope = new util.Scope(1, 20);\n      const scope2: Scope = new util.Scope(5, 10);\n      const result: Scope = intersectScopes(scope1, scope2);\n      expect(result.toString()).assertEqual('Scope{lower=5, upper=10}');\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that creates a `ThreadWorkerGlobalScope` object, sets up an `onmessage` handler to process incoming messages by converting them to uppercase, and uses `postMessage` to send the processed message back to the main thread.",
    "output": "import {ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createWorkerScope(): ThreadWorkerGlobalScope {\n  const workerScope = new ThreadWorkerGlobalScope();\n  \n  workerScope.onmessage = (event: { data: string }) => {\n    const processedMessage = event.data.toUpperCase();\n    workerScope.postMessage(processedMessage);\n  };\n  \n  return workerScope;\n}"
  },
  {
    "instruction": "Write a function that creates a `StringDecoder` object, writes a buffer to it using the `write` method, and then checks if the decoder has any remaining data by calling the `end` method without arguments.",
    "output": "import {util} from '@kit.ArkTS';\ntype StringDecoder = util.StringDecoder;\n\nexport function decodeBuffer(buffer: Uint8Array): string {\n  const decoder = new StringDecoder('utf-8');\n  decoder.write(buffer);\n  return decoder.end();\n}"
  },
  {
    "instruction": "Write a function that takes a `URI` object and normalizes its path, then checks if the URI is absolute. Use the `normalize` method and the `checkIsAbsolute` property.",
    "output": "import {uri} from '@kit.ArkTS';\ntype URI = uri.URI;\n\nexport function normalizeAndCheckAbsolute(uriObj: URI): boolean {\n  const normalizedUri = uriObj.normalize();\n  return normalizedUri.checkIsAbsolute();\n}"
  },
  {
    "instruction": "Write a function that takes a `ConvertOptions` object and sets custom key names for XML elements, text, and parent nodes, while also ignoring CDATA sections **using the `elementsKey`, `textKey`, `parentKey`, and `ignoreCDATA` properties**.",
    "output": "import {xml} from '@kit.ArkTS';\ntype ConvertOptions = xml.ConvertOptions;\n\nexport function setConvertOptions(options: ConvertOptions): void {\n  if (options.elementsKey) {\n    options.elementsKey = options.elementsKey;\n  }\n  if (options.textKey) {\n    options.textKey = options.textKey;\n  }\n  if (options.parentKey) {\n    options.parentKey = options.parentKey;\n  }\n  if (options.ignoreCDATA !== undefined) {\n    options.ignoreCDATA = options.ignoreCDATA;\n  }\n}"
  },
  {
    "instruction": "Write a function that registers an event listener for a keyboard input and removes it after the first trigger, using the `on` and `off` methods of `EventListener`.",
    "output": "import { EventListener } from '@kit.ArkTS';\n\nexport function setupButtonClickListener(buttonId: string): void {\n  const listener = new EventListener();\n  \n  listener.on('click', (event: string): void => {\n    console.log('Button clicked (on)');\n  });\n  \n  listener.once('click', (event: string): void => {\n    console.log('Button clicked (once)');\n  });\n  \n  // In a real ArkTS application, you would connect this to an actual button component\n  // For example, using @Component and @State to handle button clicks\n  // This simplified version just shows the event listener setup\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { decodeBinaryStream } from '../main/ets/functions/ArkTS_TextDecoder_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype TextDecoder = util.TextDecoder;\n\nexport default function localUnitTest() { \n  describe('decodeBinaryStream_function_test', () => {\n    it('should_decode_valid_utf8_chunks', 0, () => {\n      const inputChunks = [\n        new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f]), // 'Hello'\n        new Uint8Array([0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64]) // ' World'\n      ];\n      const result = decodeBinaryStream(inputChunks);\n      expect(result).assertEqual('Hello World');\n    });\n\n    it('should_throw_error_for_invalid_sequence_when_fatal_true', 0, () => {\n      const inputChunks = [\n        new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f]), // 'Hello'\n        new Uint8Array([0x80]) // Invalid UTF-8 sequence\n      ];\n      expect(() => decodeBinaryStream(inputChunks, true)).assertThrowError('Invalid sequence encountered during decoding.');\n    });\n\n    it('should_not_throw_error_for_invalid_sequence_when_fatal_false', 0, () => {\n      const inputChunks = [\n        new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f]), // 'Hello'\n        new Uint8Array([0x80]) // Invalid UTF-8 sequence\n      ];\n      const result = decodeBinaryStream(inputChunks, false);\n      expect(result).assertEqual('Hello\\ufffd');\n    });\n\n    it('should_return_empty_string_for_empty_chunks', 0, () => {\n      const inputChunks: Uint8Array[] = [];\n      const result = decodeBinaryStream(inputChunks);\n      expect(result).assertEqual('');\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that simulates a long-running task by combining `setTimeout` and `Promise` to delay execution for a specified duration, then logs a completion message. Use the `setTimeout` method to delay and the `Promise` constructor to wrap the task.",
    "output": "import {taskpool} from '@kit.ArkTS';\ntype LongTask = taskpool.LongTask;\n\nexport function simulateLongTask(duration: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      console.log('Task completed after ' + duration + 'ms');\n      resolve();\n    }, duration);\n  });\n}\n\nexport class CustomLongTask {\n  private duration: number;\n\n  constructor(duration: number) {\n    this.duration = duration;\n  }\n\n  async run(): Promise<void> {\n    await simulateLongTask(this.duration);\n  }\n}"
  },
  {
    "instruction": "Write a function that takes an `EncodeIntoUint8ArrayInfo` object and calculates the ratio of `written` to `read` properties, then returns the result as a float.",
    "output": "import {util} from '@kit.ArkTS';\ntype EncodeIntoUint8ArrayInfo = util.EncodeIntoUint8ArrayInfo;\n\nexport function calculateRatio(info: EncodeIntoUint8ArrayInfo): float {\n  return info.written / info.read;\n}"
  },
  {
    "instruction": "Write a function that logs the type and timestamp of an event object using the `type` and `timeStamp` properties.",
    "output": "import {Event} from '@kit.ArkTS';\n\nexport function logEventDetails(event: Event): void {\n  console.log(`Event Type: ${event.type}, Timestamp: ${event.timeStamp}`);\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { pipeStream } from '../main/ets/functions/ArkTS_Readable_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {stream} from '@kit.ArkTS';\n\ntype Readable = stream.Readable;\n\nexport default function localUnitTest() { \n  describe('pipeStream_function_test', () => {\n    it('should_pipe_stream_and_return_destination', 0, () => {\n      const source = new stream.Readable();\n      const destination = new stream.Writable();\n      const result = pipeStream(source, destination);\n      expect(result).assertEqual(destination);\n    });\n\n    it('should_have_correct_flowing_state_after_pipe', 0, () => {\n      const source = new stream.Readable();\n      const destination = new stream.Writable();\n      pipeStream(source, destination);\n      expect(source.readableFlowing).assertEqual(true);\n    });\n\n    it('should_have_readableLength_property_accessible', 0, () => {\n      const source = new stream.Readable();\n      const destination = new stream.Writable();\n      pipeStream(source, destination);\n      expect(source.readableLength).assertEqual(0);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { checkStreamEnabled } from '../main/ets/functions/ArkTS_DecodeToStringOptions_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype DecodeToStringOptions = util.DecodeToStringOptions;\n\nexport default function localUnitTest() { \n  describe('checkStreamEnabled_function_test', () => {\n    it('should_log_enabled_when_stream_true', 0, () => {\n      const options: DecodeToStringOptions = { stream: true };\n      expect(checkStreamEnabled(options)).assertUndefined();\n    });\n\n    it('should_log_disabled_when_stream_false', 0, () => {\n      const options: DecodeToStringOptions = { stream: false };\n      expect(checkStreamEnabled(options)).assertUndefined();\n    });\n\n    it('should_log_disabled_when_stream_undefined', 0, () => {\n      const options: DecodeToStringOptions = {};\n      expect(checkStreamEnabled(options)).assertUndefined();\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { getValueFromLRUCache } from '../main/ets/functions/ArkTS_LRUCache_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype LRUCache = util.LRUCache;\n\nexport default function localUnitTest() { \n  describe('getValueFromLRUCache_test', () => {\n    it('should_return_value_when_key_exists', 0, () => {\n      const cache = new util.LRUCache<string, number>(2);\n      cache.put('key1', 100);\n      expect(getValueFromLRUCache(cache, 'key1')).assertEqual(100);\n    });\n\n    it('should_return_null_when_key_does_not_exist', 0, () => {\n      const cache = new util.LRUCache<string, number>(2);\n      expect(getValueFromLRUCache(cache, 'nonexistent')).assertEqual(null);\n    });\n\n    it('should_return_null_when_cache_is_empty', 0, () => {\n      const cache = new util.LRUCache<string, number>(2);\n      expect(getValueFromLRUCache(cache, 'anykey')).assertEqual(null);\n    });\n\n    it('should_return_null_when_value_is_undefined', 0, () => {\n      const cache = new util.LRUCache<string, number | undefined>(2);\n      cache.put('key1', undefined);\n      expect(getValueFromLRUCache(cache, 'key1')).assertEqual(null);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `Type` object and checks if it is a primitive type or an object type. Use the `typeof` operator and the `instanceof` operator to determine the type.",
    "output": "import {util} from '@kit.ArkTS';\ntype Type = util.Type;\n\nexport function checkType(value: Type): string {\n  if (typeof value === 'number' || typeof value === 'string' || typeof value === 'boolean') {\n    return 'primitive';\n  } else if (typeof value === 'object' && value !== null) {\n    return 'object';\n  } else {\n    return 'unknown';\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { checkAndAdd } from '../main/ets/functions/ArkTS_LruBuffer_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype LruBuffer = util.LruBuffer;\n\nexport default function localUnitTest() { \n  describe('checkAndAdd_function_test', () => {\n    it('should_add_key_and_return_length_when_key_not_present', 0, () => {\n      const buffer: LruBuffer<string, number> = new util.LruBuffer(5);\n      const initialLength = buffer.length;\n      const result = checkAndAdd(buffer, 'key1', 100);\n      expect(result).assertEqual(initialLength + 1);\n    });\n\n    it('should_not_add_key_and_return_same_length_when_key_present', 0, () => {\n      const buffer: LruBuffer<string, number> = new util.LruBuffer(5);\n      buffer.put('key1', 100);\n      const initialLength = buffer.length;\n      const result = checkAndAdd(buffer, 'key1', 200);\n      expect(result).assertEqual(initialLength);\n    });\n\n    it('should_handle_empty_buffer_correctly', 0, () => {\n      const buffer: LruBuffer<string, number> = new util.LruBuffer(5);\n      const initialLength = buffer.length;\n      const result = checkAndAdd(buffer, 'key1', 100);\n      expect(result).assertEqual(initialLength + 1);\n    });\n\n    it('should_handle_full_buffer_correctly', 0, () => {\n      const buffer: LruBuffer<string, number> = new util.LruBuffer(2);\n      buffer.put('key1', 100);\n      buffer.put('key2', 200);\n      const initialLength = buffer.length;\n      const result = checkAndAdd(buffer, 'key3', 300);\n      expect(result).assertEqual(initialLength);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { checkAndKillProcess } from '../main/ets/functions/ArkTS_ProcessManager_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {process} from '@kit.ArkTS';\ntype ProcessManager = process.ProcessManager;\n\nexport default function localUnitTest() { \n  describe('checkAndKillProcess_function_test', () => {\n    it('should_return_true_when_uid_is_app_and_kill_succeeds', 0, () => {\n      // Mock process methods\n      const originalIsAppUid = process.isAppUid;\n      const originalKill = process.kill;\n      process.isAppUid = (uid: number): boolean => true;\n      process.kill = (signal: number, uid: number): boolean => true;\n      \n      expect(checkAndKillProcess(123)).assertEqual(true);\n      \n      // Restore original methods\n      process.isAppUid = originalIsAppUid;\n      process.kill = originalKill;\n    });\n    \n    it('should_return_false_when_uid_is_not_app', 0, () => {\n      // Mock process methods\n      const originalIsAppUid = process.isAppUid;\n      const originalKill = process.kill;\n      process.isAppUid = (uid: number): boolean => false;\n      process.kill = (signal: number, uid: number): boolean => false;\n      \n      expect(checkAndKillProcess(456)).assertEqual(false);\n      \n      // Restore original methods\n      process.isAppUid = originalIsAppUid;\n      process.kill = originalKill;\n    });\n    \n    it('should_return_false_when_kill_fails', 0, () => {\n      // Mock process methods\n      const originalIsAppUid = process.isAppUid;\n      const originalKill = process.kill;\n      process.isAppUid = (uid: number): boolean => true;\n      process.kill = (signal: number, uid: number): boolean => false;\n      \n      expect(checkAndKillProcess(789)).assertEqual(false);\n      \n      // Restore original methods\n      process.isAppUid = originalIsAppUid;\n      process.kill = originalKill;\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes an `EventType` object and logs its properties **using the `Object.keys` method and `console.log` function**.",
    "output": "import {xml} from '@kit.ArkTS';\ntype EventType = xml.EventType;\n\nexport function logEventTypeProperties(eventType: EventType): void {\n  const keys = Object.keys(eventType);\n  console.log(keys.toString());\n}"
  },
  {
    "instruction": "Write a function that decodes a given UTF-8 encoded ArrayBuffer into a string using `TextDecoder`, with the `fatal` property set to true and the `ignoreBOM` property set to false.",
    "output": "import {util} from '@kit.ArkTS';\ntype TextDecoderOptions = util.TextDecoderOptions;\n\nexport function decodeUtf8(buffer: ArrayBuffer): string {\n  const options: TextDecoderOptions = {\n    fatal: true,\n    ignoreBOM: false\n  };\n  const decoder = new util.TextDecoder('utf-8', options);\n  return decoder.decode(buffer);\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createAndTransform } from '../main/ets/functions/ArkTS_Transform_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {stream} from '@kit.ArkTS';\ntype Transform = stream.Transform;\n\nexport default function localUnitTest() { \n  describe('createAndTransform_function_test', () => {\n    it('should_transform_chunk_to_uppercase', 0, () => {\n      const transform: Transform = createAndTransform();\n      let transformedData = '';\n      transform.on('data', (chunk: string) => {\n        transformedData += chunk;\n      });\n      transform.write('hello');\n      transform.end();\n      expect(transformedData).assertEqual('HELLO');\n    });\n\n    it('should_call_flush_callback', 0, () => {\n      const transform: Transform = createAndTransform();\n      let flushCalled = false;\n      transform.on('end', () => {\n        flushCalled = true;\n      });\n      transform.end();\n      expect(flushCalled).assertTrue();\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { transformList } from '../main/ets/functions/ArkTS_List_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {List} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('transformList_function_test', () => {\n    it('should_return_empty_list_when_input_empty', 0, () => {\n        const inputList = new List<number>();\n        const result = transformList(inputList, (value: number) => value * 2);\n        expect(result.length).assertEqual(0);\n    });\n\n    it('should_transform_numbers_correctly', 0, () => {\n        const inputList = new List<number>();\n        inputList.add(1);\n        inputList.add(2);\n        inputList.add(3);\n        const result = transformList(inputList, (value: number) => value * 2);\n        expect(result.get(0)).assertEqual(2);\n        expect(result.get(1)).assertEqual(4);\n        expect(result.get(2)).assertEqual(6);\n    });\n\n    it('should_transform_strings_correctly', 0, () => {\n        const inputList = new List<string>();\n        inputList.add('a');\n        inputList.add('b');\n        inputList.add('c');\n        const result = transformList(inputList, (value: string) => value.toUpperCase());\n        expect(result.get(0)).assertEqual('A');\n        expect(result.get(1)).assertEqual('B');\n        expect(result.get(2)).assertEqual('C');\n    });\n\n    it('should_transform_to_different_type', 0, () => {\n        const inputList = new List<number>();\n        inputList.add(1);\n        inputList.add(2);\n        inputList.add(3);\n        const result = transformList(inputList, (value: number) => value.toString());\n        expect(result.get(0)).assertEqual('1');\n        expect(result.get(1)).assertEqual('2');\n        expect(result.get(2)).assertEqual('3');\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that creates a Worker with a specified name and checks if it can share memory using the `name` and `shared` properties of `WorkerOptions`.",
    "output": "import {WorkerOptions} from '@kit.ArkTS';\n\nexport function createWorkerWithOptions(name: string, shared: boolean): Worker {\n  const options: WorkerOptions = {\n    name: name,\n    shared: shared\n  };\n  return new Worker('', options);\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { WorkerHandler } from '../main/ets/functions/ArkTS_WorkerEventListener_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {WorkerEventListener} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('WorkerHandler_class_test', () => {\n    it('should_log_message_on_onmessage', 0, () => {\n      const workerHandler = new WorkerHandler();\n      const testMessage = 'Test message from worker';\n      const mockEvent = {\n        data: testMessage\n      };\n      \n      let loggedMessage = '';\n      const originalLog = console.log;\n      Object.defineProperty(console, 'log', {\n        value: (msg: string) => { loggedMessage = msg; },\n        writable: true\n      });\n      \n      workerHandler.onmessage(mockEvent);\n      expect(loggedMessage).assertEqual(`Worker thread completed task with message: ${testMessage}`);\n      \n      Object.defineProperty(console, 'log', {\n        value: originalLog,\n        writable: true\n      });\n    });\n\n    it('should_have_postMessage_method', 0, () => {\n      const workerHandler = new WorkerHandler();\n      expect(workerHandler.postMessage !== undefined).assertTrue();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `List` object and checks if it contains any duplicate values. If duplicates are found, remove all but the first occurrence of each value. Use the `has`, `getIndexOf`, and `remove` methods.",
    "output": "import {List} from '@kit.ArkTS';\n\nexport function removeDuplicates<T>(list: List<T>): void {\n  const seen = new Set<T>();\n  let i = 0;\n  while (i < list.length) {\n    const element = list.get(i);\n    if (seen.has(element)) {\n      list.remove(element);\n    } else {\n      seen.add(element);\n      i++;\n    }\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { encodeAndDecodeString } from '../main/ets/functions/ArkTS_Base64_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\ntype Base64 = util.Base64;\n\nexport default function localUnitTest() { \n  describe('encodeAndDecodeString_function_test', () => {\n    it('should_return_original_string_for_empty_input', 0, async () => {\n        const result = await encodeAndDecodeString('');\n        expect(result).assertEqual('');\n    });\n    it('should_return_original_string_for_ascii_input', 0, async () => {\n        const result = await encodeAndDecodeString('Hello World');\n        expect(result).assertEqual('Hello World');\n    });\n    it('should_return_original_string_for_unicode_input', 0, async () => {\n        const result = await encodeAndDecodeString('你好，世界');\n        expect(result).assertEqual('你好，世界');\n    });\n    it('should_return_original_string_for_special_chars_input', 0, async () => {\n        const result = await encodeAndDecodeString('!@#$%^&*()');\n        expect(result).assertEqual('!@#$%^&*()');\n    });\n    it('should_return_original_string_for_long_input', 0, async () => {\n        const longString = 'a'.repeat(1000);\n        const result = await encodeAndDecodeString(longString);\n        expect(result).assertEqual(longString);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { removeFirstAndLastEntries } from '../main/ets/functions/ArkTS_TreeMap_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {TreeMap} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('removeFirstAndLastEntries_test', () => {\n    it('should_return_correct_length_after_removal', 0, () => {\n      const treeMap = new TreeMap<number, string>();\n      treeMap.set(1, 'one');\n      treeMap.set(2, 'two');\n      treeMap.set(3, 'three');\n      \n      const result = removeFirstAndLastEntries(treeMap);\n      expect(result).assertEqual(1);\n    });\n\n    it('should_return_0_for_empty_map', 0, () => {\n      const treeMap = new TreeMap<number, string>();\n      \n      const result = removeFirstAndLastEntries(treeMap);\n      expect(result).assertEqual(0);\n    });\n\n    it('should_return_0_for_single_entry_map', 0, () => {\n      const treeMap = new TreeMap<number, string>();\n      treeMap.set(1, 'one');\n      \n      const result = removeFirstAndLastEntries(treeMap);\n      expect(result).assertEqual(0);\n    });\n\n    it('should_return_1_for_two_entries_map', 0, () => {\n      const treeMap = new TreeMap<number, string>();\n      treeMap.set(1, 'one');\n      treeMap.set(2, 'two');\n      \n      const result = removeFirstAndLastEntries(treeMap);\n      expect(result).assertEqual(0);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that creates an XML document with a root element, adds a child element with attributes, and includes a CDATA section using the `constructor`, `startElement`, `setAttributes`, and `setCDATA` methods.",
    "output": "import {xml} from '@kit.ArkTS';\ntype XmlSerializer = xml.XmlSerializer;\n\nexport function createXmlDocument(): string {\n  const buffer = new ArrayBuffer(1024);\n  const serializer = new XmlSerializer(buffer);\n  \n  serializer.startElement('root');\n  serializer.startElement('child');\n  serializer.setAttributes('attr1', 'value1');\n  serializer.setAttributes('attr2', 'value2');\n  serializer.setCDATA('<![CDATA[This is a CDATA section]]>');\n  \n  return serializer.toString();\n}"
  },
  {
    "instruction": "Write a function that parses an XML string with BigInt support enabled and ignores DOCTYPE declarations by setting the `bigIntMode` and `supportDoctype` properties.",
    "output": "import { json } from '@kit.ArkTS';\ntype ParseOptions = json.ParseOptions;\n\nexport function parseXmlWithBigInt(xmlString: string): object | null {\n  const options: ParseOptions = {\n    bigIntMode: json.BigIntMode.STRING\n  };\n  return json.parse(xmlString, options) as object | null;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { checkWorkerName } from '../main/ets/functions/ArkTS_WorkerGlobalScope_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {WorkerGlobalScope} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('checkWorkerName_function_test', () => {\n    it('should_set_onerror_when_names_mismatch', 0, () => {\n      const mockWorkerScope: WorkerGlobalScope = {\n        name: 'worker1',\n        onerror: null\n      };\n      const nameToCheck = 'worker2';\n      checkWorkerName(mockWorkerScope, nameToCheck);\n      expect(mockWorkerScope.onerror).not().assertEqual(null);\n    });\n\n    it('should_not_set_onerror_when_names_match', 0, () => {\n      const mockWorkerScope: WorkerGlobalScope = {\n        name: 'worker1',\n        onerror: null\n      };\n      const nameToCheck = 'worker1';\n      checkWorkerName(mockWorkerScope, nameToCheck);\n      expect(mockWorkerScope.onerror).assertEqual(null);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { sumTypedArray } from '../main/ets/functions/ArkTS_TypedArray_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {buffer} from '@kit.ArkTS';\n\ntype TypedArray = buffer.TypedArray;\n\nexport default function localUnitTest() { \n  describe('sumTypedArray_function_test', () => {\n    it('should_return_correct_sum_for_Int8Array', 0, () => {\n        const arr = new Int8Array([1, 2, 3]);\n        expect(sumTypedArray(arr)).assertEqual(6);\n    });\n    it('should_return_correct_sum_for_Uint8Array', 0, () => {\n        const arr = new Uint8Array([1, 2, 3]);\n        expect(sumTypedArray(arr)).assertEqual(6);\n    });\n    it('should_return_correct_sum_for_Int16Array', 0, () => {\n        const arr = new Int16Array([1, 2, 3]);\n        expect(sumTypedArray(arr)).assertEqual(6);\n    });\n    it('should_return_correct_sum_for_Uint16Array', 0, () => {\n        const arr = new Uint16Array([1, 2, 3]);\n        expect(sumTypedArray(arr)).assertEqual(6);\n    });\n    it('should_return_correct_sum_for_Int32Array', 0, () => {\n        const arr = new Int32Array([1, 2, 3]);\n        expect(sumTypedArray(arr)).assertEqual(6);\n    });\n    it('should_return_correct_sum_for_Uint32Array', 0, () => {\n        const arr = new Uint32Array([1, 2, 3]);\n        expect(sumTypedArray(arr)).assertEqual(6);\n    });\n    it('should_return_correct_sum_for_Float32Array', 0, () => {\n        const arr = new Float32Array([1.5, 2.5, 3.5]);\n        expect(sumTypedArray(arr)).assertEqual(7.5);\n    });\n    it('should_return_correct_sum_for_Float64Array', 0, () => {\n        const arr = new Float64Array([1.5, 2.5, 3.5]);\n        expect(sumTypedArray(arr)).assertEqual(7.5);\n    });\n    it('should_return_zero_for_empty_array', 0, () => {\n        const arr = new Int8Array([]);\n        expect(sumTypedArray(arr)).assertEqual(0);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that constructs a `Transform` object, chains two transformations using the `doTransform` method, and verifies the result by flushing it using the `doFlush` method.",
    "output": "import {stream} from '@kit.ArkTS';\ntype Transform = stream.Transform;\n\nexport function createAndChainTransform(): Transform {\n  const transform = new stream.Transform();\n  \n  transform.doTransform = (chunk: string, encoding: string, callback: () => void): void => {\n    const transformedChunk = chunk.toUpperCase();\n    transform.push(transformedChunk);\n    callback();\n  };\n  \n  transform.doFlush = (callback: () => void): void => {\n    transform.push('FLUSHED');\n    callback();\n  };\n\n  return transform;\n}"
  },
  {
    "instruction": "Write a function that initializes a `Readable` stream, reads data from it while checking if it is paused, and resumes the stream if paused. Use the `doInitialize`, `doRead`, `isPaused`, and `resume` methods.",
    "output": "import {stream} from '@kit.ArkTS';\ntype Readable = stream.Readable;\n\nexport function initializeAndReadStream(stream: Readable, size: number, callback: (error?: Error) => void): void {\n  stream.doInitialize(() => {\n    if (stream.isPaused()) {\n      stream.resume();\n    }\n    try {\n      stream.doRead(size);\n      callback();\n    } catch (error) {\n      callback(error as Error);\n    }\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { hasDuplicateComparable } from '../main/ets/functions/ArkTS_ScopeComparable_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype ScopeComparable = util.ScopeComparable;\n\nexport default function localUnitTest() { \n  describe('hasDuplicateComparable_function_test', () => {\n    it('should_return_true_when_duplicates_exist', 0, () => {\n      const obj1: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      const obj2: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      expect(hasDuplicateComparable([obj1, obj2])).assertEqual(true);\n    });\n\n    it('should_return_false_when_no_duplicates', 0, () => {\n      const obj1: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => false\n      };\n      const obj2: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => false\n      };\n      expect(hasDuplicateComparable([obj1, obj2])).assertEqual(false);\n    });\n\n    it('should_return_false_for_empty_array', 0, () => {\n      expect(hasDuplicateComparable([])).assertEqual(false);\n    });\n\n    it('should_return_false_for_single_element', 0, () => {\n      const obj1: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      expect(hasDuplicateComparable([obj1])).assertEqual(false);\n    });\n\n    it('should_return_true_for_multiple_duplicates', 0, () => {\n      const obj1: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      const obj2: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      const obj3: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      expect(hasDuplicateComparable([obj1, obj2, obj3])).assertEqual(true);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `MessageEvents` object and logs the value of its `data` property, then clears the `data` property.",
    "output": "import {MessageEvents} from '@kit.ArkTS';\n\nexport function logAndClearData(event: MessageEvents): void {\n  console.log(event.data);\n  // Note: Since 'data' is readonly, it cannot be directly cleared or modified.\n  // This function logs the data but cannot clear it due to API constraints.\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { setupWorkerWithErrorHandling } from '../main/ets/functions/ArkTS_ThreadWorker_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {worker} from '@kit.ArkTS';\n\ntype ThreadWorker = worker.ThreadWorker;\n\nexport default function localUnitTest() { \n  describe('setupWorkerWithErrorHandling_function_test', () => {\n    it('should_handle_null_workerInstance', 0, () => {\n      setupWorkerWithErrorHandling(null as unknown as ThreadWorker);\n      expect(true).assertTrue();\n    });\n\n    it('should_set_onerror_handler', 0, () => {\n      const mockWorker: ThreadWorker = {\n        onerror: undefined,\n        removeAllListener: () => {},\n        terminate: () => {},\n        onmessage: undefined,\n        onmessageerror: undefined,\n        postMessage: () => {},\n        onexit: undefined\n      };\n      setupWorkerWithErrorHandling(mockWorker);\n      expect(mockWorker.onerror !== undefined).assertTrue();\n    });\n\n    it('should_call_removeAllListener_and_terminate_on_error', 0, () => {\n      let removeAllListenerCalled = false;\n      let terminateCalled = false;\n      const mockWorker: ThreadWorker = {\n        onerror: undefined,\n        removeAllListener: () => { removeAllListenerCalled = true; },\n        terminate: () => { terminateCalled = true; },\n        onmessage: undefined,\n        onmessageerror: undefined,\n        postMessage: () => {},\n        onexit: undefined\n      };\n      setupWorkerWithErrorHandling(mockWorker);\n      \n      if (mockWorker.onerror) {\n        const errorEvent: worker.ErrorEvent = {\n          message: 'Test error',\n          filename: '',\n          lineno: 0,\n          colno: 0,\n          error: null,\n          type: '',\n          timeStamp: 0\n        };\n        mockWorker.onerror(errorEvent);\n      }\n      \n      expect(removeAllListenerCalled).assertTrue();\n      expect(terminateCalled).assertTrue();\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { getHostnameAndPathname } from '../main/ets/functions/ArkTS_URL_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {url} from '@kit.ArkTS';\ntype URL = url.URL;\n\nexport default function localUnitTest() { \n  describe('getHostnameAndPathname_function_test', () => {\n    it('should_return_hostname_and_pathname', 0, () => {\n        expect(getHostnameAndPathname('https://example.com/path/to/resource')).assertEqual('example.com/path/to/resource');\n    });\n    it('should_return_hostname_with_empty_pathname', 0, () => {\n        expect(getHostnameAndPathname('https://example.com')).assertEqual('example.com');\n    });\n    it('should_throw_error_for_invalid_url', 0, () => {\n        expect(() => getHostnameAndPathname('not_a_valid_url')).toThrowError();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `MessageEvents` object and logs the value of its `data` property, then clears the `data` property **using the `data` property and a custom clear method**.",
    "output": "import {MessageEvents} from '@kit.ArkTS';\n\nexport function logAndClearData(event: MessageEvents): void {\n  console.log(event.data);\n  event.data = undefined;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { pipeStringToStream } from '../main/ets/functions/ArkTS_stream_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {stream} from '@kit.ArkTS';\nimport fs from '@ohos.file.fs';\n\nexport default function localUnitTest() { \n  describe('pipeStringToStream_function_test', () => {\n    it('should_pipe_string_to_file_correctly', 0, () => {\n      const testString = 'Hello, World!';\n      const testFilePath = 'test_output.txt';\n      \n      pipeStringToStream(testString, testFilePath);\n      \n      // Verify file content after streams finish\n      setTimeout(() => {\n        const fileContent = fs.readTextSync(testFilePath);\n        expect(fileContent).assertEqual(testString);\n        \n        // Clean up\n        fs.unlink(testFilePath);\n      }, 1000);\n    });\n    \n    it('should_handle_empty_string', 0, () => {\n      const testString = '';\n      const testFilePath = 'empty_output.txt';\n      \n      pipeStringToStream(testString, testFilePath);\n      \n      setTimeout(() => {\n        const fileContent = fs.readTextSync(testFilePath);\n        expect(fileContent).assertEqual(testString);\n        \n        // Clean up\n        fs.unlink(testFilePath);\n      }, 1000);\n    });\n    \n    it('should_handle_large_string', 0, () => {\n      const testString = 'A'.repeat(10000); // 10KB string\n      const testFilePath = 'large_output.txt';\n      \n      pipeStringToStream(testString, testFilePath);\n      \n      setTimeout(() => {\n        const fileContent = fs.readTextSync(testFilePath);\n        expect(fileContent).assertEqual(testString);\n        \n        // Clean up\n        fs.unlink(testFilePath);\n      }, 1000);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createAndExecuteSequenceRunner } from '../main/ets/functions/ArkTS_SequenceRunner_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\ntype SequenceRunner = taskpool.SequenceRunner;\n\nexport default function localUnitTest() { \n  describe('createAndExecuteSequenceRunner_test', () => {\n    it('should_execute_tasks_and_return_results', 0, async () => {\n      const mockTask1 = new taskpool.Task(() => 'result1');\n      const mockTask2 = new taskpool.Task(() => 'result2');\n      const tasks = [mockTask1, mockTask2];\n      const results = await createAndExecuteSequenceRunner('testRunner', taskpool.Priority.LOW, tasks);\n      expect(results).assertDeepEquals(['result1', 'result2']);\n    });\n\n    it('should_handle_empty_tasks_array', 0, async () => {\n      const tasks: taskpool.Task[] = [];\n      const results = await createAndExecuteSequenceRunner('testRunner', taskpool.Priority.LOW, tasks);\n      expect(results).assertDeepEquals([]);\n    });\n\n    it('should_handle_task_errors', 0, async () => {\n      const mockErrorTask = new taskpool.Task(() => { throw new Error('task error'); });\n      const tasks = [mockErrorTask];\n      try {\n        await createAndExecuteSequenceRunner('testRunner', taskpool.Priority.LOW, tasks);\n        expect(true).assertFalse(); // Should not reach here\n      } catch (e) {\n        expect(e.message).assertEqual('task error');\n      }\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that sets up a `WorkerEventListener` to handle multiple event types and removes one of the listeners after the first event is received, using the `addEventListener` and `removeEventListener` methods.",
    "output": "import {WorkerEventListener} from '@kit.ArkTS';\n\nexport function registerWorkerEventListener(eventType: string, callback: () => void): void {\n  const listener: WorkerEventListener = {\n    onEvent: () => {\n      callback();\n    }\n  };\n\n  globalThis.worker.addEventListener(eventType, listener);\n}\n\nexport function unregisterWorkerEventListener(eventType: string, listener: WorkerEventListener): void {\n  globalThis.worker.removeEventListener(eventType, listener);\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createInitializedBuffer } from '../main/ets/functions/ArkTS_buffer_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {buffer} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('createInitializedBuffer_function_test', () => {\n    it('should_return_correct_buffer_for_ascii_string', 0, () => {\n        const size = 5;\n        const str = 'hello';\n        const result = createInitializedBuffer(size, str);\n        expect(result.toString('utf8')).assertEqual(str);\n    }); \n    it('should_return_correct_buffer_for_unicode_string', 0, () => {\n        const size = 4;\n        const str = '测试';\n        const result = createInitializedBuffer(size, str);\n        expect(result.toString('utf8')).assertEqual(str);\n    }); \n    it('should_return_empty_buffer_for_empty_string', 0, () => {\n        const size = 0;\n        const str = '';\n        const result = createInitializedBuffer(size, str);\n        expect(result.toString('utf8')).assertEqual(str);\n    }); \n  });\n}"
  },
  {
    "instruction": "Write a function that takes two `ScopeComparable` objects and returns the one with the higher scope value using the `compareTo` method. If they are equal, return the first object.",
    "output": "import {util} from '@kit.ArkTS';\ntype ScopeComparable = util.ScopeComparable;\n\nexport function getHigherScope(a: ScopeComparable, b: ScopeComparable): ScopeComparable {\n  return a.compareTo(b) ? a : b;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { calculateSumOfTypedArray } from '../main/ets/functions/ArkTS_TypedArray_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {buffer} from '@kit.ArkTS';\n\ntype TypedArray = buffer.TypedArray;\n\nexport default function localUnitTest() { \n  describe('calculateSum_function_test', () => {\n    it('should_return_correct_sum_for_empty_array', 0, () => {\n      const sum = calculateSumOfTypedArray(0);\n      expect(sum).assertEqual(0);\n    });\n\n    it('should_return_correct_sum_for_single_element', 0, () => {\n      const sum = calculateSumOfTypedArray(1);\n      expect(sum).assertLarger(0);\n      expect(sum).assertLessOrEqual(100);\n    });\n\n    it('should_return_correct_sum_for_multiple_elements', 0, () => {\n      const sum = calculateSumOfTypedArray(10);\n      expect(sum).assertLarger(9); // Minimum possible sum (1*10)\n      expect(sum).assertLessOrEqual(1000); // Maximum possible sum (100*10)\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { getValuesAsString } from '../main/ets/functions/ArkTS_URLParams_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {url} from '@kit.ArkTS';\ntype URLParams = url.URLParams;\n\nexport default function localUnitTest() { \n  describe('getValuesAsString_function_test', () => {\n    it('should_return_empty_string_for_empty_params', 0, () => {\n      const params: URLParams = new url.URLParams();\n      expect(getValuesAsString(params, 'key')).assertEqual('');\n    });\n\n    it('should_return_empty_string_for_nonexistent_key', 0, () => {\n      const params: URLParams = new url.URLParams('key1=value1&key2=value2');\n      expect(getValuesAsString(params, 'nonexistent')).assertEqual('');\n    });\n\n    it('should_return_single_value_as_string', 0, () => {\n      const params: URLParams = new url.URLParams('key=value1');\n      expect(getValuesAsString(params, 'key')).assertEqual('value1');\n    });\n\n    it('should_return_comma_separated_values_for_multiple_values', 0, () => {\n      const params: URLParams = new url.URLParams('key=value1&key=value2&key=value3');\n      expect(getValuesAsString(params, 'key')).assertEqual('value1,value2,value3');\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { getHigherScope } from '../main/ets/functions/ArkTS_ScopeComparable_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype ScopeComparable = util.ScopeComparable;\n\nexport default function localUnitTest() { \n  describe('getHigherScope_function_test', () => {\n    it('should_return_first_object_when_equal', 0, () => {\n      const a: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => false\n      };\n      const b: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => false\n      };\n      expect(getHigherScope(a, b)).assertEqual(a);\n    });\n\n    it('should_return_first_object_when_higher', 0, () => {\n      const a: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      const b: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => false\n      };\n      expect(getHigherScope(a, b)).assertEqual(a);\n    });\n\n    it('should_return_second_object_when_higher', 0, () => {\n      const a: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => false\n      };\n      const b: ScopeComparable = {\n        compareTo: (other: ScopeComparable) => true\n      };\n      expect(getHigherScope(a, b)).assertEqual(b);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { registerAndRemoveListeners } from '../main/ets/functions/ArkTS_EventTarget_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {EventTarget} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('registerAndRemoveListeners_function_test', () => {\n    it('should_remove_all_listeners', 0, () => {\n      // Create a mock event target to test the function's behavior\n      const mockEventTarget = {\n        listeners: new Map<string, Function[]>(),\n        addEventListener(type: string, listener: Function): void {\n          if (!this.listeners.has(type)) {\n            this.listeners.set(type, []);\n          }\n          this.listeners.get(type)?.push(listener);\n        },\n        removeAllListener(): void {\n          this.listeners.clear();\n        },\n        hasListener(type: string): boolean {\n          return this.listeners.has(type) && (this.listeners.get(type)?.length ?? 0) > 0;\n        }\n      };\n\n      const listener1 = (): void => {};\n      const listener2 = (): void => {};\n      const listener3 = (): void => {};\n\n      // Mock the EventTarget constructor in the tested function\n      const originalEventTarget = EventTarget.EventTarget;\n      EventTarget.EventTarget = function() {\n        return mockEventTarget;\n      } as any;\n\n      try {\n        // Add listeners\n        mockEventTarget.addEventListener('click', listener1);\n        mockEventTarget.addEventListener('scroll', listener2);\n        mockEventTarget.addEventListener('input', listener3);\n\n        // Verify listeners are added\n        expect(mockEventTarget.hasListener('click')).assertTrue();\n        expect(mockEventTarget.hasListener('scroll')).assertTrue();\n        expect(mockEventTarget.hasListener('input')).assertTrue();\n\n        // Call the function to remove all listeners\n        registerAndRemoveListeners();\n\n        // Verify all listeners are removed\n        expect(mockEventTarget.hasListener('click')).assertFalse();\n        expect(mockEventTarget.hasListener('scroll')).assertFalse();\n        expect(mockEventTarget.hasListener('input')).assertFalse();\n      } finally {\n        // Restore original EventTarget\n        EventTarget.EventTarget = originalEventTarget;\n      }\n    }); \n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { isTaskCompletedAndLong } from '../main/ets/functions/ArkTS_TaskInfo_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\n\ntype TaskInfo = taskpool.TaskInfo;\n\nexport default function localUnitTest() { \n  describe('isTaskCompletedAndLong_test', () => {\n    it('should_return_true_when_completed_and_duration_gt_10', 0, () => {\n      const taskInfo: TaskInfo = { state: taskpool.TaskState.COMPLETED, duration: 11, taskId: 1, name: 'task1' };\n      expect(isTaskCompletedAndLong(taskInfo)).assertTrue();\n    });\n\n    it('should_return_false_when_not_completed', 0, () => {\n      const taskInfo: TaskInfo = { state: taskpool.TaskState.RUNNING, duration: 11, taskId: 2, name: 'task2' };\n      expect(isTaskCompletedAndLong(taskInfo)).assertFalse();\n    });\n\n    it('should_return_false_when_duration_lte_10', 0, () => {\n      const taskInfo: TaskInfo = { state: taskpool.TaskState.COMPLETED, duration: 10, taskId: 3, name: 'task3' };\n      expect(isTaskCompletedAndLong(taskInfo)).assertFalse();\n    });\n\n    it('should_return_false_when_duration_undefined', 0, () => {\n      const taskInfo: TaskInfo = { state: taskpool.TaskState.COMPLETED, taskId: 4, name: 'task4' };\n      expect(isTaskCompletedAndLong(taskInfo)).assertFalse();\n    });\n\n    it('should_return_false_when_duration_null', 0, () => {\n      const taskInfo: TaskInfo = { state: taskpool.TaskState.COMPLETED, duration: undefined, taskId: 5, name: 'task5' };\n      expect(isTaskCompletedAndLong(taskInfo)).assertFalse();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that parses an XML string while ignoring namespaces and handling big integers, using the `ignoreNameSpace` and `bigIntMode` properties of `ParseOptions`.",
    "output": "import {xml} from '@kit.ArkTS';\ntype ParseOptions = xml.ParseOptions;\n\nexport function parseXmlString(xmlString: string, options: ParseOptions): void {\n  const parser = new xml.XmlPullParser();\n  parser.setOptions(options);\n  parser.parseFromString(xmlString);\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { addAndGetFirst } from '../main/ets/functions/ArkTS_Queue_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {Queue} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('addAndGetFirst_function_test', () => {\n    it('should_return_first_element_after_adding', 0, () => {\n      const queue = new Queue<number>();\n      queue.add(1);\n      queue.add(2);\n      expect(addAndGetFirst(queue, 3)).assertEqual(1);\n    });\n    it('should_return_added_element_for_empty_queue', 0, () => {\n      const queue = new Queue<string>();\n      expect(addAndGetFirst(queue, \"first\")).assertEqual(\"first\");\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `url` object and checks if it is a valid URL **using the `toString` method and a regular expression to validate the URL format**.",
    "output": "import {url} from '@kit.ArkTS';\n\nexport function isValidUrl(urlObj: url.URL): boolean {\n  const urlString = urlObj.toString();\n  const urlRegex = /^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/;\n  return urlRegex.test(urlString);\n}"
  },
  {
    "instruction": "Write a function that takes a `TreeMap` object and checks if it contains a specific value, then returns the corresponding key if found **using the `hasValue` and `get` methods**.",
    "output": "import {TreeMap} from '@kit.ArkTS';\n\nexport function findKeyByValue<K, V>(treeMap: TreeMap<K, V>, value: V): K | undefined {\n  if (treeMap.hasValue(value)) {\n    for (let key of treeMap.keys()) {\n      if (treeMap.get(key) === value) {\n        return key;\n      }\n    }\n  }\n  return undefined;\n}"
  },
  {
    "instruction": "Write a function that takes a `ThreadInfo` object and returns the highest priority thread ID **using the `priority` and `taskIds` properties**.",
    "output": "import {taskpool} from '@kit.ArkTS';\ntype ThreadInfo = taskpool.ThreadInfo;\n\nexport function getHighestPriorityThreadId(threadInfo: ThreadInfo): number | undefined {\n  if (!threadInfo.priority || !threadInfo.taskIds || threadInfo.taskIds.length === 0) {\n    return undefined;\n  }\n  \n  const maxPriority = threadInfo.priority;\n  const taskIds = threadInfo.taskIds;\n  \n  return taskIds[0];\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createAndExecuteSequenceRunner } from '../main/ets/functions/ArkTS_SequenceRunner_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\ntype SequenceRunner = taskpool.SequenceRunner;\n\nexport default function localUnitTest() { \n  describe('createAndExecuteSequenceRunner_test', () => {\n    it('should_execute_tasks_and_return_results', 0, async () => {\n      const mockTask1 = new taskpool.Task(() => 'result1');\n      const mockTask2 = new taskpool.Task(() => 'result2');\n      const tasks = [mockTask1, mockTask2];\n      \n      const results = await createAndExecuteSequenceRunner('testRunner', taskpool.Priority.HIGH, tasks);\n      expect(results.length).assertEqual(2);\n      expect(results[0]).assertEqual('result1');\n      expect(results[1]).assertEqual('result2');\n    });\n\n    it('should_handle_empty_tasks_array', 0, async () => {\n      const tasks: taskpool.Task[] = [];\n      const results = await createAndExecuteSequenceRunner('emptyRunner', taskpool.Priority.MEDIUM, tasks);\n      expect(results.length).assertEqual(0);\n    });\n\n    it('should_handle_single_task', 0, async () => {\n      const mockTask = new taskpool.Task(() => 42);\n      const tasks = [mockTask];\n      \n      const results = await createAndExecuteSequenceRunner('singleTaskRunner', taskpool.Priority.LOW, tasks);\n      expect(results.length).assertEqual(1);\n      expect(results[0]).assertEqual(42);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that initializes a Worker with a given name and then logs whether the Worker is shared or not, using the `name` and `shared` properties.",
    "output": "import {WorkerOptions} from '@kit.ArkTS';\nimport {worker} from '@kit.ArkTS';\n\nexport function createWorker(options: WorkerOptions): void {\n  const workerInstance = new worker.Worker('', options);\n  console.log(`Worker name: ${options.name}`);\n  console.log(`Is shared: ${options.shared}`);\n}"
  },
  {
    "instruction": "Write a function that takes a `URLParams` object, checks if a specific key exists using the `has` method, and if it does, deletes that key-value pair using the `delete` method.",
    "output": "import {url} from '@kit.ArkTS';\ntype URLParams = url.URLParams;\n\nexport function deleteKeyIfExists(params: URLParams, key: string): void {\n  if (params.has(key)) {\n    params.delete(key);\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { getHighestPriorityThreadId } from '../main/ets/functions/ArkTS_ThreadInfo_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\n\ntype ThreadInfo = taskpool.ThreadInfo;\n\nexport default function localUnitTest() { \n  describe('getHighestPriorityThreadId_function_test', () => {\n    it('should_return_null_when_priority_is_missing', 0, () => {\n      const threadInfo: ThreadInfo = {\n        taskIds: [1, 2, 3]\n      };\n      expect(getHighestPriorityThreadId(threadInfo)).assertEqual(null);\n    });\n\n    it('should_return_null_when_taskIds_is_missing', 0, () => {\n      const threadInfo: ThreadInfo = {\n        priority: 10\n      };\n      expect(getHighestPriorityThreadId(threadInfo)).assertEqual(null);\n    });\n\n    it('should_return_null_when_taskIds_is_empty', 0, () => {\n      const threadInfo: ThreadInfo = {\n        priority: 10,\n        taskIds: []\n      };\n      expect(getHighestPriorityThreadId(threadInfo)).assertEqual(null);\n    });\n\n    it('should_return_first_taskId_when_input_is_valid', 0, () => {\n      const threadInfo: ThreadInfo = {\n        priority: 10,\n        taskIds: [5, 6, 7]\n      };\n      expect(getHighestPriorityThreadId(threadInfo)).assertEqual(5);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `URLParams` object, retrieves all values for a given key, and converts them to a comma-separated string using the `getAll` and `toString` methods.",
    "output": "import {url} from '@kit.ArkTS';\ntype URLParams = url.URLParams;\n\nexport function getValuesAsString(params: URLParams, key: string): string {\n  const values: string[] = params.getAll(key);\n  return values.toString();\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { removeCommonElements } from '../main/ets/functions/ArkTS_HashSet_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {HashSet} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('removeCommonElements_function_test', () => {\n    it('should_remove_common_elements', 0, () => {\n      const set1 = new HashSet<number>();\n      set1.add(1);\n      set1.add(2);\n      set1.add(3);\n      const set2 = new HashSet<number>();\n      set2.add(2);\n      set2.add(3);\n      set2.add(4);\n      removeCommonElements(set1, set2);\n      expect(set1.has(1)).assertTrue();\n      expect(set1.has(2)).assertFalse();\n      expect(set1.has(3)).assertFalse();\n    });\n    it('should_not_remove_any_elements_when_no_common', 0, () => {\n      const set1 = new HashSet<string>();\n      set1.add('a');\n      set1.add('b');\n      const set2 = new HashSet<string>();\n      set2.add('c');\n      set2.add('d');\n      removeCommonElements(set1, set2);\n      expect(set1.has('a')).assertTrue();\n      expect(set1.has('b')).assertTrue();\n    });\n    it('should_handle_empty_sets', 0, () => {\n      const set1 = new HashSet<boolean>();\n      const set2 = new HashSet<boolean>();\n      set2.add(true);\n      removeCommonElements(set1, set2);\n      expect(set1.size).assertEqual(0);\n    });\n    it('should_remove_all_elements_when_all_are_common', 0, () => {\n      const set1 = new HashSet<number>();\n      set1.add(1);\n      set1.add(2);\n      const set2 = new HashSet<number>();\n      set2.add(1);\n      set2.add(2);\n      removeCommonElements(set1, set2);\n      expect(set1.size).assertEqual(0);\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `LinkedList` object and appends all elements of an array to the end of the list using the `add` and `convertToArray` methods.",
    "output": "import {LinkedList} from '@kit.ArkTS';\n\nexport function appendArrayToLinkedList<T>(list: LinkedList<T>, array: T[]): void {\n  const listArray = list.convertToArray();\n  for (const element of array) {\n    list.add(element);\n  }\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { setupWorker } from '../main/ets/functions/ArkTS_WorkerGlobalScope_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {WorkerGlobalScope} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('setupWorker_function_test', () => {\n    it('should_log_worker_name', 0, () => {\n      const mockWorkerScope: WorkerGlobalScope = {\n        name: 'testWorker',\n        onerror: null\n      };\n      \n      // Spy on console.log to verify it's called with the correct message\n      const logSpy = jest.spyOn(console, 'log');\n      setupWorker(mockWorkerScope);\n      expect(logSpy).toHaveBeenCalledWith('Worker name: testWorker');\n      logSpy.mockRestore();\n    });\n\n    it('should_set_error_handler', 0, () => {\n      const mockWorkerScope: WorkerGlobalScope = {\n        name: 'testWorker',\n        onerror: null\n      };\n      \n      setupWorker(mockWorkerScope);\n      expect(mockWorkerScope.onerror).toBeDefined();\n      \n      // Verify the error handler logs the error message\n      const errorSpy = jest.spyOn(console, 'error');\n      const testError = new ErrorEvent('test', { message: 'Test error' });\n      mockWorkerScope.onerror(testError);\n      expect(errorSpy).toHaveBeenCalledWith('Worker error: Test error');\n      errorSpy.mockRestore();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that checks if a given event type is valid by comparing it with a predefined list of valid event types using the `includes` method and a custom validation function.",
    "output": "import {xml} from '@kit.ArkTS';\ntype EventType = xml.EventType;\n\nexport function isValidEventType(eventType: EventType): boolean {\n  const validEventTypes: EventType[] = [\n    xml.EventType.ELEMENT_START,\n    xml.EventType.ELEMENT_END,\n    xml.EventType.TEXT,\n    xml.EventType.CDATA,\n    xml.EventType.COMMENT,\n    xml.EventType.DOCUMENT_START,\n    xml.EventType.DOCUMENT_END\n  ];\n  \n  return validEventTypes.includes(eventType);\n}"
  },
  {
    "instruction": "Write a function that takes an XML string, parses it using the `parseXml` method, and then extracts the root element name using the `parse` method.",
    "output": "import {xml} from '@kit.ArkTS';\ntype XmlPullParser = xml.XmlPullParser;\n\nexport function extractRootElementName(xmlString: string): string {\n  const encoder = new TextEncoder();\n  const arrayBuffer = encoder.encode(xmlString);\n  const parser: XmlPullParser = new xml.XmlPullParser(arrayBuffer);\n  const parseOptions: xml.ParseOptions = {\n    supportDoctype: true,\n    ignoreNameSpace: true\n  };\n  parser.parse(parseOptions);\n  \n  const parseResult = parser.parseXml(parseOptions);\n  return parseResult.getName();\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { addAndGetHigherValue } from '../main/ets/functions/ArkTS_TreeSet_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {TreeSet} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('addAndGetHigherValue_function_test', () => {\n    it('should_return_undefined_when_no_higher_value', 0, () => {\n      const treeSet = new TreeSet<number>();\n      treeSet.add(5);\n      expect(addAndGetHigherValue(treeSet, 10)).assertUndefined();\n    });\n\n    it('should_return_higher_value_when_exists', 0, () => {\n      const treeSet = new TreeSet<number>();\n      treeSet.add(5);\n      treeSet.add(15);\n      expect(addAndGetHigherValue(treeSet, 10)).assertEqual(15);\n    });\n\n    it('should_return_smallest_higher_value_when_multiple_exist', 0, () => {\n      const treeSet = new TreeSet<number>();\n      treeSet.add(5);\n      treeSet.add(15);\n      treeSet.add(20);\n      expect(addAndGetHigherValue(treeSet, 10)).assertEqual(15);\n    });\n\n    it('should_work_with_string_values', 0, () => {\n      const treeSet = new TreeSet<string>();\n      treeSet.add('apple');\n      treeSet.add('banana');\n      expect(addAndGetHigherValue(treeSet, 'apricot')).assertEqual('banana');\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that checks if a `TreeSet` object contains all values from a given array and returns a boolean result **using the `has` and `length` properties**.",
    "output": "import {TreeSet} from '@kit.ArkTS';\n\nexport function checkTreeSetContainsAll(treeSet: TreeSet<number>, values: number[]): boolean {\n    for (let i = 0; i < values.length; i++) {\n        if (!treeSet.has(values[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { removeDuplicates } from '../main/ets/functions/ArkTS_Vector_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {Vector} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('removeDuplicates_function_test', () => {\n    it('should_remove_duplicates_from_vector', 0, () => {\n      const vector = new Vector<number>();\n      vector.add(1);\n      vector.add(2);\n      vector.add(1);\n      vector.add(3);\n      vector.add(2);\n      removeDuplicates(vector);\n      expect(vector.length).assertEqual(3);\n      expect(vector[0]).assertEqual(1);\n      expect(vector[1]).assertEqual(2);\n      expect(vector[2]).assertEqual(3);\n    });\n\n    it('should_handle_empty_vector', 0, () => {\n      const vector = new Vector<number>();\n      removeDuplicates(vector);\n      expect(vector.length).assertEqual(0);\n    });\n\n    it('should_handle_vector_with_no_duplicates', 0, () => {\n      const vector = new Vector<string>();\n      vector.add('a');\n      vector.add('b');\n      vector.add('c');\n      removeDuplicates(vector);\n      expect(vector.length).assertEqual(3);\n      expect(vector[0]).assertEqual('a');\n      expect(vector[1]).assertEqual('b');\n      expect(vector[2]).assertEqual('c');\n    });\n\n    it('should_handle_vector_with_all_duplicates', 0, () => {\n      const vector = new Vector<boolean>();\n      vector.add(true);\n      vector.add(true);\n      vector.add(true);\n      removeDuplicates(vector);\n      expect(vector.length).assertEqual(1);\n      expect(vector[0]).assertEqual(true);\n    });\n  });\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { toggleState } from '../main/ets/functions/ArkTS_State_1';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {taskpool} from '@kit.ArkTS';\ntype State = taskpool.State;\n\nexport default function localUnitTest() { \n  describe('toggleState_function_test', () => {\n    it('should_create_state_with_initial_value_true', 0, () => {\n      const state = toggleState();\n      let currentValue = true;\n      state.update((value: boolean) => {\n        currentValue = value;\n        return value;\n      });\n      expect(currentValue).assertTrue();\n    });\n\n    it('should_toggle_state_value_to_false', 0, () => {\n      const state = toggleState();\n      let currentValue = true;\n      state.update((value: boolean) => {\n        currentValue = !value;\n        return currentValue;\n      });\n      expect(currentValue).assertFalse();\n    });\n\n    it('should_toggle_state_value_back_to_true', 0, () => {\n      const state = toggleState();\n      let currentValue = true;\n      state.update((value: boolean) => {\n        currentValue = !value;\n        return currentValue;\n      });\n      state.update((value: boolean) => {\n        currentValue = !value;\n        return currentValue;\n      });\n      expect(currentValue).assertTrue();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `PlainArray` object and returns a new array containing all keys that have a specific value **using the `forEach` and `getKeyAt` methods**.",
    "output": "import {PlainArray} from '@kit.ArkTS';\n\nexport function getKeysByValue(plainArray: PlainArray<number>, targetValue: number): number[] {\n  const keys: number[] = [];\n  \n  plainArray.forEach((value: number, key: number) => {\n    if (value === targetValue) {\n      keys.push(key);\n    }\n  });\n  \n  return keys;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { isValueInScope } from '../main/ets/functions/ArkTS_Scope_0';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {util} from '@kit.ArkTS';\n\ntype Scope = util.Scope;\n\nexport default function localUnitTest() { \n  describe('isValueInScope_function_test', () => {\n    it('should_return_true_when_value_is_within_scope', 0, () => {\n      const mockScope: Scope = {\n        getLower: () => 10,\n        getUpper: () => 20\n      };\n      expect(isValueInScope(mockScope, 15)).assertTrue();\n    });\n\n    it('should_return_true_when_value_equals_lower_bound', 0, () => {\n      const mockScope: Scope = {\n        getLower: () => 10,\n        getUpper: () => 20\n      };\n      expect(isValueInScope(mockScope, 10)).assertTrue();\n    });\n\n    it('should_return_true_when_value_equals_upper_bound', 0, () => {\n      const mockScope: Scope = {\n        getLower: () => 10,\n        getUpper: () => 20\n      };\n      expect(isValueInScope(mockScope, 20)).assertTrue();\n    });\n\n    it('should_return_false_when_value_is_below_lower_bound', 0, () => {\n      const mockScope: Scope = {\n        getLower: () => 10,\n        getUpper: () => 20\n      };\n      expect(isValueInScope(mockScope, 5)).assertFalse();\n    });\n\n    it('should_return_false_when_value_is_above_upper_bound', 0, () => {\n      const mockScope: Scope = {\n        getLower: () => 10,\n        getUpper: () => 20\n      };\n      expect(isValueInScope(mockScope, 25)).assertFalse();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that checks if a given value exists in a `Stack` and returns its position (1-based index) from the top. Use the `locate` method to find the position and the `isEmpty` method to handle empty stacks.",
    "output": "import {Stack} from '@kit.ArkTS';\n\nexport function findPositionInStack<T>(stack: Stack<T>, value: T): number {\n  if (stack.isEmpty()) {\n    return -1;\n  }\n  const position = stack.locate(value);\n  return position === -1 ? -1 : position + 1;\n}"
  },
  {
    "instruction": "Write test code for the following ArkTS code:",
    "output": "import { createWorkerAndPostTask } from '../main/ets/functions/ArkTS_worker_2';\nimport { describe, it, expect } from '@ohos/hypium';\nimport {worker} from '@kit.ArkTS';\n\nexport default function localUnitTest() { \n  describe('createWorkerAndPostTask_function_test', () => {\n    it('should_create_worker_and_post_message', 0, () => {\n      const workerInstance = createWorkerAndPostTask();\n      expect(workerInstance instanceof worker.ThreadWorker).assertTrue();\n    });\n\n    it('should_handle_error_event', 0, () => {\n      const workerInstance = createWorkerAndPostTask();\n      expect(typeof workerInstance.onerror === 'function').assertTrue();\n    });\n  });\n}"
  },
  {
    "instruction": "Write a function that takes a `ScopeHelper` object and checks if a given value lies within its bounds, then returns the clamped value if it is out of bounds. Use the `contains` and `clamp` methods.",
    "output": "import {util} from '@kit.ArkTS';\ntype ScopeHelper = util.ScopeHelper;\n\nexport function clampValue(scope: ScopeHelper, value: number): number {\n  if (!scope.contains(value)) {\n    return scope.clamp(value);\n  }\n  return value;\n}"
  }
]