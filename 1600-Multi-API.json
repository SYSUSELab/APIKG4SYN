[
  {
    "instruction": "Write a function that first uses `json.stringify` to convert an object containing user data into a JSON string, then uses `util.getHash` to generate a SHA-256 hash of the stringified JSON, and finally returns the hash as a hexadecimal string.",
    "input": "",
    "output": "import {json, util} from '@kit.ArkTS';\n\nexport function generateUserDataHash(userData: object): string {\n  const jsonString: string = json.stringify(userData);\n  const hashArray: Uint8Array = util.getHash(jsonString, 'SHA-256');\n  let hexString: string = '';\n  hashArray.forEach((byte) => {\n    hexString += byte.toString(16).padStart(2, '0');\n  });\n  return hexString;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes a JSON string containing an array of UUIDs, uses `json.parse` to convert it into an array, then filters out invalid UUIDs by checking each one with `util.parseUUID`, and finally returns the filtered array of valid UUIDs.",
    "input": "",
    "output": "import {json, util} from '@kit.ArkTS';\n\nexport function filterValidUUIDs(jsonString: string): string[] {\n  try {\n    const uuids: string[] = json.parse(jsonString);\n    if (!Array.isArray(uuids)) {\n      return [];\n    }\n    return uuids.filter((uuid: string) => {\n      try {\n        util.parseUUID(uuid);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    });\n  } catch (e) {\n    return [];\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that generates a random UUID using `util.generateRandomUUID`, converts it to a JSON string using `json.stringify`, then parses it back to a string using `json.parse`, and finally validates the parsed UUID using `util.parseUUID` to ensure it matches the original UUID.",
    "input": "",
    "output": "import {json, util} from '@kit.ArkTS';\n\nexport function generateAndValidateUUID(): boolean {\n  const originalUUID = util.generateRandomUUID();\n  const jsonString = json.stringify(originalUUID);\n  const parsedUUID = json.parse(jsonString);\n  const parsedUUIDString = util.parseUUID(parsedUUID);\n  return originalUUID === parsedUUIDString;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a series of custom events, then dispatches each event using the `dispatchEvent` method of `EventTarget`. The function should return the number of events successfully dispatched.",
    "input": "",
    "output": "import {EventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function collectAndDispatchEvents(events: string[]): number {\n  const eventTarget = new EventTarget();\n  const eventList = new LinkedList<string>();\n  \n  for (const event of events) {\n    eventList.add(event);\n  }\n  \n  let dispatchedCount = 0;\n  for (const event of eventList) {\n    const success = eventTarget.dispatchEvent(event);\n    if (success) {\n      dispatchedCount++;\n    }\n  }\n  \n  return dispatchedCount;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements, then uses these elements as event data in the `addEventListener` and `dispatchEvent` methods of `EventTarget` to simulate a start and end event sequence.",
    "input": "",
    "output": "import {EventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function simulateEventSequence(): void {\n  const list = new LinkedList<number>();\n  list.add(1);\n  list.add(2);\n  list.add(3);\n\n  const firstElement = list.getFirst();\n  const lastElement = list.getLast();\n\n  const eventTarget = new EventTarget();\n\n  eventTarget.addEventListener('start', (event: CustomEvent<number>) => {\n    console.log(`Start event triggered with data: ${event.detail}`);\n  });\n\n  eventTarget.addEventListener('end', (event: CustomEvent<number>) => {\n    console.log(`End event triggered with data: ${event.detail}`);\n  });\n\n  eventTarget.dispatchEvent(new CustomEvent('start', { detail: firstElement }));\n  eventTarget.dispatchEvent(new CustomEvent('end', { detail: lastElement }));\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LinkedList` to iterate over a list of event names, and for each name, dynamically adds an event listener using `addEventListener` from `EventTarget`. The function should then trigger all events using `dispatchEvent` and finally clear all listeners using `removeAllListener`.",
    "input": "",
    "output": "import {EventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function manageEventListeners(eventNames: LinkedList<string>, eventTarget: EventTarget): void {\n  eventNames.forEach((eventName: string) => {\n    const listener = () => {\n      console.log(`Event triggered: ${eventName}`);\n    };\n    eventTarget.addEventListener(eventName, listener);\n  });\n\n  eventNames.forEach((eventName: string) => {\n    const event = { type: eventName };\n    eventTarget.dispatchEvent(event);\n  });\n\n  eventTarget.removeAllListener();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a message containing an array of numbers to a worker thread, and then uses the `transfer` property of `PostMessageOptions` to transfer ownership of a shared buffer to the worker thread for efficient data processing.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport function sendDataToWorker(worker: ThreadWorkerGlobalScope, data: number[], buffer: ArrayBuffer): void {\n  worker.postMessage(data);\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  worker.postMessage(buffer, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that listens for incoming messages using the `onmessage` property of `ThreadWorkerGlobalScope`, processes the received data by calling a global method via `callGlobalCallObjectMethod`, and then sends the processed result back to the main thread using `postMessageWithSharedSendable` with the `transfer` property of `PostMessageOptions` to optimize performance.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport const workerScript = (self: ThreadWorkerGlobalScope) => {\n  self.onmessage = (event: MessageEvent) => {\n    const data = event.data;\n    const processedData = self.callGlobalCallObjectMethod('processData', data);\n    \n    const options: PostMessageOptions = {\n      transfer: [processedData.buffer]\n    };\n    \n    self.postMessageWithSharedSendable(processedData, options);\n  };\n};",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where the main thread uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a task to a worker thread, and the worker thread uses the `close` method of `ThreadWorkerGlobalScope` to terminate itself after completing the task, while also handling any potential errors via the `onmessageerror` property to ensure robust communication between threads.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport function setupWorkerCommunication(worker: ThreadWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent): void => {\n    console.log('Worker received message:', event.data);\n    worker.close();\n  };\n\n  worker.onmessageerror = (event: MessageEvent): void => {\n    console.error('Error in worker message:', event);\n    worker.close();\n  };\n}\n\nexport function sendTaskToWorker(worker: ThreadWorkerGlobalScope, task: ArrayBuffer, transferOptions: PostMessageOptions): void {\n  try {\n    worker.postMessage(task, transferOptions);\n  } catch (error) {\n    console.error('Error sending message to worker:', error);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addAll` method of `LightWeightSet` to merge two sets of product IDs, then passes the merged set to the `setAll` method of `HashMap` to update a product inventory map with the latest IDs.",
    "input": "",
    "output": "import {LightWeightSet, HashMap} from '@kit.ArkTS';\n\nexport function mergeAndUpdateProductInventory(productIds1: LightWeightSet<number>, productIds2: LightWeightSet<number>, inventoryMap: HashMap<number, string>): void {\n  const mergedSet = new LightWeightSet<number>();\n  mergedSet.addAll(productIds1);\n  mergedSet.addAll(productIds2);\n  \n  const tempMap = new HashMap<number, string>();\n  for (let i = 0; i < mergedSet.length; i++) {\n    const productId = mergedSet.getValueAt(i);\n    tempMap.set(productId, inventoryMap.get(productId) || '');\n  }\n  \n  inventoryMap.setAll(tempMap);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `keys` method of `HashMap` to retrieve all keys (user IDs), then uses the `add` method of `LightWeightSet` to store these keys in a set for deduplication, and finally checks if a specific user ID exists using the `has` method of `LightWeightSet`.",
    "input": "",
    "output": "import {LightWeightSet, HashMap} from '@kit.ArkTS';\n\nexport function checkUserIdInSet(userMap: HashMap<string, any>, userId: string): boolean {\n  const keys = userMap.keys();\n  const idSet = new LightWeightSet<string>();\n  for (const key of keys) {\n    idSet.add(key);\n  }\n  return idSet.has(userId);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `values` method of `LightWeightSet` to extract all values (item names), then passes these values to the `forEach` method of `HashMap` to count the occurrences of each item name in the map and return the counts as a new `HashMap`.",
    "input": "",
    "output": "import {LightWeightSet, HashMap} from '@kit.ArkTS';\n\nexport function countOccurrences(lightWeightSet: LightWeightSet<string>, hashMap: HashMap<string, number>): HashMap<string, number> {\n  const resultMap = new HashMap<string, number>();\n  const values = lightWeightSet.values();\n  \n  values.forEach((value: string) => {\n    let count = 0;\n    hashMap.forEach((val: number, key: string) => {\n      if (key === value) {\n        count += val;\n      }\n    });\n    if (count > 0) {\n      resultMap.set(value, count);\n    }\n  });\n  \n  return resultMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.getUidForName` to retrieve the UID of a given process name, then checks if the process is running in 64-bit mode using `process.is64Bit`, and finally terminates the process using `process.kill` if it is not 64-bit.",
    "input": "",
    "output": "import {worker, process} from '@kit.ArkTS';\n\nexport function checkAndKillNon64BitProcess(processName: string): void {\n    const uid = process.getUidForName(processName);\n    if (uid === -1) {\n        return;\n    }\n    const is64Bit = process.is64Bit(uid);\n    if (!is64Bit) {\n        process.kill(uid);\n    }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first retrieves the system configuration using `process.getSystemConfig`, then checks if the current process is isolated using `process.isIsolatedProcess`, and finally exits the process using `process.exit` if it is isolated and the system configuration meets certain criteria.",
    "input": "",
    "output": "import {worker, process} from '@kit.ArkTS';\n\nexport function checkAndExitIfIsolated(): void {\n  const systemConfig = process.getSystemConfig();\n  const isIsolated = process.isIsolatedProcess();\n  \n  if (isIsolated && systemConfig) {\n    process.exit(0);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that calculates the uptime of a process using `process.uptime`, retrieves the CPU time used by the process using `process.getPastCpuTime`, and then determines the process's efficiency by comparing the CPU time to the uptime, printing the result using `console.log`.",
    "input": "",
    "output": "import {worker, process} from '@kit.ArkTS';\n\nexport function calculateProcessEfficiency(): void {\n  const uptime: number = process.uptime();\n  const cpuTime: number = process.getPastCpuTime();\n  const efficiency: number = (cpuTime / uptime) * 100;\n  console.log(`Process Efficiency: ${efficiency.toFixed(2)}%`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `ArrayList` to collect a list of employee names, then transfers these names to a `LightWeightMap` using the `set` method to assign each employee a unique ID (starting from 1). Finally, use the `keys` method of `LightWeightMap` to retrieve and return the list of IDs as an array.",
    "input": "",
    "output": "import {ArrayList, LightWeightMap} from '@kit.ArkTS';\n\nexport function assignEmployeeIds(employeeNames: string[]): number[] {\n  const nameList = new ArrayList<string>();\n  employeeNames.forEach(name => {\n    nameList.add(name);\n  });\n\n  const employeeMap = new LightWeightMap<number, string>();\n  for (let i = 0; i < nameList.length; i++) {\n    employeeMap.set(i + 1, nameList.get(i));\n  }\n\n  const idArray: number[] = [];\n  const keysIter = employeeMap.keys();\n  for (const key of keysIter) {\n    idArray.push(key);\n  }\n\n  return idArray;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `LightWeightMap` with product names (keys) and their prices (values) using the `set` method. Then, extract all product names using the `keys` method, store them in an `ArrayList` using the `add` method, and sort them alphabetically using the `sort` method of `ArrayList`. Return the sorted list of product names.",
    "input": "",
    "output": "import {ArrayList, LightWeightMap} from '@kit.ArkTS';\n\nexport function getSortedProductNames(): ArrayList<string> {\n  const productMap = new LightWeightMap<string, number>();\n  productMap.set('Laptop', 999);\n  productMap.set('Phone', 699);\n  productMap.set('Tablet', 399);\n  productMap.set('Monitor', 199);\n  productMap.set('Keyboard', 99);\n\n  const productNames = new ArrayList<string>();\n  const keys = productMap.keys();\n  for (let key of keys) {\n    productNames.add(key);\n  }\n\n  productNames.sort((a, b) => a.localeCompare(b));\n  return productNames;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getValueAt` method of `LightWeightMap` to retrieve all values (e.g., student grades), stores them in an `ArrayList` using the `add` method, and then calculates the average grade by iterating through the `ArrayList` with the `forEach` method. Return the average grade rounded to two decimal places.",
    "input": "",
    "output": "import {ArrayList, LightWeightMap} from '@kit.ArkTS';\n\nexport function calculateAverageGrade(gradesMap: LightWeightMap<number, number>): number {\n  const gradesList = new ArrayList<number>();\n  \n  for (let i = 0; i < gradesMap.length; i++) {\n    const grade = gradesMap.getValueAt(i);\n    gradesList.add(grade);\n  }\n  \n  let sum = 0;\n  gradesList.forEach((grade: number) => {\n    sum += grade;\n  });\n  \n  const average = sum / gradesList.length;\n  return parseFloat(average.toFixed(2));\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `addAll` method of `LightWeightSet` to collect a set of XML node names from an XML document, then uses the `toArray` method of `LightWeightSet` to convert the set into an array, and finally passes this array to the `forEach` method of `LightWeightSet` to log each node name to the console.",
    "input": "",
    "output": "import {xml, LightWeightSet} from '@kit.ArkTS';\n\nexport function processXmlNodeNames(xmlDoc: xml.XmlDocument): void {\n  const nodeNamesSet = new LightWeightSet<string>();\n  \n  // Assuming xmlDoc has a method to get all node names\n  // This is a placeholder for the actual method to collect node names\n  const nodeNames: string[] = []; // Replace with actual node names collection\n  \n  nodeNamesSet.addAll(nodeNames);\n  \n  const nodeNamesArray = nodeNamesSet.toArray();\n  \n  nodeNamesSet.forEach((value: string) => {\n    console.log(value);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `getValueAt` method of `LightWeightSet` to retrieve values from a set of XML attributes stored in the set, then uses the `entries` method of `LightWeightSet` to iterate over these values, and finally passes each value to the `EventType` enum of `xml` to determine and return the corresponding event type for each attribute value.",
    "input": "",
    "output": "import {xml, LightWeightSet} from '@kit.ArkTS';\n\nexport function getEventTypesFromAttributes(attributeSet: LightWeightSet<string>): xml.EventType[] {\n  const eventTypes: xml.EventType[] = [];\n  \n  for (let i = 0; i < attributeSet.length; i++) {\n    const value = attributeSet.getValueAt(i);\n    const eventType = xml.EventType[value as keyof typeof xml.EventType];\n    if (eventType !== undefined) {\n      eventTypes.push(eventType);\n    }\n  }\n  \n  return eventTypes;\n}\n\nexport function iterateWithEntries(attributeSet: LightWeightSet<string>): xml.EventType[] {\n  const eventTypes: xml.EventType[] = [];\n  \n  for (const [value] of attributeSet.entries()) {\n    const eventType = xml.EventType[value as keyof typeof xml.EventType];\n    if (eventType !== undefined) {\n      eventTypes.push(eventType);\n    }\n  }\n  \n  return eventTypes;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first uses the `has` method of `LightWeightSet` to check if a specific XML node exists in a set of nodes, then uses the `remove` method of `LightWeightSet` to remove the node if it exists, and finally uses the `length` property of `LightWeightSet` to return the updated count of nodes in the set.",
    "input": "",
    "output": "import {xml, LightWeightSet} from '@kit.ArkTS';\n\nexport function removeNodeAndGetCount(set: LightWeightSet<xml.Node>, node: xml.Node): number {\n  if (set.has(node)) {\n    set.remove(node);\n  }\n  return set.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of XML event types (from the `EventType` enum of `xml`), then uses the `convertToArray` method of `LinkedList` to convert the list into an array, and finally passes this array to the `forEach` method of `LinkedList` to log each event type.",
    "input": "",
    "output": "import {LinkedList, xml} from '@kit.ArkTS';\n\nexport function logXmlEventTypes(): void {\n  const eventList = new LinkedList<xml.EventType>();\n  eventList.add(xml.EventType.START_DOCUMENT);\n  eventList.add(xml.EventType.START_ELEMENT);\n  eventList.add(xml.EventType.END_ELEMENT);\n  eventList.add(xml.EventType.END_DOCUMENT);\n\n  const eventArray = eventList.convertToArray();\n  eventList.forEach((event: xml.EventType) => {\n    console.log(event);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list, then uses these elements to construct an XML event log (using the `EventType` enum of `xml`) and stores the log in a new `LinkedList` instance using the `addFirst` and `addLast` methods.",
    "input": "",
    "output": "import {LinkedList, xml} from '@kit.ArkTS';\n\nexport function createXMLEventLog(list: LinkedList<string>): LinkedList<string> {\n  const firstElement = list.getFirst();\n  const lastElement = list.getLast();\n  \n  const eventLog = new LinkedList<string>();\n  eventLog.addFirst(`<event type=\"${xml.EventType.START}\">${firstElement}</event>`);\n  eventLog.addLast(`<event type=\"${xml.EventType.END}\">${lastElement}</event>`);\n  \n  return eventLog;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `removeByIndex` method of `LinkedList` to filter out specific XML event types (from the `EventType` enum of `xml`) based on their indices, then uses the `length` property of `LinkedList` to determine the remaining number of events, and finally passes this count to an XML logging function (using `xml` API) to record the filtered event count.",
    "input": "",
    "output": "import {LinkedList, xml} from '@kit.ArkTS';\n\nexport function filterAndLogXmlEvents(events: LinkedList<xml.EventType>, indicesToRemove: number[]): void {\n  // Sort indices in descending order to avoid shifting issues during removal\n  indicesToRemove.sort((a, b) => b - a);\n  \n  // Remove events by index\n  for (const index of indicesToRemove) {\n    if (index >= 0 && index < events.length) {\n      events.removeByIndex(index);\n    }\n  }\n  \n  // Get remaining event count\n  const remainingCount = events.length;\n  \n  // Log the filtered event count using xml API\n  xml.log(`Filtered XML event count: ${remainingCount}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then transfers the stack contents to a worker thread (using `worker.postMessage`) to compute the sum of all numbers. The result should be returned to the main thread using `worker.onmessage`.",
    "input": "",
    "output": "import {Stack, worker} from '@kit.ArkTS';\n\nexport function sumNumbersWithWorker(numbers: number[]): Promise<number> {\n  return new Promise((resolve) => {\n    const stack = new Stack<number>();\n    numbers.forEach(num => stack.push(num));\n\n    const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n    workerInstance.postMessage(stack);\n\n    workerInstance.onmessage = (msg: { data: number }) => {\n      resolve(msg.data);\n      workerInstance.terminate();\n    };\n  });\n}\n\n// Worker.ts content (should be in a separate file)\n// import {Stack} from '@kit.ArkTS';\n// \n// const workerPort = worker.workerPort;\n// workerPort.onmessage = (msg: { data: Stack<number> }) => {\n//   const stack = msg.data;\n//   let sum = 0;\n//   while (!stack.isEmpty()) {\n//     sum += stack.pop();\n//   }\n//   workerPort.postMessage(sum);\n// };",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the top element of the stack, and if it meets a condition (e.g., even number), sends it to a worker thread (using `worker.postMessage`) for further processing (e.g., squaring the number). The result should be logged using `worker.onmessage`.",
    "input": "",
    "output": "import {Stack, worker} from '@kit.ArkTS';\n\nexport function processTopElement(stack: Stack<number>, condition: (num: number) => boolean): void {\n  if (stack.isEmpty()) {\n    return;\n  }\n  \n  const topElement = stack.peek();\n  \n  if (condition(topElement)) {\n    const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n    \n    workerInstance.postMessage(topElement);\n    \n    workerInstance.onmessage = (value: number) => {\n      console.log(`Processed result: ${value}`);\n      workerInstance.terminate();\n    };\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Stack` (from @kit.ArkTS) to iterate over all elements, filters out negative numbers, and sends the filtered list to a worker thread (using `worker.postMessage`) to compute their average. The result should be displayed using `worker.onmessage`.",
    "input": "",
    "output": "import {Stack, worker} from '@kit.ArkTS';\n\nexport function filterAndComputeAverage(stack: Stack<number>): void {\n  const filteredNumbers: number[] = [];\n  \n  stack.forEach((element: number) => {\n    if (element >= 0) {\n      filteredNumbers.push(element);\n    }\n  });\n  \n  const workerInstance = new worker.ThreadWorker('workers/worker.js');\n  \n  workerInstance.postMessage(filteredNumbers);\n  \n  workerInstance.onmessage = (message: { data: number }) => {\n    console.log(`Average: ${message.data}`);\n    workerInstance.terminate();\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `PlainArray` to iterate over key-value pairs, and for each value, uses the `write` method of `stream` to append the value to a log file. The function should return the total number of entries processed.",
    "input": "",
    "output": "import {stream, PlainArray} from '@kit.ArkTS';\n\nexport function logPlainArrayValues(pa: PlainArray<string>, logStream: stream.Writable): number {\n  let count = 0;\n  pa.forEach((value: string, key: number) => {\n    logStream.write(value);\n    count++;\n  });\n  return count;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getValueAt` method of `PlainArray` to retrieve values at specific indices, then uses the `pipe` method of `stream` to transfer these values to a new `PlainArray` instance. The function should return the new `PlainArray` with the transferred values.",
    "input": "",
    "output": "import {stream, PlainArray} from '@kit.ArkTS';\n\nexport function transferValues(originalArray: PlainArray<number, any>, indices: number[]): PlainArray<number, any> {\n  const newArray = new PlainArray<number, any>();\n  \n  indices.forEach(index => {\n    const value = originalArray.getValueAt(index);\n    if (value !== undefined) {\n      const key = originalArray.getKeyAt(index);\n      if (key !== undefined) {\n        newArray.add(key, value);\n      }\n    }\n  });\n  \n  return newArray;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `Symbol.iterator` method of `PlainArray` to iterate over its entries, and for each entry, uses the `transform` method of `stream` to apply a transformation (e.g., converting values to uppercase). The transformed values should be collected into a new `PlainArray` and returned.",
    "input": "",
    "output": "import {stream, PlainArray} from '@kit.ArkTS';\n\nexport function transformPlainArrayValues(originalArray: PlainArray<string>, transformFunc: (value: string) => string): PlainArray<string> {\n  const transformedArray = new PlainArray<string>();\n  \n  for (const [key, value] of originalArray) {\n    const transformedValue = transformFunc(value);\n    transformedArray.add(key, transformedValue);\n  }\n  \n  return transformedArray;\n}\n\nexport function uppercasePlainArrayValues(originalArray: PlainArray<string>): PlainArray<string> {\n  return transformPlainArrayValues(originalArray, (value: string) => value.toUpperCase());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `from` method of `buffer` to convert a string into a buffer, then uses the `set` method of `HashMap` to store the buffer as a value with a specified key. Finally, use the `postMessage` method of `ThreadWorkerGlobalScope` to send the HashMap to another thread.",
    "input": "",
    "output": "import {HashMap, buffer, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function convertAndSendToThread(key: string, value: string, threadScope: ThreadWorkerGlobalScope): void {\n  const buf = buffer.from(value);\n  const hashMap = new HashMap<string, buffer.Buffer>();\n  hashMap.set(key, buf);\n  threadScope.postMessage(hashMap);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `alloc` method of `buffer` to create a new buffer, then uses the `forEach` method of `HashMap` to iterate over its entries and write each value into the buffer. After processing, use the `onmessage` property of `ThreadWorkerGlobalScope` to handle the buffer data received from another thread.",
    "input": "",
    "output": "import {HashMap, buffer, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processHashMapToBuffer(hashMap: HashMap<string, number>): buffer.Buffer {\n  const buf = buffer.alloc(1024); // Allocate a buffer with size 1024\n  let offset = 0;\n\n  hashMap.forEach((value: number, key: string) => {\n    const keyBuf = buffer.from(key, 'utf-8');\n    const valueBuf = buffer.alloc(4); // Assuming number is 4 bytes\n    valueBuf.writeUInt32BE(value, 0);\n\n    keyBuf.copy(buf, offset);\n    offset += keyBuf.length;\n    valueBuf.copy(buf, offset);\n    offset += valueBuf.length;\n  });\n\n  return buf;\n}\n\nexport function setupThreadWorker(workerScope: ThreadWorkerGlobalScope): void {\n  workerScope.onmessage = (message: Object) => {\n    if (message instanceof buffer.Buffer) {\n      const receivedBuffer = message;\n      // Process the received buffer here\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `keys` method of `HashMap` to get all keys, then uses the `concat` method of `buffer` to merge buffers created from each key. Finally, use the `callGlobalCallObjectMethod` method of `ThreadWorkerGlobalScope` to pass the merged buffer to a global function for further processing.",
    "input": "",
    "output": "import {HashMap, buffer, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processHashMapKeys(hashMap: HashMap<string, string>): void {\n  const keys: string[] = hashMap.keys();\n  const buffers: buffer.Buffer[] = [];\n  \n  for (const key of keys) {\n    const keyBuffer = buffer.from(key, 'utf-8');\n    buffers.push(keyBuffer);\n  }\n  \n  const mergedBuffer = buffer.concat(buffers);\n  const threadWorkerGlobalScope = new ThreadWorkerGlobalScope();\n  threadWorkerGlobalScope.callGlobalCallObjectMethod('processBuffer', mergedBuffer);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `TreeMap` to retrieve all keys, then passes these keys to the `addAll` method of `LightWeightSet` to create a set of unique keys. Finally, use the `toArray` method of `LightWeightSet` to convert the set back into an array and return it.",
    "input": "",
    "output": "import {TreeMap, stream, LightWeightSet} from '@kit.ArkTS';\n\nexport function getUniqueKeysFromTreeMap<K>(treeMap: TreeMap<K, unknown>): Array<K> {\n  const keys = treeMap.keys();\n  const lightWeightSet = new LightWeightSet<K>();\n  lightWeightSet.addAll(keys);\n  return lightWeightSet.toArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `values` method of `LightWeightSet` to retrieve all values, then passes these values to the `setAll` method of `TreeMap` to populate a new map. Use the `getFirstKey` and `getLastKey` methods of `TreeMap` to return the first and last keys of the newly created map.",
    "input": "",
    "output": "import {TreeMap, stream, LightWeightSet} from '@kit.ArkTS';\n\nexport function populateTreeMapFromLightWeightSet(lws: LightWeightSet<number>): {firstKey: number | undefined, lastKey: number | undefined} {\n  const values = lws.values();\n  const treeMap = new TreeMap<number, number>();\n  treeMap.setAll(values);\n  \n  const firstKey = treeMap.getFirstKey();\n  const lastKey = treeMap.getLastKey();\n  \n  return {firstKey, lastKey};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `entries` method of `TreeMap` to retrieve key-value pairs, then filters these pairs based on a condition and stores the filtered pairs in a `LightWeightSet` using the `add` method. Finally, use the `forEach` method of `LightWeightSet` to print each key-value pair.",
    "input": "",
    "output": "import {TreeMap, stream, LightWeightSet} from '@kit.ArkTS';\n\nexport function filterAndStoreTreeMapEntries(treeMap: TreeMap<number, string>, condition: (key: number, value: string) => boolean): void {\n  const filteredSet = new LightWeightSet<[number, string]>();\n  \n  for (const [key, value] of treeMap.entries()) {\n    if (condition(key, value)) {\n      filteredSet.add([key, value]);\n    }\n  }\n  \n  filteredSet.forEach((entry: [number, string]) => {\n    console.log(`Key: ${entry[0]}, Value: ${entry[1]}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a unique identifier, then adds it to a `LightWeightSet` using the `add` method. Finally, iterate over the set using the `[Symbol.iterator]` method of `LightWeightSet` and print each UUID using the `printf` method of `util`.",
    "input": "",
    "output": "import {util, LightWeightSet, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function generateAndPrintUUIDs(): void {\n  const uuidSet: LightWeightSet<string> = new LightWeightSet<string>();\n  const uuid: string = util.generateRandomUUID();\n  uuidSet.add(uuid);\n\n  for (const value of uuidSet) {\n    util.printf(value);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `promisify` method of `util` to convert a callback-based operation into a Promise, then post the result to a worker thread using the `postMessage` method of `ThreadWorkerGlobalScope`. The worker thread should process the message and log it using the `onmessage` property of `ThreadWorkerGlobalScope`.",
    "input": "",
    "output": "import {util, LightWeightSet, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function promisifyAndPostToWorker(callbackBasedFunc: (arg: string, callback: (error: Error | null, result: string) => void) => void, arg: string, worker: ThreadWorkerGlobalScope): void {\n  const promisifiedFunc = util.promisify(callbackBasedFunc);\n  promisifiedFunc(arg)\n    .then((result: string) => {\n      worker.postMessage(result);\n    })\n    .catch((error: Error) => {\n      worker.postMessage(`Error: ${error.message}`);\n    });\n}\n\nexport function setupWorker(worker: ThreadWorkerGlobalScope): void {\n  worker.onmessage = (message: string) => {\n    console.log(`Worker received: ${message}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getHash` method of `util` to compute the hash of a string, then stores the hash values in a `LightWeightSet` using the `addAll` method. Afterward, use the `forEach` method of `LightWeightSet` to iterate over the hashes and post each one to a worker thread using the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope`.",
    "input": "",
    "output": "import {util, LightWeightSet, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processHashes(inputStrings: string[], workerScope: ThreadWorkerGlobalScope): void {\n  const hashSet = new LightWeightSet<string>();\n  \n  // Compute hashes for each input string and add to LightWeightSet\n  inputStrings.forEach((str: string) => {\n    const hash = util.getHash(str);\n    hashSet.add(hash);\n  });\n  \n  // Iterate over hashes and post each to worker thread\n  hashSet.forEach((hash: string) => {\n    workerScope.postMessageWithSharedSendable(hash);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `List` to iterate over a list of error messages, and then passes each error message to the `onerror` property of `GlobalScope` to handle and log all errors sequentially.",
    "input": "",
    "output": "import {stream, GlobalScope, List} from '@kit.ArkTS';\n\nexport function handleErrorMessages(errorMessages: List<string>, globalScope: GlobalScope): void {\n  errorMessages.forEach((errorMessage: string) => {\n    globalScope.onerror = (event: ErrorEvent) => {\n      console.error(event.message);\n    };\n    const errorEvent: ErrorEvent = { message: errorMessage } as ErrorEvent;\n    if (globalScope.onerror) {\n      globalScope.onerror(errorEvent);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `add` and `getLast` methods of `List` to build a dynamic list of names, and then assigns the final list to the `name` property of `GlobalScope` for global access and reference.",
    "input": "",
    "output": "import {stream, GlobalScope, List} from '@kit.ArkTS';\n\nexport function buildAndAssignNameList(names: string[]): void {\n  const nameList = new List<string>();\n  \n  for (const name of names) {\n    nameList.add(name);\n  }\n  \n  GlobalScope.name = nameList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses the `sort` method of `List` to organize a list of numerical values, and then passes the sorted list to the `convertToArray` method of `List` to transform it into an array format for further processing or display.",
    "input": "",
    "output": "import {stream, GlobalScope, List} from '@kit.ArkTS';\n\nexport function sortAndConvertToArray(numbers: List<number>): number[] {\n  numbers.sort((a: number, b: number) => a - b);\n  return numbers.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirstKey` method of `TreeMap` to retrieve the smallest key, then passes this key to the `add` method of `Queue` to enqueue it. Finally, use the `pop` method of `Queue` to dequeue and return the value.",
    "input": "",
    "output": "import {TreeMap, url, Queue} from '@kit.ArkTS';\n\nexport function processTreeMapAndQueue(treeMap: TreeMap<number, unknown>, queue: Queue<number>): number | undefined {\n  const firstKey = treeMap.getFirstKey();\n  if (firstKey !== undefined) {\n    queue.add(firstKey);\n    return queue.pop();\n  }\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that iterates over the `keys` of a `TreeMap` using the `[Symbol.iterator]` method, filters out keys greater than a threshold, and stores the filtered keys in a `Queue` using its `add` method. Then, use the `length` property of `Queue` to return the count of filtered keys.",
    "input": "",
    "output": "import {TreeMap, url, Queue} from '@kit.ArkTS';\n\nexport function filterAndCountKeys(treeMap: TreeMap<number, unknown>, threshold: number): number {\n  const queue = new Queue<number>();\n  \n  for (const key of treeMap.keys()) {\n    if (key <= threshold) {\n      queue.add(key);\n    }\n  }\n  \n  return queue.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getHigherKey` method of `TreeMap` to find the next key after a given input, then checks if this key exists in the `TreeMap` using `hasKey`. If it exists, add the key to a `Queue` using `add`, and finally return the `Queue`'s contents using `getFirst` and `pop` methods.",
    "input": "",
    "output": "import {TreeMap, url, Queue} from '@kit.ArkTS';\n\nexport function processTreeMapKeys(treeMap: TreeMap<number, unknown>, inputKey: number): number | undefined {\n  const queue = new Queue<number>();\n  const higherKey = treeMap.getHigherKey(inputKey);\n  \n  if (higherKey !== undefined && treeMap.hasKey(higherKey)) {\n    queue.add(higherKey);\n  }\n  \n  if (queue.length > 0) {\n    const firstElement = queue.getFirst();\n    queue.pop();\n    return firstElement;\n  }\n  \n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `ThreadWorkerGlobalScope.postMessage` to send a message to a worker thread, and then uses `WorkerEventTarget.addEventListener` to listen for a response event from the worker thread. The function should process the response data and log it.",
    "input": "",
    "output": "import {WorkerEventTarget, ThreadWorkerGlobalScope, process} from '@kit.ArkTS';\n\nexport function communicateWithWorker(worker: ThreadWorkerGlobalScope, target: WorkerEventTarget): void {\n  const message = { data: 'Hello, Worker!' };\n  worker.postMessage(message);\n\n  target.addEventListener('message', (event: MessageEvent) => {\n    const response = event.data;\n    console.log('Received response from worker:', response);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that uses `process.getEnvironmentVar` to fetch an environment variable and then uses `ThreadWorkerGlobalScope.postMessage` to send the fetched value back to the main thread. The main thread should use `WorkerEventTarget.addEventListener` to receive and display the environment variable value.",
    "input": "",
    "output": "import {WorkerEventTarget, ThreadWorkerGlobalScope, process} from '@kit.ArkTS';\n\n// Main thread code\nexport class MainThread {\n  private worker: ThreadWorkerGlobalScope;\n\n  constructor() {\n    this.worker = new ThreadWorkerGlobalScope('workers/worker.ts');\n    this.worker.addEventListener('message', (event: MessageEvent<string>) => {\n      console.log(`Received environment variable value: ${event.data}`);\n    });\n  }\n}\n\n// Worker thread code (workers/worker.ts)\nexport class WorkerThread {\n  static init() {\n    const envVar = process.getEnvironmentVar('PATH');\n    ThreadWorkerGlobalScope.postMessage(envVar);\n  }\n}\n\nWorkerThread.init();",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a worker thread uses `process.uptime` to calculate its runtime duration and then uses `ThreadWorkerGlobalScope.postMessageWithSharedSendable` to send the duration data to the main thread. The main thread should use `WorkerEventTarget.dispatchEvent` to trigger a custom event with the received duration data.",
    "input": "",
    "output": "import {WorkerEventTarget, ThreadWorkerGlobalScope, process} from '@kit.ArkTS';\n\nexport function workerThreadCode(workerScope: ThreadWorkerGlobalScope): void {\n  const duration = process.uptime();\n  workerScope.postMessageWithSharedSendable({ duration });\n}\n\nexport function mainThreadCode(workerEventTarget: WorkerEventTarget): void {\n  workerEventTarget.addEventListener('message', (event: { data: { duration: number } }) => {\n    const customEvent = {\n      type: 'durationEvent',\n      data: event.data.duration\n    };\n    workerEventTarget.dispatchEvent(customEvent);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a sequence of key-value pairs (e.g., user IDs and names), then converts this data into a buffer using the `from` method of `buffer` to serialize it for network transmission. Finally, use the `compare` method of `buffer` to verify the integrity of the transmitted data against the original.",
    "input": "",
    "output": "import {PlainArray, buffer, ArrayList} from '@kit.ArkTS';\n\nexport function serializeAndVerifyData(): void {\n  // Create a PlainArray to store key-value pairs\n  const userData = new PlainArray<string>();\n  userData.add(1, 'Alice');\n  userData.add(2, 'Bob');\n  userData.add(3, 'Charlie');\n\n  // Convert PlainArray to a format suitable for buffer serialization\n  const serializedData: number[] = [];\n  for (let i = 0; i < userData.length; i++) {\n    const key = userData.getKeyAt(i);\n    const value = userData.getValueAt(i);\n    serializedData.push(key);\n    if (value) {\n      const valueBytes = Array.from(value).map(c => c.charCodeAt(0));\n      serializedData.push(...valueBytes);\n    }\n    serializedData.push(0); // Null terminator between entries\n  }\n\n  // Create a buffer from the serialized data\n  const dataBuffer = buffer.from(serializedData);\n\n  // Simulate network transmission by creating a copy of the buffer\n  const transmittedBuffer = buffer.from(dataBuffer);\n\n  // Verify the integrity of the transmitted data\n  const isDataValid = buffer.compare(dataBuffer, transmittedBuffer) === 0;\n  console.log(`Data integrity verified: ${isDataValid}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `convertToArray` method of `ArrayList` to extract elements into an array, then pass this array to the `concat` method of `buffer` to merge it with another buffer. Use the `length` property of `ArrayList` to ensure the merged buffer's size matches the expected total length.",
    "input": "",
    "output": "import {PlainArray, buffer, ArrayList} from '@kit.ArkTS';\n\nexport function mergeBuffersFromArrayList(list: ArrayList<number>, otherBuffer: buffer.Buffer): buffer.Buffer {\n  const array = list.convertToArray();\n  const listBuffer = buffer.from(array);\n  const mergedBuffer = buffer.concat([listBuffer, otherBuffer], list.length + otherBuffer.length);\n  return mergedBuffer;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getValueAt` method of `PlainArray` to retrieve values at specific indices, then pass these values to the `insert` method of `ArrayList` to dynamically build a list. Use the `sort` method of `ArrayList` to organize the final list in ascending order.",
    "input": "",
    "output": "import {PlainArray, buffer, ArrayList} from '@kit.ArkTS';\n\nexport function buildAndSortList(plainArray: PlainArray<number, number>, indices: number[]): ArrayList<number> {\n  const arrayList = new ArrayList<number>();\n  \n  for (const index of indices) {\n    const value = plainArray.getValueAt(index);\n    if (value !== undefined) {\n      arrayList.insert(arrayList.length, value);\n    }\n  }\n  \n  arrayList.sort((a: number, b: number) => a - b);\n  \n  return arrayList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send a `Vector` object containing a list of numbers to a worker thread. The worker thread should then use the `sort` method of the received `Vector` to sort the numbers in ascending order and return the sorted list using `postMessage` back to the main thread.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, Vector, ArrayList} from '@kit.ArkTS';\n\nexport function sendVectorToWorker(worker: DedicatedWorkerGlobalScope, numbers: number[]): void {\n  const vector = new Vector<number>();\n  numbers.forEach(num => vector.add(num));\n  worker.postMessage(vector);\n}\n\nexport function setupWorkerListener(worker: DedicatedWorkerGlobalScope, callback: (sortedNumbers: number[]) => void): void {\n  worker.onmessage = (event: MessageEvent<Vector<number>>) => {\n    const receivedVector = event.data;\n    receivedVector.sort((a, b) => a - b);\n    const sortedArray: number[] = [];\n    for (let i = 0; i < receivedVector.length; i++) {\n      sortedArray.push(receivedVector.get(i));\n    }\n    callback(sortedArray);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes an `ArrayList` with a set of strings and uses the `convertToArray` method to convert it into an array. Then, pass this array to a `Vector` object using its `constructor` method. Finally, use the `subVector` method of the `Vector` to extract a subset of elements and return them.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, Vector, ArrayList} from '@kit.ArkTS';\n\nexport function processVector(): string[] {\n  // Initialize ArrayList with strings\n  const arrayList = new ArrayList<string>();\n  arrayList.add('Apple');\n  arrayList.add('Banana');\n  arrayList.add('Cherry');\n  arrayList.add('Date');\n  arrayList.add('Elderberry');\n\n  // Convert ArrayList to array\n  const array = arrayList.convertToArray();\n\n  // Pass array to Vector constructor\n  const vector = new Vector<string>(array);\n\n  // Extract subset using subVector\n  const subVector = vector.subVector(1, 4);\n\n  // Convert subVector to array and return\n  return subVector.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a `DedicatedWorkerGlobalScope` receives a message containing an array of numbers via `onmessage`. The worker should use the `ArrayList` `add` method to populate an `ArrayList` with these numbers, then use the `sort` method to sort them. The sorted `ArrayList` should then be converted to a `Vector` using the `Vector` `constructor`, and the `getFirstElement` and `getLastElement` methods of the `Vector` should be used to return the smallest and largest values via `postMessage`.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, Vector, ArrayList} from '@kit.ArkTS';\n\nconst workerScope: DedicatedWorkerGlobalScope = self as DedicatedWorkerGlobalScope;\n\nworkerScope.onmessage = (e: MessageEvent<number[]>) => {\n  const numbers = e.data;\n  const arrayList = new ArrayList<number>();\n  \n  for (const num of numbers) {\n    arrayList.add(num);\n  }\n  \n  arrayList.sort((a: number, b: number) => a - b);\n  \n  const vector = new Vector<number>(arrayList);\n  const smallest = vector.getFirstElement();\n  const largest = vector.getLastElement();\n  \n  workerScope.postMessage({ smallest, largest });\n};\n",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to run a `CallbackFunction` in parallel, and then uses the `length` property of `Queue` to check if the results were successfully added to a queue. If the queue length is zero, use the `error` property of `ErrorEvent` to log an error message.",
    "input": "",
    "output": "import {taskpool, ErrorEvent, Queue} from '@kit.ArkTS';\n\nexport function executeAndCheckQueue(callback: taskpool.CallbackFunction, queue: Queue<unknown>): void {\n  taskpool.execute(callback).then(() => {\n    if (queue.length === 0) {\n      const errorEvent = new ErrorEvent('error');\n      errorEvent.error = 'No results were added to the queue';\n      console.error(errorEvent.error);\n    }\n  }).catch((error: ErrorEvent) => {\n    console.error(error.error);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that schedules a delayed task using the `executeDelayed` method of `taskpool` with a `Priority` of `HIGH`. After the task completes, use the `getFirst` method of `Queue` to retrieve the result and pass it to another `CallbackFunctionWithError`. If an error occurs, use the `message` property of `ErrorEvent` to display the error details.",
    "input": "",
    "output": "import {taskpool, ErrorEvent, Queue} from '@kit.ArkTS';\n\nexport function scheduleDelayedTask(\n  task: () => void,\n  delay: number,\n  callback: (result: unknown) => void,\n  errorCallback: (error: ErrorEvent) => void\n): void {\n  const queue = new Queue<unknown>();\n  \n  try {\n    taskpool.executeDelayed(\n      () => {\n        task();\n        return queue.getFirst();\n      },\n      delay,\n      taskpool.Priority.HIGH\n    ).then((result) => {\n      callback(result);\n    }).catch((error: ErrorEvent) => {\n      errorCallback(error);\n    });\n  } catch (error) {\n    const errorEvent = new ErrorEvent('error');\n    errorEvent.message = error instanceof Error ? error.message : String(error);\n    errorCallback(errorEvent);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `executePeriodically` method of `taskpool` to run a task every 5 seconds. Each time the task runs, it should add its result to a `Queue` using the `add` method. After 3 iterations, use the `terminateTask` method of `taskpool` to stop the periodic execution and then use the `forEach` method of `Queue` to process all collected results.",
    "input": "",
    "output": "import {taskpool, ErrorEvent, Queue} from '@kit.ArkTS';\n\nexport function executePeriodicallyAndProcessResults(): void {\n  const queue = new Queue<number>();\n  let iterationCount = 0;\n  \n  const taskId = taskpool.executePeriodically(() => {\n    const result = Math.random();\n    queue.add(result);\n    iterationCount++;\n    \n    if (iterationCount >= 3) {\n      taskpool.terminateTask(taskId);\n      \n      queue.forEach((value: number, index?: number) => {\n        console.log(`Processed result ${index}: ${value}`);\n      });\n    }\n    return result;\n  }, 5000);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `set` method of `LightWeightMap` to store key-value pairs of error messages and their corresponding timestamps, then passes the map to the `onerror` property of `GlobalScope` to handle and log these errors globally.",
    "input": "",
    "output": "import {LightWeightMap, PostMessageOptions, GlobalScope} from '@kit.ArkTS';\n\nexport function setupGlobalErrorHandler(): void {\n  const errorMap = new LightWeightMap<string, number>();\n\n  GlobalScope.onerror = (message: string, source: string, lineno: number, colno: number, error: Error) => {\n    const timestamp = Date.now();\n    errorMap.set(message, timestamp);\n    console.log(`Error: ${message} at ${timestamp}`);\n    return true;\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `entries` method of `LightWeightMap` to retrieve all key-value pairs, then uses the `transfer` property of `PostMessageOptions` to send these entries to another context or worker for further processing.",
    "input": "",
    "output": "import {LightWeightMap, PostMessageOptions, GlobalScope} from '@kit.ArkTS';\n\nexport function sendLightWeightMapEntries(lightWeightMap: LightWeightMap<number, ArrayBuffer>, target: GlobalScope): void {\n  const entries: IterableIterator<[number, ArrayBuffer]> = lightWeightMap.entries();\n  const entriesArray: [number, ArrayBuffer][] = Array.from(entries);\n  const transferBuffers: ArrayBuffer[] = entriesArray.map(([_, value]) => value);\n  const options: PostMessageOptions = {\n    transfer: transferBuffers\n  };\n  target.postMessage(entriesArray, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if a `LightWeightMap` is empty using the `isEmpty` method, and if it is, sets the `name` property of `GlobalScope` to a default value, otherwise sets it to the first key in the map using `getKeyAt`.",
    "input": "",
    "output": "import {LightWeightMap, PostMessageOptions, GlobalScope} from '@kit.ArkTS';\n\nexport function checkAndSetName(map: LightWeightMap<unknown, unknown>, globalScope: GlobalScope): void {\n  if (map.isEmpty()) {\n    globalScope.name = 'default';\n  } else {\n    globalScope.name = map.getKeyAt(0) as string;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that parses an XML string using the `xml.parse` method, extracts the `type` property from the resulting `Event` object, and then logs an error message using the `message` property of an `ErrorEvent` if the `type` does not match a predefined `EventType` enum value.",
    "input": "",
    "output": "import {xml, ErrorEvent, Event} from '@kit.ArkTS';\n\nexport enum EventType {\n  // Define your EventType enum values here\n  TYPE1 = 'type1',\n  TYPE2 = 'type2'\n}\n\nexport function parseAndCheckEventType(xmlString: string): void {\n  try {\n    const event: Event = xml.parse(xmlString);\n    const eventType: string = event.type;\n    \n    if (!Object.values(EventType).includes(eventType as EventType)) {\n      const errorEvent = new ErrorEvent('error', {\n        message: `Invalid event type: ${eventType}`\n      });\n      console.error(errorEvent.message);\n    }\n  } catch (error) {\n    console.error('Error parsing XML:', error);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that generates an `ErrorEvent` with custom `message`, `filename`, `lineno`, and `colno` properties, then triggers an `Event` with the `type` property set to 'error' and the `timeStamp` property recording when the error occurred. The function should return the combined error and event details as a formatted string.",
    "input": "",
    "output": "import {xml, ErrorEvent, Event} from '@kit.ArkTS';\n\nexport function generateErrorEvent(message: string, filename: string, lineno: number, colno: number): string {\n  const errorEvent = new ErrorEvent('error', {\n    message: message,\n    filename: filename,\n    lineno: lineno,\n    colno: colno\n  });\n\n  const event = new Event('error');\n  event.timeStamp = Date.now();\n\n  return `ErrorEvent Details: message=${errorEvent.message}, filename=${errorEvent.filename}, lineno=${errorEvent.lineno}, colno=${errorEvent.colno}; Event Details: type=${event.type}, timeStamp=${event.timeStamp}`;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that processes an XML string using the `xml.parse` method, checks if the parsed result contains an error by examining the `error` property of an `ErrorEvent`, and if so, creates an `Event` object with the `type` property set to 'error' and the `timeStamp` property set to the current time. The function should return the `Event` object if an error is found, otherwise return the parsed XML result.",
    "input": "",
    "output": "import {xml, ErrorEvent, Event} from '@kit.ArkTS';\n\nexport function processXmlString(xmlString: string): Event | object {\n  const parsedResult = xml.parse(xmlString);\n  if (parsedResult instanceof ErrorEvent) {\n    const errorEvent = new Event('error');\n    errorEvent.timeStamp = Date.now();\n    return errorEvent;\n  }\n  return parsedResult;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` to collect a sequence of messages, then passes the collected messages to the `transfer` property of `PostMessageOptions` to send them to another context.",
    "input": "",
    "output": "import {PostMessageOptions, xml, Deque} from '@kit.ArkTS';\n\nexport function collectAndSendMessages(messages: string[], transferBuffers: ArrayBuffer[]): PostMessageOptions {\n  const deque = new Deque<string>();\n  \n  // Insert messages into the deque\n  for (const message of messages) {\n    deque.insertFront(message);\n    deque.insertEnd(message);\n  }\n  \n  // Collect messages from the deque\n  const collectedMessages: string[] = [];\n  for (const message of deque) {\n    collectedMessages.push(message);\n  }\n  \n  // Prepare PostMessageOptions\n  const options: PostMessageOptions = {\n    transfer: transferBuffers\n  };\n  \n  return options;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that iterates over a `Deque` using the `[Symbol.iterator]` method, filters the elements based on a condition, and then uses the `EventType` enum from `xml` to log each filtered element with a specific event type.",
    "input": "",
    "output": "import {PostMessageOptions, xml, Deque} from '@kit.ArkTS';\n\nexport function filterAndLogDequeElements(deque: Deque<number>, condition: (value: number) => boolean): void {\n  for (const element of deque[Symbol.iterator]()) {\n    if (condition(element)) {\n      console.log(`Filtered element: ${element}, EventType: ${xml.EventType.CHANGE}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getFirst` and `getLast` methods of `Deque` to retrieve the first and last elements, then combines them into a single message and passes it to the `transfer` property of `PostMessageOptions` for cross-context communication.",
    "input": "",
    "output": "import {PostMessageOptions, xml, Deque} from '@kit.ArkTS';\n\nexport function combineAndTransfer(deque: Deque<ArrayBuffer>): PostMessageOptions {\n  const firstElement: ArrayBuffer | undefined = deque.getFirst();\n  const lastElement: ArrayBuffer | undefined = deque.getLast();\n  \n  if (!firstElement || !lastElement) {\n    throw new Error('Deque does not contain enough elements');\n  }\n  \n  const combinedMessage: string = `${firstElement}${lastElement}`;\n  const transferBuffers: ArrayBuffer[] = [firstElement, lastElement];\n  \n  const options: PostMessageOptions = {\n    transfer: transferBuffers\n  };\n  \n  return options;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a buffer from a string, then uses `deque.insertEnd` to add the buffer to a deque, and finally uses `deque.getLast` to retrieve and verify the last inserted buffer.",
    "input": "",
    "output": "import {Deque, buffer, util} from '@kit.ArkTS';\n\nexport function bufferDequeOperation(inputString: string): boolean {\n  const buf = buffer.from(inputString, 'utf-8');\n  const deque = new Deque<buffer.Buffer>();\n  deque.insertEnd(buf);\n  const lastBuffer = deque.getLast();\n  return buffer.compare(buf, lastBuffer) === 0;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that generates a random UUID using `util.generateRandomUUID`, converts it to a buffer using `buffer.from`, and then checks if the buffer is valid using `buffer.isBuffer`.",
    "input": "",
    "output": "import {Deque, buffer, util} from '@kit.ArkTS';\n\nexport function generateAndCheckUUID(): boolean {\n  const uuid = util.generateRandomUUID();\n  const buf = buffer.from(uuid);\n  return buffer.isBuffer(buf);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `deque.popFirst` to retrieve the first element of a deque, checks if it is a buffer using `buffer.isBuffer`, and if true, converts it to a string using `buffer.transcode` with `buffer.BufferEncoding.UTF8`.",
    "input": "",
    "output": "import {Deque, buffer, util} from '@kit.ArkTS';\n\nexport function processFirstBufferElement(deque: Deque<buffer.Buffer>): string | undefined {\n  const firstElement = deque.popFirst();\n  if (firstElement && buffer.isBuffer(firstElement)) {\n    return buffer.transcode(firstElement, buffer.BufferEncoding.UTF8, buffer.BufferEncoding.UTF8);\n  }\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a unique identifier, then passes this UUID to the `name` property of `WorkerOptions` to initialize a worker thread. Finally, use the `addEventListener` method of `WorkerEventTarget` to listen for messages from the worker.",
    "input": "",
    "output": "import {util, WorkerOptions, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function initializeWorkerWithUUID(): WorkerEventTarget {\n  const uuid: string = util.generateRandomUUID();\n  const workerOptions: WorkerOptions = {\n    name: uuid\n  };\n  const worker = new Worker('worker.js', workerOptions);\n  worker.addEventListener('message', (event: MessageEvent) => {\n    console.log('Message received from worker:', event.data);\n  });\n  return worker;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `promisify` method of `util` to convert a callback-based function into a promise, then use the `dispatchEvent` method of `WorkerEventTarget` to emit an event with the resolved promise value. Ensure the event name is dynamically generated using the `format` method of `util`.",
    "input": "",
    "output": "import {util, WorkerOptions, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function promisifyAndDispatch(callbackFunc: (arg: string, cb: (err: Error | null, result: string) => void) => void, arg: string, workerEventTarget: WorkerEventTarget, eventPrefix: string): Promise<void> {\n  const promisifiedFunc = util.promisify(callbackFunc);\n  return promisifiedFunc(arg)\n    .then((result: string) => {\n      const eventName = util.format('%s_%s', eventPrefix, 'resolved');\n      const event = { type: eventName, data: result };\n      workerEventTarget.dispatchEvent(event);\n    })\n    .catch((err: Error) => {\n      const eventName = util.format('%s_%s', eventPrefix, 'rejected');\n      const event = { type: eventName, data: err.message };\n      workerEventTarget.dispatchEvent(event);\n    });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getHash` method of `util` to compute a hash value from a string input, then pass this hash value to the `shared` property of `WorkerOptions` to enable shared memory access. Use the `removeAllListener` method of `WorkerEventTarget` to clean up any existing event listeners before setting up new ones.",
    "input": "",
    "output": "import {util, WorkerOptions, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function setupWorkerWithSharedMemory(input: string, workerEventTarget: WorkerEventTarget): WorkerOptions {\n  const hashValue: string = util.getHash(input);\n  \n  workerEventTarget.removeAllListener();\n  \n  const workerOptions: WorkerOptions = {\n    shared: hashValue\n  };\n  \n  return workerOptions;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `dispatchEvent` method of `EventTarget` to emit a custom event containing a key-value pair, and then uses the `set` method of `HashMap` to store the emitted key-value pair in a map. Finally, use the `get` method of `HashMap` to retrieve and return the stored value.",
    "input": "",
    "output": "import {stream, EventTarget, HashMap} from '@kit.ArkTS';\n\nexport function emitAndStoreEvent(eventTarget: EventTarget, eventName: string, key: string, value: string): string | undefined {\n  const event = { type: eventName, detail: { key, value } };\n  eventTarget.dispatchEvent(event);\n  \n  const map = new HashMap<string, string>();\n  map.set(key, value);\n  \n  return map.get(key);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `addEventListener` method of `EventTarget` to listen for a custom event, and then uses the `forEach` method of `HashMap` to iterate over all key-value pairs in the map and dispatch an event for each pair using `dispatchEvent` of `EventTarget`.",
    "input": "",
    "output": "import {stream, EventTarget, HashMap} from '@kit.ArkTS';\n\nexport function handleCustomEvents(eventTarget: EventTarget, eventName: string, hashMap: HashMap<string, string>): void {\n  eventTarget.addEventListener(eventName, (event: Event) => {\n    console.log(`Event received: ${event.type}`);\n  });\n\n  hashMap.forEach((value: string, key: string) => {\n    const customEvent = new Event(`${eventName}-${key}`);\n    eventTarget.dispatchEvent(customEvent);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `keys` method of `HashMap` to get all keys in the map, and then uses the `removeEventListener` method of `EventTarget` to remove all event listeners associated with those keys. Finally, use the `clear` method of `HashMap` to empty the map.",
    "input": "",
    "output": "import {stream, EventTarget, HashMap} from '@kit.ArkTS';\n\nexport function removeAllEventListenersAndClearMap(eventMap: HashMap<string, EventTarget>): void {\n  const keys = eventMap.keys();\n  for (const key of keys) {\n    const eventTarget = eventMap.get(key);\n    if (eventTarget) {\n      eventTarget.removeEventListener(key);\n    }\n  }\n  eventMap.clear();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` to collect a sequence of numbers, then passes the deque to the `setAll` method of `TreeMap` to store the numbers as keys with their squares as values. Finally, use the `getFirstKey` and `getLastKey` methods of `TreeMap` to display the smallest and largest numbers in the sequence.",
    "input": "",
    "output": "import {GlobalScope, Deque, TreeMap} from '@kit.ArkTS';\n\nexport function processSequence(numbers: number[]): void {\n  const deque = new Deque<number>();\n  const treeMap = new TreeMap<number, number>();\n\n  // Insert numbers into the deque\n  for (const num of numbers) {\n    deque.insertFront(num);\n    deque.insertEnd(num);\n  }\n\n  // Store numbers and their squares in the TreeMap\n  treeMap.setAll(deque);\n\n  // Get the smallest and largest numbers\n  const smallest = treeMap.getFirstKey();\n  const largest = treeMap.getLastKey();\n\n  console.log(`Smallest number: ${smallest}`);\n  console.log(`Largest number: ${largest}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `forEach` method of `TreeMap` to iterate over its entries and pass each key-value pair to the `insertEnd` method of `Deque` to build a deque. Then, use the `popFirst` and `popLast` methods of `Deque` to extract and display the first and last elements of the deque.",
    "input": "",
    "output": "import {GlobalScope, Deque, TreeMap} from '@kit.ArkTS';\n\nexport function buildAndDisplayDeque(): void {\n  const treeMap = new TreeMap<number, string>();\n  treeMap.set(1, 'One');\n  treeMap.set(2, 'Two');\n  treeMap.set(3, 'Three');\n  \n  const deque = new Deque<[number, string]>();\n  \n  treeMap.forEach((value: string, key: number) => {\n    deque.insertEnd([key, value]);\n  });\n  \n  const firstElement = deque.popFirst();\n  const lastElement = deque.popLast();\n  \n  console.log(`First element: ${firstElement}`);\n  console.log(`Last element: ${lastElement}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `GlobalScope.self` property to access the global context, then uses the `get` method of `TreeMap` to retrieve a value associated with a key. If the key is not found, use the `GlobalScope.onerror` property to handle the error by logging a message and inserting a default value into the `TreeMap` using the `set` method.",
    "input": "",
    "output": "import {GlobalScope, Deque, TreeMap} from '@kit.ArkTS';\n\nexport function getOrSetDefault<K, V>(map: TreeMap<K, V>, key: K, defaultValue: V): V | undefined {\n  const globalScope = GlobalScope.self;\n  \n  try {\n    const value = map.get(key);\n    if (value === undefined) {\n      throw new Error(`Key ${key} not found in TreeMap`);\n    }\n    return value;\n  } catch (error) {\n    if (globalScope.onerror) {\n      globalScope.onerror(error);\n    }\n    map.set(key, defaultValue);\n    return defaultValue;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a unique identifier, then stores it in a `Vector` using the `add` method. Finally, use the `convertToArray` method of `Vector` to return the array of generated UUIDs.",
    "input": "",
    "output": "import {WorkerOptions, util, Vector} from '@kit.ArkTS';\n\nexport function generateAndStoreUUIDs(count: number): string[] {\n  const uuidVector: Vector<string> = new Vector<string>();\n  \n  for (let i = 0; i < count; i++) {\n    const uuid: string = util.generateRandomUUID();\n    uuidVector.add(uuid);\n  }\n  \n  return uuidVector.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `promisify` method of `util` to convert a callback-based function into a promise, then use the `forEach` method of `Vector` to process each element of the vector asynchronously. The function should return a promise that resolves when all elements have been processed.",
    "input": "",
    "output": "import {WorkerOptions, util, Vector} from '@kit.ArkTS';\n\nexport function processVectorAsync<T, R>(\n  vector: Vector<T>,\n  callback: (element: T, index: number, vector: Vector<T>) => Promise<R>\n): Promise<R[]> {\n  const promises: Promise<R>[] = [];\n  vector.forEach((element: T, index: number) => {\n    promises.push(callback(element, index, vector));\n  });\n  return Promise.all(promises);\n}\n\nexport function promisifyCallbackFunction<T, R>(\n  callbackFunc: (arg: T, cb: (err: Error | null, result: R) => void) => void\n): (arg: T) => Promise<R> {\n  return util.promisify(callbackFunc);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getErrorString` method of `util` to retrieve error messages from a list of error codes stored in a `Vector`. The function should then use the `replaceAllElements` method of `Vector` to update the vector with the corresponding error messages and return the modified vector.",
    "input": "",
    "output": "import {WorkerOptions, util, Vector} from '@kit.ArkTS';\n\nexport function getErrorMessages(errorCodes: Vector<number>): Vector<string> {\n  errorCodes.replaceAllElements((errorCode: number) => {\n    return util.getErrorString(errorCode);\n  });\n  return errorCodes;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of event names, then iterates through the stack using `Symbol.iterator`, and checks if each event name exists in a `LightWeightSet` (from @kit.ArkTS) using the `has` method. The function should return an array of events that are present in both the stack and the set.",
    "input": "",
    "output": "import {LightWeightSet, Stack, EventTarget} from '@kit.ArkTS';\n\nexport function findCommonEvents(eventNames: string[], set: LightWeightSet<string>): string[] {\n  const stack = new Stack<string>();\n  const commonEvents: string[] = [];\n\n  // Push event names into the stack\n  for (const event of eventNames) {\n    stack.push(event);\n  }\n\n  // Iterate through the stack and check for common events\n  for (const event of stack) {\n    if (set.has(event)) {\n      commonEvents.push(event);\n    }\n  }\n\n  return commonEvents;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `EventTarget.addEventListener` (from @kit.ArkTS) to listen for custom events. When an event is triggered, the function should push the event type into a `Stack` (from @kit.ArkTS) using the `push` method, and then use the `peek` method to log the most recent event type. The function should also maintain a `LightWeightSet` (from @kit.ArkTS) of all unique event types encountered, using the `add` method to update the set.",
    "input": "",
    "output": "import {LightWeightSet, Stack, EventTarget} from '@kit.ArkTS';\n\nexport function setupEventListeners(eventTarget: EventTarget): void {\n  const eventStack: Stack<string> = new Stack();\n  const uniqueEventTypes: LightWeightSet<string> = new LightWeightSet();\n\n  eventTarget.addEventListener('*', (event: string) => {\n    eventStack.push(event);\n    uniqueEventTypes.add(event);\n    console.log(`Most recent event type: ${eventStack.peek()}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `LightWeightSet.forEach` (from @kit.ArkTS) to iterate over a set of values and dispatch a custom event for each value using `EventTarget.dispatchEvent` (from @kit.ArkTS). The function should also use a `Stack` (from @kit.ArkTS) to keep track of the order of dispatched events by pushing each event type into the stack with the `push` method. The function should return the stack's contents using the `toArray` method of `LightWeightSet` (from @kit.ArkTS) to convert the stack into an array.",
    "input": "",
    "output": "import {LightWeightSet, Stack, EventTarget} from '@kit.ArkTS';\n\nexport function dispatchEventsAndTrackOrder(eventTarget: EventTarget, values: LightWeightSet<string>): Array<string> {\n  const stack = new Stack<string>();\n  \n  values.forEach((value: string) => {\n    const event = { type: value };\n    eventTarget.dispatchEvent(event);\n    stack.push(value);\n  });\n  \n  return stack.toArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `List` to collect a sequence of numbers, then passes the resulting list to the `insertEnd` method of `Deque` to create a deque. Finally, use the `getFirst` and `getLast` methods of `Deque` to compute and return the difference between the first and last elements.",
    "input": "",
    "output": "import {List, Deque, LinkedList} from '@kit.ArkTS';\n\nexport function computeDifference(numbers: number[]): number {\n  const list = new List<number>();\n  numbers.forEach(num => list.add(num));\n  \n  const deque = new Deque<number>();\n  for (let i = 0; i < list.length; i++) {\n    deque.insertEnd(list.get(i));\n  }\n  \n  const first = deque.getFirst();\n  const last = deque.getLast();\n  \n  return first - last;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `convertToArray` method of `LinkedList` to transform the linked list into an array, then passes this array to the `replaceAllElements` method of `List` to update the list with the squared values of the original elements. Finally, use the `sort` method of `List` to arrange the elements in ascending order.",
    "input": "",
    "output": "import {List, Deque, LinkedList} from '@kit.ArkTS';\n\nexport function processLinkedList(list: LinkedList<number>): List<number> {\n  const array = list.convertToArray();\n  const resultList = new List<number>();\n  resultList.replaceAllElements((element: number, index: number) => {\n    return array[index] * array[index];\n  });\n  resultList.sort((a: number, b: number) => a - b);\n  return resultList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `removeFirst` and `removeLast` methods of `LinkedList` to extract the first and last elements, then inserts these elements into a `Deque` using the `insertFront` and `insertEnd` methods respectively. Finally, use the `length` property of both `LinkedList` and `Deque` to verify that the total number of elements remains consistent.",
    "input": "",
    "output": "import {List, Deque, LinkedList} from '@kit.ArkTS';\n\nexport function transferElements(linkedList: LinkedList<number>, deque: Deque<number>): void {\n  const firstElement = linkedList.removeFirst();\n  const lastElement = linkedList.removeLast();\n  \n  deque.insertFront(firstElement);\n  deque.insertEnd(lastElement);\n  \n  const totalElements = linkedList.length + deque.length;\n  console.log(`Total elements: ${totalElements}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `from` method of `buffer` to create a buffer from a string, then uses the `set` method of `HashMap` to store the buffer as a value with a specified key. Finally, use the `get` method of `HashMap` to retrieve the buffer and the `byteLength` method of `buffer` to return the size of the stored buffer.",
    "input": "",
    "output": "import {HashMap, buffer, stream} from '@kit.ArkTS';\n\nexport function storeAndGetBufferSize(key: string, value: string): number {\n  const hashMap = new HashMap<string, buffer.Buffer>();\n  const buf = buffer.from(value, 'utf-8');\n  hashMap.set(key, buf);\n  const retrievedBuf = hashMap.get(key);\n  return retrievedBuf.byteLength;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `HashMap` to get all keys, then uses the `concat` method of `buffer` to combine the keys (converted to buffers using `buffer.from`) into a single buffer. Return the resulting buffer and its length (using `buffer.byteLength`).",
    "input": "",
    "output": "import {HashMap, buffer, stream} from '@kit.ArkTS';\n\nexport function combineKeysToBuffer(map: HashMap<string, any>): { combinedBuffer: buffer.Buffer, length: number } {\n  const keysArray = Array.from(map.keys());\n  const buffers = keysArray.map(key => buffer.from(key));\n  const combinedBuffer = buffer.concat(buffers);\n  const length = buffer.byteLength(combinedBuffer);\n  return { combinedBuffer, length };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `allocUninitialized` method of `buffer` to create a buffer of a given size, then populates it with data. Use the `entries` method of `HashMap` to iterate over key-value pairs, and for each value (assuming it's a buffer), use the `compare` method of `buffer` to check if it matches the allocated buffer. Return the number of matches found.",
    "input": "",
    "output": "import {HashMap, buffer, stream} from '@kit.ArkTS';\n\nexport function countBufferMatches(size: number, map: HashMap<unknown, buffer.Buffer>): number {\n  const allocatedBuffer = buffer.allocUninitialized(size);\n  let matches = 0;\n\n  for (const [_, value] of map.entries()) {\n    if (buffer.compare(value, allocatedBuffer) === 0) {\n      matches++;\n    }\n  }\n\n  return matches;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a unique identifier, then stores this UUID as a key in a `TreeMap` along with a corresponding error message using the `set` method. Finally, retrieve the error message using the `get` method of `TreeMap` and log it using the `printf` method of `util`.",
    "input": "",
    "output": "import {util, ErrorEvent, TreeMap} from '@kit.ArkTS';\n\nexport function storeAndRetrieveErrorMessage(): void {\n  const uuid: string = util.generateRandomUUID();\n  const errorMessage: string = 'An error occurred during execution.';\n  const treeMap: TreeMap<string, string> = new TreeMap();\n  treeMap.set(uuid, errorMessage);\n  const retrievedMessage: string | undefined = treeMap.get(uuid);\n  if (retrievedMessage !== undefined) {\n    util.printf('Retrieved error message: %s', retrievedMessage);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that constructs an `ErrorEvent` object with custom `message`, `filename`, `lineno`, and `colno` properties. Then, use the `getErrorString` method of `util` to convert the error message into a formatted string, and store this string in a `TreeMap` using the `set` method. Finally, iterate over the `TreeMap` using the `forEach` method and print each entry using the `printf` method of `util`.",
    "input": "",
    "output": "import {util, ErrorEvent, TreeMap} from '@kit.ArkTS';\n\nexport function createAndProcessErrorEvent(): void {\n  // Create an ErrorEvent object with custom properties\n  const errorEvent: ErrorEvent = new ErrorEvent('error', {\n    message: 'Custom error message',\n    filename: 'example.ets',\n    lineno: 42,\n    colno: 10\n  });\n\n  // Convert the error message into a formatted string\n  const errorString: string = util.getErrorString(errorEvent.message);\n\n  // Store the formatted string in a TreeMap\n  const errorMap: TreeMap<string, string> = new TreeMap();\n  errorMap.set('errorKey', errorString);\n\n  // Iterate over the TreeMap and print each entry\n  errorMap.forEach((value: string, key: string) => {\n    util.printf('Key: %s, Value: %s', key, value);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `promisify` method of `util` to convert a callback-based function into a promise-based one. Handle any potential errors by creating an `ErrorEvent` object with the error details. Then, store the error event in a `TreeMap` using the `set` method, and retrieve the first key-value pair using the `getFirstKey` and `get` methods of `TreeMap` to log the error details using the `printf` method of `util`.",
    "input": "",
    "output": "import {util, ErrorEvent, TreeMap} from '@kit.ArkTS';\n\nexport function promisifyAndHandleError(callbackFunc: (arg: string, callback: (err: Error | null, result: string) => void) => void, arg: string): void {\n  const promisifiedFunc = util.promisify(callbackFunc);\n  const errorMap = new TreeMap<string, ErrorEvent>();\n\n  promisifiedFunc(arg)\n    .then((result: string) => {\n      console.log(result);\n    })\n    .catch((err: Error) => {\n      const errorEvent = new ErrorEvent({\n        error: err,\n        message: err.message,\n        filename: 'script.js',\n        lineno: 1,\n        colno: 1\n      });\n      errorMap.set('error1', errorEvent);\n      \n      const firstKey = errorMap.getFirstKey();\n      if (firstKey !== undefined) {\n        const firstErrorEvent = errorMap.get(firstKey);\n        if (firstErrorEvent !== undefined) {\n          util.printf('Error details: %s', firstErrorEvent.message);\n        }\n      }\n    });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send a list of numbers to a worker thread, and then uses the `sort` method of `List` to sort the numbers in ascending order before sending the sorted list back to the main thread using `postMessage` again.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, EventTarget, List} from '@kit.ArkTS';\n\nexport function sortNumbersInWorker(worker: DedicatedWorkerGlobalScope, numbers: number[]): void {\n  worker.onmessage = (event: MessageEvent<number[]>) => {\n    const list = new List<number>();\n    event.data.forEach((num) => {\n      list.add(num);\n    });\n    list.sort((a, b) => a - b);\n    worker.postMessage(list.convertToArray());\n  };\n  worker.postMessage(numbers);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `addEventListener` method of `EventTarget` to listen for a custom event, and when the event is triggered, uses the `add` and `getLast` methods of `List` to append a new item to a list and retrieve the last item for further processing.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, EventTarget, List} from '@kit.ArkTS';\n\nexport function setupCustomEventListener(eventTarget: EventTarget, eventName: string, initialList: List<string>): void {\n  eventTarget.addEventListener(eventName, (event: CustomEvent) => {\n    const newItem = event.detail;\n    initialList.add(newItem);\n    const lastItem = initialList.getLast();\n    console.log(`Last item in the list: ${lastItem}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `List` to iterate over a list of strings, and for each string, uses the `dispatchEvent` method of `EventTarget` to emit a custom event with the string as the event data, allowing other parts of the application to react to each string individually.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, EventTarget, List} from '@kit.ArkTS';\n\nexport function emitStringEvents(eventTarget: EventTarget, stringList: List<string>): void {\n  stringList.forEach((str: string) => {\n    const event = { type: 'customEvent', data: str };\n    eventTarget.dispatchEvent(event);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a message to a worker thread, and then uses the `addEventListener` method of `WorkerEventTarget` in the worker thread to listen for and process the incoming message. The function should also handle errors by utilizing the `onerror` property of `GlobalScope`.",
    "input": "",
    "output": "import {GlobalScope, WorkerEventTarget, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerCommunication() {\n  // Assuming this is running in the worker thread context\n  const workerScope: ThreadWorkerGlobalScope = self as ThreadWorkerGlobalScope;\n\n  // Set up error handler\n  workerScope.onerror = (error: ErrorEvent) => {\n    console.error(`Worker error: ${error.message}`);\n  };\n\n  // Listen for messages from main thread\n  workerScope.addEventListener('message', (event: MessageEvent) => {\n    console.log('Received message in worker:', event.data);\n    // Process the message here\n  });\n\n  // Example of sending a message back to main thread\n  workerScope.postMessage('Worker is ready');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that uses the `callGlobalCallObjectMethod` method of `ThreadWorkerGlobalScope` to invoke a global function, and then uses the `dispatchEvent` method of `WorkerEventTarget` to notify the main thread about the result of the function call. The main thread should listen for this event using the `addEventListener` method of `WorkerEventTarget`.",
    "input": "",
    "output": "import {GlobalScope, WorkerEventTarget, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createWorkerThread(): void {\n  const workerScope: ThreadWorkerGlobalScope = new ThreadWorkerGlobalScope();\n  \n  // Define a global function to be called\n  const globalFunction = (): string => {\n    return 'Global function called successfully';\n  };\n  \n  // Call the global function\n  const result = workerScope.callGlobalCallObjectMethod('globalFunction', globalFunction);\n  \n  // Create an event to dispatch the result\n  const event = {\n    type: 'workerEvent',\n    data: result\n  };\n  \n  // Dispatch the event to notify the main thread\n  workerScope.dispatchEvent(event);\n}\n\nexport function setupMainThreadListener(workerScope: WorkerEventTarget): void {\n  workerScope.addEventListener('workerEvent', (event: Event) => {\n    console.log('Event received:', event.data);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where the worker thread uses the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope` to send a shared object to the main thread, and the main thread uses the `onmessage` property of `ThreadWorkerGlobalScope` to receive and process the shared object. The function should also ensure proper cleanup by using the `removeAllListener` method of `WorkerEventTarget` to remove all event listeners after processing is complete.",
    "input": "",
    "output": "import {GlobalScope, WorkerEventTarget, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerCommunication(workerScope: ThreadWorkerGlobalScope): void {\n  // Worker thread sending a shared object to main thread\n  const sharedObject = { data: 'Shared data' };\n  workerScope.postMessageWithSharedSendable(sharedObject);\n\n  // Main thread receiving and processing the shared object\n  workerScope.onmessage = (event: MessageEvent): void => {\n    const receivedData = event.data;\n    console.log('Received shared object:', receivedData);\n\n    // Cleanup: remove all event listeners\n    workerScope.removeAllListener();\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to run a parallel task that processes an array of numbers. The task should use the `add` and `forEach` methods of `Queue` to enqueue the numbers, process them (e.g., square each number), and then return the processed queue. The main function should then use the `getFirst` method of `Queue` to retrieve and log the first processed value.",
    "input": "",
    "output": "import {taskpool, Queue, PlainArray} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[]): Queue<number> {\n  const queue = new Queue<number>();\n  numbers.forEach((num) => {\n    queue.add(num);\n  });\n  \n  const processedQueue = new Queue<number>();\n  queue.forEach((num) => {\n    processedQueue.add(num * num);\n  });\n  \n  return processedQueue;\n}\n\nexport async function main() {\n  const numbers = [1, 2, 3, 4, 5];\n  const task = new taskpool.Task(processNumbers, numbers);\n  const result: Queue<number> = await taskpool.execute(task);\n  const firstValue = result.getFirst();\n  console.log(`First processed value: ${firstValue}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `executePeriodically` method of `taskpool` to periodically update a `PlainArray` with new key-value pairs. The periodic task should use the `add` method of `PlainArray` to insert new entries and the `removeAt` method to remove old entries after a certain limit is reached. The main function should use the `getValueAt` method of `PlainArray` to retrieve and display the latest value at a specific index.",
    "input": "",
    "output": "import {taskpool, Queue, PlainArray} from '@kit.ArkTS';\n\nexport function updatePlainArrayPeriodically(plainArray: PlainArray<number, string>, limit: number, interval: number): void {\n  let counter: number = 0;\n  \n  taskpool.executePeriodically(() => {\n    plainArray.add(counter, `Value${counter}`);\n    counter++;\n    \n    if (plainArray.length > limit) {\n      plainArray.removeAt(0);\n    }\n  }, interval, false);\n}\n\nexport function displayLatestValue(plainArray: PlainArray<number, string>, index: number): string | undefined {\n  return plainArray.getValueAt(index);\n}\n\nexport function main(): void {\n  const plainArray: PlainArray<number, string> = new PlainArray();\n  const limit: number = 5;\n  const interval: number = 1000;\n  \n  updatePlainArrayPeriodically(plainArray, limit, interval);\n  \n  setInterval(() => {\n    const value = displayLatestValue(plainArray, plainArray.length - 1);\n    console.log(`Latest value: ${value}`);\n  }, interval);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `cancel` method of `taskpool` to stop a delayed task (scheduled with `executeDelayed`) if the `length` property of a `Queue` exceeds a certain threshold. The delayed task should have been designed to process the `Queue` using the `pop` method and store results in a `PlainArray` using the `setValueAt` method.",
    "input": "",
    "output": "import {taskpool, Queue, PlainArray} from '@kit.ArkTS';\n\nexport function monitorQueueAndCancelTask(queue: Queue<number>, threshold: number, delayedTaskId: number): void {\n  if (queue.length > threshold) {\n    taskpool.cancel(delayedTaskId);\n  }\n}\n\nexport function processQueue(queue: Queue<number>, plainArray: PlainArray<number, number>): void {\n  while (queue.length > 0) {\n    const value = queue.pop();\n    if (value !== undefined) {\n      plainArray.setValueAt(plainArray.length, value);\n    }\n  }\n}\n\nexport function scheduleDelayedTask(queue: Queue<number>, plainArray: PlainArray<number, number>, delay: number): number {\n  const task: taskpool.Task = new taskpool.Task(() => {\n    processQueue(queue, plainArray);\n  });\n  return taskpool.executeDelayed(task, delay);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of `Event` objects (from @kit.ArkTS) based on their `timeStamp` property. Then, use the `pop` method of `Stack` to retrieve and process the most recent event (i.e., the one with the highest `timeStamp`).",
    "input": "",
    "output": "import {Stack, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function processRecentEvent(events: Event[]): Event | undefined {\n  const stack = new Stack<Event>();\n  \n  // Push events into the stack based on their timeStamp\n  events.forEach(event => {\n    stack.push(event);\n  });\n  \n  // Pop the most recent event (highest timeStamp)\n  if (!stack.isEmpty()) {\n    return stack.pop();\n  }\n  \n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that iterates over a `Stack` (from @kit.ArkTS) using the `Symbol.iterator` method to collect all elements, then pass these elements to a `PostMessageOptions` object (from @kit.ArkTS) by setting its `transfer` property to the collected stack elements for further processing.",
    "input": "",
    "output": "import {Stack, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function processStackElements(stack: Stack<ArrayBuffer>): PostMessageOptions {\n  const elements: ArrayBuffer[] = [];\n  for (const element of stack) {\n    elements.push(element);\n  }\n  const options: PostMessageOptions = {\n    transfer: elements\n  };\n  return options;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if a `Stack` (from @kit.ArkTS) is empty using the `isEmpty` method, and if it is not empty, use the `peek` method to retrieve the top element and pass it as part of an `Event` object (from @kit.ArkTS) by setting its `type` property to a custom value based on the stack element.",
    "input": "",
    "output": "import {Stack, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function checkStackAndPostEvent(stack: Stack<number>, eventType: string): Event | undefined {\n  if (!stack.isEmpty()) {\n    const topElement = stack.peek();\n    const event = new Event();\n    event.type = `${eventType}_${topElement}`;\n    return event;\n  }\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then transfers all elements from the `Stack` to a `Deque` (from @kit.ArkTS) using the `pop` method of `Stack` and the `insertEnd` method of `Deque`. Finally, use the `getFirst` and `getLast` methods of `Deque` to return the smallest and largest values in the sequence.",
    "input": "",
    "output": "import {url, Stack, Deque} from '@kit.ArkTS';\n\nexport function getMinMaxFromStack(numbers: number[]): {min: number, max: number} {\n  const stack = new Stack<number>();\n  const deque = new Deque<number>();\n\n  for (const num of numbers) {\n    stack.push(num);\n  }\n\n  while (!stack.isEmpty()) {\n    deque.insertEnd(stack.pop());\n  }\n\n  const min = deque.getFirst();\n  const max = deque.getLast();\n\n  return {min, max};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` method of `Deque` (from @kit.ArkTS) to build a list of strings in reverse order, then transfers all elements from the `Deque` to a `Stack` (from @kit.ArkTS) using the `popFirst` method of `Deque` and the `push` method of `Stack`. Finally, use the `peek` method of `Stack` to check if the top element matches a given target string.",
    "input": "",
    "output": "import {url, Stack, Deque} from '@kit.ArkTS';\n\nexport function checkTopElementAfterReverseAndTransfer(strings: string[], target: string): boolean {\n  const deque = new Deque<string>();\n  const stack = new Stack<string>();\n\n  // Build the deque in reverse order\n  for (const str of strings) {\n    deque.insertFront(str);\n  }\n\n  // Transfer elements from deque to stack\n  while (deque.length > 0) {\n    const element = deque.popFirst();\n    if (element !== undefined) {\n      stack.push(element);\n    }\n  }\n\n  // Check if the top element matches the target\n  const topElement = stack.peek();\n  return topElement === target;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `Stack` (from @kit.ArkTS) to iterate over a stack of numbers and filter out even values, then inserts the filtered values into a `Deque` (from @kit.ArkTS) using the `insertEnd` method. Finally, use the `length` property of both `Stack` and `Deque` to return the difference in sizes before and after the operation.",
    "input": "",
    "output": "import { Stack, Deque } from '@kit.ArkTS';\n\nexport function filterEvenAndInsertToDeque(stack: Stack<number>): number {\n  const deque = new Deque<number>();\n  const initialStackLength = stack.length;\n  \n  stack.forEach((value: number) => {\n    if (value % 2 !== 0) {\n      deque.insertEnd(value);\n    }\n  });\n  \n  const finalDequeLength = deque.length;\n  return initialStackLength - finalDequeLength;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a series of numbers, then dequeues them using `pop` and stores the dequeued values in a `Vector` using its `add` method. Finally, use the `sort` method of `Vector` to arrange the numbers in ascending order.",
    "input": "",
    "output": "import {WorkerOptions, Vector, Queue} from '@kit.ArkTS';\n\nexport function processQueueAndSort(numbers: number[]): Vector<number> {\n  const queue = new Queue<number>();\n  const vector = new Vector<number>();\n\n  // Enqueue numbers\n  numbers.forEach(num => queue.add(num));\n\n  // Dequeue and store in vector\n  while (queue.length > 0) {\n    const dequeued = queue.pop();\n    if (dequeued !== undefined) {\n      vector.add(dequeued);\n    }\n  }\n\n  // Sort the vector\n  vector.sort((a, b) => a - b);\n\n  return vector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `WorkerOptions` object with a `name` property, then uses the `getFirst` method of `Queue` to retrieve the first element and passes it to the `insert` method of `Vector` at a specified index. Ensure the `Vector`'s `length` property is checked before insertion to avoid overflow.",
    "input": "",
    "output": "import {WorkerOptions, Vector, Queue} from '@kit.ArkTS';\n\nexport function processQueueToVector(queue: Queue<number>, vector: Vector<number>, index: number): void {\n  const workerOptions: WorkerOptions = {\n    name: 'worker'\n  };\n  \n  if (queue.length > 0) {\n    const firstElement = queue.getFirst();\n    if (index >= 0 && index <= vector.length) {\n      vector.insert(index, firstElement);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `convertToArray` method of `Vector` to transform its elements into an array, then iterates over this array using the `forEach` method of `Queue` to enqueue each element. After enqueueing, use the `getCapacity` method of `Vector` to verify if the `Queue` can accommodate all elements without exceeding its limits.",
    "input": "",
    "output": "import {WorkerOptions, Vector, Queue} from '@kit.ArkTS';\n\nexport function transformAndEnqueue(vector: Vector<number>, queue: Queue<number>): boolean {\n  const array = vector.convertToArray();\n  array.forEach((element: number) => {\n    queue.add(element);\n  });\n  return queue.length <= vector.getCapacity();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to asynchronously generate a random UUID with `util.generateRandomUUID`, then parses the UUID into its binary representation using `util.parseUUID`, and finally logs the result using `util.printf`.",
    "input": "",
    "output": "import {xml, taskpool, util} from '@kit.ArkTS';\n\nexport async function generateAndParseUUID(): Promise<void> {\n  const task = new taskpool.Task(async () => {\n    const uuid = util.generateRandomUUID();\n    const binaryUUID = util.parseUUID(uuid);\n    util.printf('UUID: %s, Binary: %s', uuid, binaryUUID);\n    return binaryUUID;\n  });\n\n  await taskpool.execute(task);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses `util.callbackWrapper` to convert a callback-based function into a Promise, then schedules the execution of this Promise in a task pool with `taskpool.execute` using `Priority.HIGH`, and handles any potential errors by converting the error code to a string with `util.errnoToString`.",
    "input": "",
    "output": "import {xml, taskpool, util} from '@kit.ArkTS';\n\nexport async function executeWithHighPriority(callbackBasedFunc: (err: number, data: string) => void): Promise<string> {\n  try {\n    const promisifiedFunc = util.callbackWrapper(callbackBasedFunc);\n    const task = new taskpool.Task(promisifiedFunc);\n    const result = await taskpool.execute(task, taskpool.Priority.HIGH);\n    return result;\n  } catch (error) {\n    const errorCode = error as number;\n    throw util.errnoToString(errorCode);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `taskpool.executePeriodically` to periodically generate a hash of a random UUID (using `util.generateRandomUUID` and `util.getHash`), then cancels the periodic task after 5 iterations using `taskpool.cancel`, and logs the final hash value with `util.format`.",
    "input": "",
    "output": "import {xml, taskpool, util} from '@kit.ArkTS';\n\nexport function executePeriodicHashTask(): void {\n  let counter = 0;\n  const taskId = taskpool.executePeriodically(() => {\n    const randomUUID = util.generateRandomUUID();\n    const hash = util.getHash(randomUUID);\n    counter++;\n    if (counter >= 5) {\n      taskpool.cancel(taskId);\n      const formattedHash = util.format('Final hash: %s', hash);\n      console.log(formattedHash);\n    }\n    return hash;\n  }, 1000);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `DedicatedWorkerGlobalScope` (from @kit.ArkTS) to send an array of numbers to a worker thread, where the worker thread uses the `add` and `sort` methods of `ArrayList<number>` (from @kit.ArkTS) to process and sort the array, then sends the sorted array back to the main thread using `postMessage`.",
    "input": "",
    "output": "import { ArrayList, DedicatedWorkerGlobalScope } from '@kit.ArkTS';\n\nexport function sendArrayToWorker(worker: DedicatedWorkerGlobalScope, numbers: number[]): void {\n  worker.postMessage(numbers);\n}\n\nexport function setupWorker(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent<number[]>) => {\n    const arrayList = new ArrayList<number>();\n    for (const num of event.data) {\n      arrayList.add(num);\n    }\n    arrayList.sort((a: number, b: number) => a - b);\n    worker.postMessage(arrayList.convertToArray());\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `insert` and `removeByIndex` methods of `ArrayList<string>` (from @kit.ArkTS) to manipulate a list of strings, then passes the modified list to the `postMessage` method of `DedicatedWorkerGlobalScope` (from @kit.ArkTS) to send it to a worker thread for further processing (e.g., logging or validation).",
    "input": "",
    "output": "import {ArrayList, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function manipulateAndSendToWorker(worker: DedicatedWorkerGlobalScope): void {\n  const list: ArrayList<string> = new ArrayList();\n  list.add('Item1');\n  list.add('Item2');\n  list.add('Item3');\n  \n  list.insert(1, 'InsertedItem');\n  list.removeByIndex(2);\n  \n  worker.postMessage(list);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a worker thread uses the `onmessage` property of `DedicatedWorkerGlobalScope` (from @kit.ArkTS) to receive a list of numbers, processes it using the `subArrayList` and `trimToCurrentLength` methods of `ArrayList<number>` (from @kit.ArkTS) to extract and trim a sublist, then sends the result back to the main thread using `postMessage`.",
    "input": "",
    "output": "import { ArrayList, DedicatedWorkerGlobalScope } from '@kit.ArkTS';\n\nexport function processArrayListInWorker() {\n  const workerScope = self as unknown as DedicatedWorkerGlobalScope;\n\n  workerScope.onmessage = (event: MessageEvent<number[]>) => {\n    const numbers = event.data;\n    const arrayList = new ArrayList<number>();\n    \n    for (const num of numbers) {\n      arrayList.add(num);\n    }\n    \n    const subList = arrayList.subArrayList(0, Math.floor(arrayList.length / 2));\n    subList.trimToCurrentLength();\n    \n    workerScope.postMessage(subList.convertToArray());\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a sequence of key-value pairs representing error messages and their timestamps. Then, pass the collected error messages to the `data` property of `MessageEvents` to simulate sending these errors to a global error handler via `GlobalScope.onerror`.",
    "input": "",
    "output": "import {PlainArray, GlobalScope, MessageEvents} from '@kit.ArkTS';\n\nexport function collectAndSendErrors(): void {\n  const errorMessages = new PlainArray<string>();\n  \n  errorMessages.add(1, 'Error: Invalid input at 10:30 AM');\n  errorMessages.add(2, 'Error: Network timeout at 10:35 AM');\n  errorMessages.add(3, 'Error: Database connection failed at 10:40 AM');\n  \n  const messageEvent = new MessageEvents('error');\n  messageEvent.data = errorMessages;\n  \n  if (GlobalScope.onerror) {\n    GlobalScope.onerror(messageEvent);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that iterates over a `PlainArray` using the `Symbol.iterator` method to extract all values, then uses the `self` property of `GlobalScope` to verify if the current execution context is the global scope before sending the extracted values as a message via the `data` property of `MessageEvents`.",
    "input": "",
    "output": "import {PlainArray, GlobalScope, MessageEvents} from '@kit.ArkTS';\n\nexport function processPlainArrayAndSendMessage(plainArray: PlainArray<number, unknown>): void {\n  const values: unknown[] = [];\n  \n  for (const value of plainArray[Symbol.iterator]()) {\n    values.push(value);\n  }\n  \n  if (GlobalScope.self === GlobalScope) {\n    const messageEvent = new MessageEvents('message', { data: values });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that checks if a `PlainArray` is empty using the `isEmpty` method, and if it is, uses the `name` property of `GlobalScope` to log a default message. Otherwise, it clones the `PlainArray` using the `clone` method and sends the cloned array's contents via the `data` property of `MessageEvents`.",
    "input": "",
    "output": "import {PlainArray, GlobalScope, MessageEvents} from '@kit.ArkTS';\n\nexport function checkAndProcessPlainArray(plainArray: PlainArray<number, unknown>): void {\n  if (plainArray.isEmpty()) {\n    console.log(GlobalScope.name);\n  } else {\n    const clonedArray = plainArray.clone();\n    const messageEvent = new MessageEvents('data');\n    messageEvent.data = clonedArray;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getEnvironmentVar` method of `process` to retrieve a list of environment variables, then stores them in a `TreeSet` using the `add` method, and finally iterates over the sorted set using the `Symbol.iterator` method to log each variable.",
    "input": "",
    "output": "import {TreeSet, Event, process} from '@kit.ArkTS';\n\nexport function logSortedEnvironmentVariables(): void {\n  const envVars = process.getEnvironmentVar();\n  const sortedSet = new TreeSet<string>();\n\n  for (const key in envVars) {\n    if (Object.prototype.hasOwnProperty.call(envVars, key)) {\n      sortedSet.add(key);\n    }\n  }\n\n  const iterator = sortedSet[Symbol.iterator]();\n  let result = iterator.next();\n  while (!result.done) {\n    console.log(result.value);\n    result = iterator.next();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that captures an `Event` object, extracts its `timeStamp` property, and uses the `getHigherValue` method of `TreeSet` to find the closest higher timestamp from a predefined set of timestamps stored in the `TreeSet`.",
    "input": "",
    "output": "import {TreeSet, Event, process} from '@kit.ArkTS';\n\nexport function findClosestHigherTimestamp(event: Event, timestampSet: TreeSet<number>): number | undefined {\n  const eventTimestamp = event.timeStamp;\n  return timestampSet.getHigherValue(eventTimestamp);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getPastCpuTime` method of `process` to measure CPU usage, stores the results in a `TreeSet` using the `add` method, and then uses the `getFirstValue` and `getLastValue` methods of `TreeSet` to determine the range of CPU usage over time.",
    "input": "",
    "output": "import {TreeSet, Event, process} from '@kit.ArkTS';\n\nexport function measureCpuUsage(): number[] {\n  const cpuTimes = new TreeSet<number>();\n  \n  // Measure CPU time and add to TreeSet\n  const cpuTime = process.getPastCpuTime();\n  cpuTimes.add(cpuTime);\n  \n  // Get the range of CPU usage\n  const firstValue = cpuTimes.getFirstValue();\n  const lastValue = cpuTimes.getLastValue();\n  \n  return [firstValue, lastValue];\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `parse` method of `json` to convert a JSON string into an object, then uses the `add` method of `ArrayList` to store the parsed object in a list, and finally uses the `stringify` method of `json` to convert the list back into a JSON string for output.",
    "input": "",
    "output": "import {json, ArrayList, PostMessageOptions} from '@kit.ArkTS';\n\nexport function processJsonString(jsonString: string): string {\n  const parsedObject = json.parse(jsonString);\n  const arrayList = new ArrayList<object>();\n  arrayList.add(parsedObject);\n  return json.stringify(arrayList);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `convertToArray` method of `ArrayList` to transform a list of numbers into an array, then uses the `stringify` method of `json` to serialize the array into a JSON string, and finally uses the `transfer` property of `PostMessageOptions` to send the serialized data to another thread.",
    "input": "",
    "output": "import {json, ArrayList, PostMessageOptions} from '@kit.ArkTS';\n\nexport function sendDataToThread(numbers: ArrayList<number>): void {\n  const array: number[] = numbers.convertToArray();\n  const jsonString: string = json.stringify(array);\n  const options: PostMessageOptions = {\n    transfer: []\n  };\n  postMessage(jsonString, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getIndexOf` method of `ArrayList` to find the position of a specific element in a list, then uses the `remove` method of `json` to delete a property from the element (if it exists), and finally uses the `sort` method of `ArrayList` to reorder the modified list.",
    "input": "",
    "output": "import {json, ArrayList, PostMessageOptions} from '@kit.ArkTS';\n\nexport function modifyAndSortList(list: ArrayList<object>, element: object, propertyToRemove: string): void {\n  const index = list.getIndexOf(element);\n  if (index !== -1) {\n    const item = list.get(index);\n    json.remove(item, propertyToRemove);\n    list.sort((a: object, b: object) => {\n      const aStr = json.stringify(a);\n      const bStr = json.stringify(b);\n      return aStr.localeCompare(bStr);\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `TreeSet` (from @kit.ArkTS) to store a sequence of event names, then uses the `dispatchEvent` method of `EventTarget` (from @kit.ArkTS) to trigger events for each name in the `TreeSet`. The function should also remove the dispatched events from the `TreeSet` using the `remove` method.",
    "input": "",
    "output": "import {EventTarget, TreeSet, HashSet} from '@kit.ArkTS';\n\nexport function dispatchEventsFromTreeSet(eventNames: string[]): void {\n  const eventTarget = new EventTarget();\n  const treeSet = new TreeSet<string>();\n\n  // Add event names to TreeSet\n  for (const name of eventNames) {\n    treeSet.add(name);\n  }\n\n  // Dispatch events and remove them from TreeSet\n  for (const name of treeSet) {\n    eventTarget.dispatchEvent(name);\n    treeSet.remove(name);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `HashSet` (from @kit.ArkTS) with unique values using the `add` method, then checks if any of these values exist in a `TreeSet` (from @kit.ArkTS) using the `has` method. For each value that exists in both sets, use the `removeEventListener` method of `EventTarget` (from @kit.ArkTS) to unregister any associated event listeners.",
    "input": "",
    "output": "import {EventTarget, TreeSet, HashSet} from '@kit.ArkTS';\n\nexport function processSets(hashSet: HashSet<string>, treeSet: TreeSet<string>, eventTarget: EventTarget): void {\n  const commonValues: string[] = [];\n  \n  // Populate HashSet with unique values\n  hashSet.add('value1');\n  hashSet.add('value2');\n  hashSet.add('value3');\n  \n  // Check for common values in TreeSet\n  hashSet.forEach((value: string) => {\n    if (treeSet.has(value)) {\n      commonValues.push(value);\n    }\n  });\n  \n  // Remove event listeners for common values\n  commonValues.forEach((value: string) => {\n    eventTarget.removeEventListener(value, () => {});\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getFirstValue` method of `TreeSet` (from @kit.ArkTS) to retrieve the smallest value, then passes it to the `addEventListener` method of `EventTarget` (from @kit.ArkTS) to register a callback. The function should also use the `clear` method of `HashSet` (from @kit.ArkTS) to reset a secondary storage before adding new values.",
    "input": "",
    "output": "import {EventTarget, TreeSet, HashSet} from '@kit.ArkTS';\n\nexport function registerCallbackWithSmallestValue(eventTarget: EventTarget, treeSet: TreeSet<number>, hashSet: HashSet<number>): void {\n  if (treeSet.isEmpty()) {\n    return;\n  }\n  const smallestValue = treeSet.getFirstValue();\n  hashSet.clear();\n  eventTarget.addEventListener('event', () => {\n    hashSet.add(smallestValue);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `List` to collect a sequence of numbers, then passes the resulting list to the `convertToArray` method of `List` to obtain an array, and finally uses the `addAll` method of `LightWeightSet` to store the unique values from the array.",
    "input": "",
    "output": "import {List, LightWeightSet, PlainArray} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[]): LightWeightSet<number> {\n  const list = new List<number>();\n  \n  // Add numbers to the list\n  numbers.forEach((num) => {\n    list.add(num);\n  });\n  \n  // Convert list to array\n  const array = list.convertToArray();\n  \n  // Store unique values in LightWeightSet\n  const lightWeightSet = new LightWeightSet<number>();\n  lightWeightSet.addAll(array);\n  \n  return lightWeightSet;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `getValueAt` method of `PlainArray` to retrieve values at specific indices, then uses the `insert` method of `List` to add these values at specified positions, and finally uses the `sort` method of `List` to arrange the elements in ascending order.",
    "input": "",
    "output": "import {List, LightWeightSet, PlainArray} from '@kit.ArkTS';\n\nexport function processPlainArrayToList(plainArray: PlainArray<number, number>, indices: number[], list: List<number>): void {\n  for (let i = 0; i < indices.length; i++) {\n    const index = indices[i];\n    const value = plainArray.getValueAt(index);\n    if (value !== undefined) {\n      list.insert(i, value);\n    }\n  }\n  list.sort((a: number, b: number) => a - b);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LightWeightSet` to iterate over its elements and apply a transformation, then uses the `setValueAt` method of `PlainArray` to update the values at corresponding keys, and finally uses the `getSubList` method of `List` to extract a subset of the transformed data.",
    "input": "",
    "output": "import {List, LightWeightSet, PlainArray} from '@kit.ArkTS';\n\nexport function transformAndExtractSubset(\n  lightWeightSet: LightWeightSet<number>,\n  plainArray: PlainArray<number, string>,\n  list: List<string>,\n  start: number,\n  end: number\n): List<string> {\n  // Step 1: Use forEach to iterate over LightWeightSet and apply transformation\n  lightWeightSet.forEach((value: number) => {\n    const transformedValue = `transformed_${value}`;\n    // Step 2: Use setValueAt to update PlainArray values at corresponding keys\n    plainArray.setValueAt(value, transformedValue);\n  });\n\n  // Step 3: Use getSubList to extract a subset from the List\n  const subList = list.getSubList(start, end);\n  return subList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `HashSet` to collect unique product IDs from a list, then transfers these IDs to an `ArrayList` using its `add` method, and finally sorts the IDs in ascending order using the `sort` method of `ArrayList`. The function should return the sorted list of unique product IDs.",
    "input": "",
    "output": "import {HashSet, PlainArray, ArrayList} from '@kit.ArkTS';\n\nexport function getSortedUniqueProductIds(productIds: number[]): ArrayList<number> {\n  const uniqueIds = new HashSet<number>();\n  for (const id of productIds) {\n    uniqueIds.add(id);\n  }\n  \n  const idList = new ArrayList<number>();\n  for (const id of uniqueIds) {\n    idList.add(id);\n  }\n  \n  idList.sort((a, b) => a - b);\n  return idList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `PlainArray` with key-value pairs of employee IDs and names using the `add` method, then checks for duplicate employee IDs by converting the keys to a `HashSet` (using `values` method of `PlainArray` and `add` method of `HashSet`). The function should return a boolean indicating whether duplicates were found.",
    "input": "",
    "output": "import {HashSet, PlainArray, ArrayList} from '@kit.ArkTS';\n\nexport function checkDuplicateEmployeeIds(): boolean {\n  const employees = new PlainArray<string>();\n  employees.add(1, \"John Doe\");\n  employees.add(2, \"Jane Smith\");\n  employees.add(3, \"Alice Johnson\");\n  employees.add(2, \"Bob Brown\"); // Duplicate ID\n\n  const idSet = new HashSet<number>();\n  const keys = employees.values();\n  let hasDuplicates = false;\n\n  for (const key of keys) {\n    if (idSet.has(key)) {\n      hasDuplicates = true;\n      break;\n    }\n    idSet.add(key);\n  }\n\n  return hasDuplicates;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `ArrayList` to iterate over a list of student scores, filters out scores below a threshold using the `remove` method of `HashSet`, and then calculates the average of the remaining scores by converting the `HashSet` back to an `ArrayList` (using `convertToArray` method) and applying the `reduce` method (hypothetical) or manual summation.",
    "input": "",
    "output": "import {HashSet, PlainArray, ArrayList} from '@kit.ArkTS';\n\nexport function calculateAverageAboveThreshold(scores: ArrayList<number>, threshold: number): number {\n  const filteredScores = new HashSet<number>();\n  \n  // Iterate over scores and add those above threshold to HashSet\n  scores.forEach((score: number) => {\n    if (score >= threshold) {\n      filteredScores.add(score);\n    }\n  });\n  \n  // Convert HashSet back to ArrayList\n  const filteredArrayList = new ArrayList<number>();\n  filteredScores.forEach((score: number) => {\n    filteredArrayList.add(score);\n  });\n  \n  // Calculate average\n  let sum = 0;\n  filteredArrayList.forEach((score: number) => {\n    sum += score;\n  });\n  \n  return filteredArrayList.length > 0 ? sum / filteredArrayList.length : 0;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a set of key-value pairs representing task priorities (keys) and task names (values). Then, use the `execute` method of `taskpool` to execute each task with the corresponding priority from the `PlainArray`, ensuring the priorities are correctly passed to the `Priority` enum of `taskpool`.",
    "input": "",
    "output": "import {PlainArray, taskpool, MessageEvents} from '@kit.ArkTS';\n\nexport function executeTasksWithPriority(): void {\n  const taskArray: PlainArray<string> = new PlainArray<string>();\n  \n  // Add tasks with their priorities\n  taskArray.add(1, 'Task1');\n  taskArray.add(2, 'Task2');\n  taskArray.add(3, 'Task3');\n  \n  // Execute each task with corresponding priority\n  for (let i = 0; i < taskArray.length; i++) {\n    const priority = taskArray.getKeyAt(i);\n    const taskName = taskArray.getValueAt(i);\n    \n    const task = () => {\n      console.log(`Executing ${taskName} with priority ${priority}`);\n    };\n    \n    // Map the priority number to taskpool.Priority enum\n    let taskPriority: taskpool.Priority;\n    switch (priority) {\n      case 1:\n        taskPriority = taskpool.Priority.HIGH;\n        break;\n      case 2:\n        taskPriority = taskpool.Priority.MEDIUM;\n        break;\n      case 3:\n        taskPriority = taskpool.Priority.LOW;\n        break;\n      default:\n        taskPriority = taskpool.Priority.MEDIUM;\n    }\n    \n    taskpool.execute(task, taskPriority);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `forEach` method of `PlainArray` to iterate over a collection of message data (stored as key-value pairs). For each message, extract the `data` property from `MessageEvents` and pass it to the `executeDelayed` method of `taskpool` to schedule the processing of each message after a specified delay.",
    "input": "",
    "output": "import {PlainArray, taskpool, MessageEvents} from '@kit.ArkTS';\n\nexport function processMessagesWithDelay(messages: PlainArray<number, MessageEvents>, delay: number): void {\n  messages.forEach((value: MessageEvents, key: number) => {\n    const messageData = value.data;\n    taskpool.executeDelayed(() => {\n      // Process messageData here\n    }, delay);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first uses the `getValueAt` method of `PlainArray` to retrieve a sequence of values stored at specific indices. Then, pass these values as input to the `executePeriodically` method of `taskpool` to create periodic tasks that process each value at regular intervals, using the `State` enum of `taskpool` to monitor the task status.",
    "input": "",
    "output": "import {PlainArray, taskpool, MessageEvents} from '@kit.ArkTS';\n\nexport function processValuesPeriodically(plainArray: PlainArray<number, string>, indices: number[], interval: number): void {\n  const values: string[] = [];\n  \n  indices.forEach((index) => {\n    const value = plainArray.getValueAt(index);\n    if (value !== undefined) {\n      values.push(value);\n    }\n  });\n\n  values.forEach((value) => {\n    const task = taskpool.executePeriodically(() => {\n      console.log(`Processing value: ${value}`);\n    }, interval);\n\n    const state = task.getState();\n    console.log(`Task state: ${state}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `set` method of `HashMap` to store key-value pairs of message types and their corresponding data, then retrieves a specific message type using the `get` method of `HashMap` and passes it as the `data` property of a new `MessageEvent` object.",
    "input": "",
    "output": "import {MessageEvent, HashMap, PostMessageOptions} from '@kit.ArkTS';\n\nexport function storeAndRetrieveMessage() {\n  const messageMap = new HashMap<string, string>();\n  messageMap.set('type1', 'data1');\n  messageMap.set('type2', 'data2');\n  \n  const retrievedData = messageMap.get('type1');\n  if (retrievedData !== undefined) {\n    const messageEvent = new MessageEvent<string>('message', {data: retrievedData});\n    return messageEvent;\n  }\n  return null;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that iterates over the entries of a `HashMap` using the `[Symbol.iterator]` method, filters out entries with specific values using the `hasValue` method, and then transfers the filtered entries to a new `MessageEvent` object with the `transfer` property of `PostMessageOptions` set to true.",
    "input": "",
    "output": "import {MessageEvent, HashMap, PostMessageOptions} from '@kit.ArkTS';\n\nexport function filterAndTransferHashMap<K, V>(map: HashMap<K, V>, valuesToFilter: V[]): MessageEvent<[K, V][]> {\n  const filteredEntries: [K, V][] = [];\n  \n  for (const [key, value] of map[Symbol.iterator]()) {\n    if (!valuesToFilter.some(v => v === value)) {\n      filteredEntries.push([key, value]);\n    }\n  }\n  \n  const options: PostMessageOptions = {\n    transfer: true\n  };\n  \n  return new MessageEvent('filteredData', {\n    data: filteredEntries,\n    ...options\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if a `HashMap` is empty using the `isEmpty` method, and if it is not empty, uses the `keys` method to retrieve all keys, then sends them as the `data` property of a `MessageEvent` object with `PostMessageOptions` specifying no transfer.",
    "input": "",
    "output": "import {MessageEvent, HashMap, PostMessageOptions} from '@kit.ArkTS';\n\nexport function checkAndSendHashMapKeys<K, V>(map: HashMap<K, V>): void {\n  if (!map.isEmpty()) {\n    const keys = map.keys();\n    const event = new MessageEvent<IterableIterator<K>>('message', { data: keys });\n    const options: PostMessageOptions = { transfer: undefined };\n    // Assuming there's a context to post the message, like a Worker or MessagePort\n    // For example: context.postMessage(event, options);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` (from @kit.ArkTS) to run a computationally intensive task in parallel, and then collects the results using the `add` method of `ArrayList<number>` (from @kit.ArkTS) to store and process the aggregated data.",
    "input": "",
    "output": "import {taskpool, ArrayList, EventTarget} from '@kit.ArkTS';\n\nexport function runParallelTasks(): void {\n  const results: ArrayList<number> = new ArrayList<number>();\n  const tasks: Array<Promise<number>> = [];\n\n  // Define a computationally intensive task\n  const intensiveTask = (): number => {\n    let sum = 0;\n    for (let i = 0; i < 1000000; i++) {\n      sum += Math.sqrt(i);\n    }\n    return sum;\n  };\n\n  // Execute tasks in parallel\n  for (let i = 0; i < 4; i++) {\n    const task = taskpool.execute(intensiveTask);\n    tasks.push(task);\n  }\n\n  // Collect results\n  Promise.all(tasks).then((values: number[]) => {\n    values.forEach((value: number) => {\n      results.add(value);\n    });\n\n    // Process aggregated data\n    let total = 0;\n    results.forEach((item: number) => {\n      total += item;\n    });\n    console.log(`Total sum: ${total}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `dispatchEvent` method of `EventTarget` (from @kit.ArkTS) to trigger a custom event, and then uses the `forEach` method of `ArrayList<string>` (from @kit.ArkTS) to iterate over the event data and log each entry.",
    "input": "",
    "output": "import {taskpool, ArrayList, EventTarget} from '@kit.ArkTS';\n\nexport function triggerAndLogCustomEvent(): void {\n  const eventTarget = new EventTarget();\n  const eventData = new ArrayList<string>();\n  eventData.add('Event Data 1');\n  eventData.add('Event Data 2');\n  eventData.add('Event Data 3');\n\n  const customEvent = {\n    type: 'customEvent',\n    data: eventData\n  };\n\n  eventTarget.dispatchEvent(customEvent);\n\n  eventData.forEach((item: string) => {\n    console.log(item);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task scheduler that uses the `executePeriodically` method of `taskpool` (from @kit.ArkTS) to run a recurring task, and then uses the `removeByIndex` method of `ArrayList<object>` (from @kit.ArkTS) to clean up completed tasks from a shared task list.",
    "input": "",
    "output": "import {taskpool, ArrayList, EventTarget} from '@kit.ArkTS';\n\nexport class TaskScheduler {\n  private taskList: ArrayList<object> = new ArrayList<object>();\n  private eventTarget: EventTarget = new EventTarget();\n\n  public scheduleTask(task: object, interval: number, priority: taskpool.Priority): void {\n    const taskId = taskpool.executePeriodically(task, interval, priority);\n    this.taskList.add(taskId);\n  }\n\n  public cleanupCompletedTasks(): void {\n    for (let i = this.taskList.length - 1; i >= 0; i--) {\n      const taskId = this.taskList.get(i);\n      if (taskpool.getTaskPoolInfo(taskId).state === taskpool.State.FINISHED) {\n        this.taskList.removeByIndex(i);\n      }\n    }\n  }\n\n  public addEventListener(type: string, listener: (event: object) => void): void {\n    this.eventTarget.addEventListener(type, listener);\n  }\n\n  public removeEventListener(type: string, listener: (event: object) => void): void {\n    this.eventTarget.removeEventListener(type, listener);\n  }\n\n  public dispatchEvent(event: object): void {\n    this.eventTarget.dispatchEvent(event);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `get` and `length` properties of `List` to extract all elements, then passes them to the `add` method of `Vector` to create a new dynamic collection. Finally, use the `sort` method of `Vector` to arrange the elements in ascending order.",
    "input": "",
    "output": "import {uri, List, Vector} from '@kit.ArkTS';\n\nexport function listToSortedVector(list: List<number>): Vector<number> {\n  const vector = new Vector<number>();\n  for (let i = 0; i < list.length; i++) {\n    vector.add(list.get(i));\n  }\n  vector.sort((a, b) => a - b);\n  return vector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `convertToArray` method of `List` to transform the list into an array, then uses the `copyToArray` method of `Vector` to merge this array with an existing vector. Ensure the combined collection is printed using the `toString` method of `Vector`.",
    "input": "",
    "output": "import {uri, List, Vector} from '@kit.ArkTS';\n\nexport function mergeListWithVector(list: List<number>, vector: Vector<number>): void {\n  const arrayFromList: number[] = list.convertToArray();\n  vector.copyToArray(arrayFromList);\n  console.log(vector.toString());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first checks if a `List` is empty using the `isEmpty` method, and if not, retrieves the last element using `getLast`. Then, insert this element into a `Vector` at a specific index using the `insert` method, and finally return the modified `Vector` using its `subVector` method to confirm the insertion.",
    "input": "",
    "output": "import {uri, List, Vector} from '@kit.ArkTS';\n\nexport function processListAndVector(list: List<number>, vector: Vector<number>, index: number): Vector<number> {\n  if (!list.isEmpty()) {\n    const lastElement = list.getLast();\n    vector.insert(index, lastElement);\n  }\n  return vector.subVector(0, vector.length);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `Event` object with a custom `type` property, then passes this event to the `onerror` handler of a `WorkerGlobalScope` to simulate an error event in a worker context. Use the `timeStamp` property of the `Event` to log when the error occurred.",
    "input": "",
    "output": "import {stream, Event, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function simulateWorkerError(errorType: string): void {\n  const event: Event = {\n    type: errorType,\n    timeStamp: Date.now()\n  };\n\n  const workerScope: WorkerGlobalScope = {\n    name: 'simulatedWorker',\n    onerror: (ev: Event) => {\n      console.log(`Error occurred at ${ev.timeStamp}: ${ev.type}`);\n    },\n    self: null\n  };\n\n  if (workerScope.onerror) {\n    workerScope.onerror(event);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `WorkerGlobalScope` with a `name` property, then triggers a custom `Event` with the `type` set to 'message'. Use the `self` property of `WorkerGlobalScope` to verify the worker's context before dispatching the event.",
    "input": "",
    "output": "import {stream, Event, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function initializeWorkerScope(): void {\n  const workerScope: WorkerGlobalScope = self as WorkerGlobalScope;\n  workerScope.name = 'workerScope';\n  \n  if (workerScope.self === workerScope) {\n    const event = new Event('message');\n    workerScope.dispatchEvent(event);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that listens for an `Event` of type 'data' and uses the `timeStamp` property to measure the time taken between event dispatch and handling. Then, pass this timestamp to the `onerror` handler of `WorkerGlobalScope` to log potential delays in event processing.",
    "input": "",
    "output": "import {stream, Event, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function measureEventDelay(event: Event, workerScope: WorkerGlobalScope): void {\n  const dispatchTime = event.timeStamp;\n  const currentTime = Date.now();\n  const delay = currentTime - dispatchTime;\n  \n  if (workerScope.onerror) {\n    workerScope.onerror(`Event processing delay: ${delay}ms`);\n  }\n}\n\nexport function setupEventDelayMeasurement(workerScope: WorkerGlobalScope): void {\n  workerScope.addEventListener('data', (event: Event) => {\n    measureEventDelay(event, workerScope);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `from` method of `buffer` to create a buffer from a string, then uses the `set` method of `HashMap` to store the buffer as a value with a specified key. Finally, use the `get` method of `HashMap` to retrieve the buffer and the `byteLength` method of `buffer` to return the length of the stored buffer.",
    "input": "",
    "output": "import {HashMap, buffer, LightWeightMap} from '@kit.ArkTS';\n\nexport function storeAndGetBufferLength(key: string, value: string): number {\n  const hashMap = new HashMap<string, buffer.Buffer>();\n  const buf = buffer.from(value);\n  hashMap.set(key, buf);\n  const retrievedBuf = hashMap.get(key);\n  return retrievedBuf.byteLength;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `LightWeightMap` to get all keys, then uses the `concat` method of `buffer` to combine the keys (converted to strings) into a single buffer. Finally, use the `setAll` method of `HashMap` to store the combined buffer as a value with a new key.",
    "input": "",
    "output": "import {HashMap, buffer, LightWeightMap} from '@kit.ArkTS';\n\nexport function combineKeysToHashMap(lwm: LightWeightMap<number, number>, hashMap: HashMap<string, Uint8Array>, newKey: string): void {\n  const keys = lwm.keys();\n  let combinedBuffer = buffer.from('', 'utf-8');\n  \n  for (const key of keys) {\n    const keyStr = key.toString();\n    const keyBuffer = buffer.from(keyStr, 'utf-8');\n    combinedBuffer = buffer.concat([combinedBuffer, keyBuffer]);\n  }\n  \n  hashMap.setAll(new HashMap([[newKey, combinedBuffer]]));\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `entries` method of `HashMap` to get all key-value pairs, then uses the `alloc` method of `buffer` to create a buffer for each value. Use the `setValueAt` method of `LightWeightMap` to update the values in the `LightWeightMap` with the newly created buffers. Finally, use the `values` method of `LightWeightMap` to return all updated values.",
    "input": "",
    "output": "import {HashMap, buffer, LightWeightMap} from '@kit.ArkTS';\n\nexport function updateLightWeightMapWithBuffers(inputMap: HashMap<string, string>, outputMap: LightWeightMap<string, buffer.Buffer>): Array<buffer.Buffer> {\n  const entries = inputMap.entries();\n  for (const [key, value] of entries) {\n    const buf = buffer.alloc(value.length, value);\n    outputMap.setValueAt(outputMap.getIndexOfKey(key), buf);\n  }\n  return outputMap.values();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a worker using `WorkerOptions` with a specified `name` property, then listens for a `MessageEvent` from the worker and extracts the `data` property from the event to process the received message.",
    "input": "",
    "output": "import {WorkerOptions, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function createWorkerWithName(scriptURL: string, name: string, callback: (data: string) => void): void {\n  const options: WorkerOptions = {\n    name: name\n  };\n  const worker = new Worker(scriptURL, options);\n  worker.onmessage = (event: MessageEvents) => {\n    const messageEvent = event as MessageEvent<string>;\n    callback(messageEvent.data);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a worker with `WorkerOptions` where the `shared` property is set to true, then sends a message to the worker and uses the `data` property of `MessageEvents` to verify the response from the worker.",
    "input": "",
    "output": "import {WorkerOptions, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function initializeWorker(): void {\n  const options: WorkerOptions = {\n    shared: true\n  };\n\n  const worker = new Worker('workers/worker.ts', options);\n\n  worker.postMessage('Test message');\n\n  worker.onmessage = (event: MessageEvents) => {\n    const response = event.data;\n    console.log('Response from worker:', response);\n  };\n\n  worker.onerror = (error) => {\n    console.error('Worker error:', error);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that sets up a worker using `WorkerOptions` with a custom `name`, posts a message to the worker, and then uses the `data` property of `MessageEvent` to handle and display the worker's response in the main thread.",
    "input": "",
    "output": "import {WorkerOptions, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function setupWorker(): void {\n  const workerOptions: WorkerOptions = {\n    name: 'customWorker'\n  };\n\n  const worker = new Worker('workers/worker.ts', workerOptions);\n\n  worker.postMessage('Hello from main thread');\n\n  worker.onmessage = (event: MessageEvents) => {\n    const messageData: string = event.data;\n    console.log(`Worker response: ${messageData}`);\n  };\n}\n\nexport function handleWorkerMessage(event: MessageEvent<string>): void {\n  const messageData: string = event.data;\n  console.log(`Received message from worker: ${messageData}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function in a DedicatedWorker that listens for incoming messages using `DedicatedWorkerGlobalScope.onmessage`, processes the received data (e.g., doubling a number), and sends the result back to the main thread using `DedicatedWorkerGlobalScope.postMessage` with `PostMessageOptions.transfer` to optimize performance. The main thread should then log the `Event.timeStamp` of the response message.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function workerEntry(workerScope: DedicatedWorkerGlobalScope): void {\n  workerScope.onmessage = (event: Event & { data: number }) => {\n    const doubledValue = event.data * 2;\n    const buffer = new ArrayBuffer(8);\n    const view = new DataView(buffer);\n    view.setFloat64(0, doubledValue, true);\n    const options: PostMessageOptions = {\n      transfer: [buffer]\n    };\n    workerScope.postMessage(buffer, options);\n  };\n}\n\nexport function mainThreadListener(event: Event & { data: ArrayBuffer }) {\n  const view = new DataView(event.data);\n  const result = view.getFloat64(0, true);\n  console.log(`Result: ${result}, Timestamp: ${event.timeStamp}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a DedicatedWorker that uses `DedicatedWorkerGlobalScope.postMessage` to send an array buffer to the main thread, specifying `PostMessageOptions.transfer` to transfer ownership. The main thread should listen for the message, verify the `Event.type` is 'message', and then send a confirmation back to the worker using `DedicatedWorkerGlobalScope.onmessage` to acknowledge receipt.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function setupWorker(worker: DedicatedWorkerGlobalScope): void {\n  const buffer = new ArrayBuffer(8);\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  worker.postMessage(buffer, options);\n\n  worker.onmessage = (event: Event) => {\n    if (event.type === 'message') {\n      worker.postMessage('Message received');\n    }\n  };\n}\n\nexport function setupMainThread(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: Event) => {\n    if (event.type === 'message') {\n      worker.postMessage('Acknowledged');\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a DedicatedWorker that listens for error messages using `DedicatedWorkerGlobalScope.onmessageerror`. When an error occurs (e.g., invalid data type), the worker should use `DedicatedWorkerGlobalScope.close` to terminate itself. The main thread should then log the `Event.timeStamp` of the error event before attempting to restart the worker.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function createWorker(): DedicatedWorkerGlobalScope {\n  const worker = new DedicatedWorkerGlobalScope('worker.js');\n\n  worker.onmessageerror = (event: Event) => {\n    console.log(`Error timestamp: ${event.timeStamp}`);\n    worker.close();\n    setTimeout(() => {\n      createWorker();\n    }, 0);\n  };\n\n  return worker;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a buffer from a string, then uses `buffer.byteLength` to get its size, and finally passes the size to `process.getEnvironmentVar` to check if the environment variable 'MAX_BUFFER_SIZE' allows the buffer to be processed. If the buffer size exceeds the value of 'MAX_BUFFER_SIZE', use `process.exit` to terminate the process.",
    "input": "",
    "output": "import {buffer, process, TreeSet} from '@kit.ArkTS';\n\nexport function checkBufferSize(inputString: string): void {\n  const buf = buffer.from(inputString, 'utf-8');\n  const size = buffer.byteLength(buf);\n  const maxBufferSizeStr = process.getEnvironmentVar('MAX_BUFFER_SIZE');\n  \n  if (maxBufferSizeStr) {\n    const maxBufferSize = parseInt(maxBufferSizeStr);\n    if (size > maxBufferSize) {\n      process.exit(1);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `TreeSet.add` to populate a TreeSet with numeric values, then uses `TreeSet.getFirstValue` and `TreeSet.getLastValue` to get the smallest and largest values. Pass these values to `buffer.alloc` to create two buffers of the respective sizes, and use `buffer.compare` to determine which buffer is larger.",
    "input": "",
    "output": "import {buffer, process, TreeSet} from '@kit.ArkTS';\n\nexport function compareBufferSizes(): number {\n  const treeSet = new TreeSet<number>();\n  treeSet.add(5);\n  treeSet.add(10);\n  treeSet.add(2);\n  treeSet.add(8);\n  \n  const smallest = treeSet.getFirstValue();\n  const largest = treeSet.getLastValue();\n  \n  const smallBuffer = buffer.alloc(smallest);\n  const largeBuffer = buffer.alloc(largest);\n  \n  return buffer.compare(smallBuffer, largeBuffer);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `process.uptime` to get the system uptime, then uses `buffer.concat` to merge two buffers containing timestamps. Use `TreeSet.forEach` to iterate over the merged buffer and check if any timestamp exceeds the uptime. If found, use `process.kill` to terminate the process.",
    "input": "",
    "output": "import {buffer, process, TreeSet} from '@kit.ArkTS';\n\nexport function checkTimestampsAndKill(buffer1: buffer.Buffer, buffer2: buffer.Buffer): void {\n  const uptime: number = process.uptime();\n  const mergedBuffer: buffer.Buffer = buffer.concat([buffer1, buffer2]);\n  const timestampSet: TreeSet<number> = new TreeSet<number>();\n\n  for (let i = 0; i < mergedBuffer.length; i += 4) {\n    const timestamp: number = mergedBuffer.readUInt32BE(i);\n    timestampSet.add(timestamp);\n  }\n\n  timestampSet.forEach((timestamp: number) => {\n    if (timestamp > uptime) {\n      process.kill(process.pid);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to run a background task that processes a list of numbers. The task should use the `sort` method of `List` to sort the numbers in ascending order and then return the sorted list. The function should also log the `timeStamp` property of the `Event` object emitted when the task completes.",
    "input": "",
    "output": "import {taskpool, Event, List} from '@kit.ArkTS';\n\nexport function sortNumbersInBackground(numbers: List<number>): void {\n  const task = new taskpool.Task(() => {\n    numbers.sort((a: number, b: number) => a - b);\n    return numbers;\n  });\n\n  taskpool.execute(task).then((sortedList: List<number>) => {\n    console.log('Task completed with sorted list:', sortedList);\n  }).catch((error: Error) => {\n    console.error('Task failed:', error);\n  }).finally(() => {\n    console.log('Task execution completed');\n  });\n\n  task.on('complete', (event: Event) => {\n    console.log('Task completed at timestamp:', event.timeStamp);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `executePeriodically` method of `taskpool` to periodically update a `List` of sensor readings. Each update should use the `add` method of `List` to append a new reading. The function should stop the periodic updates after 10 readings have been collected and then use the `convertToArray` method of `List` to return the readings as an array.",
    "input": "",
    "output": "import {taskpool, Event, List} from '@kit.ArkTS';\n\nexport function collectSensorReadings(): Promise<number[]> {\n  return new Promise((resolve) => {\n    const readings = new List<number>();\n    let count = 0;\n    \n    const task = taskpool.executePeriodically(() => {\n      const reading = Math.random(); // Simulate sensor reading\n      readings.add(reading);\n      count++;\n      \n      if (count >= 10) {\n        taskpool.cancel(task);\n        resolve(readings.convertToArray());\n      }\n    }, 1000); // Update every 1 second\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getSubList` method of `List` to extract a subset of data and then passes this subset to the `execute` method of `taskpool` for parallel processing. The function should use the `Priority` enum of `taskpool` to set the priority of the task to `HIGH` and log the `type` property of the `Event` object emitted when the task starts.",
    "input": "",
    "output": "import {taskpool, Event, List} from '@kit.ArkTS';\n\nexport function processSubListInParallel(list: List<number>, start: number, end: number): void {\n  const subList = list.getSubList(start, end);\n  const task = new taskpool.Task(() => {\n    return Array.from(subList);\n  });\n  \n  task.on('start', (event: Event) => {\n    console.log(`Task started with type: ${event.type}`);\n  });\n  \n  taskpool.execute(task, taskpool.Priority.HIGH).then((result) => {\n    console.log('Task result:', result);\n  }).catch((error) => {\n    console.error('Task error:', error);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `LightWeightSet.addAll` to collect a set of XML event types (from `xml.EventType`), then passes this set to `taskpool.execute` with a callback function (from `taskpool.CallbackFunction`) to process each event type asynchronously in the task pool.",
    "input": "",
    "output": "import {LightWeightSet, xml, taskpool} from '@kit.ArkTS';\n\nexport function processXmlEventTypes(): void {\n  const eventTypes = new LightWeightSet<xml.EventType>();\n  eventTypes.addAll([\n    xml.EventType.START_ELEMENT,\n    xml.EventType.END_ELEMENT,\n    xml.EventType.TEXT,\n    xml.EventType.CDATA,\n    xml.EventType.COMMENT,\n    xml.EventType.PROCESSING_INSTRUCTION,\n    xml.EventType.DOCUMENT_START,\n    xml.EventType.DOCUMENT_END,\n    xml.EventType.NAMESPACE_PREFIX,\n    xml.EventType.ENTITY_REFERENCE\n  ]);\n\n  const callback: taskpool.CallbackFunction = (eventType: xml.EventType) => {\n    console.log(`Processing XML event type: ${eventType}`);\n  };\n\n  for (const eventType of eventTypes) {\n    taskpool.execute(callback, [eventType]);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses `LightWeightSet.toArray` to convert a LightWeightSet of task priorities (from `taskpool.Priority`) into an array, then uses `xml` parsing to format this array into an XML string representation of the priorities for logging purposes.",
    "input": "",
    "output": "import {LightWeightSet, xml, taskpool} from '@kit.ArkTS';\n\nexport function convertPrioritiesToXml(prioritySet: LightWeightSet<taskpool.Priority>): string {\n  const priorityArray: Array<taskpool.Priority> = prioritySet.toArray();\n  const xmlBuilder = new xml.XmlSerializer();\n  \n  xmlBuilder.startElement('Priorities');\n  for (const priority of priorityArray) {\n    xmlBuilder.startElement('Priority');\n    xmlSerializer.text(priority.toString());\n    xmlBuilder.endElement();\n  }\n  xmlBuilder.endElement();\n  \n  return xmlBuilder.toString();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task that uses `taskpool.executePeriodically` to schedule a periodic check (using `LightWeightSet.isEmpty` and `LightWeightSet.clear`) to monitor and clear an empty LightWeightSet, while logging the set's state transitions (from `taskpool.State`) to track task execution status.",
    "input": "",
    "output": "import {LightWeightSet, xml, taskpool} from '@kit.ArkTS';\n\nexport class LightWeightSetMonitor {\n  private set: LightWeightSet<string> = new LightWeightSet<string>();\n  private taskId: number | undefined;\n\n  public startMonitoring(interval: number): void {\n    this.taskId = taskpool.executePeriodically(() => {\n      const isEmpty = this.set.isEmpty();\n      console.log(`LightWeightSet is empty: ${isEmpty}`);\n      if (isEmpty) {\n        this.set.clear();\n        console.log('LightWeightSet cleared');\n      }\n    }, interval, (state: taskpool.State) => {\n      console.log(`Task state: ${taskpool.State[state]}`);\n    });\n  }\n\n  public stopMonitoring(): void {\n    if (this.taskId !== undefined) {\n      taskpool.cancel(this.taskId);\n      this.taskId = undefined;\n    }\n  }\n\n  public addValue(value: string): void {\n    this.set.add(value);\n  }\n\n  public removeValue(value: string): void {\n    this.set.remove(value);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to run a background task that generates a list of URIs, then uses the `Priority` enum from `taskpool` to prioritize the processing of these URIs in a subsequent `executeDelayed` task.",
    "input": "",
    "output": "import {uri, taskpool, taskpool} from '@kit.ArkTS';\n\nexport function generateAndProcessUris(): void {\n  const uriGenerator = (): Array<string> => {\n    const uris: Array<string> = [];\n    for (let i = 0; i < 10; i++) {\n      uris.push(`https://example.com/resource/${i}`);\n    }\n    return uris;\n  };\n\n  taskpool.execute(uriGenerator).then((uris: Array<string>) => {\n    const uriProcessor = (): void => {\n      uris.forEach((uri: string) => {\n        console.log(`Processing URI: ${uri}`);\n      });\n    };\n\n    taskpool.executeDelayed(uriProcessor, 1000, taskpool.Priority.HIGH);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `executePeriodically` method of `taskpool` to periodically check the state of a resource (using the `State` enum from `taskpool`), and if the state changes, it triggers a callback function (using `CallbackFunction` from `taskpool`) to handle the new state, passing the resource URI as a parameter.",
    "input": "",
    "output": "import {uri, taskpool} from '@kit.ArkTS';\n\nexport function monitorResourceState(resourceUri: string, callback: taskpool.CallbackFunction, interval: number): void {\n  let previousState: taskpool.State | undefined;\n  \n  const checkState = () => {\n    const currentState = taskpool.State.RUNNING; // Example state, replace with actual state check logic\n    \n    if (currentState !== previousState) {\n      previousState = currentState;\n      callback(resourceUri);\n    }\n  };\n  \n  taskpool.executePeriodically(checkState, interval);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task management system where the `getTaskPoolInfo` method of `taskpool` is used to monitor active tasks, and based on the information retrieved, the `cancel` method of `taskpool` is called to terminate specific tasks, with the task IDs being passed as URIs for identification.",
    "input": "",
    "output": "import {uri, taskpool, taskpool} from '@kit.ArkTS';\n\nexport function monitorAndCancelTasks(taskIds: string[]): void {\n  const taskPoolInfo = taskpool.getTaskPoolInfo();\n  \n  if (taskPoolInfo && taskPoolInfo.activeTasks) {\n    taskPoolInfo.activeTasks.forEach((taskInfo: {uri: string}) => {\n      if (taskIds.includes(taskInfo.uri)) {\n        taskpool.cancel(taskInfo.uri);\n      }\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "",
    "input": "",
    "output": "",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirstElement` method of `Vector` to retrieve the first element of a vector, then checks if this element exists as a key in a `TreeMap` using the `hasKey` method. If the key exists, update its value in the `TreeMap` using the `set` method, otherwise add the key-value pair to the `TreeMap`.",
    "input": "",
    "output": "import { Vector, TreeMap } from '@kit.ArkTS';\n\nexport function updateTreeMapWithFirstElement(vector: Vector<number>, treeMap: TreeMap<number, string>): void {\n  if (vector.isEmpty()) {\n    return;\n  }\n  \n  const firstElement = vector.getFirstElement();\n  \n  if (treeMap.hasKey(firstElement)) {\n    treeMap.set(firstElement, 'updated');\n  } else {\n    treeMap.set(firstElement, 'new');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that iterates over the keys of a `TreeMap` using the `keys` method, collects these keys into a `Vector` using the `add` method, and then sorts the `Vector` in ascending order using the `sort` method. Finally, return the sorted `Vector`.",
    "input": "",
    "output": "import {url, Vector, TreeMap} from '@kit.ArkTS';\n\nexport function collectAndSortKeys(treeMap: TreeMap<number, unknown>): Vector<number> {\n  const keysVector = new Vector<number>();\n  const keysIter = treeMap.keys();\n  \n  for (const key of keysIter) {\n    keysVector.add(key);\n  }\n  \n  keysVector.sort((a: number, b: number) => a - b);\n  return keysVector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes a `Vector` of strings and a `TreeMap` as input. Use the `forEach` method of the `Vector` to process each string, and for each string, check if it exists as a value in the `TreeMap` using the `hasValue` method. If the value exists, remove the corresponding entry from the `TreeMap` using the `remove` method, otherwise add the string to the `Vector` again using the `add` method.",
    "input": "",
    "output": "import {url, Vector, TreeMap} from '@kit.ArkTS';\n\nexport function processVectorAndTreeMap(vector: Vector<string>, treeMap: TreeMap<unknown, string>): void {\n  const originalLength = vector.length;\n  for (let i = 0; i < originalLength; i++) {\n    const str = vector.get(i);\n    if (treeMap.hasValue(str)) {\n      const keysToRemove: unknown[] = [];\n      treeMap.forEach((value: string, key: unknown) => {\n        if (value === str) {\n          keysToRemove.push(key);\n        }\n      });\n      keysToRemove.forEach((key) => {\n        treeMap.remove(key);\n      });\n    } else {\n      vector.add(str);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `name` property of `WorkerOptions` to set a worker thread name, then passes this worker to `WorkerGlobalScope.self` to verify the worker's context and log the worker name.",
    "input": "",
    "output": "import {xml, WorkerGlobalScope, WorkerOptions} from '@kit.ArkTS';\n\nexport function createAndVerifyWorker(): void {\n  const workerOptions: WorkerOptions = {\n    name: 'testWorker'\n  };\n\n  const workerScope: WorkerGlobalScope = self as WorkerGlobalScope;\n  if (workerScope.name === workerOptions.name) {\n    console.log(`Worker name verified: ${workerScope.name}`);\n  } else {\n    console.log('Worker name verification failed');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a worker with `WorkerOptions.shared` set to true, then uses `WorkerGlobalScope.onerror` to handle any errors that occur during the worker's execution, logging them with a custom message.",
    "input": "",
    "output": "import {xml, WorkerGlobalScope, WorkerOptions} from '@kit.ArkTS';\n\nexport function initializeSharedWorker(): void {\n  const options: WorkerOptions = {\n    shared: true\n  };\n\n  const workerGlobalScope: WorkerGlobalScope = new WorkerGlobalScope('./worker.js', options);\n\n  workerGlobalScope.onerror = (error: ErrorEvent): void => {\n    console.error(`Custom error message: ${error.message}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `EventType` enum from `xml` to define an event type, then triggers this event in a worker thread (initialized with `WorkerOptions`) and uses `WorkerGlobalScope.name` to identify which worker triggered the event.",
    "input": "",
    "output": "import {xml, WorkerGlobalScope, WorkerOptions} from '@kit.ArkTS';\n\nexport enum CustomEventType {\n  EVENT_ONE = xml.EventType.ELEMENT,\n  EVENT_TWO = xml.EventType.ATTRIBUTE\n}\n\nexport function triggerEventInWorker(): void {\n  const workerOptions: WorkerOptions = {\n    name: 'testWorker'\n  };\n\n  const workerScript = `\n    import {WorkerGlobalScope} from '@kit.ArkTS';\n    const globalScope = self as unknown as WorkerGlobalScope;\n    globalScope.postMessage(globalScope.name);\n  `;\n\n  const blob = new Blob([workerScript], { type: 'application/javascript' });\n  const workerUrl = URL.createObjectURL(blob);\n  const worker = new Worker(workerUrl, workerOptions);\n\n  worker.onmessage = (event: MessageEvent<string>) => {\n    console.log(`Event triggered by worker: ${event.data}`);\n    URL.revokeObjectURL(workerUrl);\n  };\n\n  worker.onerror = (error: ErrorEvent) => {\n    console.error(`Worker error: ${error.message}`);\n    URL.revokeObjectURL(workerUrl);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a DedicatedWorkerGlobalScope and uses its `postMessage` method to send a message to the worker. The worker should use the `onmessage` property to receive the message and then return the `data` property of the MessageEvent to the main thread.",
    "input": "",
    "output": "import {url, DedicatedWorkerGlobalScope, MessageEvent} from '@kit.ArkTS';\n\nexport function createWorkerAndSendMessage(): void {\n  const worker: DedicatedWorkerGlobalScope = new DedicatedWorkerGlobalScope();\n  \n  worker.onmessage = (event: MessageEvent<string>) => {\n    worker.postMessage(event.data);\n  };\n  \n  worker.postMessage('Hello from main thread');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a scenario where a DedicatedWorkerGlobalScope uses its `close` method to terminate itself after processing a message received via its `onmessage` property. The message should be constructed using the `data` property of a MessageEvent object passed from the main thread.",
    "input": "",
    "output": "import {url, DedicatedWorkerGlobalScope, MessageEvent} from '@kit.ArkTS';\n\nexport class WorkerScript {\n  private workerScope: DedicatedWorkerGlobalScope;\n\n  constructor(workerScope: DedicatedWorkerGlobalScope) {\n    this.workerScope = workerScope;\n    this.workerScope.onmessage = (event: MessageEvent<string>) => {\n      this.handleMessage(event);\n    };\n  }\n\n  private handleMessage(event: MessageEvent<string>): void {\n    const messageData = event.data;\n    console.log(`Worker received: ${messageData}`);\n    this.workerScope.close();\n  }\n}\n\nconst workerScript = new WorkerScript(self as DedicatedWorkerGlobalScope);",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function where the main thread sends a URL string to a DedicatedWorkerGlobalScope using the `postMessage` method. The worker should use the `onmessage` property to receive the URL, process it, and then send back a response using the `postMessage` method, with the response data stored in the `data` property of a MessageEvent.",
    "input": "",
    "output": "import {url, DedicatedWorkerGlobalScope, MessageEvent} from '@kit.ArkTS';\n\nexport function setupWorkerCommunication(worker: DedicatedWorkerGlobalScope, urlString: string): void {\n  worker.postMessage(urlString);\n}\n\nexport function processWorkerMessage(worker: DedicatedWorkerGlobalScope, callback: (data: string) => void): void {\n  worker.onmessage = (event: MessageEvent<string>) => {\n    const processedData = processUrl(event.data);\n    callback(processedData);\n  };\n}\n\nfunction processUrl(urlString: string): string {\n  // Placeholder for URL processing logic\n  return `Processed: ${urlString}`;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a Worker using `WorkerOptions` with a specified name and shared flag, then uses the `name` property of `WorkerGlobalScope` to verify the worker's identity, and finally stores the worker's name in a `LightWeightSet` using the `add` method.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightSet, WorkerOptions} from '@kit.ArkTS';\n\nexport function createAndVerifyWorker(workerName: string, sharedFlag: boolean): void {\n  const options: WorkerOptions = {\n    name: workerName,\n    shared: sharedFlag\n  };\n\n  const worker = new Worker('worker.js', options);\n  const workerScope: WorkerGlobalScope = worker.self;\n  const verifiedName: string = workerScope.name;\n\n  const nameSet: LightWeightSet<string> = new LightWeightSet<string>();\n  nameSet.add(verifiedName);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that initializes a `LightWeightSet` with a set of values using the `addAll` method, then creates a Worker with `WorkerOptions` where the name is dynamically generated from the `LightWeightSet`'s `length` property, and finally uses the `WorkerGlobalScope`'s `onerror` property to handle any errors during worker execution.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightSet, WorkerOptions} from '@kit.ArkTS';\n\nexport function initializeWorkerWithLightWeightSet(values: string[]): void {\n  const lightWeightSet = new LightWeightSet<string>();\n  lightWeightSet.addAll(values);\n\n  const workerName = `worker_${lightWeightSet.length}`;\n  const workerOptions: WorkerOptions = {\n    name: workerName,\n    shared: false\n  };\n\n  const worker = new WorkerGlobalScope(workerOptions);\n  worker.onerror = (error: ErrorEvent) => {\n    console.error(`Worker error: ${error.message}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `WorkerGlobalScope`'s `self` property to get the current worker context, then checks if the worker's name (from `WorkerOptions`) exists in a `LightWeightSet` using the `has` method, and finally clears the set using the `clear` method if the name is found.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightSet, WorkerOptions} from '@kit.ArkTS';\n\nexport function checkAndClearWorkerName(set: LightWeightSet<string>): void {\n  const workerScope: WorkerGlobalScope = self;\n  const workerName: string | undefined = workerScope.name;\n  \n  if (workerName && set.has(workerName)) {\n    set.clear();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of error messages, then uses the `onerror` property of `GlobalScope` (from @kit.ArkTS) to handle the last error message popped from the stack using the `pop` method.",
    "input": "",
    "output": "import {GlobalScope, Stack, Deque} from '@kit.ArkTS';\n\nexport function handleErrorMessages(errorMessages: string[]): void {\n  const stack = new Stack<string>();\n  \n  // Push all error messages into the stack\n  errorMessages.forEach((message: string) => {\n    stack.push(message);\n  });\n  \n  // Set up the onerror handler to process the last error message\n  GlobalScope.onerror = (event: ErrorEvent): void => {\n    if (!stack.isEmpty()) {\n      const lastErrorMessage = stack.pop();\n      console.log(`Last error message: ${lastErrorMessage}`);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first inserts elements into a `Deque` (from @kit.ArkTS) using `insertFront` and `insertEnd`, then transfers these elements to a `Stack` (from @kit.ArkTS) using `push` and `pop` methods to reverse their order, and finally logs the result using the `self` property of `GlobalScope` (from @kit.ArkTS).",
    "input": "",
    "output": "import {GlobalScope, Stack, Deque} from '@kit.ArkTS';\n\nexport function reverseDequeToStack(): void {\n  const deque = new Deque<number>();\n  deque.insertFront(1);\n  deque.insertEnd(2);\n  deque.insertFront(3);\n  deque.insertEnd(4);\n\n  const stack = new Stack<number>();\n  while (deque.length > 0) {\n    stack.push(deque.popFirst()!);\n  }\n\n  const result: number[] = [];\n  while (stack.length > 0) {\n    result.push(stack.pop()!);\n  }\n\n  GlobalScope.self.name = 'reverseDequeToStack';\n  GlobalScope.self.onerror = (error) => {\n    console.error(error);\n  };\n  console.log(result);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if a `Stack` (from @kit.ArkTS) is empty using the `isEmpty` method, and if it is, fills it with elements from a `Deque` (from @kit.ArkTS) using `getFirst` and `popFirst` methods, then logs the stack's new length using the `length` property of `Stack`.",
    "input": "",
    "output": "import {GlobalScope, Stack, Deque} from '@kit.ArkTS';\n\nexport function fillStackFromDeque(stack: Stack<unknown>, deque: Deque<unknown>): void {\n  if (stack.isEmpty()) {\n    while (!deque.isEmpty()) {\n      const element = deque.getFirst();\n      deque.popFirst();\n      stack.push(element);\n    }\n    console.log(`Stack's new length: ${stack.length}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` and `get` methods of `List` to collect a series of URLs from user input, then passes the collected URLs to the `worker` API to asynchronously fetch the content of each URL and store the results in a new `List` using its `insert` method.",
    "input": "",
    "output": "import {url, worker, List} from '@kit.ArkTS';\n\nexport function fetchURLContents(urls: List<string>): List<string> {\n  const results = new List<string>();\n  const workerInstance = new worker.ThreadWorker('workers/worker.js');\n\n  workerInstance.onmessage = (message: worker.MessageEvents): void => {\n    if (message.data) {\n      results.insert(results.length, message.data);\n    }\n  };\n\n  workerInstance.onerror = (error: worker.ErrorEvent): void => {\n    console.error(`Worker error: ${error.message}`);\n  };\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls.get(i);\n    workerInstance.postMessage(url);\n  }\n\n  workerInstance.terminate();\n  return results;\n}\n\nexport function collectAndFetchURLs(): void {\n  const urlList = new List<string>();\n  // Simulate user input by adding URLs to the list\n  urlList.add('https://example.com');\n  urlList.add('https://example.org');\n  urlList.add('https://example.net');\n\n  const fetchedContents = fetchURLContents(urlList);\n  console.log('Fetched contents:', fetchedContents.convertToArray());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `forEach` method of `List` to iterate over a list of worker tasks, then uses the `worker` API to execute each task in parallel, and finally employs the `sort` method of `List` to organize the results based on task completion time.",
    "input": "",
    "output": "import {url, worker, List} from '@kit.ArkTS';\n\nexport function executeAndSortTasks(taskList: List<string>): List<{task: string, completionTime: number}> {\n  const results: List<{task: string, completionTime: number}> = new List();\n  \n  taskList.forEach((task: string) => {\n    const wk = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n    wk.postMessage(task);\n    wk.onmessage = (msg: {data: {task: string, completionTime: number}}) => {\n      results.add(msg.data);\n      wk.terminate();\n    };\n  });\n  \n  results.sort((a, b) => a.completionTime - b.completionTime);\n  return results;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first uses the `convertToArray` method of `List` to transform a list of data into an array, then passes this array to the `worker` API for processing, and subsequently uses the `replaceAllElements` method of `List` to update the original list with the processed results.",
    "input": "",
    "output": "import {url, worker, List} from '@kit.ArkTS';\n\nexport function processListWithWorker(originalList: List<number>, workerScript: string): void {\n  // Convert the list to an array\n  const arrayData: number[] = originalList.convertToArray();\n\n  // Create a worker\n  const myWorker = new worker.ThreadWorker(workerScript);\n\n  // Send the array data to the worker\n  myWorker.postMessage(arrayData);\n\n  // Receive the processed data from the worker\n  myWorker.onmessage = (processedData: number[]) => {\n    // Update the original list with the processed data\n    originalList.replaceAllElements((index: number) => {\n      return processedData[index];\n    });\n\n    // Terminate the worker\n    myWorker.terminate();\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `HashSet` to collect a set of unique message IDs, then checks if a specific message ID exists using the `has` method of `HashSet`. If the ID exists, retrieve the corresponding message data using the `data` property of `MessageEvents` and return it; otherwise, return an empty string.",
    "input": "",
    "output": "import {HashSet, MessageEvents} from '@kit.ArkTS';\n\nexport function checkMessageId(messageId: string, messageSet: HashSet<string>, messageEvents: MessageEvents): string {\n  if (messageSet.has(messageId)) {\n    return messageEvents.data;\n  }\n  return '';\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `HashSet` with a list of event IDs using the `add` method, then iterates over the set using the `forEach` method of `HashSet`. For each event ID, check if it exists in another `HashSet` (using the `has` method) and log the event data (using the `data` property of `MessageEvents`) if it does.",
    "input": "",
    "output": "import {HashSet, MessageEvents} from '@kit.ArkTS';\n\nexport function processEventIds(eventIds: string[], otherEventSet: HashSet<string>, messageEvents: MessageEvents[]): void {\n  const eventSet = new HashSet<string>();\n  \n  // Populate the HashSet with event IDs\n  eventIds.forEach((id: string) => {\n    eventSet.add(id);\n  });\n  \n  // Iterate over the HashSet and check for existence in the other HashSet\n  eventSet.forEach((id: string) => {\n    if (otherEventSet.has(id)) {\n      const eventData = messageEvents.find(event => event.data === id)?.data;\n      if (eventData) {\n        console.log(eventData);\n      }\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `entries` method of `HashSet` to get an iterator of key-value pairs, then filters out entries where the value (message ID) is not present in a second `HashSet` (using the `has` method). For the remaining entries, extract the message data using the `data` property of `MessageEvents` and return them as an array.",
    "input": "",
    "output": "import {HashSet, MessageEvents} from '@kit.ArkTS';\n\nexport function filterAndExtractMessages(messageEventsSet: HashSet<MessageEvents>, messageIdsSet: HashSet<string>): Array<unknown> {\n  const result: Array<unknown> = [];\n  const iterator = messageEventsSet.entries();\n  let entry = iterator.next();\n  while (!entry.done) {\n    const [key, value] = entry.value;\n    if (messageIdsSet.has(value.data)) {\n      result.push(value.data);\n    }\n    entry = iterator.next();\n  }\n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a buffer from a string with 'utf-8' encoding (using `BufferEncoding`), then checks if the encoding is valid using `buffer.isEncoding`, and finally dispatches an event with the buffer's byte length as `Event.timeStamp`.",
    "input": "",
    "output": "import {buffer, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function processBuffer(inputString: string): void {\n  const encoding: buffer.BufferEncoding = 'utf-8';\n  if (buffer.isEncoding(encoding)) {\n    const buf = buffer.from(inputString, encoding);\n    const event = new Event('bufferEvent');\n    event.timeStamp = buf.byteLength;\n    // Dispatch the event here if needed\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that generates two buffers using `buffer.alloc` and `buffer.allocUninitialized`, compares them using `buffer.compare`, and posts the comparison result to another thread using `PostMessageOptions` with the `transfer` property set to transfer ownership of the buffers.",
    "input": "",
    "output": "import {buffer, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function compareAndTransferBuffers(): void {\n  const buf1 = buffer.alloc(10);\n  const buf2 = buffer.allocUninitialized(10);\n  \n  const comparisonResult = buffer.compare(buf1, buf2);\n  \n  const event: Event = {\n    timeStamp: Date.now(),\n    type: 'bufferComparison'\n  };\n  \n  const options: PostMessageOptions = {\n    transfer: [buf1.buffer, buf2.buffer]\n  };\n  \n  // In a real scenario, you would post this to another thread\n  // For example: worker.postMessage({ event, result: comparisonResult }, options);\n  // This is a placeholder for the actual postMessage call\n  console.log(`Comparison result: ${comparisonResult}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that concatenates multiple buffers using `buffer.concat`, verifies if the result is a valid buffer using `buffer.isBuffer`, and then triggers an event where the concatenated buffer's length is stored in `Event.type` as a string.",
    "input": "",
    "output": "import {buffer, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function concatenateAndTriggerEvent(buffers: buffer[]): Event {\n  const concatenatedBuffer = buffer.concat(buffers);\n  const isValidBuffer = buffer.isBuffer(concatenatedBuffer);\n  \n  if (!isValidBuffer) {\n    throw new Error('Invalid buffer');\n  }\n  \n  const event = new Event();\n  event.type = concatenatedBuffer.length.toString();\n  \n  return event;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that listens for a `MessageEvent` and extracts its `data` property, then uses this data to create an `ErrorEvent` by setting the `message` property of the `ErrorEvent` to the received data. The function should also log the `filename` and `lineno` properties of the `ErrorEvent` for debugging purposes.",
    "input": "",
    "output": "import {MessageEvents, ErrorEvent, uri} from '@kit.ArkTS';\n\nexport function handleMessageEvent(event: MessageEvents): void {\n  const messageData = event.data;\n  const errorEvent = new ErrorEvent('error', {\n    message: messageData,\n    filename: '',\n    lineno: 0,\n    colno: 0,\n    error: null\n  });\n\n  console.log(`Filename: ${errorEvent.filename}`);\n  console.log(`Line number: ${errorEvent.lineno}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that constructs a URI string and passes it as the `data` property of a `MessageEvent`. Then, handle this `MessageEvent` by parsing the URI and using its components to populate an `ErrorEvent`'s `filename` and `message` properties, ensuring the `error` property is set to a custom error object.",
    "input": "",
    "output": "import {MessageEvents, ErrorEvent, uri} from '@kit.ArkTS';\n\nexport function constructAndHandleMessageEvent(): void {\n  // Construct a URI string\n  const uriString = 'https://example.com/error?message=CustomError&filename=script.js';\n  \n  // Create a MessageEvent with the URI string as data\n  const messageEvent = new MessageEvents('message', {\n    data: uriString\n  });\n  \n  // Handle the MessageEvent\n  handleMessageEvent(messageEvent);\n}\n\nexport function handleMessageEvent(event: MessageEvents): void {\n  // Parse the URI from the event data\n  const parsedUri = uri.parse(event.data as string);\n  \n  // Extract components from the parsed URI\n  const searchParams = new URLSearchParams(parsedUri.query);\n  const errorMessage = searchParams.get('message') || 'Unknown error';\n  const filename = searchParams.get('filename') || 'unknown';\n  \n  // Create a custom error object\n  const customError = new Error(errorMessage);\n  \n  // Create an ErrorEvent with the extracted components\n  const errorEvent = new ErrorEvent('error', {\n    message: errorMessage,\n    filename: filename,\n    error: customError\n  });\n  \n  // Handle the ErrorEvent (e.g., dispatch it or log it)\n  console.log(`ErrorEvent created: ${errorEvent.message} in ${errorEvent.filename}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that captures an `ErrorEvent`, extracts its `error` and `message` properties, and sends them as the `data` property of a new `MessageEvent`. The function should then handle this `MessageEvent` by logging the `data` and triggering another `ErrorEvent` if the original `message` contains specific keywords.",
    "input": "",
    "output": "import {MessageEvents, ErrorEvent, uri} from '@kit.ArkTS';\n\nexport function handleErrorEvent(errorEvent: ErrorEvent): void {\n  const errorData = {\n    error: errorEvent.error,\n    message: errorEvent.message\n  };\n\n  const messageEvent = new MessageEvents('errorData', {\n    data: errorData\n  });\n\n  handleMessageEvent(messageEvent);\n}\n\nexport function handleMessageEvent(messageEvent: MessageEvents): void {\n  const data = messageEvent.data;\n  console.log('Error data:', data);\n\n  if (data.message.includes('critical') || data.message.includes('fatal')) {\n    const newErrorEvent = new ErrorEvent('criticalError', {\n      error: data.error,\n      message: data.message\n    });\n    \n    throw newErrorEvent;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `ThreadWorkerGlobalScope.postMessage` to send an error object to a worker thread, and then in the worker thread, use `ErrorEvent.error` to extract and log the error details. The error object should include properties like `message`, `filename`, `lineno`, and `colno` from the `ErrorEvent` API.",
    "input": "",
    "output": "import {ErrorEvent, ThreadWorkerGlobalScope, url} from '@kit.ArkTS';\n\nexport function sendErrorToWorker(worker: ThreadWorkerGlobalScope, error: ErrorEvent): void {\n  worker.postMessage({\n    message: error.message,\n    filename: error.filename,\n    lineno: error.lineno,\n    colno: error.colno,\n    error: error.error\n  });\n}\n\nexport function handleWorkerError(event: ErrorEvent): void {\n  console.error(`Error: ${event.error}`);\n  console.error(`Message: ${event.message}`);\n  console.error(`Filename: ${event.filename}`);\n  console.error(`Line: ${event.lineno}`);\n  console.error(`Column: ${event.colno}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread using `ThreadWorkerGlobalScope` and set up an `onmessage` handler to receive a URL string. Inside the handler, use the `url` API to parse the URL and then use `ThreadWorkerGlobalScope.postMessage` to send the parsed components (like hostname, path, etc.) back to the main thread.",
    "input": "",
    "output": "import {ErrorEvent, ThreadWorkerGlobalScope, url} from '@kit.ArkTS';\n\nconst workerPort: ThreadWorkerGlobalScope = workerPortGlobalScope;\n\nworkerPort.onmessage = (event: MessageEvent<string>) => {\n  try {\n    const parsedUrl = url.parse(event.data);\n    workerPort.postMessage({\n      hostname: parsedUrl.hostname,\n      path: parsedUrl.path,\n      protocol: parsedUrl.protocol,\n      search: parsedUrl.search\n    });\n  } catch (error) {\n    const errorEvent: ErrorEvent = {\n      error: error,\n      message: error.message,\n      filename: '',\n      lineno: 0,\n      colno: 0\n    };\n    workerPort.postMessage(errorEvent);\n  }\n};\n",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a worker thread uses `ThreadWorkerGlobalScope.postMessageWithSharedSendable` to send an error event object (constructed using `ErrorEvent` properties like `error`, `message`, and `filename`) to the main thread. The main thread should then use `ErrorEvent` properties to display the error details in a user-friendly format.",
    "input": "",
    "output": "import {ErrorEvent, ThreadWorkerGlobalScope, url} from '@kit.ArkTS';\n\n// Worker thread implementation\nexport function workerThreadCode() {\n  const workerScope: ThreadWorkerGlobalScope = self as unknown as ThreadWorkerGlobalScope;\n  \n  try {\n    // Simulate an error occurring in the worker\n    throw new Error('Sample error occurred in worker');\n  } catch (error) {\n    const errorEvent = {\n      error: error,\n      message: error.message,\n      filename: 'workerScript.ets',\n      colno: 10,\n      lineno: 5\n    };\n    \n    workerScope.postMessageWithSharedSendable({\n      type: 'error',\n      data: errorEvent\n    });\n  }\n}\n\n// Main thread implementation\nexport function mainThreadCode() {\n  const worker = new ThreadWorker('path/to/workerScript.ets');\n  \n  worker.onmessage = (event: {type: string, data: {error: Error, message: string, filename: string, colno: number, lineno: number}}) => {\n    if (event.type === 'error') {\n      const errorDetails = event.data;\n      console.error(`Error occurred in ${errorDetails.filename} at line ${errorDetails.lineno}, column ${errorDetails.colno}:`);\n      console.error(`Message: ${errorDetails.message}`);\n      console.error(`Stack: ${errorDetails.error.stack}`);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addEventListener` method of `WorkerEventTarget` to listen for custom events, and upon receiving an event, uses the `add` method of `TreeSet` to store the event data in a sorted collection. Then, use the `getFirstValue` and `getLastValue` methods of `TreeSet` to log the smallest and largest values from the collected data.",
    "input": "",
    "output": "import {WorkerEventTarget, TreeSet} from '@kit.ArkTS';\n\nexport function listenAndStoreEvents(eventTarget: WorkerEventTarget): void {\n  const sortedData: TreeSet<number> = new TreeSet<number>();\n\n  eventTarget.addEventListener('customEvent', (event: CustomEvent<number>) => {\n    sortedData.add(event.detail);\n    const smallest = sortedData.getFirstValue();\n    const largest = sortedData.getLastValue();\n    console.log(`Smallest value: ${smallest}, Largest value: ${largest}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `TreeSet` and populates it with values using the `add` method. Then, use the `dispatchEvent` method of `WorkerEventTarget` to trigger a custom event, passing the `TreeSet`'s `length` property as part of the event data. Finally, use the `removeEventListener` method of `WorkerEventTarget` to clean up the event listener after the event is handled.",
    "input": "",
    "output": "import {WorkerEventTarget, TreeSet} from '@kit.ArkTS';\n\nexport function initializeTreeSetAndDispatchEvent(eventTarget: WorkerEventTarget): void {\n  const treeSet = new TreeSet<number>();\n  treeSet.add(1);\n  treeSet.add(2);\n  treeSet.add(3);\n\n  const eventHandler = (event: CustomEvent<number>) => {\n    console.log(`TreeSet length: ${event.detail}`);\n    eventTarget.removeEventListener('customEvent', eventHandler);\n  };\n\n  eventTarget.addEventListener('customEvent', eventHandler);\n  const customEvent = new CustomEvent('customEvent', { detail: treeSet.length });\n  eventTarget.dispatchEvent(customEvent);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `TreeSet` to iterate over its values and dispatch a custom event for each value using the `dispatchEvent` method of `WorkerEventTarget`. The event listener, registered via `addEventListener`, should then use the `remove` method of `TreeSet` to filter out specific values based on the event data.",
    "input": "",
    "output": "import {WorkerEventTarget, TreeSet} from '@kit.ArkTS';\n\nexport function processTreeSetWithEvents(treeSet: TreeSet<number>, eventTarget: WorkerEventTarget, filterValue: number): void {\n  treeSet.forEach((value: number) => {\n    const event = { data: value };\n    eventTarget.dispatchEvent(event);\n  });\n\n  eventTarget.addEventListener('data', (event: { data: number }) => {\n    if (event.data === filterValue) {\n      treeSet.remove(event.data);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addAll` method of `LightWeightSet` to combine two sets of employee IDs, then passes the resulting set to the `worker` API to distribute processing tasks across multiple threads, ensuring each thread processes a subset of IDs using the `getValueAt` method of `LightWeightSet`.",
    "input": "",
    "output": "import {uri, worker, LightWeightSet} from '@kit.ArkTS';\n\nexport function combineAndProcessEmployeeIDs(set1: LightWeightSet<number>, set2: LightWeightSet<number>): void {\n  const combinedSet = new LightWeightSet<number>();\n  combinedSet.addAll(set1);\n  combinedSet.addAll(set2);\n\n  const workerInstance = new worker.ThreadWorker('scripts/worker.js');\n  \n  workerInstance.onmessage = (message: worker.MessageEvents): void => {\n    console.log(`Worker response: ${message.data}`);\n  };\n\n  workerInstance.onerror = (error: worker.ErrorEvent): void => {\n    console.error(`Worker error: ${error.message}`);\n  };\n\n  for (let i = 0; i < combinedSet.length; i++) {\n    const employeeID = combinedSet.getValueAt(i);\n    workerInstance.postMessage(employeeID);\n  }\n\n  workerInstance.terminate();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `toArray` method of `LightWeightSet` to convert a set of product SKUs into an array, then uses the `uri` API to generate encoded URIs for each SKU, and finally checks if all generated URIs are valid by using the `hasAll` method of `LightWeightSet` on the URI array.",
    "input": "",
    "output": "import {uri, worker, LightWeightSet} from '@kit.ArkTS';\n\nexport function validateProductSkus(skuSet: LightWeightSet<string>): boolean {\n  const skuArray: string[] = skuSet.toArray();\n  const uriArray: string[] = [];\n\n  for (const sku of skuArray) {\n    const encodedUri: string = uri.encode(sku);\n    uriArray.push(encodedUri);\n  }\n\n  const uriSet: LightWeightSet<string> = new LightWeightSet<string>();\n  uriSet.addAll(uriArray);\n\n  return skuSet.hasAll(uriSet);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LightWeightSet` to iterate over a set of transaction IDs, then passes each ID to the `worker` API for parallel processing, and finally collects the results using the `entries` method of `LightWeightSet` to store the processed data.",
    "input": "",
    "output": "import {uri, worker, LightWeightSet} from '@kit.ArkTS';\n\nexport function processTransactions(transactionIds: LightWeightSet<string>, workerScript: string): LightWeightSet<string> {\n  const processedResults = new LightWeightSet<string>();\n  \n  transactionIds.forEach((id: string) => {\n    const workerInstance = new worker.ThreadWorker(workerScript);\n    workerInstance.postMessage(id);\n    workerInstance.onmessage = (message: string) => {\n      processedResults.add(message);\n      workerInstance.terminate();\n    };\n  });\n  \n  return processedResults;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a set of key-value pairs representing employee IDs and their names, then passes the values (names) to the `convertToArray` method of `Vector` to create an array of names, and finally uses the `sort` method of `Vector` to alphabetically sort the names.",
    "input": "",
    "output": "import {PlainArray, WorkerGlobalScope, Vector} from '@kit.ArkTS';\n\nexport function processEmployeeNames(): string[] {\n  // Create a PlainArray to store employee IDs and names\n  const employees = new PlainArray<string>();\n  employees.add(1, 'John');\n  employees.add(2, 'Alice');\n  employees.add(3, 'Bob');\n  employees.add(4, 'Zoe');\n  employees.add(5, 'Mike');\n\n  // Create a Vector to store the names\n  const namesVector = new Vector<string>();\n\n  // Iterate through the PlainArray and add names to the Vector\n  for (let i = 0; i < employees.length; i++) {\n    const name = employees.getValueAt(i);\n    if (name !== undefined) {\n      namesVector.add(name);\n    }\n  }\n\n  // Convert the Vector to an array and sort it alphabetically\n  const namesArray = namesVector.convertToArray();\n  namesVector.sort((a, b) => a.localeCompare(b));\n\n  return namesVector.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `WorkerGlobalScope` with a `name` property set to 'DataProcessor', then uses the `forEach` method of `PlainArray` to iterate over a collection of numeric data, and passes each value to the `add` method of `Vector` for processing. The function should then use the `getLastElement` method of `Vector` to retrieve the final processed value and log it to the console.",
    "input": "",
    "output": "import {PlainArray, WorkerGlobalScope, Vector} from '@kit.ArkTS';\n\nexport function processData(): void {\n  const workerScope: WorkerGlobalScope = new WorkerGlobalScope();\n  workerScope.name = 'DataProcessor';\n\n  const dataArray: PlainArray<number> = new PlainArray<number>();\n  dataArray.add(0, 10);\n  dataArray.add(1, 20);\n  dataArray.add(2, 30);\n\n  const vector: Vector<number> = new Vector<number>();\n\n  dataArray.forEach((value: number, index: number) => {\n    vector.add(value);\n  });\n\n  const lastElement: number = vector.getLastElement();\n  console.log(lastElement);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses the `getKeyAt` and `getValueAt` methods of `PlainArray` to extract specific entries, then passes these entries to the `insert` method of `Vector` at specified positions. The function should then use the `trimToCurrentLength` method of `Vector` to remove any unused capacity and return the final compacted vector.",
    "input": "",
    "output": "import {PlainArray, WorkerGlobalScope, Vector} from '@kit.ArkTS';\n\nexport function transferPlainArrayToVector(plainArray: PlainArray<number, number>, vector: Vector<number>, positions: number[]): Vector<number> {\n  for (let i = 0; i < positions.length; i++) {\n    const key = plainArray.getKeyAt(positions[i]);\n    const value = plainArray.getValueAt(positions[i]);\n    if (key !== undefined && value !== undefined) {\n      vector.insert(positions[i], value);\n    }\n  }\n  vector.trimToCurrentLength();\n  return vector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to store a sequence of event names, then iterates through the list using `Symbol.iterator` and dispatches each event using the `dispatchEvent` method of `WorkerEventTarget`. The function should return the number of events successfully dispatched.",
    "input": "",
    "output": "import {LinkedList, WorkerEventTarget, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function dispatchEvents(eventNames: string[], target: WorkerEventTarget): number {\n  const list = new LinkedList<string>();\n  let dispatchedCount = 0;\n\n  for (const name of eventNames) {\n    list.add(name);\n  }\n\n  for (const eventName of list) {\n    try {\n      target.dispatchEvent(eventName);\n      dispatchedCount++;\n    } catch (e) {\n      continue;\n    }\n  }\n\n  return dispatchedCount;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `name` property from `WorkerGlobalScope` and uses it to create a new `LinkedList`. The function should then use the `addFirst` and `addLast` methods of `LinkedList` to add the name in uppercase and lowercase formats, respectively. Finally, the function should return the `length` property of the `LinkedList`.",
    "input": "",
    "output": "import {LinkedList, WorkerEventTarget, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processWorkerName(workerScope: WorkerGlobalScope): number {\n  const name = workerScope.name;\n  const linkedList = new LinkedList<string>();\n  linkedList.addFirst(name.toUpperCase());\n  linkedList.addLast(name.toLowerCase());\n  return linkedList.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that listens for errors using the `onerror` property of `WorkerGlobalScope`. When an error occurs, the function should use the `add` method of `LinkedList` to log the error message and then use the `removeEventListener` method of `WorkerEventTarget` to clean up any existing error listeners. The function should return the `LinkedList` containing all logged error messages.",
    "input": "",
    "output": "import {LinkedList, WorkerEventTarget, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function listenAndLogErrors(workerScope: WorkerGlobalScope): LinkedList<string> {\n  const errorList: LinkedList<string> = new LinkedList();\n\n  const errorHandler = (error: ErrorEvent) => {\n    errorList.add(error.message);\n    (workerScope as unknown as WorkerEventTarget).removeEventListener('error', errorHandler);\n  };\n\n  workerScope.onerror = errorHandler;\n\n  return errorList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` to collect a sequence of messages, then dispatches each message as a `MessageEvent` using the `dispatchEvent` method of `EventTarget`. The `data` property of `MessageEvent` should contain the message from the `Deque`.",
    "input": "",
    "output": "import {Deque, EventTarget, MessageEvent} from '@kit.ArkTS';\n\nexport function dispatchMessagesFromDeque(messages: string[]): void {\n  const deque = new Deque<string>();\n  const eventTarget = new EventTarget();\n\n  for (const message of messages) {\n    deque.insertEnd(message);\n  }\n\n  while (deque.length > 0) {\n    const message = deque.popFirst();\n    if (message !== undefined) {\n      const messageEvent = new MessageEvent<string>('message', { data: message });\n      eventTarget.dispatchEvent(messageEvent);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that listens for incoming messages using the `addEventListener` method of `EventTarget`, stores them in a `Deque` using the `insertEnd` method, and then processes the messages by iterating through the `Deque` using the `Symbol.iterator` method to log each message's `data` property from the `MessageEvent`.",
    "input": "",
    "output": "import {Deque, EventTarget, MessageEvent} from '@kit.ArkTS';\n\nexport function listenAndProcessMessages(eventTarget: EventTarget): void {\n  const messageQueue = new Deque<MessageEvent<string>>();\n\n  eventTarget.addEventListener('message', (event: MessageEvent<string>) => {\n    messageQueue.insertEnd(event);\n  });\n\n  function processMessages() {\n    for (const message of messageQueue) {\n      console.log(message.data);\n    }\n  }\n\n  processMessages();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `popFirst` method of `Deque` to retrieve messages, checks if they meet a certain condition using the `has` method, and then dispatches the filtered messages as `MessageEvent` objects using the `dispatchEvent` method of `EventTarget`, where the `data` property of `MessageEvent` contains the filtered message.",
    "input": "",
    "output": "import {Deque, EventTarget, MessageEvent} from '@kit.ArkTS';\n\nexport function processAndDispatchMessages(deque: Deque<string>, condition: string, eventTarget: EventTarget): void {\n  while (deque.length > 0) {\n    const message = deque.popFirst();\n    if (message && deque.has(condition)) {\n      const messageEvent = new MessageEvent('message', { data: message });\n      eventTarget.dispatchEvent(messageEvent);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of strings, then passes the resulting LinkedList to the `setAll` method of `HashMap` to store the strings as keys with their lengths as values. Finally, use the `values` method of `HashMap` to return an array of all the string lengths.",
    "input": "",
    "output": "import {LinkedList, HashMap, GlobalScope} from '@kit.ArkTS';\n\nexport function collectStringLengths(strings: string[]): number[] {\n  const linkedList = new LinkedList<string>();\n  strings.forEach((str) => {\n    linkedList.add(str);\n  });\n\n  const hashMap = new HashMap<string, number>();\n  hashMap.setAll(linkedList);\n\n  return Array.from(hashMap.values());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `get` method of `HashMap` to retrieve a value associated with a key, then checks if the value exists using the `has` method of `LinkedList`. If the value exists, use the `insert` method of `LinkedList` to add it at a specific index, otherwise use the `addLast` method to append it to the end of the LinkedList.",
    "input": "",
    "output": "import {LinkedList, HashMap, GlobalScope} from '@kit.ArkTS';\n\nexport function processValue(\n  hashMap: HashMap<string, string>,\n  linkedList: LinkedList<string>,\n  key: string,\n  index: number\n): void {\n  const value = hashMap.get(key);\n  if (value !== undefined) {\n    if (linkedList.has(value)) {\n      linkedList.insert(index, value);\n    } else {\n      linkedList.addLast(value);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `keys` method of `HashMap` to get all keys, then converts them to an array using the `convertToArray` method of `LinkedList`. After that, use the `forEach` method of `LinkedList` to iterate over the array and log each key to the console using `GlobalScope.self.console.log`.",
    "input": "",
    "output": "import {LinkedList, HashMap, GlobalScope} from '@kit.ArkTS';\n\nexport function logHashMapKeys(hashMap: HashMap<unknown, unknown>): void {\n  const keysLinkedList: LinkedList<unknown> = hashMap.keys();\n  const keysArray: unknown[] = keysLinkedList.convertToArray();\n  const linkedList: LinkedList<unknown> = new LinkedList();\n  keysArray.forEach((key) => {\n    linkedList.add(key);\n  });\n  linkedList.forEach((key) => {\n    GlobalScope.self.console.log(key);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `set` method of `HashMap` to store key-value pairs representing user preferences, then converts the HashMap to a JSON string using `json.stringify`, and finally logs the JSON string to the console using `GlobalScope.self.console.log`.",
    "input": "",
    "output": "import {HashMap, GlobalScope, json} from '@kit.ArkTS';\n\nexport function storeAndLogUserPreferences(): void {\n  const userPreferences = new HashMap<string, string>();\n  userPreferences.set('theme', 'dark');\n  userPreferences.set('language', 'en');\n  userPreferences.set('notifications', 'enabled');\n\n  const jsonString = json.stringify(userPreferences);\n  GlobalScope.self.console.log(jsonString);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that parses a JSON string containing a list of items using `json.parse`, then iterates over the parsed array using `HashMap.forEach` to populate a new HashMap where each item's ID is the key and the item itself is the value. Finally, use `HashMap.keys` to extract and return an array of all IDs.",
    "input": "",
    "output": "import {HashMap, GlobalScope, json} from '@kit.ArkTS';\n\nexport function parseAndExtractIds(jsonString: string): Array<string> {\n  const parsedArray = json.parse(jsonString) as Array<Record<string, any>>;\n  const itemMap = new HashMap<string, Record<string, any>>();\n  \n  parsedArray.forEach((item) => {\n    itemMap.set(item.id, item);\n  });\n  \n  const ids: Array<string> = [];\n  itemMap.keys().forEach((key) => {\n    ids.push(key);\n  });\n  \n  return ids;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that reads a JSON string representing a configuration object using `json.parse`, checks if a specific key exists in the parsed object using `json.has`, and if it does, updates the corresponding value in a `HashMap` using `HashMap.replace`. The function should return the updated HashMap.",
    "input": "",
    "output": "import {HashMap, GlobalScope, json} from '@kit.ArkTS';\n\nexport function updateHashMapFromJson(jsonString: string, keyToCheck: string, hashMap: HashMap<string, string>): HashMap<string, string> {\n  const parsedObject = json.parse(jsonString);\n  if (json.has(parsedObject, keyToCheck)) {\n    const value = parsedObject[keyToCheck];\n    hashMap.replace(keyToCheck, value);\n  }\n  return hashMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a new Worker with a specified `name` (using `WorkerOptions`), then posts a message to the Worker with an array of data and the `transfer` option (using `PostMessageOptions`). Finally, listen for an event from the Worker and log the `type` and `timeStamp` of the received event (using `Event`).",
    "input": "",
    "output": "import {WorkerOptions, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function createAndCommunicateWithWorker(name: string, data: ArrayBuffer): void {\n  const workerOptions: WorkerOptions = {\n    name: name\n  };\n  \n  const worker = new Worker('worker.ts', workerOptions);\n  \n  const postMessageOptions: PostMessageOptions = {\n    transfer: [data]\n  };\n  \n  worker.postMessage(data, postMessageOptions);\n  \n  worker.onmessage = (event: Event) => {\n    console.log(`Event type: ${event.type}`);\n    console.log(`Event timestamp: ${event.timeStamp}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that initializes a shared Worker (using `shared` property of `WorkerOptions`), then posts a message to it with a transferable object (using `transfer` property of `PostMessageOptions`). Upon receiving an event from the Worker, extract and display the `type` of the event and the `timeStamp` when it was received (using `Event`).",
    "input": "",
    "output": "import {WorkerOptions, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function initializeSharedWorker() {\n  const workerOptions: WorkerOptions = {\n    shared: true\n  };\n  \n  const worker = new Worker('workers/worker.ts', workerOptions);\n  \n  const buffer = new ArrayBuffer(8);\n  const postMessageOptions: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  \n  worker.postMessage(buffer, postMessageOptions);\n  \n  worker.onmessage = (event: Event) => {\n    console.log(`Event type: ${event.type}`);\n    console.log(`Event timestamp: ${event.timeStamp}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a Worker with a custom `name` (using `WorkerOptions`), sends it a message with transferable data (using `PostMessageOptions`), and then listens for a completion event. When the event is received, log the `type` of the event and the `timeStamp` (using `Event`) to confirm the operation's success.",
    "input": "",
    "output": "import {WorkerOptions, Event, PostMessageOptions} from '@kit.ArkTS';\n\nexport function createAndCommunicateWithWorker() {\n  const workerOptions: WorkerOptions = {\n    name: 'customWorker'\n  };\n\n  const worker = new Worker('workers/worker.ts', workerOptions);\n\n  const buffer = new ArrayBuffer(8);\n  const postMessageOptions: PostMessageOptions = {\n    transfer: [buffer]\n  };\n\n  worker.postMessage(buffer, postMessageOptions);\n\n  worker.onmessage = (event: Event) => {\n    console.log(`Event type: ${event.type}`);\n    console.log(`Event timestamp: ${event.timeStamp}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getEnvironmentVar` method of `process` to retrieve the current working directory path, then constructs a URL using this path as the base (using URL API methods), and finally passes this URL to a worker thread for asynchronous processing (using worker API methods).",
    "input": "",
    "output": "import {worker, process, url} from '@kit.ArkTS';\n\nexport function processAndSendToWorker(): void {\n  const cwd: string = process.getEnvironmentVar('cwd');\n  const baseUrl: string = `file://${cwd}`;\n  const workerInstance: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/worker.ts');\n  workerInstance.postMessage(baseUrl);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `getStartRealtime` method of `process` to measure the application's startup time, then uses the `uptime` method of `process` to calculate the total runtime, and finally sends both metrics to a worker thread (using worker API methods) for performance analysis and logging.",
    "input": "",
    "output": "import {worker, process, url} from '@kit.ArkTS';\n\nexport function measureAndSendMetrics(): void {\n  const startupTime: number = process.getStartRealtime();\n  const runtime: number = process.uptime();\n  \n  const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n  \n  workerInstance.postMessage({\n    startupTime,\n    runtime\n  });\n}\n\nexport class WorkerScript {\n  constructor() {\n    worker.parentPort.onmessage = (event: MessageEvent<{startupTime: number, runtime: number}>): void => {\n      const { startupTime, runtime } = event.data;\n      this.analyzePerformance(startupTime, runtime);\n    };\n  }\n\n  private analyzePerformance(startupTime: number, runtime: number): void {\n    // Perform analysis and logging here\n    console.log(`Startup Time: ${startupTime}ms`);\n    console.log(`Runtime: ${runtime}s`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if the current process is 64-bit using the `is64Bit` method of `process`, then retrieves the thread priority using `getThreadPriority`, and finally constructs a URL (using URL API methods) to report these system characteristics to a monitoring service.",
    "input": "",
    "output": "import {worker, process, url} from '@kit.ArkTS';\n\nexport function reportSystemCharacteristics(monitoringServiceUrl: string): string {\n  const is64Bit: boolean = process.is64Bit();\n  const threadPriority: number = process.getThreadPriority();\n  \n  const urlObj = new url.URL(monitoringServiceUrl);\n  urlObj.searchParams.append('is64Bit', is64Bit.toString());\n  urlObj.searchParams.append('threadPriority', threadPriority.toString());\n  \n  return urlObj.toString();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addAll` method of `LightWeightSet` to merge two sets of employee IDs, then transfers the merged set to a `HashMap` using its `setAll` method to associate each ID with a default department value 'Unassigned'. Finally, use the `keys` method of `HashMap` to retrieve and return the list of all employee IDs.",
    "input": "",
    "output": "import {LightWeightSet, PostMessageOptions, HashMap} from '@kit.ArkTS';\n\nexport function mergeAndTransferEmployeeIds(set1: LightWeightSet<number>, set2: LightWeightSet<number>): Array<number> {\n  const mergedSet = new LightWeightSet<number>();\n  mergedSet.addAll(set1);\n  mergedSet.addAll(set2);\n\n  const employeeMap = new HashMap<number, string>();\n  employeeMap.setAll(mergedSet.toArray().map(id => [id, 'Unassigned']));\n\n  return Array.from(employeeMap.keys());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getValueAt` method of `LightWeightSet` to retrieve a specific product ID by index, then checks if this ID exists as a key in a `HashMap` using its `hasKey` method. If it exists, use the `get` method of `HashMap` to return the associated product details; otherwise, return 'Product not found'.",
    "input": "",
    "output": "import {LightWeightSet, PostMessageOptions, HashMap} from '@kit.ArkTS';\n\nexport function getProductDetails(lightWeightSet: LightWeightSet<number>, index: number, hashMap: HashMap<number, string>): string {\n  const productId = lightWeightSet.getValueAt(index);\n  if (productId === undefined) {\n    return 'Product not found';\n  }\n  if (hashMap.hasKey(productId)) {\n    return hashMap.get(productId) as string;\n  } else {\n    return 'Product not found';\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `entries` method of `HashMap` to iterate over key-value pairs of student IDs and their grades, then filters out students with failing grades (below 60) and stores their IDs in a `LightWeightSet` using its `add` method. Finally, use the `toArray` method of `LightWeightSet` to return the list of failing student IDs.",
    "input": "",
    "output": "import {LightWeightSet, PostMessageOptions, HashMap} from '@kit.ArkTS';\n\nexport function getFailingStudentIds(studentGrades: HashMap<number, number>): number[] {\n  const failingStudents = new LightWeightSet<number>();\n  \n  for (const [id, grade] of studentGrades.entries()) {\n    if (grade < 60) {\n      failingStudents.add(id);\n    }\n  }\n  \n  return failingStudents.toArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "",
    "input": "",
    "output": "",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `set` method of `HashMap` to store a collection of employee IDs (keys) and their corresponding salaries (values), then uses the `getKeyAt` and `getValueAt` methods of `PlainArray` to iterate over the entries and calculate the average salary. The result should be returned as a number.",
    "input": "",
    "output": "import {HashMap, worker, PlainArray} from '@kit.ArkTS';\n\nexport function calculateAverageSalary(employeeSalaries: HashMap<number, number>): number {\n  const plainArray = new PlainArray<number, number>();\n  const keys = employeeSalaries.keys();\n  \n  for (const key of keys) {\n    const value = employeeSalaries.get(key);\n    if (value !== undefined) {\n      plainArray.add(key, value);\n    }\n  }\n  \n  let totalSalary = 0;\n  const length = plainArray.length;\n  \n  for (let i = 0; i < length; i++) {\n    const salary = plainArray.getValueAt(i);\n    totalSalary += salary;\n  }\n  \n  return totalSalary / length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `keys` method of `HashMap` to extract all keys (as an array), then passes this array to the `add` method of `PlainArray` to store and manipulate the keys. Finally, use the `removeRangeFrom` method of `PlainArray` to filter out a specific range of keys and return the remaining keys as an array.",
    "input": "",
    "output": "import {HashMap, worker, PlainArray} from '@kit.ArkTS';\n\nexport function processKeys(hashMap: HashMap<number, unknown>, start: number, end: number): number[] {\n  const keysArray: number[] = hashMap.keys();\n  const plainArray: PlainArray<number, unknown> = new PlainArray();\n  \n  for (const key of keysArray) {\n    plainArray.add(key, null);\n  }\n  \n  plainArray.removeRangeFrom(start, end);\n  \n  const remainingKeys: number[] = [];\n  for (let i = 0; i < plainArray.length; i++) {\n    remainingKeys.push(plainArray.getKeyAt(i));\n  }\n  \n  return remainingKeys;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `entries` method of `HashMap` to retrieve key-value pairs, then uses the `forEach` method of `PlainArray` to process each pair and create a new `PlainArray` where each entry's value is doubled. The function should return the new `PlainArray`.",
    "input": "",
    "output": "import {HashMap, worker, PlainArray} from '@kit.ArkTS';\n\nexport function doubleHashMapValues(map: HashMap<number, number>): PlainArray<number> {\n  const entries = map.entries();\n  const result = new PlainArray<number>();\n  \n  entries.forEach((entry: [number, number]) => {\n    const [key, value] = entry;\n    result.add(key, value * 2);\n  });\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `HashMap` to retrieve all keys, then passes them to the `add` method of `LinkedList` to create a linked list of the keys. Finally, use the `convertToArray` method of `LinkedList` to return the keys as an array.",
    "input": "",
    "output": "import {HashMap, LinkedList, PostMessageOptions} from '@kit.ArkTS';\n\nexport function getKeysAsArray<K, V>(hashMap: HashMap<K, V>): K[] {\n  const keys = hashMap.keys();\n  const linkedList = new LinkedList<K>();\n  for (const key of keys) {\n    linkedList.add(key);\n  }\n  return linkedList.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `entries` method of `HashMap` to retrieve key-value pairs, then filters the pairs based on a condition. Pass the filtered pairs to the `setAll` method of another `HashMap` to create a new map. Finally, use the `transfer` property of `PostMessageOptions` to prepare the new map for message passing.",
    "input": "",
    "output": "import {HashMap, LinkedList, PostMessageOptions} from '@kit.ArkTS';\n\nexport function filterAndTransferMap(sourceMap: HashMap<string, number>, condition: (key: string, value: number) => boolean): PostMessageOptions {\n  const filteredEntries: [string, number][] = [];\n  \n  for (const [key, value] of sourceMap.entries()) {\n    if (condition(key, value)) {\n      filteredEntries.push([key, value]);\n    }\n  }\n  \n  const newMap = new HashMap<string, number>();\n  newMap.setAll(filteredEntries);\n  \n  const transferBuffer = new ArrayBuffer(1);\n  const postMessageOptions: PostMessageOptions = {\n    transfer: [transferBuffer]\n  };\n  \n  return postMessageOptions;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements, then stores them in a `HashMap` using the `set` method with keys 'first' and 'last'. Finally, use the `length` property of both `LinkedList` and `HashMap` to verify the data was transferred correctly.",
    "input": "",
    "output": "import {HashMap, LinkedList, PostMessageOptions} from '@kit.ArkTS';\n\nexport function transferLinkedListToHashMap(linkedList: LinkedList<number>): HashMap<string, number> {\n  const hashMap = new HashMap<string, number>();\n  const firstElement = linkedList.getFirst();\n  const lastElement = linkedList.getLast();\n  \n  hashMap.set('first', firstElement);\n  hashMap.set('last', lastElement);\n  \n  const linkedListLength = linkedList.length;\n  const hashMapLength = hashMap.length;\n  \n  if (linkedListLength >= 2 && hashMapLength === 2) {\n    return hashMap;\n  } else {\n    throw new Error('Data transfer verification failed');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to collect a sequence of event timestamps, then transfers these timestamps to a `TreeSet` (from @kit.ArkTS) using its `add` method. Finally, use the `getFirstValue` and `getLastValue` methods of `TreeSet` to determine the earliest and latest timestamps in the sequence.",
    "input": "",
    "output": "import {Event, TreeSet, Stack} from '@kit.ArkTS';\n\nexport function processEventTimestamps(events: Event[]): {earliest: number, latest: number} {\n  const stack = new Stack<number>();\n  const treeSet = new TreeSet<number>();\n\n  for (const event of events) {\n    stack.push(event.timeStamp);\n  }\n\n  while (!stack.isEmpty()) {\n    const timestamp = stack.pop();\n    if (timestamp !== undefined) {\n      treeSet.add(timestamp);\n    }\n  }\n\n  const earliest = treeSet.getFirstValue();\n  const latest = treeSet.getLastValue();\n\n  return {earliest, latest};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `TreeSet` (from @kit.ArkTS) to iterate over a set of values and push each value onto a `Stack` (from @kit.ArkTS) using its `push` method. Then, use the `pop` method of `Stack` to reverse the order of the values and store them back into the `TreeSet` using its `clear` and `add` methods.",
    "input": "",
    "output": "import {Event, TreeSet, Stack} from '@kit.ArkTS';\n\nexport function reverseTreeSetValues(treeSet: TreeSet<number>): void {\n  const stack = new Stack<number>();\n  \n  treeSet.forEach((value: number) => {\n    stack.push(value);\n  });\n  \n  treeSet.clear();\n  \n  while (!stack.isEmpty()) {\n    const value = stack.pop();\n    treeSet.add(value);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the top element of the stack and then uses the `getHigherValue` method of `TreeSet` (from @kit.ArkTS) to find the smallest value in the set that is greater than the peeked value. If such a value exists, push it onto the stack using the `push` method of `Stack`.",
    "input": "",
    "output": "import {Event, TreeSet, Stack} from '@kit.ArkTS';\n\nexport function pushHigherValue(stack: Stack<number>, treeSet: TreeSet<number>): void {\n  if (stack.isEmpty() || treeSet.isEmpty()) {\n    return;\n  }\n  const topValue = stack.peek();\n  const higherValue = treeSet.getHigherValue(topValue);\n  if (higherValue !== undefined) {\n    stack.push(higherValue);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a sequence of process IDs, then iterates over the queue using `Symbol.iterator` to pass each ID to the `kill` method of `process` to terminate all processes in the queue. Finally, use the `length` property of `Queue` to return the number of terminated processes.",
    "input": "",
    "output": "import {Queue, process} from '@kit.ArkTS';\n\nexport function terminateProcesses(pids: number[]): number {\n  const queue = new Queue<number>();\n  \n  for (const pid of pids) {\n    queue.add(pid);\n  }\n  \n  for (const pid of queue) {\n    process.kill(pid);\n  }\n  \n  return queue.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the current CPU time using `process.getPastCpuTime`, then uses the `forEach` method of `Queue` to log each item in the queue along with the CPU time. The function should also use `process.uptime` to measure the total execution time of this operation.",
    "input": "",
    "output": "import {Queue, process} from '@kit.ArkTS';\n\nexport function logQueueWithCpuTime(queue: Queue<number>): void {\n  const startTime: number = process.uptime();\n  const cpuTime: number = process.getPastCpuTime();\n  \n  queue.forEach((item: number) => {\n    console.log(`Item: ${item}, CPU Time: ${cpuTime}`);\n  });\n  \n  const endTime: number = process.uptime();\n  const executionTime: number = endTime - startTime;\n  console.log(`Total execution time: ${executionTime}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `process.getEnvironmentVar` to fetch an environment variable containing comma-separated values, splits these values into a list, and adds them to a `Queue` using its `add` method. Then, use the `getFirst` and `pop` methods of `Queue` to process and remove each item while logging the process ID using `process.getUidForName` for each item.",
    "input": "",
    "output": "import {Queue, process} from '@kit.ArkTS';\n\nexport function processEnvironmentVarQueue(envVarName: string): void {\n  const envVarValue = process.getEnvironmentVar(envVarName);\n  if (!envVarValue) {\n    return;\n  }\n\n  const values = envVarValue.split(',');\n  const queue = new Queue<string>();\n\n  for (const value of values) {\n    queue.add(value.trim());\n  }\n\n  while (queue.length > 0) {\n    const firstItem = queue.getFirst();\n    const processId = process.getUidForName(firstItem);\n    console.log(`Process ID for ${firstItem}: ${processId}`);\n    queue.pop();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a new worker thread using `worker.ThreadWorker` (from @kit.ArkTS) and assigns a name to it using the `name` property of `WorkerGlobalScope`. Then, use the `self` property of `WorkerGlobalScope` to log the worker's scope information to the console.",
    "input": "",
    "output": "import {WorkerGlobalScope, worker} from '@kit.ArkTS';\n\nexport function createWorkerThread(): void {\n  const workerThread = new worker.ThreadWorker('workers/worker.ts');\n  workerThread.postMessage('init');\n}\n\nexport class WorkerScript {\n  constructor() {\n    self.name = 'MyWorkerThread';\n    console.log('Worker scope info:', self);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a worker thread using `worker.ThreadWorker` (from @kit.ArkTS) and sets up an error handler using the `onerror` property of `WorkerGlobalScope`. The error handler should log any errors encountered in the worker thread to the console.",
    "input": "",
    "output": "import {WorkerGlobalScope, worker} from '@kit.ArkTS';\n\nexport function initializeWorkerThread(scriptURL: string): worker.ThreadWorker {\n  const workerInstance = new worker.ThreadWorker(scriptURL);\n  \n  workerInstance.onerror = (error: ErrorEvent) => {\n    console.error(`Error in worker thread: ${error.message}`);\n  };\n  \n  return workerInstance;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a program where a worker thread is created using `worker.ThreadWorker` (from @kit.ArkTS), and the worker's `name` property (from `WorkerGlobalScope`) is dynamically updated based on user input. The program should then verify the updated name by accessing it through the `self` property of `WorkerGlobalScope`.",
    "input": "",
    "output": "import {WorkerGlobalScope, worker} from '@kit.ArkTS';\n\nexport function createWorkerWithDynamicName(workerScriptURL: string, initialName: string, newName: string): void {\n  const workerInstance: worker.ThreadWorker = new worker.ThreadWorker(workerScriptURL);\n  \n  workerInstance.postMessage({\n    type: 'updateName',\n    name: initialName\n  });\n  \n  workerInstance.onmessage = (event: MessageEvent): void => {\n    if (event.data.type === 'nameUpdated') {\n      console.log(`Worker name updated to: ${event.data.name}`);\n      workerInstance.postMessage({\n        type: 'verifyName',\n        expectedName: newName\n      });\n    } else if (event.data.type === 'nameVerified') {\n      console.log(`Worker name verified: ${event.data.success}`);\n      workerInstance.terminate();\n    }\n  };\n}\n\nexport function workerScript(): void {\n  const self: WorkerGlobalScope = worker.workerGlobalScope;\n  \n  self.onmessage = (event: MessageEvent): void => {\n    if (event.data.type === 'updateName') {\n      self.name = event.data.name;\n      self.postMessage({\n        type: 'nameUpdated',\n        name: self.name\n      });\n    } else if (event.data.type === 'verifyName') {\n      const success: boolean = self.name === event.data.expectedName;\n      self.postMessage({\n        type: 'nameVerified',\n        success: success\n      });\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "",
    "input": "",
    "output": "",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a series of error messages, then uses the `getFirst` method to retrieve the oldest error message and passes it to the `onerror` property of `GlobalScope` to handle the error globally.",
    "input": "",
    "output": "import {Queue, GlobalScope} from '@kit.ArkTS';\n\nexport function handleErrorMessages(errorMessages: string[]): void {\n  const queue = new Queue<string>();\n  \n  for (const message of errorMessages) {\n    queue.add(message);\n  }\n  \n  if (queue.length > 0) {\n    const oldestError = queue.getFirst();\n    if (oldestError !== undefined) {\n      GlobalScope.onerror = (event: ErrorEvent) => {\n        console.error(`Global error handled: ${oldestError}`);\n      };\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `Queue` using its `constructor`, adds elements using the `add` method, and then iterates over the queue using `Symbol.iterator` to log each element's value to the `name` property of `GlobalScope` for debugging purposes.",
    "input": "",
    "output": "import {Queue, GlobalScope} from '@kit.ArkTS';\n\nexport function initializeAndLogQueue(): void {\n  const queue = new Queue<number>();\n  queue.add(1);\n  queue.add(2);\n  queue.add(3);\n\n  for (const item of queue[Symbol.iterator]()) {\n    GlobalScope.name = item.toString();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Queue` to process each item in the queue, checks if the `length` property of the queue exceeds a threshold, and if so, triggers a global error by assigning an error message to the `onerror` property of `GlobalScope`.",
    "input": "",
    "output": "import {Queue, GlobalScope} from '@kit.ArkTS';\n\nexport function processQueue(queue: Queue<number>, threshold: number): void {\n  queue.forEach((item: number) => {\n    // Process each item here\n    console.log(`Processing item: ${item}`);\n  });\n\n  if (queue.length > threshold) {\n    if (GlobalScope.onerror !== undefined) {\n      GlobalScope.onerror = 'Queue length exceeds threshold';\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `HashSet` to collect a series of error messages from an `ErrorEvent` object (accessing its `message` property), then checks if the `HashSet` is empty using the `isEmpty` property, and finally iterates over the collected messages using the `Symbol.iterator` method to log them.",
    "input": "",
    "output": "import {HashSet, ErrorEvent} from '@kit.ArkTS';\n\nexport function collectAndLogErrorMessages(errorEvents: ErrorEvent[]): void {\n  const errorSet = new HashSet<string>();\n  \n  for (const event of errorEvents) {\n    errorSet.add(event.message);\n  }\n  \n  if (!errorSet.isEmpty) {\n    for (const message of errorSet) {\n      console.log(message);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that processes multiple `ErrorEvent` objects by extracting their `error` and `lineno` properties, stores them as tuples in a `HashSet` using the `add` method, and then uses the `forEach` method of `HashSet` to print each error and line number pair.",
    "input": "",
    "output": "import {HashSet, ErrorEvent} from '@kit.ArkTS';\n\nexport function processErrorEvents(errorEvents: ErrorEvent[]): void {\n  const errorSet = new HashSet<[string, number]>();\n  \n  for (const event of errorEvents) {\n    errorSet.add([event.error, event.lineno]);\n  }\n  \n  errorSet.forEach((value: [string, number]) => {\n    console.log(`Error: ${value[0]}, Line: ${value[1]}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `has` method of `HashSet` to check if a specific error message (from the `message` property of an `ErrorEvent` object) exists in the set. If not, add it using the `add` method, and then use the `length` property of `HashSet` to return the total count of unique error messages.",
    "input": "",
    "output": "import {HashSet, ErrorEvent} from '@kit.ArkTS';\n\nexport function checkAndAddError(errorSet: HashSet<string>, errorEvent: ErrorEvent): number {\n  const message = errorEvent.message;\n  if (!errorSet.has(message)) {\n    errorSet.add(message);\n  }\n  return errorSet.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `HashSet` to store a collection of unique event names, then iterates over the set using `Symbol.iterator` and dispatches each event name using the `dispatchEvent` method of `EventTarget` to simulate event triggering.",
    "input": "",
    "output": "import {HashSet, EventTarget} from '@kit.ArkTS';\n\nexport function triggerEvents(eventNames: string[]): void {\n  const eventSet = new HashSet<string>();\n  const eventTarget = new EventTarget();\n\n  for (const name of eventNames) {\n    eventSet.add(name);\n  }\n\n  const iterator = eventSet[Symbol.iterator]();\n  let result = iterator.next();\n  while (!result.done) {\n    const eventName = result.value;\n    eventTarget.dispatchEvent(eventName);\n    result = iterator.next();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `has` method of `HashSet` to check if a specific event listener is registered, and if not, adds it using the `addEventListener` method of `EventTarget`. Then, use the `remove` method of `HashSet` to remove the event name from the set and the `removeEventListener` method of `EventTarget` to clean up the listener.",
    "input": "",
    "output": "import {HashSet, EventTarget} from '@kit.ArkTS';\n\nexport function manageEventListener(eventTarget: EventTarget, eventName: string, listener: EventListener, eventSet: HashSet<string>): void {\n  if (!eventSet.has(eventName)) {\n    eventTarget.addEventListener(eventName, listener);\n    eventSet.add(eventName);\n  }\n}\n\nexport function cleanupEventListener(eventTarget: EventTarget, eventName: string, listener: EventListener, eventSet: HashSet<string>): void {\n  if (eventSet.has(eventName)) {\n    eventTarget.removeEventListener(eventName, listener);\n    eventSet.remove(eventName);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `HashSet` to iterate over a set of event names and for each event, use the `removeAllListener` method of `EventTarget` to remove all associated listeners. Then, clear the set using the `clear` method of `HashSet` to reset the event tracking system.",
    "input": "",
    "output": "import {HashSet, EventTarget} from '@kit.ArkTS';\n\nexport function resetEventTracking(eventNames: HashSet<string>, eventTarget: EventTarget): void {\n  eventNames.forEach((eventName: string) => {\n    eventTarget.removeAllListener(eventName);\n  });\n  eventNames.clear();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `parse` method of `json` to convert a JSON string into an object, then uses the `add` and `get` methods of `Vector` to store and retrieve specific values from the parsed object.",
    "input": "",
    "output": "import {json, Vector} from '@kit.ArkTS';\n\nexport function parseAndStoreJSON(jsonString: string, keys: string[]): Vector<string> {\n  const parsedObject = json.parse(jsonString);\n  const vector = new Vector<string>();\n  \n  for (const key of keys) {\n    if (parsedObject[key] !== undefined) {\n      vector.add(parsedObject[key]);\n    }\n  }\n  \n  return vector;\n}\n\nexport function getValuesFromVector(vector: Vector<string>, indices: number[]): string[] {\n  const values: string[] = [];\n  \n  for (const index of indices) {\n    if (index >= 0 && index < vector.length) {\n      values.push(vector.get(index));\n    }\n  }\n  \n  return values;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `stringify` method of `json` to convert a `Vector` object into a JSON string, then uses the `has` method of `json` to check if a specific key exists in the resulting JSON string before performing further operations.",
    "input": "",
    "output": "import {json, Vector} from '@kit.ArkTS';\n\nexport function checkKeyInVectorJSON(vector: Vector<number>, key: string): boolean {\n  const jsonString: string = json.stringify(vector);\n  return json.has(jsonString, key);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Vector` to iterate over its elements, applies a transformation using the `Transformer` type alias from `json` to each element, and then uses the `replaceAllElements` method of `Vector` to update the vector with the transformed values.",
    "input": "",
    "output": "import {json, Vector} from '@kit.ArkTS';\n\nexport function transformVectorElements<T>(vector: Vector<T>, transformer: json.Transformer<T>): void {\n  const transformedElements: T[] = [];\n  vector.forEach((element: T) => {\n    const transformedElement = transformer(element);\n    transformedElements.push(transformedElement);\n  });\n  vector.replaceAllElements(transformedElements);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then transfers these numbers to a `PlainArray` (from @kit.ArkTS) using its `add` method. Finally, use the `getValueAt` method of `PlainArray` to retrieve and print the values in reverse order.",
    "input": "",
    "output": "import {Stack, PlainArray} from '@kit.ArkTS';\n\nexport function transferStackToPlainArrayAndPrintReverse(numbers: number[]): void {\n  const stack = new Stack<number>();\n  numbers.forEach((num) => {\n    stack.push(num);\n  });\n\n  const plainArray = new PlainArray<number>();\n  let index = 0;\n  while (!stack.isEmpty()) {\n    const value = stack.pop();\n    plainArray.add(index, value);\n    index++;\n  }\n\n  for (let i = plainArray.length - 1; i >= 0; i--) {\n    console.log(plainArray.getValueAt(i));\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if a `Stack` (from @kit.ArkTS) is empty using the `isEmpty` method, and if not, pops all elements using `pop` and stores them in a `PlainArray` (from @kit.ArkTS) using the `add` method. Then, use the `forEach` method of `PlainArray` to log each element along with its index obtained from `getIndexOfValue`.",
    "input": "",
    "output": "import {Stack, PlainArray} from '@kit.ArkTS';\n\nexport function processStack(stack: Stack<number>): PlainArray<number> {\n  const plainArray = new PlainArray<number>();\n  if (!stack.isEmpty()) {\n    while (!stack.isEmpty()) {\n      const value = stack.pop();\n      plainArray.add(plainArray.length, value);\n    }\n  }\n  plainArray.forEach((value: number, index: number) => {\n    const valueIndex = plainArray.getIndexOfValue(value);\n    console.log(`Index: ${index}, Value: ${value}, Value Index: ${valueIndex}`);\n  });\n  return plainArray;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the top element, and if it matches a given key, uses the `get` method of `PlainArray` (from @kit.ArkTS) to retrieve the corresponding value. If the value exists, push it onto the `Stack` using the `push` method.",
    "input": "",
    "output": "import {Stack, PlainArray} from '@kit.ArkTS';\n\nexport function checkAndPush(stack: Stack<number>, plainArray: PlainArray<number, number>, key: number): void {\n  if (stack.isEmpty()) {\n    return;\n  }\n  const topElement = stack.peek();\n  if (topElement === key) {\n    const value = plainArray.get(key);\n    if (value !== undefined) {\n      stack.push(value);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `buffer.from` method to create a Buffer from a given string with UTF-8 encoding, then uses the `xml.EventType` enum to check if the parsed XML event type matches a specific type (e.g., START_ELEMENT), and finally converts the Buffer back to a string using the specified encoding.",
    "input": "",
    "output": "import {buffer, xml} from '@kit.ArkTS';\n\nexport function checkXmlEventType(inputString: string, encoding: buffer.BufferEncoding, eventType: xml.EventType): boolean {\n  const buf = buffer.from(inputString, encoding);\n  const parser = new xml.XmlPullParser(buf.toString(encoding));\n  const event = parser.next();\n  return event === eventType;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `buffer.concat` to merge multiple Buffers containing XML fragments, then checks if the resulting Buffer is valid XML by attempting to parse it with the XML API's event parsing mechanism, using `xml.EventType` to validate the structure (e.g., ensuring it starts with a START_DOCUMENT event).",
    "input": "",
    "output": "import {buffer, xml} from '@kit.ArkTS';\n\nexport function mergeAndValidateXmlBuffers(buffers: buffer.Buffer[]): boolean {\n  try {\n    const mergedBuffer = buffer.concat(buffers);\n    const xmlParser = new xml.XmlPullParser(mergedBuffer.toString());\n    \n    let eventType = xmlParser.getEventType();\n    if (eventType !== xml.EventType.START_DOCUMENT) {\n      return false;\n    }\n    \n    let hasRootElement = false;\n    while (eventType !== xml.EventType.END_DOCUMENT) {\n      eventType = xmlParser.next();\n      \n      if (eventType === xml.EventType.START_TAG) {\n        if (!hasRootElement) {\n          hasRootElement = true;\n        }\n      }\n    }\n    \n    return hasRootElement;\n  } catch (error) {\n    return false;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that reads a file into a Buffer using `buffer.alloc` or `buffer.from`, then processes the Buffer to extract specific XML tags by leveraging the XML API's event parsing (using `xml.EventType` to identify tags) and writes the extracted data into a new Buffer using `buffer.concat` or `buffer.allocUninitialized`.",
    "input": "",
    "output": "import {buffer, xml} from '@kit.ArkTS';\n\nexport function extractXmlTags(fileBuffer: buffer.Buffer, tagName: string): buffer.Buffer {\n  const extractedChunks: buffer.Buffer[] = [];\n  const parser = new xml.XmlPullParser(fileBuffer.toString());\n  let currentTag = '';\n  let isTargetTag = false;\n  let tagContent = '';\n\n  while (parser.next() !== xml.EventType.END_DOCUMENT) {\n    const eventType = parser.getEventType();\n\n    if (eventType === xml.EventType.START_TAG) {\n      currentTag = parser.getName();\n      if (currentTag === tagName) {\n        isTargetTag = true;\n      }\n    } else if (eventType === xml.EventType.TEXT && isTargetTag) {\n      tagContent += parser.getText();\n    } else if (eventType === xml.EventType.END_TAG) {\n      if (parser.getName() === tagName) {\n        if (tagContent) {\n          extractedChunks.push(buffer.from(tagContent));\n          tagContent = '';\n        }\n        isTargetTag = false;\n      }\n    }\n  }\n\n  return extractedChunks.length > 0 ? buffer.concat(extractedChunks) : buffer.alloc(0);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a list of 5 random UUIDs, then pushes them into a `Stack` (using the `push` method) and finally iterates over the stack (using `[Symbol.iterator]`) to print each UUID in reverse order.",
    "input": "",
    "output": "import {util, Stack} from '@kit.ArkTS';\n\nexport function generateAndPrintUUIDs(): void {\n  const stack = new Stack<string>();\n  \n  for (let i = 0; i < 5; i++) {\n    const uuid = util.generateRandomUUID();\n    stack.push(uuid);\n  }\n  \n  const iterator = stack[Symbol.iterator]();\n  let result = iterator.next();\n  while (!result.done) {\n    console.log(result.value);\n    result = iterator.next();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `peek` method of `Stack` to check the top element, then passes this element to the `parseUUID` method of `util` to validate if it is a properly formatted UUID. If valid, print the UUID using `printf` from `util`; otherwise, pop it from the stack using the `pop` method.",
    "input": "",
    "output": "import {util, Stack} from '@kit.ArkTS';\n\nexport function validateAndPrintUUID(stack: Stack<string>): void {\n  if (stack.isEmpty()) {\n    return;\n  }\n  \n  const topElement = stack.peek();\n  if (util.parseUUID(topElement)) {\n    util.printf(topElement);\n  } else {\n    stack.pop();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Stack` to process each element in the stack, applies the `getHash` method of `util` to compute a hash for each element, and then stores the results in an array. Finally, use the `format` method of `util` to display the hashes in a formatted string.",
    "input": "",
    "output": "import {util, Stack} from '@kit.ArkTS';\n\nexport function processStackAndFormatHashes(stack: Stack<string>): string {\n  const hashArray: string[] = [];\n  \n  stack.forEach((element: string) => {\n    const hash = util.getHash(element);\n    hashArray.push(hash);\n  });\n  \n  return util.format('Hashes: %s', hashArray.join(', '));\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a unique identifier, then stores this UUID as a key in a `TreeMap` using the `set` method, along with a randomly generated value. Finally, use the `getFirstKey` method of `TreeMap` to retrieve and return the first key in the sorted map.",
    "input": "",
    "output": "import {util, TreeMap} from '@kit.ArkTS';\n\nexport function generateAndRetrieveFirstKey(): string {\n  const uuid: string = util.generateRandomUUID();\n  const treeMap: TreeMap<string, number> = new TreeMap();\n  const randomValue: number = Math.random();\n  treeMap.set(uuid, randomValue);\n  return treeMap.getFirstKey();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getHash` method of `util` to compute the hash of a given string, then checks if the hash exists as a value in a `TreeMap` using the `hasValue` method. If the hash is found, use the `get` method of `TreeMap` to retrieve and return the corresponding key; otherwise, return the hash as a string.",
    "input": "",
    "output": "import {util, TreeMap} from '@kit.ArkTS';\n\nexport function findKeyByHash(input: string, map: TreeMap<string, string>): string {\n  const hash = util.getHash(input);\n  if (map.hasValue(hash)) {\n    const keys = map.keys();\n    for (const key of keys) {\n      const value = map.get(key);\n      if (value === hash) {\n        return key;\n      }\n    }\n  }\n  return hash;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `TreeMap` to retrieve all keys, then formats these keys into a comma-separated string using the `format` method of `util`. Finally, use the `printf` method of `util` to print the formatted string to the console.",
    "input": "",
    "output": "import {util, TreeMap} from '@kit.ArkTS';\n\nexport function formatAndPrintTreeMapKeys(treeMap: TreeMap<number, string>): void {\n  const keys = treeMap.keys();\n  const formattedString = util.format('%s', Array.from(keys).join(','));\n  util.printf('%s', formattedString);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `stream` to read a JSON file as a string, then parses it into an object using `json.parse`, and finally checks if a specific key exists in the parsed object using `json.has`.",
    "input": "",
    "output": "import {stream, json} from '@kit.ArkTS';\n\nexport function checkKeyInJsonFile(filePath: string, key: string): boolean {\n  try {\n    const readableStream = stream.createReadableStream(filePath);\n    let jsonString = '';\n    readableStream.on('data', (chunk: string) => {\n      jsonString += chunk;\n    });\n\n    return new Promise<boolean>((resolve, reject) => {\n      readableStream.on('end', () => {\n        try {\n          const parsedObject = json.parse(jsonString);\n          resolve(json.has(parsedObject, key));\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      readableStream.on('error', (error: Error) => {\n        reject(error);\n      });\n    });\n  } catch (error) {\n    throw error;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes an object, converts it to a JSON string using `json.stringify`, writes the string to a file using `stream`, and then validates the written content by reading it back with `stream` and parsing it with `json.parse`.",
    "input": "",
    "output": "import {stream, json} from '@kit.ArkTS';\n\nexport function writeAndValidateJson(obj: object, filePath: string): Promise<boolean> {\n  return new Promise((resolve, reject) => {\n    try {\n      const jsonString = json.stringify(obj);\n      const writableStream = stream.createWritableStream(filePath);\n      writableStream.write(jsonString, (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        writableStream.close((closeErr) => {\n          if (closeErr) {\n            reject(closeErr);\n            return;\n          }\n          const readableStream = stream.createReadableStream(filePath);\n          let data = '';\n          readableStream.on('data', (chunk) => {\n            data += chunk;\n          });\n          readableStream.on('end', () => {\n            try {\n              const parsedObj = json.parse(data);\n              resolve(JSON.stringify(parsedObj) === jsonString);\n            } catch (parseErr) {\n              reject(parseErr);\n            }\n          });\n          readableStream.on('error', (readErr) => {\n            reject(readErr);\n          });\n        });\n      });\n    } catch (err) {\n      reject(err);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that reads a JSON file using `stream`, removes a specified key from the parsed object using `json.remove`, converts the modified object back to a JSON string using `json.stringify`, and writes the updated string back to the file using `stream`.",
    "input": "",
    "output": "import {stream, json} from '@kit.ArkTS';\n\nexport function removeKeyFromJsonFile(filePath: string, keyToRemove: string): void {\n  const readableStream = new stream.Readable();\n  const writableStream = new stream.Writable();\n\n  let fileContent = '';\n  readableStream.on('data', (chunk: string) => {\n    fileContent += chunk;\n  });\n\n  readableStream.on('end', () => {\n    try {\n      const parsedJson = json.parse(fileContent);\n      json.remove(parsedJson, keyToRemove);\n      const updatedJsonString = json.stringify(parsedJson);\n\n      writableStream.write(updatedJsonString, () => {\n        writableStream.end();\n      });\n    } catch (error) {\n      console.error(`Error processing JSON: ${error}`);\n    }\n  });\n\n  readableStream.on('error', (error: Error) => {\n    console.error(`Error reading file: ${error}`);\n  });\n\n  writableStream.on('error', (error: Error) => {\n    console.error(`Error writing file: ${error}`);\n  });\n\n  readableStream.read(filePath);\n  writableStream.writeTo(filePath);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a DedicatedWorker and sets up an `onmessage` handler in the worker's global scope to process incoming messages. If an error occurs during message processing, use the `ErrorEvent` properties (`message`, `filename`, `lineno`, `colno`, and `error`) to log detailed error information and then call the `close` method of `DedicatedWorkerGlobalScope` to terminate the worker.",
    "input": "",
    "output": "import {ErrorEvent, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createWorker(): void {\n  const worker = new Worker('worker.ts');\n  worker.onmessage = (event: MessageEvent) => {\n    try {\n      // Process the incoming message\n      console.log('Message received in worker:', event.data);\n    } catch (error) {\n      const errorEvent = new ErrorEvent('error', {\n        message: error.message,\n        filename: 'worker.ts',\n        lineno: error.lineNumber,\n        colno: error.columnNumber,\n        error: error\n      });\n      \n      console.error('Error in worker:', errorEvent.message);\n      console.error('Filename:', errorEvent.filename);\n      console.error('Line number:', errorEvent.lineno);\n      console.error('Column number:', errorEvent.colno);\n      console.error('Error object:', errorEvent.error);\n      \n      // Terminate the worker\n      worker.terminate();\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a worker communication system where the main thread posts a message to a DedicatedWorker. Inside the worker, use the `postMessage` method of `DedicatedWorkerGlobalScope` to send a response back to the main thread. If an error occurs during message handling, construct an `ErrorEvent` object with relevant error details (using `message`, `filename`, `lineno`, and `colno`) and pass it back to the main thread via `postMessage`.",
    "input": "",
    "output": "import {ErrorEvent, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerCommunication(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent) => {\n    try {\n      // Process the message from the main thread\n      const processedData = processMessage(event.data);\n      // Send the response back to the main thread\n      worker.postMessage(processedData);\n    } catch (error) {\n      // Construct an ErrorEvent with relevant error details\n      const errorEvent = new ErrorEvent(\n        'error',\n        {\n          message: error.message,\n          filename: 'worker.js',\n          lineno: error.lineNumber || 0,\n          colno: error.columnNumber || 0,\n          error: error\n        }\n      );\n      // Send the error event back to the main thread\n      worker.postMessage(errorEvent);\n    }\n  };\n}\n\nfunction processMessage(data: unknown): unknown {\n  // Example processing logic\n  if (typeof data === 'string') {\n    return `Processed: ${data}`;\n  }\n  throw new Error('Invalid message type');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a DedicatedWorker and sets up an `onmessageerror` handler in the worker's global scope. When a message error occurs, use the `ErrorEvent` properties (`error` and `message`) to identify the issue, then call the `close` method of `DedicatedWorkerGlobalScope` to shut down the worker gracefully, ensuring no further messages are processed.",
    "input": "",
    "output": "import {ErrorEvent, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function initializeWorker(): void {\n  const workerGlobalScope: DedicatedWorkerGlobalScope = self as DedicatedWorkerGlobalScope;\n\n  workerGlobalScope.onmessageerror = (event: ErrorEvent) => {\n    console.error(`Message error occurred: ${event.message}`);\n    console.error(`Error details: ${event.error}`);\n    workerGlobalScope.close();\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` method of `Deque` to collect a sequence of numbers from a worker thread, then uses the `getFirst` and `popFirst` methods of `Deque` to process and remove each number from the front of the deque, passing each processed number back to the worker thread for further computation.",
    "input": "",
    "output": "import {Deque, worker} from '@kit.ArkTS';\n\nexport function processDequeWithWorker(workerPort: worker.ThreadWorkerGlobalScope): void {\n  const deque = new Deque<number>();\n\n  workerPort.onmessage = (event: MessageEvent<number>) => {\n    deque.insertFront(event.data);\n  };\n\n  function processDeque() {\n    if (deque.length > 0) {\n      const firstElement = deque.getFirst();\n      deque.popFirst();\n      workerPort.postMessage(firstElement);\n    }\n    setTimeout(processDeque, 0);\n  }\n\n  processDeque();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `forEach` method of `Deque` to iterate over its elements and send each element to a worker thread for parallel processing. The worker thread should return processed results, which are then collected and inserted back into the deque using the `insertEnd` method.",
    "input": "",
    "output": "import {Deque, worker} from '@kit.ArkTS';\n\nexport function processDequeWithWorkers(inputDeque: Deque<number>, workerScript: string): Deque<number> {\n  const resultDeque = new Deque<number>();\n  const workerList: worker.ThreadWorker[] = [];\n\n  inputDeque.forEach((element: number) => {\n    const w = new worker.ThreadWorker(workerScript);\n    workerList.push(w);\n\n    w.postMessage(element);\n\n    w.onmessage = (msg: worker.MessageEvents<number>) => {\n      const processedResult = msg.data;\n      resultDeque.insertEnd(processedResult);\n      w.terminate();\n    };\n  });\n\n  return resultDeque;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a worker thread generates a list of tasks, which are then inserted into a `Deque` using the `insertEnd` method. The main thread should use the `popLast` method to retrieve and execute tasks from the deque, and the worker thread should be notified of task completion using a callback mechanism.",
    "input": "",
    "output": "import {Deque, worker} from '@kit.ArkTS';\n\nexport class Task {\n  constructor(public id: number, public data: string) {}\n}\n\nexport class TaskManager {\n  private deque: Deque<Task> = new Deque<Task>();\n  private workerThread: worker.ThreadWorker;\n\n  constructor() {\n    this.workerThread = new worker.ThreadWorker('entry/ets/workers/TaskWorker.js');\n    this.setupWorkerListeners();\n  }\n\n  private setupWorkerListeners(): void {\n    this.workerThread.onmessage = (message: worker.MessageEvents): void => {\n      if (message.data.type === 'newTask') {\n        const task = new Task(message.data.id, message.data.data);\n        this.deque.insertEnd(task);\n      }\n    };\n  }\n\n  public executeTasks(): void {\n    while (this.deque.length > 0) {\n      const task = this.deque.popLast();\n      if (task) {\n        console.log(`Executing task ${task.id}: ${task.data}`);\n        this.workerThread.postMessage({\n          type: 'taskCompleted',\n          id: task.id\n        });\n      }\n    }\n  }\n\n  public terminate(): void {\n    this.workerThread.terminate();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a unique identifier, then stores this UUID as a key in a `TreeMap` along with a corresponding value using the `set` method. Finally, use the `getFirstKey` method of `TreeMap` to retrieve and return the first UUID key added to the map.",
    "input": "",
    "output": "import {util, TreeMap} from '@kit.ArkTS';\n\nexport function storeAndRetrieveFirstUUID(): string {\n  const uuid = util.generateRandomUUID();\n  const treeMap = new TreeMap<string, string>();\n  treeMap.set(uuid, 'value');\n  return treeMap.getFirstKey();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getHash` method of `util` to compute the hash of a given string, then stores this hash as a value in a `TreeMap` with a user-provided key using the `set` method. Use the `hasValue` method of `TreeMap` to check if the computed hash already exists in the map and return a boolean indicating the result.",
    "input": "",
    "output": "import {util, TreeMap} from '@kit.ArkTS';\n\nexport function storeAndCheckHash(key: string, value: string, map: TreeMap<string, string>): boolean {\n  const hash = util.getHash(value);\n  const hasValue = map.hasValue(hash);\n  if (!hasValue) {\n    map.set(key, hash);\n  }\n  return hasValue;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `TreeMap` to iterate over all key-value pairs, where each value is a string. For each string value, use the `format` method of `util` to apply a predefined template (e.g., 'Item: %s') and collect the formatted strings into an array. Return the array of formatted strings.",
    "input": "",
    "output": "import {util, TreeMap} from '@kit.ArkTS';\n\nexport function formatTreeMapValues(treeMap: TreeMap<string, string>, template: string): string[] {\n  const formattedStrings: string[] = [];\n  treeMap.forEach((value: string, key: string) => {\n    const formattedString = util.format(template, value);\n    formattedStrings.push(formattedString);\n  });\n  return formattedStrings;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LightWeightSet` to store a collection of `MessageEvent` objects, then iterates over the set using the `Symbol.iterator` method to extract the `data` property from each `MessageEvent` and stores the results in an array using the `toArray` method of `LightWeightSet`.",
    "input": "",
    "output": "import {MessageEvent, LightWeightSet} from '@kit.ArkTS';\n\nexport function processMessageEvents(events: MessageEvent<string>[]): string[] {\n  const set = new LightWeightSet<MessageEvent<string>>();\n  \n  events.forEach(event => {\n    set.add(event);\n  });\n  \n  const dataArray: string[] = [];\n  for (const event of set) {\n    dataArray.push(event.data);\n  }\n  \n  return set.toArray().map(event => event.data);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks if a `LightWeightSet` contains all the `data` values from an array of `MessageEvent` objects. Use the `hasAll` method of `LightWeightSet` to verify the presence of each value, after extracting the `data` property from each `MessageEvent` using iteration.",
    "input": "",
    "output": "import {MessageEvent, LightWeightSet} from '@kit.ArkTS';\n\nexport function checkAllMessageEventsInSet(messageEvents: MessageEvent<string>[], set: LightWeightSet<string>): boolean {\n  const dataValues: string[] = [];\n  for (const event of messageEvents) {\n    dataValues.push(event.data);\n  }\n  return set.hasAll(dataValues);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that filters a `LightWeightSet` of `MessageEvent` objects by a specific condition on their `data` properties. Use the `getValueAt` method of `LightWeightSet` to access each `MessageEvent`, check the `data` property, and then use the `removeAt` method to remove elements that do not meet the condition.",
    "input": "",
    "output": "import {MessageEvent, LightWeightSet} from '@kit.ArkTS';\n\nexport function filterMessageEventsByData<T>(set: LightWeightSet<MessageEvent<T>>, condition: (data: T) => boolean): void {\n  for (let i = set.length - 1; i >= 0; i--) {\n    const event = set.getValueAt(i);\n    if (!condition(event.data)) {\n      set.removeAt(i);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that listens for a `MessageEvent` using its `data` property to receive a message, then checks if the `name` property of `GlobalScope` matches the received message. If they match, log a success message; otherwise, log an error using the `onerror` property of `GlobalScope`.",
    "input": "",
    "output": "import {MessageEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function listenForMessageEvent(event: MessageEvent<string>): void {\n  const receivedMessage = event.data;\n  if (GlobalScope.name === receivedMessage) {\n    console.log('Success: Names match');\n  } else {\n    GlobalScope.onerror = (error: ErrorEvent) => {\n      console.error('Error:', error.message);\n    };\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `self` property of `GlobalScope` to access the global context, then sends a message via `MessageEvent` with its `data` property set to the `name` property of `GlobalScope`. Ensure the message is handled by an event listener that validates the `data` property of the received `MessageEvent`.",
    "input": "",
    "output": "import {MessageEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function sendGlobalScopeName(): void {\n  const globalScope: GlobalScope = GlobalScope.self;\n  const messageEvent: MessageEvent<string> = new MessageEvent('message', {\n    data: globalScope.name\n  });\n  globalScope.dispatchEvent(messageEvent);\n}\n\nexport function setupMessageListener(): void {\n  const globalScope: GlobalScope = GlobalScope.self;\n  globalScope.addEventListener('message', (event: MessageEvent<string>) => {\n    if (event.data === globalScope.name) {\n      console.log('Message validated successfully');\n    } else {\n      console.log('Message validation failed');\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that sets up an error handler using the `onerror` property of `GlobalScope`. When an error occurs, the handler should create a `MessageEvent` with its `data` property containing the error details and dispatch it to the global scope using the `self` property of `GlobalScope`.",
    "input": "",
    "output": "import {MessageEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function setupErrorHandler(): void {\n  GlobalScope.onerror = (message: string, source: string, lineno: number, colno: number, error: Error) => {\n    const errorDetails = {\n      message,\n      source,\n      lineno,\n      colno,\n      error\n    };\n    const event = new MessageEvent('error', {\n      data: errorDetails\n    });\n    GlobalScope.self.dispatchEvent(event);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a list of 5 random UUIDs, then stores them in a `Vector` using its `add` method. Finally, use the `sort` method of `Vector` to arrange the UUIDs in alphabetical order and return the sorted list.",
    "input": "",
    "output": "import {util, Vector} from '@kit.ArkTS';\n\nexport function generateAndSortUUIDs(): Vector<string> {\n  const uuidVector = new Vector<string>();\n  for (let i = 0; i < 5; i++) {\n    const uuid = util.generateRandomUUID();\n    uuidVector.add(uuid);\n  }\n  uuidVector.sort();\n  return uuidVector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getHash` method of `util` to compute the hash of a given string, then stores the hash value in a `Vector` using its `insert` method at a specified index. Use the `convertToArray` method of `Vector` to return the resulting array of hash values.",
    "input": "",
    "output": "import {util, Vector} from '@kit.ArkTS';\n\nexport function computeAndStoreHash(inputString: string, index: number): Array<string> {\n  const hashValue: string = util.getHash(inputString);\n  const vector: Vector<string> = new Vector();\n  vector.insert(index, hashValue);\n  return vector.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `Vector` to iterate over its elements and apply the `printf` method of `util` to print each element in a formatted string. The function should return the concatenated result of all formatted strings.",
    "input": "",
    "output": "import {util, Vector} from '@kit.ArkTS';\n\nexport function printAndConcatenate(vector: Vector<string>): string {\n  let result = '';\n  vector.forEach((element: string) => {\n    const formattedString = util.printf('%s', element);\n    result += formattedString;\n  });\n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getEnvironmentVar` method of `process` to retrieve a list of environment variables, then stores them in an `ArrayList<string>` using the `add` method. Finally, use the `sort` method of `ArrayList<string>` to alphabetically sort the environment variables and return the sorted list.",
    "input": "",
    "output": "import {process, ArrayList} from '@kit.ArkTS';\n\nexport function getSortedEnvironmentVars(): ArrayList<string> {\n  const envVars = new ArrayList<string>();\n  const env = process.getEnvironmentVar();\n  \n  for (const key in env) {\n    if (env.hasOwnProperty(key)) {\n      envVars.add(key);\n    }\n  }\n  \n  envVars.sort();\n  return envVars;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getUidForName` method of `process` to fetch the UID for a given process name, then checks if the UID belongs to an isolated process using the `isIsolatedProcess` method. Store the result (true/false) along with the UID in an `ArrayList<any>` using the `add` method, and return the ArrayList.",
    "input": "",
    "output": "import {process, ArrayList} from '@kit.ArkTS';\n\nexport function checkIsolatedProcess(processName: string): ArrayList<[number, boolean]> {\n  const resultList = new ArrayList<[number, boolean]>();\n  const uid = process.getUidForName(processName);\n  const isIsolated = process.isIsolatedProcess(uid);\n  resultList.add([uid, isIsolated]);\n  return resultList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `uptime` method of `process` to get the system uptime in seconds, then creates an `ArrayList<number>` and uses the `add` method to store the uptime value. Next, use the `increaseCapacityTo` method of `ArrayList<number>` to ensure the list can hold at least 10 more elements, and then add 10 sequential numbers (starting from the uptime value) to the list using the `add` method. Return the final ArrayList.",
    "input": "",
    "output": "import {process, ArrayList} from '@kit.ArkTS';\n\nexport function getUptimeArrayList(): ArrayList<number> {\n  const uptime: number = process.uptime();\n  const list: ArrayList<number> = new ArrayList();\n  list.add(uptime);\n  list.increaseCapacityTo(list.length + 10);\n  for (let i = 0; i < 10; i++) {\n    list.add(uptime + i + 1);\n  }\n  return list;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `LightWeightMap.set` to store key-value pairs representing user preferences (e.g., 'theme': 'dark'), then converts the map to a JSON string using `json.stringify` for storage or transmission.",
    "input": "",
    "output": "import {json, LightWeightMap} from '@kit.ArkTS';\n\nexport function storeUserPreferences(): string {\n  const preferences = new LightWeightMap<string, string>();\n  preferences.set('theme', 'dark');\n  preferences.set('language', 'en');\n  preferences.set('notifications', 'enabled');\n  \n  const jsonString = json.stringify(preferences);\n  return jsonString;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that parses a JSON string of product data (using `json.parse`) into an object, then iterates over its properties using `LightWeightMap.forEach` to populate a LightWeightMap with the product IDs as keys and their prices as values.",
    "input": "",
    "output": "import {json, LightWeightMap} from '@kit.ArkTS';\n\nexport function parseAndPopulate(jsonString: string): LightWeightMap<string, number> {\n  const parsedData = json.parse(jsonString) as Record<string, {id: string, price: number}>;\n  const productMap = new LightWeightMap<string, number>();\n\n  Object.values(parsedData).forEach((product) => {\n    productMap.set(product.id, product.price);\n  });\n\n  return productMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if a LightWeightMap (using `LightWeightMap.hasKey`) contains a specific key, and if not, adds the key-value pair from a JSON string (parsed with `json.parse`) to the map using `LightWeightMap.set`.",
    "input": "",
    "output": "import {json, LightWeightMap} from '@kit.ArkTS';\n\nexport function checkAndAddKeyValuePair(map: LightWeightMap<string, string>, key: string, jsonString: string): void {\n  if (!map.hasKey(key)) {\n    const parsedValue = json.parse(jsonString);\n    map.set(key, parsedValue);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of messages, then iterates over the stack using the `[Symbol.iterator]` method to extract each message, and finally passes them to the `transfer` property of `PostMessageOptions` (from @kit.ArkTS) to prepare the messages for cross-thread communication.",
    "input": "",
    "output": "import {Stack, PostMessageOptions} from '@kit.ArkTS';\n\nexport function prepareMessagesForTransfer(messages: ArrayBuffer[]): PostMessageOptions {\n  const stack = new Stack<ArrayBuffer>();\n  \n  for (const message of messages) {\n    stack.push(message);\n  }\n  \n  const transferMessages: ArrayBuffer[] = [];\n  for (const message of stack) {\n    transferMessages.push(message);\n  }\n  \n  const postMessageOptions: PostMessageOptions = {\n    transfer: transferMessages\n  };\n  \n  return postMessageOptions;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks if a `Stack` (from @kit.ArkTS) is empty using the `isEmpty` method, and if it is not empty, uses the `peek` method to retrieve the top element and assigns it to the `transfer` property of `PostMessageOptions` (from @kit.ArkTS) for further processing.",
    "input": "",
    "output": "import {Stack, PostMessageOptions} from '@kit.ArkTS';\n\nexport function processStack(stack: Stack<ArrayBuffer>, options: PostMessageOptions): void {\n  if (!stack.isEmpty()) {\n    const topElement = stack.peek();\n    options.transfer = topElement;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `locate` method of `Stack` (from @kit.ArkTS) to find the position of a specific message in the stack, then uses the `forEach` method to iterate over the stack and collect all messages up to that position, and finally passes the collected messages to the `transfer` property of `PostMessageOptions` (from @kit.ArkTS) for batch transfer.",
    "input": "",
    "output": "import {Stack, PostMessageOptions} from '@kit.ArkTS';\n\nexport function collectAndTransferMessages(stack: Stack<string>, targetMessage: string): PostMessageOptions {\n  const position = stack.locate(targetMessage);\n  const messages: string[] = [];\n  \n  stack.forEach((message: string, index: number) => {\n    if (index <= position) {\n      messages.push(message);\n    }\n  });\n  \n  const transferBuffers: ArrayBuffer[] = messages.map(msg => {\n    const encoder = new TextEncoder();\n    return encoder.encode(msg).buffer;\n  });\n  \n  const options: PostMessageOptions = {\n    transfer: transferBuffers\n  };\n  \n  return options;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `EventTarget.addEventListener` to listen for a custom event, then processes the event data by parsing it with `json.parse` and logs the parsed object. The function should also remove the event listener using `EventTarget.removeEventListener` after processing the data.",
    "input": "",
    "output": "import {EventTarget, json} from '@kit.ArkTS';\n\nexport function setupCustomEventListener(target: EventTarget, eventName: string): void {\n  const eventHandler = (event: Event) => {\n    const customEvent = event as CustomEvent<string>;\n    try {\n      const parsedData = json.parse(customEvent.detail);\n      console.log(parsedData);\n    } catch (error) {\n      console.error('Error parsing JSON:', error);\n    } finally {\n      target.removeEventListener(eventName, eventHandler);\n    }\n  };\n\n  target.addEventListener(eventName, eventHandler);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that dispatches a custom event using `EventTarget.dispatchEvent` with a JSON string payload generated by `json.stringify`. The function should then verify if the dispatched event data exists in a JSON object using `json.has` before dispatching.",
    "input": "",
    "output": "import {EventTarget, json} from '@kit.ArkTS';\n\nexport function dispatchAndVerifyEvent(eventTarget: EventTarget, eventName: string, payload: object, jsonObj: object): boolean {\n  const eventData = json.stringify(payload);\n  const event = { type: eventName, data: eventData };\n  eventTarget.dispatchEvent(event);\n  return json.has(jsonObj, eventData);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `json.remove` to delete a specific property from a JSON object, then dispatches an event using `EventTarget.dispatchEvent` to notify listeners about the removal. The event listeners should be added and removed dynamically using `EventTarget.addEventListener` and `EventTarget.removeEventListener`.",
    "input": "",
    "output": "import {EventTarget, json} from '@kit.ArkTS';\n\nexport function removePropertyAndDispatchEvent(obj: Record<string, unknown>, property: string, eventTarget: EventTarget, eventType: string): void {\n  if (json.has(obj, property)) {\n    json.remove(obj, property);\n    const event = { type: eventType, property: property };\n    eventTarget.dispatchEvent(event);\n  }\n}\n\nexport function addEventListenerToTarget(eventTarget: EventTarget, eventType: string, listener: (event: { type: string, property: string }) => void): void {\n  eventTarget.addEventListener(eventType, listener);\n}\n\nexport function removeEventListenerFromTarget(eventTarget: EventTarget, eventType: string, listener: (event: { type: string, property: string }) => void): void {\n  eventTarget.removeEventListener(eventType, listener);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `from` method of `buffer` to create a buffer from a string, then iterates over the buffer's bytes using the `Symbol.iterator` method of `LinkedList` to store each byte in a linked list. Finally, use the `convertToArray` method of `LinkedList` to return the bytes as an array.",
    "input": "",
    "output": "import {LinkedList, buffer} from '@kit.ArkTS';\n\nexport function stringToBufferToLinkedListToArray(inputString: string): number[] {\n  const buf = buffer.from(inputString);\n  const linkedList = new LinkedList<number>();\n  \n  for (const byte of buf) {\n    linkedList.add(byte);\n  }\n  \n  return linkedList.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `concat` method of `buffer` to merge two buffers into one, then uses the `forEach` method of `LinkedList` to iterate over the merged buffer's bytes and calculate their sum. Store the result in a variable and return it.",
    "input": "",
    "output": "import {LinkedList, buffer} from '@kit.ArkTS';\n\nexport function mergeBuffersAndCalculateSum(buffer1: buffer.Buffer, buffer2: buffer.Buffer): number {\n  const mergedBuffer = buffer.concat([buffer1, buffer2]);\n  const linkedList = new LinkedList<number>();\n  \n  for (const byte of mergedBuffer) {\n    linkedList.add(byte);\n  }\n  \n  let sum = 0;\n  linkedList.forEach((byte: number) => {\n    sum += byte;\n  });\n  \n  return sum;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `alloc` method of `buffer` to create a buffer of a specified size, then uses the `insert` method of `LinkedList` to insert the buffer's bytes at specific positions in the linked list. Finally, use the `length` property of `LinkedList` to verify the number of elements and return the modified linked list.",
    "input": "",
    "output": "import {LinkedList, buffer} from '@kit.ArkTS';\n\nexport function manipulateLinkedListWithBuffer(size: number, positions: number[]): LinkedList<number> {\n  const buf = buffer.alloc(size);\n  const linkedList = new LinkedList<number>();\n  \n  for (let i = 0; i < buf.length; i++) {\n    linkedList.add(buf[i]);\n  }\n  \n  for (const pos of positions) {\n    if (pos >= 0 && pos <= linkedList.length) {\n      linkedList.insert(pos, buf[pos % buf.length]);\n    }\n  }\n  \n  const listLength = linkedList.length;\n  return linkedList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of URIs, then iterates through the stack using the `[Symbol.iterator]` method to validate each URI by passing it to the `uri` API's validation logic (assume `uri` has an implicit validation method). Remove invalid URIs using the `pop` method and return the cleaned stack.",
    "input": "",
    "output": "import {Stack, uri} from '@kit.ArkTS';\n\nexport function validateAndCleanURIs(uris: string[]): Stack<string> {\n  const stack = new Stack<string>();\n  \n  // Push all URIs into the stack\n  for (const uriStr of uris) {\n    stack.push(uriStr);\n  }\n  \n  const tempStack = new Stack<string>();\n  \n  // Iterate through the stack using Symbol.iterator\n  for (const uriStr of stack) {\n    // Assume uri has an implicit validation method\n    if (uri.isValidURI(uriStr)) {\n      tempStack.push(uriStr);\n    }\n  }\n  \n  // Clear the original stack\n  while (!stack.isEmpty()) {\n    stack.pop();\n  }\n  \n  // Push back the valid URIs\n  while (!tempStack.isEmpty()) {\n    stack.push(tempStack.pop());\n  }\n  \n  return stack;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if a `Stack` (from @kit.ArkTS) is empty using the `isEmpty` method, and if not, uses the `peek` method to retrieve the top URI. Then, extract the domain from this URI using the `uri` API (assume `uri` has a domain extraction method) and push it back into the stack. Repeat this process for all elements using the `forEach` method.",
    "input": "",
    "output": "import {Stack, uri} from '@kit.ArkTS';\n\nexport function processStackDomains(stack: Stack<string>): void {\n  if (stack.isEmpty()) {\n    return;\n  }\n\n  const tempStack = new Stack<string>();\n  \n  stack.forEach((uriString: string) => {\n    const domain = uri.extractDomain(uriString);\n    tempStack.push(domain);\n  });\n\n  stack.length = 0;\n  \n  tempStack.forEach((domain: string) => {\n    stack.push(domain);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `locate` method of `Stack` (from @kit.ArkTS) to find the position of a specific URI in the stack, then uses the `uri` API (assume `uri` has a normalization method) to normalize this URI. Replace the original URI with the normalized version using the stack's index and return the updated stack.",
    "input": "",
    "output": "import {Stack, uri} from '@kit.ArkTS';\n\nexport function normalizeUriInStack(stack: Stack<string>, targetUri: string): Stack<string> {\n  const index = stack.locate(targetUri);\n  if (index !== -1) {\n    const normalizedUri = uri.normalize(targetUri);\n    stack[index] = normalizedUri;\n  }\n  return stack;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `transfer` property of `PostMessageOptions` to send an array buffer to a worker, and then handles any errors that occur during the transfer by accessing the `message` and `error` properties of the `ErrorEvent` object to log detailed error information.",
    "input": "",
    "output": "import {PostMessageOptions, ErrorEvent} from '@kit.ArkTS';\n\nexport function sendArrayBufferToWorker(worker: Worker, buffer: ArrayBuffer): void {\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n\n  try {\n    worker.postMessage(buffer, options);\n  } catch (error) {\n    if (error instanceof ErrorEvent) {\n      console.error(`Error occurred: ${error.message}`);\n      console.error(`Error details: ${error.error}`);\n      console.error(`File: ${error.filename}, Line: ${error.lineno}, Column: ${error.colno}`);\n    } else {\n      console.error('An unknown error occurred during transfer');\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that sends data to a worker using `PostMessageOptions` with the `transfer` property, and if an error occurs during the message posting, use the `filename`, `lineno`, and `colno` properties of the `ErrorEvent` to identify and report the exact location of the error in the source code.",
    "input": "",
    "output": "import {PostMessageOptions, ErrorEvent} from '@kit.ArkTS';\n\nexport function sendDataToWorker(worker: Worker, data: ArrayBuffer, transferList: ArrayBuffer[]): void {\n  const options: PostMessageOptions = {\n    transfer: transferList\n  };\n\n  try {\n    worker.postMessage(data, options);\n  } catch (error) {\n    if (error instanceof ErrorEvent) {\n      console.error(`Error occurred at ${error.filename}:${error.lineno}:${error.colno} - ${error.message}`);\n    } else {\n      console.error('An unknown error occurred while posting message to worker.');\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that utilizes the `transfer` property of `PostMessageOptions` to pass ownership of a large data object to a worker, and then monitors for any errors during the transfer by checking the `error` and `message` properties of `ErrorEvent`, logging them along with the line number (`lineno`) where the error occurred.",
    "input": "",
    "output": "import {PostMessageOptions, ErrorEvent} from '@kit.ArkTS';\n\nexport function transferDataToWorker(worker: Worker, data: ArrayBuffer): void {\n  const options: PostMessageOptions = {\n    transfer: [data]\n  };\n  worker.postMessage(data, options);\n\n  worker.onerror = (event: ErrorEvent) => {\n    console.error(`Error occurred at line ${event.lineno}: ${event.message}`);\n    if (event.error) {\n      console.error(`Error details: ${event.error}`);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that parses an XML string using the `xml` API to extract a list of numeric values, then uses the `add` method of `TreeSet` to store these values in a sorted set. Finally, use the `getFirstValue` and `getLastValue` methods of `TreeSet` to return the smallest and largest values from the parsed data.",
    "input": "",
    "output": "import {xml, TreeSet} from '@kit.ArkTS';\n\nexport function parseAndGetMinMax(xmlString: string): {min: number, max: number} {\n  const parsedData = xml.parse(xmlString);\n  const numberSet = new TreeSet<number>();\n\n  function extractNumbers(obj: any): void {\n    if (typeof obj === 'number') {\n      numberSet.add(obj);\n    } else if (typeof obj === 'object' && obj !== null) {\n      for (const key in obj) {\n        extractNumbers(obj[key]);\n      }\n    }\n  }\n\n  extractNumbers(parsedData);\n\n  const min = numberSet.getFirstValue();\n  const max = numberSet.getLastValue();\n\n  return {min, max};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if a `TreeSet` is empty using the `isEmpty` method, and if it is not, iterates over its values using the `Symbol.iterator` method to generate an XML string representation of the set's contents using the `xml` API. The XML should include each value as a child node with a specified tag name.",
    "input": "",
    "output": "import {xml, TreeSet} from '@kit.ArkTS';\n\nexport function treeSetToXML(treeSet: TreeSet<string>, tagName: string): string {\n  if (treeSet.isEmpty()) {\n    return '';\n  }\n\n  const xmlBuilder = new xml.XmlBuilder();\n  const root = xmlBuilder.createElement('root');\n\n  for (const value of treeSet) {\n    const child = xmlBuilder.createElement(tagName);\n    child.setTextContent(value);\n    root.appendChild(child);\n  }\n\n  return xmlBuilder.build(root);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `xml` API to parse an XML document containing a list of items with attributes, then filters these items based on a condition. The filtered items' IDs (extracted from attributes) should be added to a `TreeSet` using the `add` method, and the final result should be the size of the set obtained using the `length` property.",
    "input": "",
    "output": "import {xml, TreeSet} from '@kit.ArkTS';\n\nexport function filterAndCountItems(xmlString: string, condition: (item: Record<string, string>) => boolean): number {\n  const parser = new xml.XmlPullParser(xmlString);\n  const itemIds = new TreeSet<string>();\n\n  while (parser.next() !== xml.EventType.END_DOCUMENT) {\n    if (parser.getEventType() === xml.EventType.START_TAG) {\n      const tagName = parser.getName();\n      if (tagName === 'item') {\n        const attributes = parser.getAttributes();\n        if (condition(attributes)) {\n          const id = attributes['id'];\n          if (id) {\n            itemIds.add(id);\n          }\n        }\n      }\n    }\n  }\n\n  return itemIds.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send a message to a worker thread, and includes the `transfer` property of `PostMessageOptions` to transfer ownership of an ArrayBuffer to the worker. Then, use the `onmessage` property of `DedicatedWorkerGlobalScope` to handle the response from the worker.",
    "input": "",
    "output": "import {PostMessageOptions, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendMessageToWorker(worker: DedicatedWorkerGlobalScope, buffer: ArrayBuffer): void {\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  worker.postMessage(buffer, options);\n}\n\nexport function setupWorkerResponseHandler(worker: DedicatedWorkerGlobalScope, callback: (event: MessageEvent) => void): void {\n  worker.onmessage = callback;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a worker thread and uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send a task to the worker. Use the `transfer` property of `PostMessageOptions` to ensure efficient data transfer. Finally, use the `close` method of `DedicatedWorkerGlobalScope` to terminate the worker after the task is completed.",
    "input": "",
    "output": "import {PostMessageOptions, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function initializeWorker(): void {\n  const workerScript = `\n    self.onmessage = (e: MessageEvent) => {\n      const buffer = e.data;\n      console.log('Worker received buffer:', buffer);\n      self.close();\n    };\n  `;\n\n  const blob = new Blob([workerScript], { type: 'application/javascript' });\n  const workerUrl = URL.createObjectURL(blob);\n  const worker = new Worker(workerUrl);\n\n  const buffer = new ArrayBuffer(8);\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n\n  worker.postMessage(buffer, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that sets up an `onmessageerror` handler using the `onmessageerror` property of `DedicatedWorkerGlobalScope` to catch any message errors. Then, use the `postMessage` method of `DedicatedWorkerGlobalScope` with the `transfer` property of `PostMessageOptions` to send a message to the worker, ensuring proper error handling and data transfer.",
    "input": "",
    "output": "import {PostMessageOptions, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerMessageErrorHandler(workerScope: DedicatedWorkerGlobalScope): void {\n  workerScope.onmessageerror = (event: MessageEvent) => {\n    console.error('Message error occurred:', event);\n  };\n}\n\nexport function sendMessageToWorker(\n  workerScope: DedicatedWorkerGlobalScope,\n  message: ArrayBuffer,\n  transferList: ArrayBuffer[]\n): void {\n  const options: PostMessageOptions = {\n    transfer: transferList\n  };\n  workerScope.postMessage(message, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to run a computationally intensive task (e.g., calculating a large Fibonacci number) in the background, and then uses `util.promiseWrapper` to convert the task's callback-based result into a Promise for easier asynchronous handling in the main thread.",
    "input": "",
    "output": "import {taskpool, util} from '@kit.ArkTS';\n\nexport function calculateFibonacciInBackground(n: number): Promise<number> {\n  const fibonacciTask = (n: number): number => {\n    if (n <= 1) {\n      return n;\n    }\n    return fibonacciTask(n - 1) + fibonacciTask(n - 2);\n  };\n\n  const task = new taskpool.Task(fibonacciTask, n);\n  const promise = util.promiseWrapper<number>(taskpool.execute(task));\n  return promise;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that generates a random UUID using `util.generateRandomUUID`, then schedules a delayed task with `taskpool.executeDelayed` to log the UUID after a specified delay (e.g., 5 seconds), demonstrating cross-API coordination for timed operations with generated data.",
    "input": "",
    "output": "import {taskpool, util} from '@kit.ArkTS';\n\nexport function scheduleDelayedUUIDLogging(delay: number): void {\n  const uuid: string = util.generateRandomUUID();\n  \n  const task: taskpool.Task = new taskpool.Task(() => {\n    console.log(`Generated UUID: ${uuid}`);\n  });\n  \n  taskpool.executeDelayed(task, delay).then(() => {\n    console.log('Task scheduled successfully');\n  }).catch((error: Error) => {\n    console.error(`Error scheduling task: ${error.message}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `taskpool.executePeriodically` to perform a periodic hash calculation (e.g., SHA-256) on a random string generated by `util.generateRandomBinaryUUID` every 2 seconds, and then uses `util.getHash` to verify the integrity of the generated hash, showcasing combined periodic task execution and cryptographic utility usage.",
    "input": "",
    "output": "import {taskpool, util} from '@kit.ArkTS';\n\nexport function performPeriodicHashVerification(): void {\n  const task: taskpool.Task = {\n    execute: (): void => {\n      const randomUUID: Uint8Array = util.generateRandomBinaryUUID();\n      const hash: Uint8Array = util.getHash(randomUUID, 'SHA256');\n      const verifiedHash: Uint8Array = util.getHash(randomUUID, 'SHA256');\n      \n      if (hash.length !== verifiedHash.length) {\n        return;\n      }\n      \n      for (let i = 0; i < hash.length; i++) {\n        if (hash[i] !== verifiedHash[i]) {\n          return;\n        }\n      }\n    }\n  };\n  \n  taskpool.executePeriodically(task, 2000);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `uri` API to parse a given URI string and then logs the parsed components (like protocol, host, path) using the `Event` API's `type` property to categorize the log entry and `timeStamp` property to record the time of parsing.",
    "input": "",
    "output": "import {uri, Event} from '@kit.ArkTS';\n\nexport function parseAndLogUri(uriString: string): void {\n  try {\n    const parsedUri = uri.parse(uriString);\n    const event: Event = {\n      type: 'URI_PARSE',\n      timeStamp: Date.now()\n    };\n\n    console.log(`[${event.type}] [${event.timeStamp}] Protocol: ${parsedUri.protocol}`);\n    console.log(`[${event.type}] [${event.timeStamp}] Host: ${parsedUri.host}`);\n    console.log(`[${event.type}] [${event.timeStamp}] Path: ${parsedUri.path}`);\n  } catch (error) {\n    const errorEvent: Event = {\n      type: 'URI_PARSE_ERROR',\n      timeStamp: Date.now()\n    };\n    console.error(`[${errorEvent.type}] [${errorEvent.timeStamp}] Error parsing URI: ${error}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that listens for a custom event using the `Event` API (capturing `type` and `timeStamp`), and then constructs a new URI string using the `uri` API based on the event type and timestamp (e.g., appending timestamp as a query parameter).",
    "input": "",
    "output": "import {uri, Event} from '@kit.ArkTS';\n\nexport function listenAndConstructUri(eventType: string, callback: (uriString: string) => void): void {\n  const eventListener = (event: Event) => {\n    if (event.type === eventType) {\n      const newUri = new uri.URI();\n      const uriString = `${newUri.toString()}?timestamp=${event.timeStamp}`;\n      callback(uriString);\n    }\n  };\n\n  // Assuming there's a way to add event listeners with the Event API\n  // This part is hypothetical since the actual Event API usage isn't fully specified\n  // In a real implementation, you would use the appropriate method to listen for events\n  // For example: someEventTarget.addEventListener(eventType, eventListener);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that first extracts the `type` property from an `Event` object to determine the action needed, then uses the `uri` API to dynamically generate a URI based on the event type (e.g., redirecting to different paths depending on the event type).",
    "input": "",
    "output": "import {uri, Event} from '@kit.ArkTS';\n\nexport function handleEvent(event: Event): string {\n  const eventType = event.type;\n  let generatedUri: string = '';\n\n  switch (eventType) {\n    case 'click':\n      generatedUri = 'path/to/click';\n      break;\n    case 'hover':\n      generatedUri = 'path/to/hover';\n      break;\n    case 'focus':\n      generatedUri = 'path/to/focus';\n      break;\n    default:\n      generatedUri = 'path/to/default';\n      break;\n  }\n\n  return generatedUri;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `WorkerEventTarget.addEventListener` to listen for a 'message' event, and upon receiving the event, accesses the `data` property of the `MessageEvents` object to process the received message and then uses `WorkerEventTarget.dispatchEvent` to emit a new event with the processed data.",
    "input": "",
    "output": "import {WorkerEventTarget, MessageEvents} from '@kit.ArkTS';\n\nexport function processWorkerMessage(workerTarget: WorkerEventTarget): void {\n  workerTarget.addEventListener('message', (event: MessageEvents) => {\n    const receivedData = event.data;\n    const processedData = processData(receivedData);\n    const newEvent: MessageEvents = {\n      data: processedData,\n      type: 'message'\n    };\n    workerTarget.dispatchEvent(newEvent);\n  });\n}\n\nfunction processData(data: unknown): unknown {\n  // Implement your data processing logic here\n  return data;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that sets up a message handler using `WorkerEventTarget.addEventListener` to listen for incoming messages. When a message is received (accessed via `MessageEvents.data`), use `WorkerEventTarget.removeEventListener` to remove the handler after processing the first message, ensuring it only reacts once.",
    "input": "",
    "output": "import {WorkerEventTarget, MessageEvents} from '@kit.ArkTS';\n\nexport function setupOneTimeMessageHandler(workerTarget: WorkerEventTarget, callback: (data: string) => void): void {\n  const handler = (event: MessageEvents) => {\n    callback(event.data);\n    workerTarget.removeEventListener('message', handler);\n  };\n  workerTarget.addEventListener('message', handler);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `WorkerEventTarget.addEventListener` to listen for multiple 'message' events. For each event, extract the `data` from `MessageEvents` and accumulate it in an array. After a specific condition is met (e.g., receiving 5 messages), use `WorkerEventTarget.removeAllListener` to stop further event processing and return the accumulated data array.",
    "input": "",
    "output": "import {WorkerEventTarget, MessageEvents} from '@kit.ArkTS';\n\nexport function listenAndAccumulateMessages(workerTarget: WorkerEventTarget, maxMessages: number): Promise<Array<unknown>> {\n  return new Promise((resolve) => {\n    const messages: Array<unknown> = [];\n    const messageHandler = (event: MessageEvents) => {\n      messages.push(event.data);\n      if (messages.length >= maxMessages) {\n        workerTarget.removeAllListener('message');\n        resolve(messages);\n      }\n    };\n    workerTarget.addEventListener('message', messageHandler);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `TreeMap` to retrieve all keys, then dispatches a custom event using `EventTarget.dispatchEvent` with the keys as part of the event data. The function should also ensure all listeners are removed afterward using `EventTarget.removeAllListener`.",
    "input": "",
    "output": "import {TreeMap, EventTarget} from '@kit.ArkTS';\n\nexport function dispatchTreeMapKeysEvent(treeMap: TreeMap<unknown, unknown>, eventTarget: EventTarget): void {\n  const keys = treeMap.keys();\n  const event = {\n    type: 'treeMapKeys',\n    data: Array.from(keys)\n  };\n  eventTarget.dispatchEvent(event);\n  eventTarget.removeAllListener();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `TreeMap.getFirstKey` and `TreeMap.getLastKey` to retrieve the first and last keys, then adds event listeners for these keys using `EventTarget.addEventListener`. The listeners should log a message when the corresponding key is accessed via `TreeMap.get`.",
    "input": "",
    "output": "import {TreeMap, EventTarget} from '@kit.ArkTS';\n\nexport function setupTreeMapListeners(treeMap: TreeMap<number, string>, eventTarget: EventTarget): void {\n  const firstKey = treeMap.getFirstKey();\n  const lastKey = treeMap.getLastKey();\n\n  if (firstKey !== undefined) {\n    eventTarget.addEventListener(`key-${firstKey}`, () => {\n      console.log(`First key ${firstKey} accessed with value: ${treeMap.get(firstKey)}`);\n    });\n  }\n\n  if (lastKey !== undefined) {\n    eventTarget.addEventListener(`key-${lastKey}`, () => {\n      console.log(`Last key ${lastKey} accessed with value: ${treeMap.get(lastKey)}`);\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if a `TreeMap` is empty using `TreeMap.isEmpty`, and if it is, dispatches an 'empty' event using `EventTarget.dispatchEvent`. Otherwise, it should iterate over the `TreeMap` using `TreeMap.forEach` and dispatch a 'non-empty' event with each key-value pair as event data.",
    "input": "",
    "output": "import {TreeMap, EventTarget} from '@kit.ArkTS';\n\nexport function checkAndDispatchTreeMapEvent(treeMap: TreeMap<unknown, unknown>, eventTarget: EventTarget): void {\n  if (treeMap.isEmpty()) {\n    eventTarget.dispatchEvent(new Event('empty'));\n  } else {\n    treeMap.forEach((value: unknown, key: unknown) => {\n      const eventData = { key, value };\n      const event = new CustomEvent('non-empty', { detail: eventData });\n      eventTarget.dispatchEvent(event);\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a URL string to a worker thread, and then uses the `url` API to parse the URL into its components (e.g., protocol, hostname) within the worker thread. The parsed components should be sent back to the main thread using the `postMessage` method of `ThreadWorkerGlobalScope`.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, url} from '@kit.ArkTS';\n\nexport function setupWorker() {\n  const worker = new ThreadWorkerGlobalScope('entry/ets/workers/worker.ts');\n  \n  worker.onmessage = (message: string) => {\n    const parsedUrl = url.parse(message);\n    worker.postMessage(parsedUrl);\n  };\n  \n  return worker;\n}\n\nexport function sendUrlToWorker(worker: ThreadWorkerGlobalScope, urlString: string) {\n  worker.postMessage(urlString);\n}\n\nexport function handleWorkerResponse(worker: ThreadWorkerGlobalScope, callback: (parsedUrl: url.URL) => void) {\n  worker.onmessage = (message: url.URL) => {\n    callback(message);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that listens for messages using the `onmessage` property of `ThreadWorkerGlobalScope`. When a message containing a URL is received, use the `url` API to validate the URL (e.g., check if it has a valid protocol). If the URL is valid, send a confirmation message back to the main thread using the `postMessage` method of `ThreadWorkerGlobalScope`; otherwise, send an error message.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, url} from '@kit.ArkTS';\n\nexport class URLValidatorWorker {\n  private workerScope: ThreadWorkerGlobalScope;\n\n  constructor(workerScope: ThreadWorkerGlobalScope) {\n    this.workerScope = workerScope;\n    this.setupMessageListener();\n  }\n\n  private setupMessageListener(): void {\n    this.workerScope.onmessage = (message: string) => {\n      this.handleMessage(message);\n    };\n  }\n\n  private handleMessage(message: string): void {\n    try {\n      const parsedUrl = new url.URL(message);\n      const isValid = this.validateURL(parsedUrl);\n      if (isValid) {\n        this.workerScope.postMessage(`Valid URL: ${message}`);\n      } else {\n        this.workerScope.postMessage(`Invalid URL: ${message}`);\n      }\n    } catch (error) {\n      this.workerScope.postMessage(`Error parsing URL: ${message}`);\n    }\n  }\n\n  private validateURL(parsedUrl: url.URL): boolean {\n    const validProtocols = ['http:', 'https:'];\n    return validProtocols.includes(parsedUrl.protocol);\n  }\n}\n\nconst worker = new URLValidatorWorker(self as ThreadWorkerGlobalScope);",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where the main thread sends a shared object containing a URL string to a worker thread using the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope`. The worker thread should use the `url` API to extract the query parameters from the URL and modify the shared object to include these parameters. The modified object should then be sent back to the main thread using the `postMessage` method of `ThreadWorkerGlobalScope`.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, url} from '@kit.ArkTS';\n\nexport class SharedObject {\n  url: string;\n  queryParams?: Record<string, string>;\n\n  constructor(url: string) {\n    this.url = url;\n  }\n}\n\nexport function setupWorker(workerScope: ThreadWorkerGlobalScope): void {\n  workerScope.onmessage = (event: MessageEvent<SharedObject>) => {\n    const sharedObj = event.data;\n    const parsedUrl = new url.URL(sharedObj.url);\n    const queryParams: Record<string, string> = {};\n\n    parsedUrl.searchParams.forEach((value, key) => {\n      queryParams[key] = value;\n    });\n\n    sharedObj.queryParams = queryParams;\n    workerScope.postMessage(sharedObj);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `self` property of `GlobalScope` to access the current worker context, then passes this context to a worker thread using the `worker` API to perform a background task. The function should handle any errors using the `onerror` property of `GlobalScope` to log errors from the worker thread.",
    "input": "",
    "output": "import {worker, GlobalScope} from '@kit.ArkTS';\n\nexport function startBackgroundTask(scriptURL: string): void {\n  const currentContext: GlobalScope = GlobalScope.self;\n  \n  try {\n    const backgroundWorker: worker.ThreadWorker = new worker.ThreadWorker(scriptURL);\n    \n    backgroundWorker.onerror = (error: ErrorEvent): void => {\n      console.error(`Worker error: ${error.message}`);\n    };\n    \n    backgroundWorker.postMessage(currentContext);\n  } catch (error) {\n    console.error(`Failed to start worker: ${error}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a script that initializes a worker thread using the `worker` API and sets the `name` property of `GlobalScope` to identify the main thread. The worker thread should send a message back to the main thread, which the main thread should process and log using the `self` property of `GlobalScope` to verify the execution context.",
    "input": "",
    "output": "import {worker, GlobalScope} from '@kit.ArkTS';\n\n// Main thread code\nconst mainThreadWorker = new worker.ThreadWorker('workers/worker.ts');\nGlobalScope.name = 'mainThread';\n\nmainThreadWorker.onmessage = (message: string): void => {\n  console.log(`Main thread received message: ${message}`);\n  console.log(`GlobalScope.self in main thread: ${GlobalScope.self}`);\n};\n\n// Worker thread code (workers/worker.ts)\nGlobalScope.name = 'workerThread';\nconst workerPort = worker.parentPort;\n\nif (workerPort) {\n  workerPort.postMessage('Hello from worker thread!');\n  console.log(`GlobalScope.self in worker thread: ${GlobalScope.self}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task where the `onerror` property of `GlobalScope` is used to catch and handle errors thrown by a worker thread created via the `worker` API. The worker thread should perform a computation and return the result to the main thread, which then uses the `self` property of `GlobalScope` to display the result or error message.",
    "input": "",
    "output": "import {worker, GlobalScope} from '@kit.ArkTS';\n\nconst workerPort = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n\nworkerPort.onmessage = (message: worker.MessageEvents): void => {\n  console.log(`Main thread received: ${message.data}`);\n  GlobalScope.self.postMessage(`Result: ${message.data}`);\n};\n\nworkerPort.onerror = (error: ErrorEvent): void => {\n  console.error(`Main thread error: ${error.message}`);\n  GlobalScope.self.postMessage(`Error: ${error.message}`);\n};\n\nworkerPort.postMessage('Start computation');",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a Worker using the `WorkerOptions` API, setting the `name` property to a unique identifier, and then passes the worker's script URL (constructed using the `url` API) to initialize the worker. The function should return the worker instance after ensuring both the name and URL are properly configured.",
    "input": "",
    "output": "import {WorkerOptions, url} from '@kit.ArkTS';\n\nexport function createWorker(scriptPath: string, workerName: string): Worker {\n  const workerOptions: WorkerOptions = {\n    name: workerName\n  };\n  const scriptUrl: string = url.pathToFileURL(scriptPath).toString();\n  return new Worker(scriptUrl, workerOptions);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that dynamically generates a Worker script URL using the `url` API, then initializes a shared Worker by passing this URL along with the `shared` property set to `true` in the `WorkerOptions` API. The function should verify that the Worker is correctly initialized as a shared worker before returning it.",
    "input": "",
    "output": "import {WorkerOptions, url} from '@kit.ArkTS';\n\nexport function createSharedWorker(scriptPath: string): Worker {\n  const scriptUrl = new url.URL(scriptPath);\n  const options: WorkerOptions = {\n    shared: true\n  };\n  const worker = new Worker(scriptUrl.toString(), options);\n  return worker;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes an array of script URLs (constructed using the `url` API) and creates multiple Workers, each with a unique `name` property specified in the `WorkerOptions` API. The function should return an array of the initialized Workers, ensuring each Worker's name and URL are correctly set.",
    "input": "",
    "output": "import {WorkerOptions, url} from '@kit.ArkTS';\n\nexport function createWorkers(scriptUrls: string[], workerNames: string[]): Worker[] {\n  if (scriptUrls.length !== workerNames.length) {\n    throw new Error('The number of script URLs must match the number of worker names');\n  }\n\n  const workers: Worker[] = [];\n  \n  for (let i = 0; i < scriptUrls.length; i++) {\n    const options: WorkerOptions = {\n      name: workerNames[i]\n    };\n    \n    const worker = new Worker(scriptUrls[i], options);\n    workers.push(worker);\n  }\n  \n  return workers;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a `Queue` of events (using the `add` method) and then iterates through the queue (using `[Symbol.iterator]`) to filter out events with a specific `type` (using the `type` property of `Event`). Return the filtered events as a new `Queue`.",
    "input": "",
    "output": "import {Event, Queue} from '@kit.ArkTS';\n\nexport function filterEventsByType(events: Event[], type: string): Queue<Event> {\n  const queue = new Queue<Event>();\n  events.forEach(event => queue.add(event));\n  \n  const filteredQueue = new Queue<Event>();\n  for (const event of queue) {\n    if (event.type === type) {\n      filteredQueue.add(event);\n    }\n  }\n  \n  return filteredQueue;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that processes a `Queue` of events (using the `pop` method) and collects the `timeStamp` values (using the `timeStamp` property of `Event`) into an array. Then, use the `forEach` method of `Queue` to log each timestamp in the array.",
    "input": "",
    "output": "import {Event, Queue} from '@kit.ArkTS';\n\nexport function processEvents(queue: Queue<Event>): void {\n  const timeStamps: number[] = [];\n  while (queue.length > 0) {\n    const event = queue.pop();\n    if (event) {\n      timeStamps.push(event.timeStamp);\n    }\n  }\n  queue.forEach((event: Event) => {\n    console.log(event.timeStamp);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that initializes a `Queue` (using the `constructor`), adds multiple events to it (using the `add` method), and then uses the `getFirst` method to retrieve the first event. Check if the first event's `type` matches a given value (using the `type` property of `Event`). Return `true` if it matches, otherwise `false`.",
    "input": "",
    "output": "import {Event, Queue} from '@kit.ArkTS';\n\nexport function checkFirstEventType(events: Event[], expectedType: string): boolean {\n  const queue = new Queue<Event>();\n  events.forEach(event => queue.add(event));\n  const firstEvent = queue.getFirst();\n  return firstEvent?.type === expectedType;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a sequence of key-value pairs representing user IDs and their corresponding scores. Then, use the `transfer` property of `PostMessageOptions` to send the top 3 highest scores (extracted using `getValueAt` and sorting logic) to another context for further processing.",
    "input": "",
    "output": "import {PlainArray, PostMessageOptions} from '@kit.ArkTS';\n\nexport function processAndSendTopScores(): void {\n  const scores = new PlainArray<number>();\n  \n  // Add sample key-value pairs (user IDs and scores)\n  scores.add(1, 95);\n  scores.add(2, 87);\n  scores.add(3, 92);\n  scores.add(4, 78);\n  scores.add(5, 88);\n  \n  // Extract all scores and sort them in descending order\n  const scoreEntries: Array<[number, number]> = [];\n  for (let i = 0; i < scores.length; i++) {\n    const key = scores.getKeyAt(i);\n    const value = scores.getValueAt(i);\n    scoreEntries.push([key, value]);\n  }\n  \n  // Sort by score in descending order\n  scoreEntries.sort((a, b) => b[1] - a[1]);\n  \n  // Get top 3 scores\n  const topScores = scoreEntries.slice(0, 3);\n  \n  // Prepare data for transfer\n  const buffer = new ArrayBuffer(topScores.length * 8); // 8 bytes per entry (4 for key, 4 for value)\n  const view = new DataView(buffer);\n  \n  for (let i = 0; i < topScores.length; i++) {\n    const [key, value] = topScores[i];\n    view.setInt32(i * 8, key, true);\n    view.setInt32(i * 8 + 4, value, true);\n  }\n  \n  // Create PostMessageOptions with transfer\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  \n  // In a real scenario, you would post this to a worker or another context\n  // For example: worker.postMessage({ type: 'topScores', data: buffer }, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `PlainArray` with a set of key-value pairs using the `constructor` method. Then, iterate over the array using the `forEach` method to filter out entries with values below a certain threshold. Finally, use the `transfer` property of `PostMessageOptions` to send the filtered entries to a worker thread for parallel processing.",
    "input": "",
    "output": "import {PlainArray, PostMessageOptions} from '@kit.ArkTS';\n\nexport function initializeAndFilterPlainArray(threshold: number): void {\n  // Initialize PlainArray with key-value pairs\n  const plainArray = new PlainArray<number>();\n  plainArray.add(1, 10);\n  plainArray.add(2, 20);\n  plainArray.add(3, 5);\n  plainArray.add(4, 30);\n  plainArray.add(5, 15);\n\n  // Filter entries with values below the threshold\n  const filteredEntries: Array<[number, number]> = [];\n  plainArray.forEach((value: number, key: number) => {\n    if (value >= threshold) {\n      filteredEntries.push([key, value]);\n    }\n  });\n\n  // Prepare data for transfer\n  const buffer = new ArrayBuffer(filteredEntries.length * 2 * 4); // Assuming each entry is two 4-byte numbers\n  const view = new Int32Array(buffer);\n  filteredEntries.forEach((entry, index) => {\n    view[index * 2] = entry[0];\n    view[index * 2 + 1] = entry[1];\n  });\n\n  // Create PostMessageOptions with transfer\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n\n  // Send to worker thread (assuming worker is defined elsewhere)\n  // worker.postMessage({ data: filteredEntries }, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getIndexOfKey` method of `PlainArray` to find the index of a specific user ID. If found, use the `setValueAt` method to update the user's score. Then, use the `transfer` property of `PostMessageOptions` to send the updated `PlainArray` to a remote server for synchronization.",
    "input": "",
    "output": "import {PlainArray, PostMessageOptions} from '@kit.ArkTS';\n\nexport function updateUserScoreAndSync(userScores: PlainArray<number, number>, userId: number, newScore: number, serverUrl: string): void {\n  const index = userScores.getIndexOfKey(userId);\n  if (index !== -1) {\n    userScores.setValueAt(index, newScore);\n    const transferArray = new ArrayBuffer(userScores.length * 8);\n    const options: PostMessageOptions = {\n      transfer: [transferArray]\n    };\n    // In a real implementation, you would use a method to send the data to the server\n    // For example: postMessage(serverUrl, userScores, options);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `convertToArray` method of `Vector` to transform a vector of URIs into an array, then iterates over the array using the `Symbol.iterator` method of `Vector` to validate each URI (assuming URI validation is implicit). Finally, use the `replaceAllElements` method of `Vector` to update the vector with only the valid URIs.",
    "input": "",
    "output": "import {Vector, uri} from '@kit.ArkTS';\n\nexport function validateAndFilterURIs(vector: Vector<string>): Vector<string> {\n  const uriArray: string[] = vector.convertToArray();\n  const validURIs: string[] = [];\n\n  for (const uri of vector) {\n    try {\n      // Implicit validation by attempting to use the URI\n      validURIs.push(uri);\n    } catch (e) {\n      // Skip invalid URIs\n    }\n  }\n\n  vector.replaceAllElements((value: string, index: number) => {\n    return validURIs[index] || '';\n  });\n\n  return vector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getFirstElement` and `getLastElement` methods of `Vector` to retrieve the first and last elements of a vector containing URIs. Then, concatenate these URIs into a new URI string (assuming URI concatenation is implicit) and use the `insert` method of `Vector` to add this new URI at the middle index of the original vector.",
    "input": "",
    "output": "import {Vector, uri} from '@kit.ArkTS';\n\nexport function concatenateAndInsertURIs(vector: Vector<string>): void {\n  if (vector.isEmpty()) {\n    return;\n  }\n\n  const firstElement: string = vector.getFirstElement();\n  const lastElement: string = vector.getLastElement();\n  const concatenatedURI: string = firstElement + lastElement;\n\n  const middleIndex: number = Math.floor(vector.length / 2);\n  vector.insert(middleIndex, concatenatedURI);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses the `subVector` method of `Vector` to extract a range of elements from a vector of URIs, then applies the `sort` method to this sub-vector. Finally, use the `copyToArray` method of `Vector` to convert the sorted sub-vector into an array and return it alongside the original vector's `length` property for comparison.",
    "input": "",
    "output": "import {Vector, uri} from '@kit.ArkTS';\n\nexport function processVector(originalVector: Vector<uri>, start: number, end: number): {sortedArray: Array<uri>, originalLength: number} {\n    const subVector = originalVector.subVector(start, end);\n    subVector.sort();\n    const sortedArray = subVector.copyToArray();\n    return {\n        sortedArray: sortedArray,\n        originalLength: originalVector.length\n    };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to asynchronously fetch data from a URL (using `url` API) and then processes the fetched data with a callback function defined using `CallbackFunction` from `taskpool`. The function should handle errors by passing them to `CallbackFunctionWithError` and log the final result.",
    "input": "",
    "output": "import {url, taskpool} from '@kit.ArkTS';\n\nexport function fetchAndProcessData(urlStr: string, callback: taskpool.CallbackFunction<string>, errorCallback: taskpool.CallbackFunctionWithError): void {\n  const task = new taskpool.Task(async () => {\n    try {\n      const response = await url.fetch(urlStr);\n      const data = await response.text();\n      callback(data);\n    } catch (error) {\n      errorCallback(error as Error);\n    }\n  });\n\n  taskpool.execute(task);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a task scheduler that uses the `executeDelayed` and `executePeriodically` methods of `taskpool` to manage URL fetch operations (using `url` API) at specified intervals. The scheduler should prioritize tasks using the `Priority` enum from `taskpool` and cancel any pending tasks if the `State` of the taskpool indicates overload (using `getTaskPoolInfo`).",
    "input": "",
    "output": "import {url, taskpool} from '@kit.ArkTS';\n\nexport class TaskScheduler {\n  private tasks: Map<number, taskpool.Task> = new Map();\n  private nextTaskId: number = 0;\n\n  executeDelayedFetch(urlStr: string, delay: number, priority: taskpool.Priority): number {\n    const taskId = this.nextTaskId++;\n    const task = taskpool.executeDelayed(\n      () => {\n        // URL fetch operation would go here\n        // Since url module has no members, we can't implement actual fetch\n        console.log(`Fetching URL: ${urlStr}`);\n      },\n      delay,\n      priority\n    );\n    this.tasks.set(taskId, task);\n    return taskId;\n  }\n\n  executePeriodicFetch(urlStr: string, interval: number, priority: taskpool.Priority): number {\n    const taskId = this.nextTaskId++;\n    const task = taskpool.executePeriodically(\n      () => {\n        // URL fetch operation would go here\n        console.log(`Periodically fetching URL: ${urlStr}`);\n      },\n      interval,\n      priority\n    );\n    this.tasks.set(taskId, task);\n    return taskId;\n  }\n\n  cancelTask(taskId: number): boolean {\n    const task = this.tasks.get(taskId);\n    if (task) {\n      taskpool.cancel(task);\n      this.tasks.delete(taskId);\n      return true;\n    }\n    return false;\n  }\n\n  checkAndCancelTasksIfOverloaded(): boolean {\n    const info = taskpool.getTaskPoolInfo();\n    if (info.state === taskpool.State.OVERLOAD) {\n      this.tasks.forEach((task, taskId) => {\n        taskpool.cancel(task);\n        this.tasks.delete(taskId);\n      });\n      return true;\n    }\n    return false;\n  }\n\n  clearAllTasks(): void {\n    this.tasks.forEach((task) => {\n      taskpool.cancel(task);\n    });\n    this.tasks.clear();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a concurrent data processing system where the `isConcurrent` method of `taskpool` checks if concurrent execution is possible. If true, use the `execute` method to parallelize multiple URL fetch operations (using `url` API) and aggregate the results. If false, fall back to sequential processing and log the reason using `terminateTask` to clean up any partial tasks.",
    "input": "",
    "output": "import {url, taskpool} from '@kit.ArkTS';\n\nexport async function fetchUrlsConcurrently(urls: string[]): Promise<string[]> {\n  if (taskpool.isConcurrent()) {\n    try {\n      const tasks = urls.map(urlStr => {\n        return taskpool.execute(async () => {\n          // Simulate URL fetch operation since actual URL API members are not provided\n          return `Data from ${urlStr}`;\n        });\n      });\n      const results = await Promise.all(tasks);\n      return results;\n    } catch (error) {\n      taskpool.terminateTask();\n      throw error;\n    }\n  } else {\n    console.log('Concurrent execution not possible. Falling back to sequential processing.');\n    const results: string[] = [];\n    for (const urlStr of urls) {\n      // Simulate sequential URL fetch operation\n      results.push(`Data from ${urlStr}`);\n    }\n    return results;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LightWeightSet` to store a collection of event objects (from `Event` API). Then, use the `getValueAt` method of `LightWeightSet` to retrieve each event and print its `type` and `timeStamp` properties in a formatted string.",
    "input": "",
    "output": "import {Event, LightWeightSet} from '@kit.ArkTS';\n\nexport function storeAndPrintEvents(events: Event[]): void {\n  const eventSet = new LightWeightSet<Event>();\n  \n  for (const event of events) {\n    eventSet.add(event);\n  }\n  \n  for (let i = 0; i < eventSet.length; i++) {\n    const event = eventSet.getValueAt(i);\n    console.log(`Event type: ${event.type}, timestamp: ${event.timeStamp}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if a `LightWeightSet` is empty using the `isEmpty` method. If it is not empty, iterate over the set using the `forEach` method and for each event object (from `Event` API), use the `has` method to check if the event type exists in another `LightWeightSet` containing predefined event types.",
    "input": "",
    "output": "import {Event, LightWeightSet} from '@kit.ArkTS';\n\nexport function checkEventTypes(eventSet: LightWeightSet<Event>, predefinedTypes: LightWeightSet<string>): void {\n  if (!eventSet.isEmpty()) {\n    eventSet.forEach((event: Event) => {\n      if (predefinedTypes.has(event.type)) {\n        // Handle the event type found in predefinedTypes\n      }\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `toArray` method of `LightWeightSet` to convert a set of event objects (from `Event` API) into an array. Then, use the `entries` method of `LightWeightSet` to iterate over the original set and compare each event's `timeStamp` property with the corresponding array element to ensure consistency.",
    "input": "",
    "output": "import {Event, LightWeightSet} from '@kit.ArkTS';\n\nexport function compareEventSetToArray(eventSet: LightWeightSet<Event>): boolean {\n  const eventArray = eventSet.toArray();\n  const iterator = eventSet.entries();\n  let index = 0;\n  let result = true;\n  \n  for (const entry of iterator) {\n    const [key, event] = entry;\n    if (event.timeStamp !== eventArray[index].timeStamp) {\n      result = false;\n      break;\n    }\n    index++;\n  }\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to run a background task (defined by `CallbackFunction`) and then uses `WorkerEventTarget.addEventListener` to listen for a custom event dispatched by the background task. The event should carry the result of the background computation, and the listener should log this result.",
    "input": "",
    "output": "import {WorkerEventTarget, taskpool} from '@kit.ArkTS';\n\nexport function runBackgroundTaskAndListen(callback: taskpool.CallbackFunction, eventName: string): void {\n  const workerEventTarget = new WorkerEventTarget();\n  \n  workerEventTarget.addEventListener(eventName, (event: CustomEvent) => {\n    console.log('Result from background task:', event.detail);\n  });\n  \n  taskpool.execute(callback).then((result) => {\n    workerEventTarget.dispatchEvent(new CustomEvent(eventName, { detail: result }));\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that schedules a delayed task using `taskpool.executeDelayed` with a `Priority` of `HIGH`. Once the task completes, it should dispatch an event using `WorkerEventTarget.dispatchEvent`, and another part of the code should listen for this event using `WorkerEventTarget.addEventListener` to confirm the task's completion.",
    "input": "",
    "output": "import {WorkerEventTarget, taskpool} from '@kit.ArkTS';\n\nexport function scheduleDelayedTask(): void {\n  const eventTarget = new WorkerEventTarget();\n  \n  const task = () => {\n    console.log('Delayed task executed');\n    const event = { type: 'taskCompleted', data: 'Task completed successfully' };\n    eventTarget.dispatchEvent(event);\n  };\n  \n  taskpool.executeDelayed(task, 1000, taskpool.Priority.HIGH).then(() => {\n    console.log('Task scheduled');\n  }).catch((error) => {\n    console.error('Error scheduling task:', error);\n  });\n  \n  eventTarget.addEventListener('taskCompleted', (event) => {\n    console.log('Event received:', event.data);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that starts a periodic task using `taskpool.executePeriodically` and uses `WorkerEventTarget.addEventListener` to listen for progress updates. If the task encounters an error (handled via `CallbackFunctionWithError`), it should dispatch an error event, which the listener should catch and handle by calling `taskpool.cancel` to stop the periodic execution.",
    "input": "",
    "output": "import {WorkerEventTarget, taskpool} from '@kit.ArkTS';\n\nexport function startPeriodicTaskWithErrorHandling(\n  task: taskpool.CallbackFunctionWithError,\n  interval: number,\n  eventTarget: WorkerEventTarget\n): void {\n  const taskId = taskpool.executePeriodically(task, interval);\n\n  eventTarget.addEventListener('error', (errorEvent: ErrorEvent) => {\n    console.error('Error in periodic task:', errorEvent.message);\n    taskpool.cancel(taskId);\n  });\n\n  eventTarget.addEventListener('progress', (progressEvent: Event) => {\n    console.log('Progress update:', progressEvent);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that listens for a `MessageEvent` and extracts the `data` property containing XML content. Then, parse the XML content using the `xml` API's `EventType` enum to determine the type of event and log it accordingly.",
    "input": "",
    "output": "import {MessageEvent, xml} from '@kit.ArkTS';\n\nexport function parseXmlMessageEvent(event: MessageEvent<string>): void {\n  const xmlContent = event.data;\n  const parser = new xml.XmlPullParser(xmlContent);\n  \n  while (parser.next() !== xml.EventType.END_DOCUMENT) {\n    const eventType = parser.getEventType();\n    \n    switch (eventType) {\n      case xml.EventType.START_DOCUMENT:\n        console.log('Start Document');\n        break;\n      case xml.EventType.END_DOCUMENT:\n        console.log('End Document');\n        break;\n      case xml.EventType.START_TAG:\n        console.log('Start Tag: ' + parser.getName());\n        break;\n      case xml.EventType.END_TAG:\n        console.log('End Tag: ' + parser.getName());\n        break;\n      case xml.EventType.TEXT:\n        console.log('Text: ' + parser.getText());\n        break;\n      default:\n        console.log('Unknown Event Type');\n        break;\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that generates an XML string representing a message, then wraps this XML string in a `MessageEvent` object. Use the `data` property of the `MessageEvent` to pass the XML string to another function that validates the XML structure using the `xml` API's `EventType` enum.",
    "input": "",
    "output": "import {MessageEvent, xml} from '@kit.ArkTS';\n\nexport function generateXmlMessage(): string {\n  return '<message><content>Hello, World!</content></message>';\n}\n\nexport function createMessageEvent(xmlString: string): MessageEvent<string> {\n  return new MessageEvent('message', { data: xmlString });\n}\n\nexport function validateXmlStructure(event: MessageEvent<string>): boolean {\n  try {\n    const parser = new xml.XmlPullParser(event.data);\n    let eventType = parser.getEventType();\n    \n    while (eventType !== xml.EventType.END_DOCUMENT) {\n      if (eventType === xml.EventType.START_TAG) {\n        const tagName = parser.getName();\n        if (tagName !== 'message' && tagName !== 'content') {\n          return false;\n        }\n      }\n      eventType = parser.next();\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport function processXmlMessage(): boolean {\n  const xmlString = generateXmlMessage();\n  const messageEvent = createMessageEvent(xmlString);\n  return validateXmlStructure(messageEvent);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that processes a `MessageEvent` by checking its `data` property for XML content. If the XML content matches a specific `EventType` from the `xml` API, trigger a corresponding action (e.g., logging, updating UI).",
    "input": "",
    "output": "import {MessageEvent, xml} from '@kit.ArkTS';\n\nexport function processMessageEvent(event: MessageEvent<string>): void {\n  try {\n    const xmlData = event.data;\n    const parsedXml = xml.parse(xmlData);\n    \n    if (parsedXml.eventType === xml.EventType.LOG) {\n      console.log('Log event triggered:', parsedXml);\n    } else if (parsedXml.eventType === xml.EventType.UI_UPDATE) {\n      console.log('UI update event triggered:', parsedXml);\n    } else {\n      console.log('Unknown event type:', parsedXml.eventType);\n    }\n  } catch (error) {\n    console.error('Error processing XML data:', error);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a buffer from a string encoded in UTF-8, then checks if the buffer is valid using `buffer.isBuffer`, and finally logs the `type` and `timeStamp` properties of an `Event` object triggered after the buffer validation.",
    "input": "",
    "output": "import {Event, buffer} from '@kit.ArkTS';\n\nexport function processBufferAndEvent(inputString: string, event: Event): void {\n  const buf = buffer.from(inputString, 'utf-8');\n  const isValidBuffer = buffer.isBuffer(buf);\n  if (isValidBuffer) {\n    console.log(`Event type: ${event.type}, timestamp: ${event.timeStamp}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `buffer.alloc` to allocate a new buffer of a specified size, then fills it with data from another buffer using `buffer.concat`, and triggers an `Event` with the concatenated buffer's `byteLength` as part of the event's properties.",
    "input": "",
    "output": "import {Event, buffer} from '@kit.ArkTS';\n\nexport function concatenateAndTriggerEvent(size: number, sourceBuffer: buffer.Buffer): void {\n  const newBuffer = buffer.alloc(size);\n  const concatenatedBuffer = buffer.concat([newBuffer, sourceBuffer]);\n  \n  const event = new Event('bufferConcatenated');\n  event.timeStamp = Date.now();\n  event['byteLength'] = concatenatedBuffer.byteLength;\n  \n  // Trigger the event (assuming there's an event emitter mechanism)\n  // In a real scenario, you would use an EventEmitter or similar\n  // For this example, we'll just create and return the event\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes two strings, converts them to buffers using `buffer.from` with different encodings (e.g., UTF-8 and ASCII), compares them using `buffer.compare`, and emits an `Event` with the comparison result and the current `timeStamp`.",
    "input": "",
    "output": "import {Event, buffer} from '@kit.ArkTS';\n\nexport function compareStringsWithDifferentEncodings(str1: string, str2: string): Event {\n  const buf1 = buffer.from(str1, 'utf-8');\n  const buf2 = buffer.from(str2, 'ascii');\n  const comparisonResult = buffer.compare(buf1, buf2);\n  \n  const event = new Event('comparisonResult');\n  event.timeStamp = Date.now();\n  \n  return event;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to asynchronously process a large dataset stored in a `Vector`. The function should first populate the `Vector` using its `add` method, then pass the `Vector` to `taskpool.execute` for parallel processing, and finally use the `Vector`'s `convertToArray` method to return the processed results as an array.",
    "input": "",
    "output": "import {taskpool, Vector} from '@kit.ArkTS';\n\nexport async function processLargeDataset(): Promise<number[]> {\n  const vector = new Vector<number>();\n  \n  // Populate the vector with sample data\n  for (let i = 0; i < 1000; i++) {\n    vector.add(i);\n  }\n  \n  // Define the processing function\n  const processData = (data: Vector<number>): Vector<number> => {\n    const processedVector = new Vector<number>();\n    for (let i = 0; i < data.length; i++) {\n      processedVector.add(data.get(i) * 2); // Example processing: multiply each element by 2\n    }\n    return processedVector;\n  };\n  \n  // Execute the processing in parallel using taskpool\n  const task = new taskpool.Task(processData, vector);\n  const processedVector = await taskpool.execute(task) as Vector<number>;\n  \n  // Convert the processed vector to an array and return\n  return processedVector.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `executePeriodically` method of `taskpool` to periodically update a `Vector` with new elements. The function should use the `Vector`'s `insert` method to add elements at specific positions and the `getLastElement` method to check the latest entry. The `taskpool` should stop execution when the `Vector`'s `length` property reaches a specified maximum size.",
    "input": "",
    "output": "import {taskpool, Vector} from '@kit.ArkTS';\n\nexport function periodicallyUpdateVector(maxSize: number, interval: number): void {\n  const vec = new Vector<number>();\n  let taskId: number;\n\n  const task = () => {\n    if (vec.length >= maxSize) {\n      taskpool.cancel(taskId);\n      return;\n    }\n\n    const lastElement = vec.isEmpty() ? 0 : vec.getLastElement();\n    const newElement = lastElement + 1;\n    const insertPosition = vec.length % 2 === 0 ? 0 : vec.length;\n    vec.insert(newElement, insertPosition);\n  };\n\n  taskId = taskpool.executePeriodically(task, interval, false);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getTaskPoolInfo` method of `taskpool` to monitor the state of concurrent tasks and dynamically adjust the capacity of a `Vector` based on the task load. The function should use the `Vector`'s `increaseCapacityTo` method to resize the `Vector` when the task pool is busy and the `trimToCurrentLength` method to optimize memory usage when the task pool is idle.",
    "input": "",
    "output": "import {taskpool, Vector} from '@kit.ArkTS';\n\nexport function monitorAndAdjustVector(vector: Vector<number>): void {\n  const taskPoolInfo = taskpool.getTaskPoolInfo();\n  const isBusy = taskPoolInfo.state === taskpool.State.RUNNING || taskPoolInfo.state === taskpool.State.BUSY;\n  \n  if (isBusy) {\n    const currentCapacity = vector.getCapacity();\n    vector.increaseCapacityTo(currentCapacity * 2);\n  } else {\n    vector.trimToCurrentLength();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of event names, then iterates through the stack using `forEach` to register each event name as a listener using `addEventListener` of `WorkerEventTarget` (from @kit.ArkTS). Finally, dispatch the events using `dispatchEvent`.",
    "input": "",
    "output": "import {WorkerEventTarget, Stack} from '@kit.ArkTS';\n\nexport function registerAndDispatchEvents(eventNames: string[], target: WorkerEventTarget): void {\n  const stack = new Stack<string>();\n  \n  eventNames.forEach((eventName) => {\n    stack.push(eventName);\n  });\n  \n  stack.forEach((eventName) => {\n    target.addEventListener(eventName, () => {\n      console.log(`Event ${eventName} triggered`);\n    });\n  });\n  \n  stack.forEach((eventName) => {\n    target.dispatchEvent(eventName);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the topmost event name, then removes it using `pop` and triggers that event using `dispatchEvent` of `WorkerEventTarget` (from @kit.ArkTS). Repeat this process until the stack is empty (checked via `isEmpty`).",
    "input": "",
    "output": "import {WorkerEventTarget, Stack} from '@kit.ArkTS';\n\nexport function processStackEvents(stack: Stack<string>, eventTarget: WorkerEventTarget): void {\n  while (!stack.isEmpty()) {\n    const eventName = stack.peek();\n    stack.pop();\n    eventTarget.dispatchEvent(eventName);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task where you use the `locate` method of `Stack` (from @kit.ArkTS) to find the position of a specific event name, then use `removeEventListener` of `WorkerEventTarget` (from @kit.ArkTS) to unregister that event if it exists in the stack. Ensure the stack's `length` property is updated and verified after removal.",
    "input": "",
    "output": "import {WorkerEventTarget, Stack} from '@kit.ArkTS';\n\nexport function unregisterEventIfExists(eventName: string, eventStack: Stack<string>, eventTarget: WorkerEventTarget): void {\n  const position = eventStack.locate(eventName);\n  if (position !== -1) {\n    eventTarget.removeEventListener(eventName);\n    eventStack.pop();\n  }\n}\n\nexport function verifyStackLength(eventStack: Stack<string>): number {\n  return eventStack.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of JSON strings, then parses each string using `json.parse` and stores the parsed objects in a new `LinkedList`. Finally, use the `convertToArray` method of `LinkedList` to return the array of parsed objects.",
    "input": "",
    "output": "import {LinkedList, json} from '@kit.ArkTS';\n\nexport function parseJsonStrings(jsonStrings: LinkedList<string>): object[] {\n  const parsedObjects = new LinkedList<object>();\n  \n  for (const jsonString of jsonStrings) {\n    const parsedObject = json.parse(jsonString);\n    parsedObjects.add(parsedObject);\n  }\n  \n  return parsedObjects.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes a `LinkedList` of objects and uses the `json.stringify` method to convert each object to a JSON string. Then, use the `removeFirstFound` method of `LinkedList` to remove any string that matches a given pattern, and return the modified `LinkedList` using the `get` method to verify the remaining elements.",
    "input": "",
    "output": "import {LinkedList, json} from '@kit.ArkTS';\n\nexport function processLinkedList(linkedList: LinkedList<object>, pattern: string): LinkedList<string> {\n  const jsonStrings = new LinkedList<string>();\n  \n  for (const obj of linkedList) {\n    const jsonString = json.stringify(obj);\n    jsonStrings.add(jsonString);\n  }\n  \n  jsonStrings.removeFirstFound(pattern);\n  \n  return jsonStrings;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list, then combines these elements into a new object and converts it to a JSON string using `json.stringify`. The function should then parse this string back into an object using `json.parse` and return the result.",
    "input": "",
    "output": "import {LinkedList, json} from '@kit.ArkTS';\n\nexport function combineFirstAndLast(list: LinkedList<string>): {first: string, last: string} {\n  const firstElement = list.getFirst();\n  const lastElement = list.getLast();\n  const combinedObject = {first: firstElement, last: lastElement};\n  const jsonString = json.stringify(combinedObject);\n  return json.parse(jsonString);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a new Worker using the `WorkerOptions` API with a specified `name` property, then checks if the Worker is shared by accessing the `shared` property of `WorkerOptions`. Use the results to log the Worker's configuration details.",
    "input": "",
    "output": "import { Worker, WorkerOptions } from '@kit.ArkTS';\n\nexport function createAndCheckWorker(workerName: string): void {\n  const options: WorkerOptions = {\n    name: workerName,\n    shared: false\n  };\n\n  const worker = new Worker('workers/worker.ts', options);\n  \n  console.log(`Worker name: ${options.name}`);\n  console.log(`Is shared worker: ${options.shared}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes two Worker instances using `WorkerOptions` with different `name` properties, then compares their `shared` properties to determine if they can share data. Use the comparison result to enable or disable a data-sharing feature between the Workers.",
    "input": "",
    "output": "import { Worker, WorkerOptions } from '@kit.ArkTS';\n\nexport function initializeWorkersAndCheckDataSharing(): boolean {\n  const options1: WorkerOptions = {\n    name: 'worker1',\n    shared: true\n  };\n\n  const options2: WorkerOptions = {\n    name: 'worker2',\n    shared: true\n  };\n\n  const worker1 = new Worker('worker1', options1);\n  const worker2 = new Worker('worker2', options2);\n\n  const canShareData = options1.shared && options2.shared;\n\n  worker1.terminate();\n  worker2.terminate();\n\n  return canShareData;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that dynamically generates a Worker configuration object using the `name` and `shared` properties of `WorkerOptions`, then passes this object to another API (e.g., a Worker manager) to spawn and manage the Worker instance based on the provided settings.",
    "input": "",
    "output": "import {WorkerOptions} from '@kit.ArkTS';\n\nexport function generateWorkerConfig(name: string, shared: boolean): WorkerOptions {\n  return {\n    name: name,\n    shared: shared\n  };\n}\n\nexport class WorkerManager {\n  private workerOptions: WorkerOptions;\n\n  constructor(options: WorkerOptions) {\n    this.workerOptions = options;\n  }\n\n  public spawnWorker(): void {\n    // Implementation to spawn and manage the Worker instance based on the provided settings\n    // This is a placeholder for the actual Worker spawning logic\n    console.log(`Spawning worker with name: ${this.workerOptions.name} and shared: ${this.workerOptions.shared}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to run a computationally intensive task in the background with `Priority.HIGH`, and then uses `WorkerEventTarget.addEventListener` to listen for the task's completion event. Once the event is received, use `taskpool.getTaskPoolInfo` to log the current task pool state.",
    "input": "",
    "output": "import {taskpool, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function runIntensiveTaskWithHighPriority() {\n  const workerEventTarget = new WorkerEventTarget();\n  \n  const task = () => {\n    // Simulate a computationally intensive task\n    let sum = 0;\n    for (let i = 0; i < 1000000000; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n  \n  workerEventTarget.addEventListener('taskCompleted', (event) => {\n    const taskPoolInfo = taskpool.getTaskPoolInfo();\n    console.log('Task pool state:', taskPoolInfo);\n  });\n  \n  taskpool.execute(task, taskpool.Priority.HIGH).then((result) => {\n    workerEventTarget.dispatchEvent({ type: 'taskCompleted', data: result });\n  }).catch((error) => {\n    console.error('Task execution failed:', error);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that schedules a delayed task using `taskpool.executeDelayed` with a 5-second delay. Use `WorkerEventTarget.addEventListener` to listen for a cancellation signal (e.g., a user action). If the signal is received before the task starts, cancel the task using `taskpool.cancel` and log the cancellation status.",
    "input": "",
    "output": "import {taskpool, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function scheduleDelayedTaskWithCancellation(eventTarget: WorkerEventTarget): void {\n  const task: taskpool.Task = new taskpool.Task(() => {\n    console.log('Task executed after delay');\n  });\n\n  const taskId: number = taskpool.executeDelayed(task, 5000);\n\n  const cancellationListener = () => {\n    const isCancelled: boolean = taskpool.cancel(taskId);\n    console.log(`Task cancellation status: ${isCancelled}`);\n    eventTarget.removeEventListener('cancel', cancellationListener);\n  };\n\n  eventTarget.addEventListener('cancel', cancellationListener);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a periodic task using `taskpool.executePeriodically` that runs every 3 seconds. Use `WorkerEventTarget.addEventListener` to listen for a stop signal. When the signal is received, use `taskpool.terminateTask` to stop the periodic execution and log the termination status.",
    "input": "",
    "output": "import {taskpool, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function startPeriodicTask(): void {\n  const workerEventTarget = new WorkerEventTarget();\n  const taskId = taskpool.executePeriodically(() => {\n    console.log('Periodic task executed');\n  }, 3000);\n\n  workerEventTarget.addEventListener('stop', () => {\n    const status = taskpool.terminateTask(taskId);\n    console.log(`Task terminated with status: ${status}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a `WorkerEventTarget` instance and uses its `addEventListener` method to listen for a custom event. Then, use the `worker` API to post a message to a worker thread, which should trigger the custom event. Finally, use `dispatchEvent` from `WorkerEventTarget` to propagate the event after receiving the worker's response.",
    "input": "",
    "output": "import {WorkerEventTarget, worker} from '@kit.ArkTS';\n\nexport function setupWorkerEventTarget(): void {\n  const eventTarget = new WorkerEventTarget();\n  \n  eventTarget.addEventListener('customEvent', (event: Event) => {\n    console.log('Custom event triggered:', event.type);\n  });\n  \n  const workerInstance = new worker.ThreadWorker('workers/worker.ts');\n  \n  workerInstance.postMessage('triggerEvent');\n  \n  workerInstance.onmessage = (message: MessageEvent) => {\n    if (message.data === 'eventTriggered') {\n      const customEvent = new Event('customEvent');\n      eventTarget.dispatchEvent(customEvent);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that sets up a `WorkerEventTarget` instance to listen for multiple events using `addEventListener`. Use the `worker` API to send data to a worker thread, and upon receiving a response, use `removeEventListener` to clean up specific event listeners while keeping others active. Ensure the remaining listeners can still handle subsequent events.",
    "input": "",
    "output": "import {WorkerEventTarget, worker} from '@kit.ArkTS';\n\nexport function setupWorkerEventListeners(workerTarget: WorkerEventTarget): void {\n  const messageHandler = (event: MessageEvent): void => {\n    console.log('Message received:', event.data);\n    workerTarget.removeEventListener('message', messageHandler);\n  };\n\n  const errorHandler = (event: ErrorEvent): void => {\n    console.error('Error occurred:', event.message);\n  };\n\n  workerTarget.addEventListener('message', messageHandler);\n  workerTarget.addEventListener('error', errorHandler);\n\n  worker.postMessage('Initial data');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that initializes a `WorkerEventTarget` and uses its `addEventListener` to register a callback for a 'task_complete' event. Use the `worker` API to delegate a heavy computation task to a worker thread. Once the worker completes the task and posts the result back, use `dispatchEvent` to emit the 'task_complete' event with the result, and then call `removeAllListener` to clean up all event listeners.",
    "input": "",
    "output": "import {WorkerEventTarget, worker} from '@kit.ArkTS';\n\nexport function initializeWorkerAndHandleEvent() {\n  const workerEventTarget = new WorkerEventTarget();\n  \n  workerEventTarget.addEventListener('task_complete', (event: CustomEvent) => {\n    console.log('Task completed with result:', event.detail);\n    workerEventTarget.removeAllListener();\n  });\n  \n  const workerInstance = new worker.ThreadWorker('scripts/worker.js');\n  \n  workerInstance.onmessage = (message: MessageEvent) => {\n    const event = new CustomEvent('task_complete', {\n      detail: message.data\n    });\n    workerEventTarget.dispatchEvent(event);\n  };\n  \n  workerInstance.postMessage('start_heavy_computation');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a sequence of numbers to a worker thread, where the worker thread uses the `add` and `getFirst` methods of `Queue` to process the numbers and return the first element of the queue back to the main thread using `postMessage`.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, Queue} from '@kit.ArkTS';\n\nexport function setupWorker() {\n  const worker = new ThreadWorkerGlobalScope();\n  const queue = new Queue<number>();\n\n  worker.onmessage = (message: MessageEvent<number[]>) => {\n    const numbers = message.data;\n    numbers.forEach((num) => {\n      queue.add(num);\n    });\n    const firstElement = queue.getFirst();\n    worker.postMessage(firstElement);\n  };\n\n  return worker;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that initializes a `Queue` object, uses its `forEach` method to iterate over the elements, and sends each element to the main thread using the `postMessage` method of `ThreadWorkerGlobalScope`. The main thread should then use the `onmessage` property of `ThreadWorkerGlobalScope` to receive and log each element.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, Queue} from '@kit.ArkTS';\n\nconst worker: ThreadWorkerGlobalScope = new ThreadWorkerGlobalScope();\nconst queue: Queue<number> = new Queue<number>();\n\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\n\nqueue.forEach((element: number) => {\n  worker.postMessage(element);\n});\n\nworker.onmessage = (message: MessageEvent<number>) => {\n  console.log(`Received element: ${message.data}`);\n};\n",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where the main thread sends a shared object to a worker thread using the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope`. The worker thread should use the `Queue`'s `add` method to enqueue the object, then use the `pop` method to dequeue it and send it back to the main thread using `postMessage`. The main thread should use the `onmessage` property to receive and process the returned object.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, Queue} from '@kit.ArkTS';\n\n// Main thread code\nexport function mainThreadCode(worker: ThreadWorkerGlobalScope): void {\n  const sharedObject = { data: 'Shared Object Data' };\n  worker.postMessageWithSharedSendable(sharedObject);\n\n  worker.onmessage = (message: Object) => {\n    console.log('Main thread received:', message);\n  };\n}\n\n// Worker thread code\nexport function workerThreadCode(self: ThreadWorkerGlobalScope): void {\n  self.onmessage = (message: Object) => {\n    const queue = new Queue<Object>();\n    queue.add(message);\n    const dequeuedObject = queue.pop();\n    self.postMessage(dequeuedObject);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `Event` API to track a series of timestamped events (using the `timeStamp` property) and then stores these timestamps in a `TreeSet` (using the `add` method). Finally, use the `getFirstValue` and `getLastValue` methods of `TreeSet` to determine the earliest and latest event timestamps.",
    "input": "",
    "output": "import {TreeSet, Event} from '@kit.ArkTS';\n\nexport function trackAndAnalyzeEvents(events: Event[]): {first: number, last: number} {\n  const timestampSet = new TreeSet<number>();\n  \n  for (const event of events) {\n    timestampSet.add(event.timeStamp);\n  }\n  \n  const first = timestampSet.getFirstValue();\n  const last = timestampSet.getLastValue();\n  \n  return {first, last};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that populates a `TreeSet` with a set of values (using the `add` method) and then iterates over them (using the `Symbol.iterator` method). For each value, generate an `Event` object (using the `type` property to categorize the event) and log the events in chronological order based on the `TreeSet`'s sorted values.",
    "input": "",
    "output": "import {TreeSet, Event} from '@kit.ArkTS';\n\nexport function populateAndLogEvents(): void {\n  const treeSet = new TreeSet<number>();\n  treeSet.add(3);\n  treeSet.add(1);\n  treeSet.add(4);\n  treeSet.add(2);\n\n  const events: Event[] = [];\n  for (const value of treeSet) {\n    const event: Event = {\n      timeStamp: Date.now(),\n      type: `Event for value ${value}`\n    };\n    events.push(event);\n  }\n\n  for (const event of events) {\n    console.log(`Event: ${event.type}, Timestamp: ${event.timeStamp}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if a `TreeSet` (using the `isEmpty` method) is empty. If it is not empty, use the `values` method to extract all values and pass them to a function that creates an `Event` for each value (using the `type` property to mark the event type). Then, use the `Event`'s `timeStamp` property to log the time of each event creation.",
    "input": "",
    "output": "import {TreeSet, Event} from '@kit.ArkTS';\n\nexport function checkAndProcessTreeSet(treeSet: TreeSet<number>, eventType: string): void {\n  if (!treeSet.isEmpty()) {\n    const values = treeSet.values();\n    for (const value of values) {\n      const event = new Event(eventType);\n      event.timeStamp = Date.now();\n      console.log(`Event created at: ${event.timeStamp}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `keys` method of `TreeMap` to retrieve all keys, then converts these keys into an XML string using the `xml` API's serialization methods. The function should return the XML string representing the keys.",
    "input": "",
    "output": "import {xml, TreeMap} from '@kit.ArkTS';\n\nexport function treeMapKeysToXml(treeMap: TreeMap<number | string, unknown>): string {\n  const keys = treeMap.keys();\n  const xmlBuilder = new xml.XmlSerializer();\n  const xmlElement = xmlBuilder.createElement('keys');\n  \n  for (const key of keys) {\n    const keyElement = xmlBuilder.createElement('key');\n    keyElement.setTextContent(key.toString());\n    xmlElement.appendChild(keyElement);\n  }\n  \n  return xmlBuilder.serializeToString(xmlElement);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that parses an XML string using the `xml` API to extract key-value pairs, then inserts these pairs into a `TreeMap` using its `set` method. The function should return the populated `TreeMap`.",
    "input": "",
    "output": "import {xml, TreeMap} from '@kit.ArkTS';\n\nexport function parseXmlToTreeMap(xmlString: string): TreeMap<string, string> {\n  const parsedXml = xml.parse(xmlString);\n  const treeMap = new TreeMap<string, string>();\n\n  if (parsedXml && typeof parsedXml === 'object') {\n    for (const key in parsedXml) {\n      if (Object.prototype.hasOwnProperty.call(parsedXml, key)) {\n        const value = parsedXml[key];\n        if (typeof value === 'string') {\n          treeMap.set(key, value);\n        }\n      }\n    }\n  }\n\n  return treeMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getFirstKey` and `getLastKey` methods of `TreeMap` to retrieve the smallest and largest keys, then generates an XML representation of these two keys using the `xml` API. The function should return the XML string containing the first and last keys.",
    "input": "",
    "output": "import {xml, TreeMap} from '@kit.ArkTS';\n\nexport function generateKeysXml<K, V>(treeMap: TreeMap<K, V>): string {\n  const firstKey = treeMap.getFirstKey();\n  const lastKey = treeMap.getLastKey();\n  \n  const xmlBuilder = new xml.Builder();\n  const rootElement = xmlBuilder.createElement('keys');\n  \n  const firstKeyElement = xmlBuilder.createElement('firstKey');\n  firstKeyElement.setTextContent(String(firstKey));\n  rootElement.appendChild(firstKeyElement);\n  \n  const lastKeyElement = xmlBuilder.createElement('lastKey');\n  lastKeyElement.setTextContent(String(lastKey));\n  rootElement.appendChild(lastKeyElement);\n  \n  return xmlBuilder.buildDocument(rootElement);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `set` method of `HashMap` to store error codes as keys and error messages as values, then uses the `message` property of `ErrorEvent` to update the corresponding error message in the `HashMap` if the error code already exists.",
    "input": "",
    "output": "import {HashMap, ErrorEvent} from '@kit.ArkTS';\n\nexport function updateErrorMap(errorMap: HashMap<number, string>, errorEvent: ErrorEvent): void {\n  const errorCode: number = errorEvent.error;\n  const errorMessage: string = errorEvent.message;\n  \n  if (errorMap.hasKey(errorCode)) {\n    errorMap.set(errorCode, errorMessage);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that iterates over the entries of a `HashMap` using the `Symbol.iterator` method, checks if any of the values match the `error` property of an `ErrorEvent` object, and if so, removes those entries using the `remove` method of `HashMap`.",
    "input": "",
    "output": "import {HashMap, ErrorEvent} from '@kit.ArkTS';\n\nexport function removeErrorEventMatches(map: HashMap<unknown, unknown>, errorEvent: ErrorEvent): void {\n  for (const [key, value] of map[Symbol.iterator]()) {\n    if (value === errorEvent.error) {\n      map.remove(key);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `HashMap` to log all key-value pairs where the key matches the `filename` property of an `ErrorEvent` object, and then uses the `clear` method of `HashMap` to remove all entries if the `lineno` property of the `ErrorEvent` exceeds a certain threshold.",
    "input": "",
    "output": "import {HashMap, ErrorEvent} from '@kit.ArkTS';\n\nexport function processErrorEventMap(map: HashMap<string, string>, errorEvent: ErrorEvent, threshold: number): void {\n  map.forEach((value: string, key: string) => {\n    if (key === errorEvent.filename) {\n      console.log(`Key: ${key}, Value: ${value}`);\n    }\n  });\n\n  if (errorEvent.lineno > threshold) {\n    map.clear();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `from` method of `buffer` to create a Buffer from a given string with 'utf8' encoding, then uses the `byteLength` method of `buffer` to calculate its size, and finally uses the `concat` method of `buffer` to combine it with another Buffer created from a second string. Return the resulting Buffer.",
    "input": "",
    "output": "import {buffer} from '@kit.ArkTS';\n\nexport function combineBuffers(str1: string, str2: string): buffer.Buffer {\n  const buf1: buffer.Buffer = buffer.from(str1, 'utf8');\n  const buf2: buffer.Buffer = buffer.from(str2, 'utf8');\n  const size: number = buffer.byteLength(str1, 'utf8');\n  const combinedBuffer: buffer.Buffer = buffer.concat([buf1, buf2]);\n  return combinedBuffer;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that takes two strings and an encoding type (of `BufferEncoding`). Use the `isEncoding` method of `buffer` to validate the encoding, then use the `from` method of `buffer` to create Buffers from both strings with the given encoding. Use the `compare` method of `buffer` to determine which string's Buffer is larger, and return the comparison result.",
    "input": "",
    "output": "import {buffer} from '@kit.ArkTS';\n\nexport function compareStringBuffers(str1: string, str2: string, encoding: buffer.BufferEncoding): number {\n  if (!buffer.isEncoding(encoding)) {\n    throw new Error('Invalid encoding type');\n  }\n\n  const buf1 = buffer.from(str1, encoding);\n  const buf2 = buffer.from(str2, encoding);\n\n  return buffer.compare(buf1, buf2);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `alloc` method of `buffer` to create a new Buffer of a specified size, then uses the `transcode` method of `buffer` to convert the Buffer from 'utf8' encoding to 'utf16le'. Finally, use the `isBuffer` method of `buffer` to verify the result is indeed a Buffer and return it.",
    "input": "",
    "output": "import {buffer} from '@kit.ArkTS';\n\nexport function createAndTranscodeBuffer(size: number): buffer.Buffer {\n  const utf8Buffer = buffer.alloc(size, 'utf8');\n  const utf16leBuffer = buffer.transcode(utf8Buffer, 'utf8', 'utf16le');\n  if (buffer.isBuffer(utf16leBuffer)) {\n    return utf16leBuffer;\n  }\n  throw new Error('Failed to transcode buffer');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a new worker thread using the `Worker` constructor (from @kit.ArkTS) with `WorkerOptions` (from @kit.ArkTS) specifying a unique `name` property, and then sends a message to the worker using the `postMessage` method of the `Worker` API to initiate a task.",
    "input": "",
    "output": "import {worker, WorkerOptions} from '@kit.ArkTS';\n\nexport function createAndStartWorker(scriptURL: string, workerName: string, taskMessage: string): void {\n  const options: WorkerOptions = {\n    name: workerName\n  };\n  const newWorker = new worker.ThreadWorker(scriptURL, options);\n  newWorker.postMessage(taskMessage);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that initializes a shared worker by passing a `WorkerOptions` object (from @kit.ArkTS) with the `shared` property set to `true`, then uses the `onmessage` event handler of the `Worker` API (from @kit.ArkTS) to listen for responses from the worker and process the received data.",
    "input": "",
    "output": "import {worker, WorkerOptions} from '@kit.ArkTS';\n\nexport function initializeSharedWorker(scriptURL: string): worker.Worker {\n  const options: WorkerOptions = {\n    shared: true\n  };\n  const sharedWorker = new worker.Worker(scriptURL, options);\n\n  sharedWorker.onmessage = (event: MessageEvent): void => {\n    const receivedData = event.data;\n    // Process the received data here\n    console.log('Received data from shared worker:', receivedData);\n  };\n\n  return sharedWorker;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that spawns multiple worker threads using the `Worker` API (from @kit.ArkTS), each configured with distinct `name` properties via `WorkerOptions` (from @kit.ArkTS), and then coordinates their tasks by using the `postMessage` and `onmessage` methods of the `Worker` API to exchange data between the main thread and the workers.",
    "input": "",
    "output": "import {worker, WorkerOptions} from '@kit.ArkTS';\n\nexport function spawnWorkers(workerScriptURL: string, workerNames: string[]): void {\n  const workers: worker.ThreadWorker[] = [];\n\n  workerNames.forEach((name) => {\n    const options: WorkerOptions = {\n      name: name\n    };\n    const newWorker = new worker.ThreadWorker(workerScriptURL, options);\n    \n    newWorker.onmessage = (message: MessageEvent) => {\n      console.log(`Message from worker ${name}:`, message.data);\n    };\n\n    newWorker.onerror = (error: ErrorEvent) => {\n      console.error(`Error from worker ${name}:`, error.message);\n    };\n\n    workers.push(newWorker);\n  });\n\n  workers.forEach((workerInstance, index) => {\n    workerInstance.postMessage({ task: `Task ${index + 1}` });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `EventTarget` instance, registers an event listener using `addEventListener` (from `EventTarget`), and then uses `getUidForName` (from `process`) to fetch the UID associated with the event name. The function should dispatch the event using `dispatchEvent` (from `EventTarget`) only if the UID is valid (i.e., not -1).",
    "input": "",
    "output": "import {EventTarget, process} from '@kit.ArkTS';\n\nexport function handleEventWithUidCheck(eventName: string): void {\n  const eventTarget = new EventTarget();\n  \n  eventTarget.addEventListener(eventName, () => {\n    console.log(`Event ${eventName} triggered`);\n  });\n  \n  const uid = process.getUidForName(eventName);\n  \n  if (uid !== -1) {\n    eventTarget.dispatchEvent(eventName);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `getEnvironmentVar` (from `process`) to retrieve the value of an environment variable, then creates an `EventTarget` instance and dispatches a custom event using `dispatchEvent` (from `EventTarget`) with the retrieved environment variable value as part of the event payload. The function should also log the event dispatch time using `getStartRealtime` (from `process`).",
    "input": "",
    "output": "import {EventTarget, process} from '@kit.ArkTS';\n\nexport function dispatchEnvVarEvent(envVarName: string): void {\n  const envVarValue = process.getEnvironmentVar(envVarName);\n  const eventTarget = new EventTarget();\n  const eventTime = process.getStartRealtime();\n  \n  const customEvent = {\n    type: 'envVarEvent',\n    detail: {\n      value: envVarValue,\n      time: eventTime\n    }\n  };\n  \n  eventTarget.dispatchEvent(customEvent);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that checks if the current process is 64-bit using `is64Bit` (from `process`). If it is, the function should create an `EventTarget` instance, register a one-time event listener using `addEventListener` (from `EventTarget`), and then exit the process using `exit` (from `process`) after the event is dispatched. The event listener should log the process uptime using `uptime` (from `process`) before exiting.",
    "input": "",
    "output": "import {EventTarget, process} from '@kit.ArkTS';\n\nexport function checkAndHandle64BitProcess(): void {\n  if (process.is64Bit()) {\n    const eventTarget = new EventTarget();\n    const eventType = 'exitEvent';\n    \n    const listener = () => {\n      console.log(`Process uptime: ${process.uptime()} seconds`);\n      process.exit(0);\n    };\n    \n    eventTarget.addEventListener(eventType, listener, { once: true });\n    eventTarget.dispatchEvent(eventType);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `ArrayList<string>` (from @kit.ArkTS) to collect a list of event types from user input, then passes this list to the `forEach` method of `ArrayList<string>` to log each event type along with its corresponding `timeStamp` property from the `Event` (from @kit.ArkTS) class, assuming each event type has a predefined timestamp.",
    "input": "",
    "output": "import {ArrayList, Event} from '@kit.ArkTS';\n\nexport function logEventTypesWithTimestamps(eventTypes: string[]): void {\n  const eventList: ArrayList<string> = new ArrayList();\n  \n  eventTypes.forEach((type: string) => {\n    eventList.add(type);\n  });\n  \n  eventList.forEach((type: string) => {\n    const event: Event = new Event();\n    event.type = type;\n    console.log(`Event Type: ${event.type}, Timestamp: ${event.timeStamp}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getIndexOf` method of `ArrayList<number>` (from @kit.ArkTS) to find the index of a specific value in the list, then uses this index to retrieve and modify the `type` property of an `Event` (from @kit.ArkTS) object stored at that index in a separate `ArrayList<Event>`.",
    "input": "",
    "output": "import {ArrayList, Event} from '@kit.ArkTS';\n\nexport function findAndModifyEventType(numberList: ArrayList<number>, eventList: ArrayList<Event>, targetValue: number, newType: string): void {\n  const index = numberList.getIndexOf(targetValue);\n  if (index !== -1 && index < eventList.length) {\n    const event = eventList.get(index);\n    if (event) {\n      event.type = newType;\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `sort` method of `ArrayList<Event>` (from @kit.ArkTS) to order events by their `timeStamp` property, then uses the `subArrayList` method to extract a subset of events within a specific time range and passes this subset to the `convertToArray` method for further processing.",
    "input": "",
    "output": "import {ArrayList, Event} from '@kit.ArkTS';\n\nexport function sortAndFilterEvents(events: ArrayList<Event>, startTime: number, endTime: number): Event[] {\n  // Sort events by timeStamp\n  events.sort((a: Event, b: Event) => a.timeStamp - b.timeStamp);\n\n  // Find the indices of events within the time range\n  let startIndex = -1;\n  let endIndex = -1;\n  for (let i = 0; i < events.length; i++) {\n    const event = events.get(i);\n    if (event.timeStamp >= startTime && startIndex === -1) {\n      startIndex = i;\n    }\n    if (event.timeStamp <= endTime) {\n      endIndex = i;\n    }\n  }\n\n  // Extract the sublist if valid indices are found\n  if (startIndex !== -1 && endIndex !== -1 && startIndex <= endIndex) {\n    const subList = events.subArrayList(startIndex, endIndex + 1);\n    return subList.convertToArray();\n  }\n\n  return [];\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that captures an error event using the `message` and `error` properties of `ErrorEvent`, then converts the error details into a JSON string using the `stringify` method of `json` for logging purposes.",
    "input": "",
    "output": "import {ErrorEvent, json} from '@kit.ArkTS';\n\nexport function logErrorEvent(event: ErrorEvent): string {\n  const errorDetails = {\n    message: event.message,\n    error: event.error,\n    filename: event.filename,\n    lineno: event.lineno,\n    colno: event.colno\n  };\n  return json.stringify(errorDetails);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that parses a JSON string using the `parse` method of `json`, checks if the parsed object contains a specific key using the `has` method of `json`, and if not, throws an error with details (filename, lineno) captured in an `ErrorEvent` object.",
    "input": "",
    "output": "import {ErrorEvent, json} from '@kit.ArkTS';\n\nexport function parseAndCheckKey(jsonString: string, key: string): Record<string, unknown> {\n  const parsedObject = json.parse(jsonString);\n  if (!json.has(parsedObject, key)) {\n    const errorEvent = new ErrorEvent('error', {\n      error: new Error(`Key '${key}' not found in JSON object`),\n      filename: __filename,\n      lineno: (new Error()).stack?.split('\\n')[1]?.match(/:(\\d+):\\d+\\)$/)?.pop() || '0',\n      message: `Key '${key}' not found in JSON object`\n    });\n    throw errorEvent.error;\n  }\n  return parsedObject;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that processes an array of error events (using `ErrorEvent` properties like `filename`, `lineno`, and `message`), filters out duplicate errors, and then converts the filtered array into a JSON string using the `stringify` method of `json` for storage.",
    "input": "",
    "output": "import {ErrorEvent, json} from '@kit.ArkTS';\n\nexport function processErrorEvents(errorEvents: ErrorEvent[]): string {\n  const uniqueErrors: ErrorEvent[] = [];\n  const seenErrors = new Set<string>();\n\n  for (const event of errorEvents) {\n    const errorKey = `${event.filename}:${event.lineno}:${event.message}`;\n    if (!seenErrors.has(errorKey)) {\n      seenErrors.add(errorKey);\n      uniqueErrors.push(event);\n    }\n  }\n\n  const filteredErrors = uniqueErrors.map(event => ({\n    filename: event.filename,\n    lineno: event.lineno,\n    message: event.message,\n    colno: event.colno,\n    error: event.error\n  }));\n\n  return json.stringify(filteredErrors);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then transfers all elements from the `Stack` to a `Queue` (from @kit.ArkTS) using the `pop` method of `Stack` and the `add` method of `Queue`. Finally, use the `getFirst` method of `Queue` to retrieve and return the first element added to the `Queue`.",
    "input": "",
    "output": "import {Stack, Queue} from '@kit.ArkTS';\n\nexport function transferStackToQueue(numbers: number[]): number | undefined {\n  const stack = new Stack<number>();\n  const queue = new Queue<number>();\n\n  numbers.forEach(num => stack.push(num));\n\n  while (!stack.isEmpty()) {\n    const poppedValue = stack.pop();\n    if (poppedValue !== undefined) {\n      queue.add(poppedValue);\n    }\n  }\n\n  return queue.getFirst();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `Queue` (from @kit.ArkTS) to iterate over its elements and apply a filter condition. For each element that meets the condition, use the `push` method of `Stack` (from @kit.ArkTS) to store it. Then, use the `peek` method of `Stack` to return the top element without removing it.",
    "input": "",
    "output": "import {Stack, Queue} from '@kit.ArkTS';\n\nexport function filterAndPeek(queue: Queue<number>, condition: (value: number) => boolean): number | undefined {\n  const stack = new Stack<number>();\n  queue.forEach((value: number) => {\n    if (condition(value)) {\n      stack.push(value);\n    }\n  });\n  return stack.peek();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that checks if a `Stack` (from @kit.ArkTS) and a `Queue` (from @kit.ArkTS) contain the same elements in the same order. Use the `pop` method of `Stack` and the `getFirst` method of `Queue` to compare elements sequentially. If all elements match, return `true`; otherwise, return `false`.",
    "input": "",
    "output": "import {Stack, Queue} from '@kit.ArkTS';\n\nexport function checkStackAndQueue(stack: Stack<number>, queue: Queue<number>): boolean {\n    if (stack.length !== queue.length) {\n        return false;\n    }\n\n    const tempStack = new Stack<number>();\n    let isEqual = true;\n\n    while (!stack.isEmpty()) {\n        const stackElement = stack.pop();\n        const queueElement = queue.getFirst();\n\n        if (stackElement !== queueElement) {\n            isEqual = false;\n            tempStack.push(stackElement);\n            break;\n        }\n\n        tempStack.push(stackElement);\n        queue.pop();\n    }\n\n    while (!tempStack.isEmpty()) {\n        stack.push(tempStack.pop());\n    }\n\n    return isEqual;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a series of tasks, then iterates through the queue using `Symbol.iterator` and passes each task to the `execute` method of `taskpool` with `Priority.HIGH` to process them concurrently.",
    "input": "",
    "output": "import {Queue, taskpool} from '@kit.ArkTS';\n\nexport function processTasksConcurrently(tasks: string[]): void {\n  const queue = new Queue<string>();\n  \n  // Enqueue tasks\n  for (const task of tasks) {\n    queue.add(task);\n  }\n  \n  // Process tasks concurrently\n  for (const task of queue) {\n    taskpool.execute(() => {\n      console.log(`Executing task: ${task}`);\n    }, taskpool.Priority.HIGH);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `getFirst` and `pop` methods of `Queue` to retrieve and remove tasks in order, then checks their execution status using `taskpool.State` before passing them to `taskpool.executeDelayed` if they are in `State.PENDING`.",
    "input": "",
    "output": "import {Queue, taskpool} from '@kit.ArkTS';\n\nexport function processTasks(queue: Queue<taskpool.Task>): void {\n  while (queue.length > 0) {\n    const task = queue.getFirst();\n    if (task.getState() === taskpool.State.PENDING) {\n      taskpool.executeDelayed(task, 0);\n    }\n    queue.pop();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task scheduler that uses `Queue.forEach` to iterate over a queue of callback functions, then executes each function with `taskpool.executePeriodically` while monitoring the queue's `length` property to dynamically adjust the task pool size using `taskpool.getTaskPoolInfo`.",
    "input": "",
    "output": "import {Queue, taskpool} from '@kit.ArkTS';\n\nexport class TaskScheduler {\n  private taskQueue: Queue<taskpool.CallbackFunction> = new Queue();\n  private taskHandles: Array<number> = [];\n\n  public addTask(callback: taskpool.CallbackFunction): void {\n    this.taskQueue.add(callback);\n  }\n\n  public startScheduler(): void {\n    this.taskQueue.forEach((callback: taskpool.CallbackFunction) => {\n      const handle = taskpool.executePeriodically(callback, 0, 0, taskpool.Priority.LOW);\n      this.taskHandles.push(handle);\n    });\n\n    this.adjustTaskPoolSize();\n  }\n\n  private adjustTaskPoolSize(): void {\n    const poolInfo = taskpool.getTaskPoolInfo();\n    const currentLength = this.taskQueue.length;\n    \n    if (currentLength > poolInfo.concurrency) {\n      const additionalTasks = currentLength - poolInfo.concurrency;\n      for (let i = 0; i < additionalTasks; i++) {\n        const callback = this.taskQueue.getFirst();\n        if (callback) {\n          const handle = taskpool.executePeriodically(callback, 0, 0, taskpool.Priority.LOW);\n          this.taskHandles.push(handle);\n        }\n      }\n    }\n  }\n\n  public stopScheduler(): void {\n    this.taskHandles.forEach((handle: number) => {\n      taskpool.cancel(handle);\n    });\n    this.taskHandles = [];\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` to collect a sequence of event names, then iterates through the stack using `forEach` to register each event name as a listener on a `WorkerEventTarget` instance using `addEventListener`. Finally, dispatch all events using `dispatchEvent` in the order they were pushed onto the stack.",
    "input": "",
    "output": "import {WorkerEventTarget, Stack} from '@kit.ArkTS';\n\nexport function registerAndDispatchEvents(eventNames: string[], workerEventTarget: WorkerEventTarget): void {\n  const stack = new Stack<string>();\n  \n  eventNames.forEach((eventName) => {\n    stack.push(eventName);\n  });\n  \n  stack.forEach((eventName) => {\n    workerEventTarget.addEventListener(eventName, () => {});\n  });\n  \n  while (!stack.isEmpty()) {\n    const eventName = stack.pop();\n    if (eventName) {\n      workerEventTarget.dispatchEvent(eventName);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `Stack` with a set of values using `push`, then uses the `Symbol.iterator` method to iterate through the stack and pass each value to a `WorkerEventTarget`'s `dispatchEvent` method. Ensure the stack is emptied using `pop` after each event is dispatched, and verify the stack is empty using `isEmpty` at the end.",
    "input": "",
    "output": "import {WorkerEventTarget, Stack} from '@kit.ArkTS';\n\nexport function initializeAndDispatchEvents(values: number[]): void {\n  const stack = new Stack<number>();\n  const workerEventTarget = new WorkerEventTarget();\n\n  // Initialize stack with values\n  values.forEach(value => stack.push(value));\n\n  // Iterate through the stack using Symbol.iterator\n  for (const value of stack[Symbol.iterator]()) {\n    workerEventTarget.dispatchEvent(value.toString());\n    stack.pop();\n  }\n\n  // Verify stack is empty\n  if (!stack.isEmpty()) {\n    throw new Error('Stack is not empty after dispatching all events');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `WorkerEventTarget`'s `addEventListener` to listen for a custom event, and upon triggering, pushes the event data onto a `Stack` using `push`. Then, use the `peek` method to check the top value of the stack and `removeEventListener` to clean up the listener once the stack's `length` reaches a specified limit.",
    "input": "",
    "output": "import {WorkerEventTarget, Stack} from '@kit.ArkTS';\n\nexport function listenAndPushEvents(eventTarget: WorkerEventTarget, eventName: string, limit: number): void {\n  const stack = new Stack<unknown>();\n\n  const eventListener = (event: Event) => {\n    const customEvent = event as CustomEvent;\n    stack.push(customEvent.detail);\n\n    if (stack.length >= limit) {\n      const topValue = stack.peek();\n      console.log(`Top value of stack: ${topValue}`);\n      eventTarget.removeEventListener(eventName, eventListener);\n    }\n  };\n\n  eventTarget.addEventListener(eventName, eventListener);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a new Worker with a specified `name` (using `WorkerOptions` property) and then uses the `addEventListener` method of `EventTarget` to listen for messages from the worker. The function should dispatch a custom event when a specific message is received.",
    "input": "",
    "output": "import {EventTarget, WorkerOptions} from '@kit.ArkTS';\n\nexport function createWorkerWithListener(workerScriptURL: string, workerName: string, targetEvent: string, specificMessage: string): void {\n  const options: WorkerOptions = {\n    name: workerName\n  };\n  \n  const worker = new Worker(workerScriptURL, options);\n  const eventTarget = new EventTarget();\n  \n  worker.addEventListener('message', (event: MessageEvent) => {\n    if (event.data === specificMessage) {\n      const customEvent = {\n        type: targetEvent,\n        detail: event.data\n      };\n      eventTarget.dispatchEvent(customEvent);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that configures a Worker with `shared` set to true (using `WorkerOptions` property) and then uses the `dispatchEvent` method of `EventTarget` to send a custom event to the worker. The function should also use `removeEventListener` to clean up the event listener after the event is handled.",
    "input": "",
    "output": "import {EventTarget, WorkerOptions} from '@kit.ArkTS';\n\nexport function configureWorkerWithShared(): void {\n  const workerOptions: WorkerOptions = {\n    shared: true\n  };\n\n  const worker = new Worker('worker.js', workerOptions);\n  const eventTarget = new EventTarget();\n\n  const eventListener = (event: Event): void => {\n    console.log('Custom event received:', event.type);\n    eventTarget.removeEventListener('customEvent', eventListener);\n  };\n\n  eventTarget.addEventListener('customEvent', eventListener);\n  const customEvent = new Event('customEvent');\n  eventTarget.dispatchEvent(customEvent);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that initializes a Worker with a unique `name` (using `WorkerOptions` property) and then uses the `removeAllListener` method of `EventTarget` to remove all event listeners associated with the worker before terminating it. The function should ensure no residual listeners remain.",
    "input": "",
    "output": "import {EventTarget, WorkerOptions} from '@kit.ArkTS';\n\nexport function initializeAndTerminateWorker(workerScriptURL: string, workerName: string): void {\n  const options: WorkerOptions = {\n    name: workerName\n  };\n  const worker = new Worker(workerScriptURL, options);\n  (worker as unknown as EventTarget).removeAllListener();\n  worker.terminate();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a `TreeMap` object (created using the `constructor` and populated with `set` method) to a worker thread, and then processes the received `TreeMap` in the worker thread using the `forEach` method to log all key-value pairs.",
    "input": "",
    "output": "import {TreeMap, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendTreeMapToWorker(worker: ThreadWorkerGlobalScope): void {\n  const treeMap = new TreeMap<string, string>();\n  treeMap.set('key1', 'value1');\n  treeMap.set('key2', 'value2');\n  treeMap.set('key3', 'value3');\n  worker.postMessage(treeMap);\n}\n\nexport function processTreeMapInWorker(): void {\n  const workerScope = self as unknown as ThreadWorkerGlobalScope;\n  workerScope.onmessage = (event: MessageEvent<TreeMap<string, string>>): void => {\n    const receivedTreeMap = event.data;\n    receivedTreeMap.forEach((value: string, key: string): void => {\n      console.log(`Key: ${key}, Value: ${value}`);\n    });\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first constructs a `TreeMap` using the `constructor` and populates it with data using the `setAll` method, then passes this `TreeMap` to a worker thread via `postMessageWithSharedSendable` of `ThreadWorkerGlobalScope`. In the worker thread, use the `getFirstKey` and `getLastKey` methods of `TreeMap` to determine the range of keys and send the result back to the main thread using `postMessage`.",
    "input": "",
    "output": "import {TreeMap, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createAndSendTreeMapToWorker(): void {\n  const treeMap = new TreeMap<number, string>();\n  treeMap.setAll(new TreeMap<number, string>([[1, 'one'], [2, 'two'], [3, 'three']]));\n  \n  const worker = new ThreadWorkerGlobalScope('workers/worker.ts');\n  worker.postMessageWithSharedSendable(treeMap);\n}\n\nexport function handleTreeMapInWorker(): void {\n  const workerScope = new ThreadWorkerGlobalScope('workers/worker.ts');\n  workerScope.onmessage = (message: {data: TreeMap<number, string>}) => {\n    const treeMap = message.data;\n    const firstKey = treeMap.getFirstKey();\n    const lastKey = treeMap.getLastKey();\n    workerScope.postMessage({firstKey, lastKey});\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a worker thread receives a `TreeMap` object via the `onmessage` property of `ThreadWorkerGlobalScope`, uses the `entries` method of `TreeMap` to iterate over its entries, processes the data (e.g., filtering or transforming), and then sends the modified `TreeMap` back to the main thread using the `postMessage` method.",
    "input": "",
    "output": "import {TreeMap, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processTreeMap(workerScope: ThreadWorkerGlobalScope): void {\n  workerScope.onmessage = (message: {data: TreeMap<number, string>}): void => {\n    const receivedTreeMap: TreeMap<number, string> = message.data;\n    const processedTreeMap: TreeMap<number, string> = new TreeMap<number, string>();\n    \n    for (const [key, value] of receivedTreeMap.entries()) {\n      // Example processing: transform values to uppercase\n      processedTreeMap.set(key, value.toUpperCase());\n    }\n    \n    workerScope.postMessage(processedTreeMap);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a `worker` thread to perform a computationally intensive task (e.g., calculating Fibonacci numbers). Use `EventTarget.addEventListener` to listen for messages from the worker, and `EventTarget.dispatchEvent` to notify the main thread when the task is complete. The worker should use `postMessage` to send results back to the main thread.",
    "input": "",
    "output": "import {worker, EventTarget} from '@kit.ArkTS';\n\nexport function createWorkerForFibonacci(n: number): void {\n  const workerInstance = new worker.ThreadWorker('workers/worker.js');\n  const eventTarget = new EventTarget();\n\n  workerInstance.onmessage = (e: MessageEvent<number>) => {\n    const result = e.data;\n    const event = { type: 'complete', data: result };\n    eventTarget.dispatchEvent(event);\n    workerInstance.terminate();\n  };\n\n  eventTarget.addEventListener('complete', (e: { type: string, data: number }) => {\n    console.log(`Fibonacci result: ${e.data}`);\n  });\n\n  workerInstance.postMessage(n);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task queue where the main thread uses `EventTarget.addEventListener` to listen for custom events (e.g., 'taskAdded') and dispatches tasks to a `worker` thread for processing. The worker should use `postMessage` to send task results back to the main thread, which then uses `EventTarget.dispatchEvent` to notify other parts of the application of the completed task.",
    "input": "",
    "output": "import {worker, EventTarget} from '@kit.ArkTS';\n\nexport class TaskQueue {\n  private workerInstance: worker.ThreadWorker;\n  private eventTarget: EventTarget;\n\n  constructor() {\n    this.eventTarget = new EventTarget();\n    this.workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n    this.setupWorkerListeners();\n  }\n\n  private setupWorkerListeners(): void {\n    this.workerInstance.onmessage = (message: worker.MessageEvents): void => {\n      this.eventTarget.dispatchEvent(new CustomEvent('taskCompleted', { detail: message.data }));\n    };\n\n    this.workerInstance.onerror = (error: Error): void => {\n      this.eventTarget.dispatchEvent(new CustomEvent('taskError', { detail: error.message }));\n    };\n  }\n\n  public addTask(task: string): void {\n    this.workerInstance.postMessage(task);\n    this.eventTarget.dispatchEvent(new CustomEvent('taskAdded', { detail: task }));\n  }\n\n  public addEventListener(type: string, listener: (event: Event) => void): void {\n    this.eventTarget.addEventListener(type, listener);\n  }\n\n  public removeEventListener(type: string, listener: (event: Event) => void): void {\n    this.eventTarget.removeEventListener(type, listener);\n  }\n\n  public destroy(): void {\n    this.workerInstance.terminate();\n    this.eventTarget.removeAllListener();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function where a `worker` thread monitors a resource (e.g., a file or network status) and sends updates to the main thread via `postMessage`. The main thread should use `EventTarget.addEventListener` to listen for these updates and `EventTarget.removeEventListener` to stop listening when the resource is no longer needed. The worker should terminate itself using `worker.terminate` once the monitoring is complete.",
    "input": "",
    "output": "import {worker, EventTarget} from '@kit.ArkTS';\n\nexport function startResourceMonitoring(resourcePath: string): void {\n  const workerInstance = new worker.ThreadWorker('scripts/worker.js');\n  const eventTarget = new EventTarget();\n\n  workerInstance.onmessage = (event: MessageEvent): void => {\n    eventTarget.dispatchEvent(new CustomEvent('resourceUpdate', { detail: event.data }));\n  };\n\n  workerInstance.onerror = (event: ErrorEvent): void => {\n    eventTarget.dispatchEvent(new CustomEvent('error', { detail: event.message }));\n  };\n\n  workerInstance.postMessage({ command: 'start', path: resourcePath });\n\n  const updateListener = (event: CustomEvent): void => {\n    console.log('Resource update:', event.detail);\n  };\n\n  const errorListener = (event: CustomEvent): void => {\n    console.error('Error:', event.detail);\n  };\n\n  eventTarget.addEventListener('resourceUpdate', updateListener);\n  eventTarget.addEventListener('error', errorListener);\n\n  const stopMonitoring = (): void => {\n    eventTarget.removeEventListener('resourceUpdate', updateListener);\n    eventTarget.removeEventListener('error', errorListener);\n    workerInstance.terminate();\n  };\n\n  // Example usage: stop monitoring after 10 seconds\n  setTimeout(() => {\n    stopMonitoring();\n  }, 10000);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `worker` API to spawn a new worker thread, then uses the `buffer.from` method to create a buffer containing a string message, and finally sends this buffer to the worker thread using the `worker.postMessage` method.",
    "input": "",
    "output": "import {worker, buffer} from '@kit.ArkTS';\n\nexport function spawnWorkerAndSendMessage(): void {\n  const workerInstance = new worker.ThreadWorker('workers/worker.ts');\n  const message: string = 'Hello from main thread!';\n  const messageBuffer: buffer.Buffer = buffer.from(message, 'utf-8');\n  workerInstance.postMessage(messageBuffer);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `buffer.alloc` method to allocate a buffer of a specified size, then fills it with data using the `buffer.from` method, and finally passes this buffer to a worker thread (using the `worker` API) for processing, ensuring the worker thread receives the buffer via `worker.postMessage`.",
    "input": "",
    "output": "import {worker, buffer} from '@kit.ArkTS';\n\nexport function processBufferInWorker(size: number, data: string | number[] | ArrayBuffer): void {\n  const allocatedBuffer = buffer.alloc(size);\n  const filledBuffer = buffer.from(data);\n  \n  const workerInstance = new worker.ThreadWorker('entry/ets/workers/worker.ts');\n  workerInstance.postMessage(filledBuffer);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `buffer.concat` method to merge multiple buffers into one, then checks if the merged buffer is a valid buffer using the `buffer.isBuffer` method, and finally sends the validated buffer to a worker thread (using the `worker` API) for further processing via `worker.postMessage`.",
    "input": "",
    "output": "import {worker, buffer} from '@kit.ArkTS';\n\nexport function mergeAndProcessBuffers(buffers: buffer.Buffer[]): void {\n  const mergedBuffer = buffer.concat(buffers);\n  const isValidBuffer = buffer.isBuffer(mergedBuffer);\n  \n  if (isValidBuffer) {\n    const myWorker = new worker.ThreadWorker('entry/ets/workers/worker.ts');\n    myWorker.postMessage(mergedBuffer);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to run a computationally intensive task in the background with `Priority.HIGH`, and then uses `PostMessageOptions.transfer` to send the result back to the main thread for further processing.",
    "input": "",
    "output": "import {taskpool, PostMessageOptions} from '@kit.ArkTS';\n\nexport function runIntensiveTask(): void {\n  const task = () => {\n    // Simulate a computationally intensive task\n    let result = 0;\n    for (let i = 0; i < 100000000; i++) {\n      result += Math.sqrt(i);\n    }\n    return new Float64Array([result]).buffer;\n  };\n\n  taskpool.execute(task, taskpool.Priority.HIGH).then((result: ArrayBuffer) => {\n    const options: PostMessageOptions = {\n      transfer: [result]\n    };\n    // Post the result back to the main thread for further processing\n    postMessage(result, options);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that schedules a delayed task using `taskpool.executeDelayed` with a specified delay, and upon completion, uses `PostMessageOptions.transfer` to transfer ownership of a large data object to the main thread to avoid unnecessary copying.",
    "input": "",
    "output": "import {taskpool, PostMessageOptions} from '@kit.ArkTS';\n\nexport function scheduleDelayedTaskWithTransfer(delay: number, largeData: ArrayBuffer, callback: (data: ArrayBuffer) => void): void {\n  const task = () => {\n    return largeData;\n  };\n\n  taskpool.executeDelayed(task, delay).then((result: ArrayBuffer) => {\n    const options: PostMessageOptions = {\n      transfer: [result]\n    };\n    callback(result);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a periodic task using `taskpool.executePeriodically` to monitor system state, and after each iteration, use `PostMessageOptions.transfer` to send aggregated logs to the main thread for display or storage.",
    "input": "",
    "output": "import {taskpool, PostMessageOptions} from '@kit.ArkTS';\n\nexport function monitorSystemState(): void {\n  const task = () => {\n    // Simulate collecting system state logs\n    const logs = {\n      timestamp: new Date().toISOString(),\n      cpuUsage: Math.random() * 100,\n      memoryUsage: Math.random() * 100\n    };\n    \n    // Convert logs to ArrayBuffer for transfer\n    const encoder = new TextEncoder();\n    const logsString = JSON.stringify(logs);\n    const logsBuffer = encoder.encode(logsString).buffer;\n    \n    // Prepare PostMessageOptions with transfer\n    const options: PostMessageOptions = {\n      transfer: [logsBuffer]\n    };\n    \n    // Send logs to main thread (simulated)\n    return logsBuffer;\n  };\n  \n  // Execute task periodically every 5 seconds\n  taskpool.executePeriodically(task, 5000);\n}\n\nexport function startMonitoring(): void {\n  monitorSystemState();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a new Worker instance by passing a WorkerOptions object with a specified `name` property, then checks if the Worker is shared by accessing the `shared` property of the WorkerOptions object. Use the WorkerOptions API to configure the Worker and the Worker API to verify its shared status.",
    "input": "",
    "output": "import { Worker, WorkerOptions } from '@kit.ArkTS';\n\nexport function createAndCheckWorker(name: string, shared: boolean): boolean {\n  const options: WorkerOptions = {\n    name: name,\n    shared: shared\n  };\n  const worker = new Worker('', options);\n  return worker.shared;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes two Worker instances with different WorkerOptions configurations (one with `name` set to 'worker1' and `shared` set to true, and another with `name` set to 'worker2' and `shared` set to false). Then, use the Worker API to post a message to the shared Worker and verify its behavior compared to the non-shared Worker.",
    "input": "",
    "output": "import { Worker, WorkerOptions } from '@kit.ArkTS';\n\nexport function initializeWorkers(): void {\n  const options1: WorkerOptions = {\n    name: 'worker1',\n    shared: true\n  };\n\n  const options2: WorkerOptions = {\n    name: 'worker2',\n    shared: false\n  };\n\n  const worker1 = new Worker('worker1', options1);\n  const worker2 = new Worker('worker2', options2);\n\n  worker1.postMessage('Message to shared worker');\n  worker2.postMessage('Message to non-shared worker');\n\n  worker1.onmessage = (event: MessageEvent): void => {\n    console.log('Shared worker response:', event.data);\n  };\n\n  worker2.onmessage = (event: MessageEvent): void => {\n    console.log('Non-shared worker response:', event.data);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that dynamically generates a WorkerOptions object with a `name` property based on user input and a `shared` property set to false. Then, use this object to create a Worker instance and post a message to it using the Worker API. Finally, terminate the Worker and log its name from the WorkerOptions object.",
    "input": "",
    "output": "import { Worker, WorkerOptions } from '@kit.ArkTS';\n\nexport function createAndTerminateWorker(workerName: string): void {\n  const options: WorkerOptions = {\n    name: workerName,\n    shared: false\n  };\n\n  const worker = new Worker('', options);\n  worker.postMessage('Hello from main thread');\n  worker.terminate();\n  console.log(`Worker name: ${options.name}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `HashSet` to collect unique product IDs from a list, then transfers these IDs to a `LightWeightMap` using the `set` method to associate each product ID with its corresponding price from a separate price list. Finally, use the `getValueAt` method of `LightWeightMap` to retrieve and return the price of the product at a specified index.",
    "input": "",
    "output": "import {LightWeightMap, HashSet} from '@kit.ArkTS';\n\nexport function getProductPrice(productIds: string[], prices: number[], index: number): number | undefined {\n  const uniqueProductIds = new HashSet<string>();\n  productIds.forEach((id) => {\n    uniqueProductIds.add(id);\n  });\n\n  const productPriceMap = new LightWeightMap<string, number>();\n  const uniqueIdsArray = Array.from(uniqueProductIds.values());\n  \n  uniqueIdsArray.forEach((id, i) => {\n    if (i < prices.length) {\n      productPriceMap.set(id, prices[i]);\n    }\n  });\n\n  if (index >= 0 && index < productPriceMap.length) {\n    return productPriceMap.getValueAt(index);\n  }\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `LightWeightMap` with student names (keys) and their scores (values) using the `set` method. Then, use the `keys` method of `LightWeightMap` to extract all student names and pass them to a `HashSet` using the `add` method to ensure no duplicate names exist. Finally, return the size of the `HashSet` using the `length` property to verify the count of unique student names.",
    "input": "",
    "output": "import {LightWeightMap, HashSet} from '@kit.ArkTS';\n\nexport function countUniqueStudentNames(): number {\n  const studentScores = new LightWeightMap<string, number>();\n  studentScores.set('Alice', 90);\n  studentScores.set('Bob', 85);\n  studentScores.set('Charlie', 88);\n  studentScores.set('Alice', 92); // Duplicate key\n\n  const uniqueNames = new HashSet<string>();\n  const studentNames = studentScores.keys();\n  for (const name of studentNames) {\n    uniqueNames.add(name);\n  }\n\n  return uniqueNames.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `has` method of `HashSet` to check if a given employee ID exists in a set of active employees. If the ID exists, use the `get` method of `LightWeightMap` to retrieve the employee's department from a separate department mapping. If the department is found, use the `remove` method of `HashSet` to mark the employee as inactive and return the department name.",
    "input": "",
    "output": "import {LightWeightMap, HashSet} from '@kit.ArkTS';\n\nexport function checkAndRemoveEmployee(activeEmployees: HashSet<number>, departmentMap: LightWeightMap<number, string>, employeeId: number): string | undefined {\n  if (activeEmployees.has(employeeId)) {\n    const department = departmentMap.get(employeeId);\n    if (department !== undefined) {\n      activeEmployees.remove(employeeId);\n      return department;\n    }\n  }\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a random UUID, then posts this UUID to a dedicated worker using the `postMessage` method of `DedicatedWorkerGlobalScope`. The worker should log the received UUID using `console.log`.",
    "input": "",
    "output": "import {util, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function postRandomUUIDToWorker(worker: DedicatedWorkerGlobalScope): void {\n  const randomUUID: string = util.generateRandomUUID();\n  worker.postMessage(randomUUID);\n}\n\nexport function setupWorkerListener(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent<string>): void => {\n    console.log(`Received UUID: ${event.data}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `promisify` method of `util` to convert a callback-based function into a promise, then use the `postMessage` method of `DedicatedWorkerGlobalScope` to send the resolved promise result to a dedicated worker. The worker should handle the message using its `onmessage` property.",
    "input": "",
    "output": "import {util, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function promisifyAndPostMessage(\n  callbackBasedFunc: (arg: string, callback: (error: Error | null, result: string) => void) => void,\n  arg: string,\n  worker: DedicatedWorkerGlobalScope\n): void {\n  const promisifiedFunc = util.promisify(callbackBasedFunc);\n  promisifiedFunc(arg)\n    .then((result: string) => {\n      worker.postMessage(result);\n    })\n    .catch((error: Error) => {\n      worker.postMessage({ error: error.message });\n    });\n}\n\nexport function setupWorkerMessageHandler(worker: DedicatedWorkerGlobalScope, handler: (message: string) => void): void {\n  worker.onmessage = (event: MessageEvent<string>) => {\n    handler(event.data);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getHash` method of `util` to compute the hash of a given string, then use the `close` method of `DedicatedWorkerGlobalScope` to terminate the worker after sending the computed hash via `postMessage`. The worker should log the hash before termination.",
    "input": "",
    "output": "import {util, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function computeHashAndTerminate(input: string, workerScope: DedicatedWorkerGlobalScope): void {\n  const hash: string = util.getHash(input);\n  console.log(hash);\n  workerScope.postMessage(hash);\n  workerScope.close();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `ThreadWorkerGlobalScope.postMessage` to send a JSON string to a worker thread, then in the worker thread, use `json.parse` to convert the JSON string into an object, manipulate the object (e.g., add a new property), and finally use `json.stringify` to convert it back to a JSON string before sending it back to the main thread using `ThreadWorkerGlobalScope.postMessage`.",
    "input": "",
    "output": "import {json, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendDataToWorker(worker: ThreadWorkerGlobalScope, data: string): void {\n  worker.postMessage(data);\n}\n\nexport function handleWorkerMessage(worker: ThreadWorkerGlobalScope): void {\n  worker.onmessage = (message: string) => {\n    const parsedData = json.parse(message);\n    parsedData.newProperty = 'addedInWorker';\n    const stringifiedData = json.stringify(parsedData);\n    worker.postMessage(stringifiedData);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function where the main thread uses `json.stringify` to serialize an object containing a list of tasks, then passes this string to a worker thread via `ThreadWorkerGlobalScope.postMessage`. The worker thread should use `json.parse` to deserialize the string, process the tasks (e.g., filter or sort them), and then use `ThreadWorkerGlobalScope.postMessage` to send the processed results back to the main thread.",
    "input": "",
    "output": "import {json, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport interface Task {\n  id: number;\n  name: string;\n  priority: number;\n}\n\nexport function processTasksInWorker(tasks: Task[]): void {\n  const worker = new ThreadWorkerGlobalScope('workers/worker.js');\n  \n  worker.onmessage = (message: { data: Task[] }) => {\n    console.log('Processed tasks received from worker:', message.data);\n    worker.close();\n  };\n  \n  worker.onmessageerror = () => {\n    console.error('Error receiving message from worker');\n    worker.close();\n  };\n  \n  const serializedTasks = json.stringify(tasks);\n  worker.postMessage(serializedTasks);\n}\n\n// worker.js content (should be in a separate file in workers/worker.js)\n// import {json, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n// \n// const workerScope = new ThreadWorkerGlobalScope();\n// \n// workerScope.onmessage = (message: { data: string }) => {\n//   const tasks: Task[] = json.parse(message.data);\n//   const processedTasks = tasks.filter(task => task.priority > 5).sort((a, b) => b.priority - a.priority);\n//   workerScope.postMessage(processedTasks);\n// };\n// \n// workerScope.onmessageerror = () => {\n//   console.error('Error processing tasks in worker');\n// };",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a scenario where a worker thread receives a JSON string via `ThreadWorkerGlobalScope.onmessage`, uses `json.parse` to convert it into an object, checks if a specific property exists in the object using `json.has`, and then modifies the object accordingly. The worker thread should then use `json.stringify` to convert the modified object back to a JSON string and send it back to the main thread using `ThreadWorkerGlobalScope.postMessage`.",
    "input": "",
    "output": "import {json, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport class WorkerThread {\n  private workerScope: ThreadWorkerGlobalScope;\n\n  constructor(workerScope: ThreadWorkerGlobalScope) {\n    this.workerScope = workerScope;\n    this.workerScope.onmessage = (message: string) => {\n      this.handleMessage(message);\n    };\n  }\n\n  private handleMessage(message: string): void {\n    try {\n      const parsedObject = json.parse(message);\n      \n      if (json.has(parsedObject, 'propertyToCheck')) {\n        parsedObject.modifiedProperty = 'newValue';\n      }\n      \n      const modifiedJsonString = json.stringify(parsedObject);\n      this.workerScope.postMessage(modifiedJsonString);\n    } catch (error) {\n      this.workerScope.postMessage(json.stringify({ error: 'Invalid JSON' }));\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `json.parse` to convert a JSON string into an object, then checks if a specific property exists in the object using `json.has`, and finally logs the `type` and `timeStamp` properties of an `Event` object that records the time of this operation.",
    "input": "",
    "output": "import {json, Event} from '@kit.ArkTS';\n\nexport function parseAndCheckJson(jsonString: string, property: string): void {\n  const obj = json.parse(jsonString);\n  const hasProperty = json.has(obj, property);\n  \n  const event: Event = {\n    timeStamp: new Date().getTime(),\n    type: 'JSON_PARSE_AND_CHECK'\n  };\n  \n  console.log(`Event type: ${event.type}, timeStamp: ${event.timeStamp}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes an `Event` object, extracts its `timeStamp` property, converts it to a JSON string using `json.stringify`, and then removes a specified key from the resulting JSON string using `json.remove` before returning the modified string.",
    "input": "",
    "output": "import {json, Event} from '@kit.ArkTS';\n\nexport function processEvent(event: Event, keyToRemove: string): string {\n  const eventJson = json.stringify(event.timeStamp);\n  const modifiedJson = json.remove(eventJson, keyToRemove);\n  return modifiedJson;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `json.parse` to convert a JSON string into an object, then creates an `Event` object with the `type` property set to 'JSON_PROCESSED' and the `timeStamp` property set to the current time, and finally converts the `Event` object back to a JSON string using `json.stringify`.",
    "input": "",
    "output": "import {json, Event} from '@kit.ArkTS';\n\nexport function processJsonString(jsonString: string): string {\n  const parsedObject = json.parse(jsonString);\n  const event = new Event();\n  event.type = 'JSON_PROCESSED';\n  event.timeStamp = new Date().getTime();\n  return json.stringify(event);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a data object to a worker thread, and then in the worker thread, use the `data` property of `MessageEvents` to process the received data and send a response back using `postMessageWithSharedSendable`.",
    "input": "",
    "output": "import {MessageEvents, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendDataToWorker(worker: ThreadWorkerGlobalScope, data: object): void {\n  worker.postMessage(data);\n}\n\nexport function setupWorkerListener(worker: ThreadWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvents) => {\n    const receivedData = event.data;\n    const processedData = processData(receivedData);\n    worker.postMessageWithSharedSendable(processedData);\n  };\n}\n\nfunction processData(data: object): object {\n  return { processed: true, originalData: data };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that listens for messages using the `onmessage` property of `ThreadWorkerGlobalScope`. When a message is received, use the `data` property of `MessageEvents` to validate the input, and if valid, use the `callGlobalCallObjectMethod` to invoke a global function with the processed data.",
    "input": "",
    "output": "import {MessageEvents, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport class WorkerThread {\n  private workerScope: ThreadWorkerGlobalScope;\n\n  constructor() {\n    this.workerScope = new ThreadWorkerGlobalScope();\n    this.setupMessageListener();\n  }\n\n  private setupMessageListener(): void {\n    this.workerScope.onmessage = (event: MessageEvents) => {\n      const data = event.data;\n      if (this.validateInput(data)) {\n        this.workerScope.callGlobalCallObjectMethod('processData', data);\n      }\n    };\n  }\n\n  private validateInput(data: string): boolean {\n    return typeof data === 'string' && data.length > 0;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a worker thread that uses the `close` method of `ThreadWorkerGlobalScope` to terminate itself after processing a message. Before closing, the worker should use the `data` property of `MessageEvents` to check if the received message meets a certain condition, and if so, send a final message using `postMessage`.",
    "input": "",
    "output": "import {MessageEvents, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport class WorkerThread {\n  private workerScope: ThreadWorkerGlobalScope;\n\n  constructor(workerScope: ThreadWorkerGlobalScope) {\n    this.workerScope = workerScope;\n    this.workerScope.onmessage = (event: MessageEvents) => this.handleMessage(event);\n  }\n\n  private handleMessage(event: MessageEvents): void {\n    const messageData = event.data;\n    \n    if (messageData === 'terminate') {\n      this.workerScope.postMessage('Terminating worker');\n      this.workerScope.close();\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that listens for global errors using the `onerror` property of `GlobalScope` and constructs an `ErrorEvent` object using the error details (e.g., `message`, `filename`, `lineno`, `colno`). The function should then log the error details by accessing the properties of the `ErrorEvent` object.",
    "input": "",
    "output": "import {ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function setupGlobalErrorListener(): void {\n  const globalScope: GlobalScope = globalThis as unknown as GlobalScope;\n  \n  globalScope.onerror = (message: string, filename?: string, lineno?: number, colno?: number, error?: Error): boolean => {\n    const errorEvent: ErrorEvent = new ErrorEvent('error', {\n      message: message,\n      filename: filename,\n      lineno: lineno,\n      colno: colno,\n      error: error\n    });\n    \n    console.log(`Error Message: ${errorEvent.message}`);\n    console.log(`Filename: ${errorEvent.filename}`);\n    console.log(`Line Number: ${errorEvent.lineno}`);\n    console.log(`Column Number: ${errorEvent.colno}`);\n    console.log(`Error Object: ${errorEvent.error}`);\n    \n    return true;\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks if the current execution context is the global scope by comparing `GlobalScope.self` with the global `this` object. If an error occurs during this check, use the `ErrorEvent` properties (`error`, `message`) to handle and display the error details.",
    "input": "",
    "output": "import {ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function checkGlobalScope(): boolean {\n  try {\n    return GlobalScope.self === this;\n  } catch (error) {\n    const errorEvent = new ErrorEvent('error', {\n      error: error,\n      message: error instanceof Error ? error.message : 'Unknown error occurred'\n    });\n    \n    console.error(`Error occurred: ${errorEvent.message}`);\n    return false;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that sets up a global error handler using `GlobalScope.onerror` to capture errors. For each error, create an `ErrorEvent` instance and extract its `filename`, `lineno`, and `colno` properties to generate a detailed error report, which is then stored in a global variable defined in `GlobalScope`.",
    "input": "",
    "output": "import {ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nlet globalErrorReports: Array<{\n  filename: string;\n  lineno: number;\n  colno: number;\n  message: string;\n}> = [];\n\nGlobalScope.onerror = (event: ErrorEvent) => {\n  const errorReport = {\n    filename: event.filename,\n    lineno: event.lineno,\n    colno: event.colno,\n    message: event.message\n  };\n  globalErrorReports.push(errorReport);\n  return false;\n};\n\nexport function getGlobalErrorReports(): Array<{\n  filename: string;\n  lineno: number;\n  colno: number;\n  message: string;\n}> {\n  return globalErrorReports;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.getUidForName` to retrieve the UID for a given process name, then stores the UID and process name as a key-value pair in a `LightWeightMap` using its `set` method. Finally, use `LightWeightMap.getValueAt` to verify the stored UID matches the original retrieval.",
    "input": "",
    "output": "import {process, LightWeightMap} from '@kit.ArkTS';\n\nexport function storeAndVerifyUid(processName: string): boolean {\n  const uid = process.getUidForName(processName);\n  const map = new LightWeightMap<string, number>();\n  map.set(processName, uid);\n  const storedUid = map.getValueAt(map.getIndexOfKey(processName));\n  return storedUid === uid;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that collects the system environment variables using `process.getEnvironmentVar`, then iterates over the collected variables using `LightWeightMap.forEach` to filter and store only those variables with values longer than 10 characters in a new `LightWeightMap` instance. Use `LightWeightMap.length` to return the count of filtered variables.",
    "input": "",
    "output": "import {process, LightWeightMap} from '@kit.ArkTS';\n\nexport function filterEnvVars(): number {\n  const envVars = process.getEnvironmentVar();\n  const filteredVars = new LightWeightMap<string, string>();\n  \n  envVars.forEach((value: string, key: string) => {\n    if (value.length > 10) {\n      filteredVars.set(key, value);\n    }\n  });\n  \n  return filteredVars.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `process.getStartRealtime` to get the start time of the current process, then uses `LightWeightMap.setValueAt` to update the start time in a predefined `LightWeightMap` entry. Use `LightWeightMap.getKeyAt` to confirm the entry's key before updating and `process.uptime` to calculate the elapsed time since the process started.",
    "input": "",
    "output": "import {process, LightWeightMap} from '@kit.ArkTS';\n\nexport function updateProcessStartTime(map: LightWeightMap<number, number>, key: number): void {\n  if (map.hasKey(key)) {\n    const startTime = process.getStartRealtime();\n    const elapsedTime = process.uptime();\n    map.setValueAt(map.getIndexOfKey(key), startTime + elapsedTime);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to store a sequence of event names, then iterates through the list using `forEach` and dispatches each event using the `dispatchEvent` method of `WorkerEventTarget`. The function should return the number of events successfully dispatched.",
    "input": "",
    "output": "import {WorkerEventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function dispatchEvents(eventNames: string[], target: WorkerEventTarget): number {\n  const list = new LinkedList<string>();\n  eventNames.forEach(name => list.add(name));\n  \n  let dispatchedCount = 0;\n  list.forEach(name => {\n    try {\n      target.dispatchEvent(name);\n      dispatchedCount++;\n    } catch (e) {\n      // Ignore errors and continue with next event\n    }\n  });\n  \n  return dispatchedCount;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list, then uses the `addEventListener` method of `WorkerEventTarget` to listen for custom events named after these elements. The function should return the `LinkedList` length after the listeners are added.",
    "input": "",
    "output": "import {WorkerEventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function setupEventListeners(list: LinkedList<string>, eventTarget: WorkerEventTarget): number {\n  const firstElement = list.getFirst();\n  const lastElement = list.getLast();\n\n  eventTarget.addEventListener(firstElement, () => {});\n  eventTarget.addEventListener(lastElement, () => {});\n\n  return list.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `removeFirstFound` method of `LinkedList` to remove a specific event name from the list, then uses the `removeEventListener` method of `WorkerEventTarget` to remove the corresponding event listener. The function should return `true` if both operations succeed, otherwise `false`.",
    "input": "",
    "output": "import {WorkerEventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function removeEventAndListener(eventList: LinkedList<string>, eventTarget: WorkerEventTarget, eventName: string): boolean {\n  const isRemovedFromList = eventList.removeFirstFound(eventName);\n  const isRemovedFromTarget = eventTarget.removeEventListener(eventName);\n  return isRemovedFromList && isRemovedFromTarget;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that captures error events using the `message` and `error` properties of `ErrorEvent`, then stores these error details in a `Vector` using its `add` method. Finally, use the `convertToArray` method of `Vector` to return the collected errors as an array.",
    "input": "",
    "output": "import {ErrorEvent, Vector} from '@kit.ArkTS';\n\nexport function captureAndStoreErrors(errorEvents: ErrorEvent[]): ErrorEvent[] {\n  const errorVector: Vector<ErrorEvent> = new Vector<ErrorEvent>();\n  \n  for (const event of errorEvents) {\n    errorVector.add(event);\n  }\n  \n  return errorVector.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `getFirstElement` and `getLastElement` methods of `Vector` to extract the first and last elements, then constructs an `ErrorEvent` object using these elements as the `message` and `error` properties respectively. Return the constructed `ErrorEvent` object.",
    "input": "",
    "output": "import {ErrorEvent, Vector} from '@kit.ArkTS';\n\nexport function createErrorEventFromVector(vector: Vector<string>): ErrorEvent {\n  const message = vector.getFirstElement();\n  const error = vector.getLastElement();\n  const errorEvent = new ErrorEvent('error', { message, error });\n  return errorEvent;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that filters a `Vector` of strings using its `forEach` method to collect strings containing a specific substring. For each matching string, create an `ErrorEvent` object with the string as the `message` property and a custom error code as the `error` property. Use the `trimToCurrentLength` method of `Vector` to optimize storage before returning the filtered results.",
    "input": "",
    "output": "import {ErrorEvent, Vector} from '@kit.ArkTS';\n\nexport function filterStringsWithSubstring(vector: Vector<string>, substring: string, errorCode: number): Vector<ErrorEvent> {\n  const result: Vector<ErrorEvent> = new Vector<ErrorEvent>();\n  \n  vector.forEach((str: string) => {\n    if (str.includes(substring)) {\n      const errorEvent = new ErrorEvent();\n      errorEvent.message = str;\n      errorEvent.error = errorCode;\n      result.add(errorEvent);\n    }\n  });\n  \n  result.trimToCurrentLength();\n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `xml.parse` method to convert an XML string into a DOM object, then traverse the DOM tree using `xml.getElementsByTagName` to extract specific elements, and finally use `stream.write` to write the extracted data into a file.",
    "input": "",
    "output": "import {stream, xml} from '@kit.ArkTS';\n\nexport function parseAndWriteXMLToFile(xmlString: string, tagName: string, filePath: string): void {\n  // Parse the XML string into a DOM object\n  const dom: xml.Document = xml.parse(xmlString);\n\n  // Extract elements by tag name\n  const elements: xml.Element[] = xml.getElementsByTagName(dom, tagName);\n\n  // Prepare data to write\n  let dataToWrite: string = '';\n  for (const element of elements) {\n    dataToWrite += xml.serialize(element) + '\\n';\n  }\n\n  // Write data to file\n  const fileStream: stream.Writable = stream.createWritable(filePath);\n  fileStream.write(dataToWrite, (err: Error | null) => {\n    if (err) {\n      console.error(`Error writing to file: ${err.message}`);\n    }\n    fileStream.close();\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a program that reads an XML file using `stream.read` to get the raw XML content, then uses `xml.parse` to convert it into a DOM object, and finally uses `xml.serialize` to convert the DOM object back into a formatted XML string which is then written to a new file using `stream.write`.",
    "input": "",
    "output": "import {stream, xml} from '@kit.ArkTS';\n\nexport function processXmlFile(inputFilePath: string, outputFilePath: string): void {\n  try {\n    // Read the XML file\n    const fileStream = new stream.FileStream(inputFilePath, 'r');\n    const xmlContent: string = fileStream.read();\n    fileStream.close();\n\n    // Parse the XML content into a DOM object\n    const domParser = new xml.XmlPullParser();\n    const domObject = domParser.parse(xmlContent);\n\n    // Serialize the DOM object back to a formatted XML string\n    const xmlSerializer = new xml.XmlSerializer();\n    const formattedXml: string = xmlSerializer.serialize(domObject);\n\n    // Write the formatted XML to a new file\n    const outputStream = new stream.FileStream(outputFilePath, 'w');\n    outputStream.write(formattedXml);\n    outputStream.close();\n  } catch (error) {\n    console.error(`Error processing XML file: ${error}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `xml.createDocument` to generate a new XML document, populate it with elements and attributes using `xml.createElement` and `xml.setAttribute`, then use `xml.serialize` to convert the document into a string, and finally use `stream.write` to save the serialized XML string to a file.",
    "input": "",
    "output": "import {stream, xml} from '@kit.ArkTS';\n\nexport function createAndSaveXmlDocument(filePath: string): void {\n  // Create a new XML document\n  const doc: xml.XmlDocument = xml.createDocument();\n\n  // Create root element\n  const rootElement: xml.XmlElement = xml.createElement('root');\n  doc.appendChild(rootElement);\n\n  // Create child element\n  const childElement: xml.XmlElement = xml.createElement('child');\n  xml.setAttribute(childElement, 'attribute', 'value');\n  rootElement.appendChild(childElement);\n\n  // Serialize the XML document to a string\n  const xmlString: string = xml.serialize(doc);\n\n  // Create a writable stream to save the file\n  const writableStream: stream.Writable = stream.createWritable(filePath);\n\n  // Write the XML string to the file\n  writableStream.write(xmlString, (err: Error) => {\n    if (err) {\n      console.error(`Failed to write XML to file: ${err.message}`);\n    } else {\n      console.log('XML file saved successfully');\n    }\n    writableStream.close();\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `Vector` method `convertToArray` to transform a Vector of URIs into an array, then uses the `uri` API to extract and return the domain names from each URI in the array.",
    "input": "",
    "output": "import {Vector, uri} from '@kit.ArkTS';\n\nexport function extractDomainsFromUris(uriVector: Vector<string>): string[] {\n  const uriArray: string[] = uriVector.convertToArray();\n  const domains: string[] = [];\n  \n  for (const uriString of uriArray) {\n    try {\n      const parsedUri = new uri.URI(uriString);\n      const domain = parsedUri.getDomain();\n      if (domain) {\n        domains.push(domain);\n      }\n    } catch (e) {\n      console.error(`Failed to parse URI: ${uriString}`);\n    }\n  }\n  \n  return domains;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `Vector` method `sort` to alphabetically order a list of URIs stored in a Vector, then uses the `uri` API to filter and return only those URIs that use the HTTPS protocol.",
    "input": "",
    "output": "import {Vector, uri} from '@kit.ArkTS';\n\nexport function sortAndFilterHTTPS(uris: Vector<string>): Vector<string> {\n  uris.sort((a: string, b: string) => a.localeCompare(b));\n  const httpsUris: Vector<string> = new Vector<string>();\n  for (let i = 0; i < uris.length; i++) {\n    const currentUri = uris.get(i);\n    if (currentUri.startsWith('https://')) {\n      httpsUris.add(currentUri);\n    }\n  }\n  return httpsUris;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `Vector` method `getByRange` to select a subset of URIs, then uses the `uri` API to validate each URI in the subset and returns a new Vector containing only the valid URIs.",
    "input": "",
    "output": "import {Vector, uri} from '@kit.ArkTS';\n\nexport function filterValidURIs(uriVector: Vector<string>, start: number, end: number): Vector<string> {\n  const subset = uriVector.getByRange(start, end);\n  const validURIs = new Vector<string>();\n  \n  for (let i = 0; i < subset.length; i++) {\n    const currentURI = subset.get(i);\n    try {\n      uri.parse(currentURI);\n      validURIs.add(currentURI);\n    } catch (error) {\n      continue;\n    }\n  }\n  \n  return validURIs;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getSubList` method of `List` to extract a subset of elements based on given indices, then passes the extracted subset to the `convertToArray` method of `List` to convert it into an array, and finally uses the `EventType` enum from `xml` to log the result with a specific event type (e.g., `EventType.INFO`).",
    "input": "",
    "output": "import {List, xml} from '@kit.ArkTS';\n\nexport function processSubList(list: List<number>, start: number, end: number): number[] {\n  const subList = list.getSubList(start, end);\n  const array = subList.convertToArray();\n  xml.EventType.INFO;\n  return array;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `sort` method of `List` to sort a list of XML node names alphabetically, then uses the `getFirst` and `getLast` methods of `List` to retrieve the first and last elements of the sorted list, and finally uses the `EventType` enum from `xml` to log these elements with a specific event type (e.g., `EventType.DEBUG`).",
    "input": "",
    "output": "import {List, xml} from '@kit.ArkTS';\n\nexport function sortAndLogXmlNodeNames(nodeNames: List<string>): void {\n  nodeNames.sort((a: string, b: string) => a.localeCompare(b));\n  const firstNode: string = nodeNames.getFirst();\n  const lastNode: string = nodeNames.getLast();\n  console.log(`First node: ${firstNode}`, xml.EventType.DEBUG);\n  console.log(`Last node: ${lastNode}`, xml.EventType.DEBUG);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `List` to iterate over a list of XML attributes, then uses the `insert` method of `List` to add a new attribute at a specific position, and finally uses the `EventType` enum from `xml` to log the modified list with a specific event type (e.g., `EventType.WARNING`).",
    "input": "",
    "output": "import {List, xml} from '@kit.ArkTS';\n\nexport function modifyAttributes(attributes: List<string>, newAttribute: string, position: number): void {\n  attributes.forEach((attribute: string, index: number) => {\n    console.log(`Attribute at index ${index}: ${attribute}`);\n  });\n\n  attributes.insert(position, newAttribute);\n\n  console.log(`Modified attributes: ${attributes.convertToArray()}`);\n  console.log(`Event type: ${xml.EventType.WARNING}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getEnvironmentVar` method of `process` to retrieve the value of an environment variable named 'WORKER_NAME', then assigns this value to the `name` property of `WorkerGlobalScope`. Finally, log the updated `name` property to verify the assignment.",
    "input": "",
    "output": "import {WorkerGlobalScope, process} from '@kit.ArkTS';\n\nexport function assignWorkerName() {\n  const workerName = process.getEnvironmentVar('WORKER_NAME');\n  if (workerName !== undefined) {\n    WorkerGlobalScope.name = workerName;\n    console.log(`Worker name assigned: ${WorkerGlobalScope.name}`);\n  } else {\n    console.log('WORKER_NAME environment variable not found');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if the current process is a 64-bit system using the `is64Bit` method of `process`, then uses this boolean result to determine whether to call the `abort` method of `process` (if false) or the `exit` method (if true). Before exiting, log the `self` property of `WorkerGlobalScope` to identify the worker context.",
    "input": "",
    "output": "import {WorkerGlobalScope, process} from '@kit.ArkTS';\n\nexport function checkAndExit(): void {\n  const is64Bit: boolean = process.is64Bit();\n  console.log(WorkerGlobalScope.self);\n  if (!is64Bit) {\n    process.abort();\n  } else {\n    process.exit();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that calculates the uptime of the current process using the `uptime` method of `process`, then uses this value to set a timeout in the `WorkerGlobalScope` using `setTimeout` (assumed to be available in the worker context). The timeout callback should log the `onerror` property of `WorkerGlobalScope` to check for any pending error handlers.",
    "input": "",
    "output": "import {WorkerGlobalScope, process} from '@kit.ArkTS';\n\nexport function setupUptimeTimeout(workerScope: WorkerGlobalScope): void {\n  const uptime = process.uptime();\n  const timeoutDuration = uptime * 1000;\n  \n  workerScope.setTimeout(() => {\n    console.log(workerScope.onerror);\n  }, timeoutDuration);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `set` method of `TreeMap` to store a series of key-value pairs representing student names and their scores, then uses the `values` method of `TreeMap` to extract the scores and pass them to the `add` method of `TreeSet` to create a sorted collection of unique scores.",
    "input": "",
    "output": "import {TreeMap, TreeSet} from '@kit.ArkTS';\n\nexport function storeAndSortScores(): TreeSet<number> {\n  const studentScores = new TreeMap<string, number>();\n  studentScores.set('Alice', 90);\n  studentScores.set('Bob', 85);\n  studentScores.set('Charlie', 90);\n  studentScores.set('David', 78);\n\n  const uniqueScores = new TreeSet<number>();\n  const scoreValues = studentScores.values();\n  for (const score of scoreValues) {\n    uniqueScores.add(score);\n  }\n\n  return uniqueScores;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `getFirstKey` and `getLastKey` methods of `TreeMap` to find the range of keys in a map, then uses the `getHigherValue` and `getLowerValue` methods of `TreeSet` to find the closest values within a specified range in a set, combining the results to identify overlapping or adjacent entries.",
    "input": "",
    "output": "import {TreeMap, TreeSet} from '@kit.ArkTS';\n\nexport function findOverlappingEntries<K, V>(map: TreeMap<K, V>, set: TreeSet<V>, rangeStart: K, rangeEnd: K): Array<[K, V]> {\n  const result: Array<[K, V]> = [];\n  \n  if (map.isEmpty() || set.isEmpty()) {\n    return result;\n  }\n  \n  const firstKey = map.getFirstKey();\n  const lastKey = map.getLastKey();\n  \n  if (firstKey === undefined || lastKey === undefined) {\n    return result;\n  }\n  \n  const keysInRange: K[] = [];\n  let currentKey: K | undefined = map.getHigherKey(rangeStart);\n  \n  while (currentKey !== undefined && currentKey <= rangeEnd) {\n    keysInRange.push(currentKey);\n    currentKey = map.getHigherKey(currentKey);\n  }\n  \n  for (const key of keysInRange) {\n    const value = map.get(key);\n    if (value !== undefined) {\n      const higherValue = set.getHigherValue(value);\n      const lowerValue = set.getLowerValue(value);\n      \n      if (higherValue !== undefined && higherValue === value) {\n        result.push([key, value]);\n      } else if (lowerValue !== undefined && lowerValue === value) {\n        result.push([key, value]);\n      }\n    }\n  }\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `entries` method of `TreeSet` to iterate over a set of product IDs, then for each ID, checks if it exists in a `TreeMap` using the `hasKey` method, and if it does, uses the `get` method of `TreeMap` to retrieve and log the corresponding product details.",
    "input": "",
    "output": "import {TreeMap, TreeSet} from '@kit.ArkTS';\n\nexport function logProductDetails(productIds: TreeSet<number>, productMap: TreeMap<number, string>): void {\n  for (const [id] of productIds.entries()) {\n    if (productMap.hasKey(id)) {\n      const productDetail = productMap.get(id);\n      console.log(`Product ID: ${id}, Detail: ${productDetail}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a series of URLs (as strings), then iterates through the queue using the `Symbol.iterator` method to process each URL, and finally uses the `length` property of `Queue` to return the total number of URLs processed.",
    "input": "",
    "output": "import {url, Queue} from '@kit.ArkTS';\n\nexport function processURLs(urls: string[]): number {\n  const queue = new Queue<string>();\n  \n  for (const url of urls) {\n    queue.add(url);\n  }\n  \n  for (const url of queue[Symbol.iterator]()) {\n    // Process each URL here\n  }\n  \n  return queue.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirst` method of `Queue` to retrieve the first element (a URL string), then passes this URL to a hypothetical `fetch` function (from `url` API) to make a network request, and finally uses the `pop` method of `Queue` to remove the processed URL from the queue.",
    "input": "",
    "output": "import {url, Queue} from '@kit.ArkTS';\n\nexport function processQueue(queue: Queue<string>): void {\n  if (queue.length > 0) {\n    const firstUrl = queue.getFirst();\n    url.fetch(firstUrl);\n    queue.pop();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that initializes a `Queue` using its `constructor`, adds a list of URLs using the `add` method, then uses the `forEach` method of `Queue` to log each URL, and finally checks if the queue is empty using the `length` property.",
    "input": "",
    "output": "import {url, Queue} from '@kit.ArkTS';\n\nexport function initializeAndLogQueue(): void {\n  const queue = new Queue<string>();\n  const urls: string[] = ['https://example.com', 'https://example.org', 'https://example.net'];\n  urls.forEach((url) => {\n    queue.add(url);\n  });\n  queue.forEach((url) => {\n    console.log(url);\n  });\n  console.log(queue.length === 0 ? 'Queue is empty' : 'Queue is not empty');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that listens for an error event using the `onerror` property of `GlobalScope` and logs the event's `type` and `timeStamp` properties from the `Event` object passed to the handler.",
    "input": "",
    "output": "import {Event, GlobalScope} from '@kit.ArkTS';\n\nexport function setupErrorListener(): void {\n  const globalScope: GlobalScope = globalThis as unknown as GlobalScope;\n  globalScope.onerror = (event: Event) => {\n    console.log(`Error event type: ${event.type}, timestamp: ${event.timeStamp}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks if the `name` property of `GlobalScope` matches a given string, and if it does, triggers a custom event with a `type` property set to 'match' and logs the `timeStamp` of the event using the `Event` API.",
    "input": "",
    "output": "import {Event, GlobalScope} from '@kit.ArkTS';\n\nexport function checkNameAndTriggerEvent(nameToCheck: string): void {\n  if (GlobalScope.name === nameToCheck) {\n    const customEvent = new Event('match');\n    GlobalScope.dispatchEvent(customEvent);\n    console.log(customEvent.timeStamp);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `self` property of `GlobalScope` to compare with the current context, and if they match, dispatches an event with a `type` property of 'self-match' and records the `timeStamp` from the `Event` object.",
    "input": "",
    "output": "import {Event, GlobalScope} from '@kit.ArkTS';\n\nexport function checkSelfAndDispatchEvent(): void {\n  if (GlobalScope.self === this) {\n    const event: Event = {\n      type: 'self-match',\n      timeStamp: Date.now()\n    };\n    GlobalScope.self.dispatchEvent(event);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of messages from a worker thread, then uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send the collected messages back to the main thread. The function must also handle errors by using the `onmessageerror` property of `DedicatedWorkerGlobalScope` to log any message processing failures.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function collectAndSendMessages(workerScope: DedicatedWorkerGlobalScope): void {\n  const messageList: LinkedList<string> = new LinkedList();\n\n  workerScope.onmessage = (event: MessageEvent<string>) => {\n    try {\n      messageList.add(event.data);\n    } catch (error) {\n      console.error(`Error adding message to list: ${error}`);\n    }\n  };\n\n  workerScope.onmessageerror = (event: MessageEvent) => {\n    console.error(`Message processing error: ${event}`);\n  };\n\n  // Example of sending collected messages back to main thread\n  // In a real scenario, you might want to trigger this at a specific time or condition\n  workerScope.postMessage(Array.from(messageList));\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list, then uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send these elements to a worker thread for further processing. The function should also use the `onmessage` property of `DedicatedWorkerGlobalScope` to receive and log the processed results from the worker thread.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function processLinkedListElements(worker: DedicatedWorkerGlobalScope, list: LinkedList<number>): void {\n  const firstElement = list.getFirst();\n  const lastElement = list.getLast();\n  \n  worker.postMessage({ first: firstElement, last: lastElement });\n  \n  worker.onmessage = (event: MessageEvent<{ processedFirst: number, processedLast: number }>) => {\n    console.log(`Processed first element: ${event.data.processedFirst}`);\n    console.log(`Processed last element: ${event.data.processedLast}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LinkedList` to iterate over a list of tasks, then uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send each task to a worker thread for parallel execution. The function should use the `onmessage` property of `DedicatedWorkerGlobalScope` to collect the results from the worker thread and the `convertToArray` method of `LinkedList` to transform the results into an array for further processing.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function processTasksInParallel(tasks: LinkedList<string>, worker: DedicatedWorkerGlobalScope): Promise<string[]> {\n  return new Promise((resolve) => {\n    const results: string[] = [];\n    \n    worker.onmessage = (event: MessageEvent<string>) => {\n      results.push(event.data);\n      \n      if (results.length === tasks.length) {\n        resolve(results);\n      }\n    };\n    \n    tasks.forEach((task: string) => {\n      worker.postMessage(task);\n    });\n  });\n}\n\nexport function getTaskResultsAsArray(tasks: LinkedList<string>, worker: DedicatedWorkerGlobalScope): string[] {\n  const results: string[] = [];\n  \n  worker.onmessage = (event: MessageEvent<string>) => {\n    results.push(event.data);\n  };\n  \n  tasks.forEach((task: string) => {\n    worker.postMessage(task);\n  });\n  \n  return tasks.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a buffer from a string with 'utf-8' encoding, then uses `process.getEnvironmentVar` to retrieve an environment variable, and finally compares the buffer content with the environment variable using `buffer.compare` to check if they match.",
    "input": "",
    "output": "import {buffer, process} from '@kit.ArkTS';\n\nexport function compareBufferWithEnvVar(str: string, envVarName: string): boolean {\n  const strBuffer = buffer.from(str, 'utf-8');\n  const envVarValue = process.getEnvironmentVar(envVarName);\n  if (envVarValue === undefined) {\n    return false;\n  }\n  const envVarBuffer = buffer.from(envVarValue, 'utf-8');\n  return buffer.compare(strBuffer, envVarBuffer) === 0;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.uptime` to get the system uptime in seconds, converts it to a string, then uses `buffer.byteLength` to calculate the byte length of the uptime string when encoded in 'utf-16le', and finally logs the result.",
    "input": "",
    "output": "import {buffer, process} from '@kit.ArkTS';\n\nexport function logUptimeByteLength(): void {\n  const uptime: number = process.uptime();\n  const uptimeString: string = uptime.toString();\n  const byteLength: number = buffer.byteLength(uptimeString, 'utf-16le');\n  console.log(byteLength);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.allocUninitialized` to create a buffer of a specific size, then uses `process.getThreadPriority` to get the current thread priority, and writes the priority value into the buffer at a specified offset using `buffer.writeUInt32LE` (assuming it's available).",
    "input": "",
    "output": "import {buffer, process} from '@kit.ArkTS';\n\nexport function createBufferWithThreadPriority(size: number, offset: number): buffer.Buffer {\n  const buf = buffer.allocUninitialized(size);\n  const priority = process.getThreadPriority();\n  buf.writeUInt32LE(priority, offset);\n  return buf;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then iterates through the stack using the `Symbol.iterator` method to pass each number to a `worker` thread (from @kit.ArkTS) for processing (e.g., squaring each number). The processed results should be collected and returned as an array.",
    "input": "",
    "output": "import {worker, Stack} from '@kit.ArkTS';\n\nexport function processNumbersWithWorker(numbers: number[]): number[] {\n  const stack = new Stack<number>();\n  numbers.forEach(num => stack.push(num));\n  \n  const processedResults: number[] = [];\n  \n  for (const num of stack[Symbol.iterator]()) {\n    const workerInstance = new worker.ThreadWorker('entry/ets/workers/WorkerExample.ts');\n    workerInstance.postMessage(num);\n    workerInstance.onmessage = (msg: { data: number }) => {\n      processedResults.push(msg.data);\n      workerInstance.terminate();\n    };\n  }\n  \n  return processedResults;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that checks if a `Stack` (from @kit.ArkTS) is empty using the `isEmpty` method, and if not, uses the `peek` method to retrieve the top element and passes it to a `worker` thread (from @kit.ArkTS) for validation (e.g., checking if it is a prime number). The validation result should be returned as a boolean.",
    "input": "",
    "output": "import {worker, Stack} from '@kit.ArkTS';\n\nexport function validateTopElement(stack: Stack<number>, workerScript: string): boolean {\n  if (stack.isEmpty()) {\n    return false;\n  }\n  \n  const topElement = stack.peek();\n  const workerInstance = new worker.ThreadWorker(workerScript);\n  \n  let result = false;\n  \n  workerInstance.onmessage = (message: worker.MessageEvents) => {\n    result = message.data;\n    workerInstance.terminate();\n  };\n  \n  workerInstance.postMessage(topElement);\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `Stack` (from @kit.ArkTS) to traverse all elements, passes each element to a `worker` thread (from @kit.ArkTS) for transformation (e.g., converting strings to uppercase), and then uses the `push` method of a new `Stack` to store the transformed results. The new stack should be returned.",
    "input": "",
    "output": "import {worker, Stack} from '@kit.ArkTS';\n\nexport function transformStackElements(inputStack: Stack<string>): Stack<string> {\n  const outputStack = new Stack<string>();\n  \n  inputStack.forEach((element: string) => {\n    const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n    \n    workerInstance.onmessage = (transformedElement: string) => {\n      outputStack.push(transformedElement);\n      workerInstance.terminate();\n    };\n    \n    workerInstance.postMessage(element);\n  });\n  \n  return outputStack;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `uri` API to parse a given URI string into its components, then uses the `TreeSet` API's `add` method to store the extracted query parameters in a sorted set. Finally, use the `TreeSet`'s `getFirstValue` and `getLastValue` methods to return the smallest and largest query parameters alphabetically.",
    "input": "",
    "output": "import {TreeSet, uri} from '@kit.ArkTS';\n\nexport function parseAndSortQueryParams(uriString: string): {first: string, last: string} {\n  const parsedUri = new uri.URI(uriString);\n  const queryParams = parsedUri.getQuery();\n  const paramSet = new TreeSet<string>();\n  \n  if (queryParams) {\n    const params = queryParams.split('&');\n    for (const param of params) {\n      const [key] = param.split('=');\n      paramSet.add(key);\n    }\n  }\n  \n  return {\n    first: paramSet.getFirstValue(),\n    last: paramSet.getLastValue()\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `TreeSet` API's `add` method to populate a set with a list of file paths, then iterates over the sorted set using the `Symbol.iterator` method. For each file path, use the `uri` API to extract the file extension and store it in another `TreeSet`. Return the final set of unique file extensions sorted alphabetically.",
    "input": "",
    "output": "import {TreeSet, uri} from '@kit.ArkTS';\n\nexport function getUniqueFileExtensions(filePaths: string[]): TreeSet<string> {\n  const filePathSet = new TreeSet<string>();\n  filePaths.forEach((path) => {\n    filePathSet.add(path);\n  });\n\n  const extensionSet = new TreeSet<string>();\n  for (const path of filePathSet) {\n    const parsedUri = uri.parse(path);\n    const pathStr = parsedUri.path;\n    if (pathStr) {\n      const lastDotIndex = pathStr.lastIndexOf('.');\n      if (lastDotIndex !== -1) {\n        const extension = pathStr.substring(lastDotIndex + 1);\n        extensionSet.add(extension);\n      }\n    }\n  }\n\n  return extensionSet;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that takes an array of URI strings, uses the `uri` API to extract the hostnames from each URI, and then stores these hostnames in a `TreeSet` using the `add` method. Use the `TreeSet`'s `isEmpty` method to check if any hostnames were collected, and if not, return an error. Otherwise, use the `values` method to return the sorted list of unique hostnames.",
    "input": "",
    "output": "import {TreeSet, uri} from '@kit.ArkTS';\n\nexport function extractAndSortHostnames(uris: string[]): string[] | Error {\n  const hostnameSet = new TreeSet<string>();\n  \n  for (const uriStr of uris) {\n    try {\n      const parsedUri = new uri.URI(uriStr);\n      const hostname = parsedUri.getHostName();\n      if (hostname) {\n        hostnameSet.add(hostname);\n      }\n    } catch (e) {\n      continue;\n    }\n  }\n  \n  if (hostnameSet.isEmpty()) {\n    return new Error('No hostnames were collected');\n  }\n  \n  return Array.from(hostnameSet.values());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a Worker using the `WorkerOptions` API with a specified `name` property, then constructs a URL using the `url` API to pass as the script path to the Worker. The function should return the Worker instance after both configurations are applied.",
    "input": "",
    "output": "import {WorkerOptions, url} from '@kit.ArkTS';\n\nexport function createWorker(scriptPath: string, workerName: string): Worker {\n  const workerOptions: WorkerOptions = {\n    name: workerName\n  };\n  const scriptUrl = new url.URL(scriptPath);\n  return new Worker(scriptUrl.toString(), workerOptions);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a shared Worker by setting the `shared` property of `WorkerOptions` to true, then dynamically generates a URL using the `url` API to point to a worker script located in a specific directory. The function should return the configured shared Worker instance.",
    "input": "",
    "output": "import {WorkerOptions, url} from '@kit.ArkTS';\n\nexport function createSharedWorker(scriptPath: string): Worker {\n  const workerOptions: WorkerOptions = {\n    shared: true\n  };\n  const scriptUrl = url.pathToFileURL(scriptPath);\n  return new Worker(scriptUrl.href, workerOptions);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes a base URL string and a Worker name as input, uses the `url` API to resolve the full path for the worker script, then creates a Worker instance using `WorkerOptions` with the resolved URL and the provided name. The function should return the Worker instance after proper initialization.",
    "input": "",
    "output": "import {WorkerOptions, url} from '@kit.ArkTS';\n\nexport function createWorker(baseUrl: string, workerName: string): Worker {\n  const resolvedUrl = url.resolve(baseUrl, workerName);\n  const options: WorkerOptions = {\n    name: workerName\n  };\n  return new Worker(resolvedUrl, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Vector` to collect a sequence of numbers, then passes the resulting Vector to the `constructor` of `TreeSet` to eliminate duplicates, and finally uses the `getFirstValue` and `getLastValue` methods of `TreeSet` to determine the smallest and largest values in the dataset.",
    "input": "",
    "output": "import {Vector, TreeSet} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[]): {min: number, max: number} {\n  const vector = new Vector<number>();\n  \n  // Add numbers to the Vector\n  numbers.forEach(num => {\n    vector.add(num);\n  });\n  \n  // Create a TreeSet from the Vector to eliminate duplicates\n  const treeSet = new TreeSet<number>(vector);\n  \n  // Get the smallest and largest values\n  const min = treeSet.getFirstValue();\n  const max = treeSet.getLastValue();\n  \n  return {min, max};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `convertToArray` method of `Vector` to transform a Vector of strings into an array, then passes this array to the `add` method of `TreeSet` to create a sorted and unique collection of strings, and finally uses the `forEach` method of `TreeSet` to print each string in alphabetical order.",
    "input": "",
    "output": "import {Vector, TreeSet} from '@kit.ArkTS';\n\nexport function transformAndPrintSortedStrings(vector: Vector<string>): void {\n  const array: string[] = vector.convertToArray();\n  const treeSet: TreeSet<string> = new TreeSet<string>();\n  treeSet.add(array);\n  treeSet.forEach((value: string) => {\n    console.log(value);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `subVector` method of `Vector` to extract a range of elements, then passes this sub-vector to the `entries` method of `TreeSet` to create an iterable collection of key-value pairs, and finally uses the `length` property of both `Vector` and `TreeSet` to compare the sizes of the original and processed datasets.",
    "input": "",
    "output": "import {Vector, TreeSet} from '@kit.ArkTS';\n\nexport function compareVectorAndTreeSetSizes(vector: Vector<number>, start: number, end: number): boolean {\n  const subVector = vector.subVector(start, end);\n  const treeSet = new TreeSet<number>();\n  \n  for (const value of subVector) {\n    treeSet.add(value);\n  }\n  \n  const entries = treeSet.entries();\n  const vectorLength = vector.length;\n  const treeSetLength = treeSet.length;\n  \n  return vectorLength === treeSetLength;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that listens for an error event using the `onerror` property of `GlobalScope` and, when triggered, creates an `Event` object to log the event's `type` and `timeStamp` properties for debugging purposes.",
    "input": "",
    "output": "import {Event, GlobalScope} from '@kit.ArkTS';\n\nexport function setupErrorListener(): void {\n  GlobalScope.onerror = (event: Event): void => {\n    console.log(`Error event type: ${event.type}`);\n    console.log(`Error event timestamp: ${event.timeStamp}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `self` property of `GlobalScope` to access the current context, then simulates an event dispatch by manually creating an `Event` object with a custom `type` and the current timestamp (`timeStamp`), and logs the event details.",
    "input": "",
    "output": "import {Event, GlobalScope} from '@kit.ArkTS';\n\nexport function simulateEventDispatch(): void {\n  const currentContext = GlobalScope.self;\n  const customEvent = new Event('customEvent');\n  customEvent.timeStamp = Date.now();\n  \n  console.log(`Event Type: ${customEvent.type}, Timestamp: ${customEvent.timeStamp}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if the `name` property of `GlobalScope` matches a predefined value, and if so, triggers a custom event by creating an `Event` object with a specific `type` and logs the `timeStamp` of when the check was performed.",
    "input": "",
    "output": "import {Event, GlobalScope} from '@kit.ArkTS';\n\nexport function checkNameAndTriggerEvent(predefinedName: string, eventType: string): void {\n  if (GlobalScope.name === predefinedName) {\n    const customEvent = new Event(eventType);\n    console.log(customEvent.timeStamp);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getUidForName` method of `process` to retrieve the UID for a given process name, then stores the UID and process name as a key-value pair in a `PlainArray` using its `add` method. Finally, use the `getValueAt` method of `PlainArray` to verify the stored UID matches the expected value.",
    "input": "",
    "output": "import {process, PlainArray} from '@kit.ArkTS';\n\nexport function storeAndVerifyProcessUid(processName: string, expectedUid: number): boolean {\n  const uid = process.getUidForName(processName);\n  const plainArray = new PlainArray<string>();\n  plainArray.add(uid, processName);\n  const storedUid = plainArray.getKeyAt(0);\n  return storedUid === expectedUid;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `getEnvironmentVar` method of `process` to fetch an environment variable, then checks if the variable exists using the `has` method of `PlainArray`. If it exists, update its value in the `PlainArray` using the `setValueAt` method; otherwise, add it using the `add` method.",
    "input": "",
    "output": "import {process, PlainArray} from '@kit.ArkTS';\n\nexport function updateOrAddEnvVar(envVarName: string, plainArray: PlainArray<number, string>): void {\n  const envVarValue = process.getEnvironmentVar(envVarName);\n  if (envVarValue !== undefined) {\n    const index = plainArray.getIndexOfKey(envVarName);\n    if (index !== -1) {\n      plainArray.setValueAt(index, envVarValue);\n    } else {\n      plainArray.add(envVarName, envVarValue);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first uses the `getStartRealtime` method of `process` to get the start time of a process, then stores this time along with the process name in a `PlainArray` using the `add` method. Use the `forEach` method of `PlainArray` to iterate over all entries and print each process name and its start time.",
    "input": "",
    "output": "import {process, PlainArray} from '@kit.ArkTS';\n\nexport function storeAndPrintProcessInfo(processNames: string[]): void {\n  const processArray: PlainArray<string> = new PlainArray<string>();\n\n  processNames.forEach((name: string) => {\n    const startTime: number = process.getStartRealtime();\n    processArray.add(startTime, name);\n  });\n\n  processArray.forEach((value: string, key: number) => {\n    console.log(`Process Name: ${value}, Start Time: ${key}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` (from @kit.ArkTS) to enqueue a series of numbers, then transfers all elements from the `Queue` to an `ArrayList` (from @kit.ArkTS) using its `add` method, and finally sorts the `ArrayList` using its `sort` method to display the numbers in ascending order.",
    "input": "",
    "output": "import {ArrayList, Queue} from '@kit.ArkTS';\n\nexport function processQueueToSortedArrayList(numbers: number[]): ArrayList<number> {\n  const queue = new Queue<number>();\n  numbers.forEach((num) => {\n    queue.add(num);\n  });\n\n  const arrayList = new ArrayList<number>();\n  while (queue.length > 0) {\n    const num = queue.pop();\n    if (num !== undefined) {\n      arrayList.add(num);\n    }\n  }\n\n  arrayList.sort((a, b) => a - b);\n  return arrayList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `ArrayList` (from @kit.ArkTS) of strings, uses its `subArrayList` method to extract a subset of elements, and then adds these elements to a `Queue` (from @kit.ArkTS) using its `add` method to process them in a first-in-first-out manner.",
    "input": "",
    "output": "import {ArrayList, Queue} from '@kit.ArkTS';\n\nexport function processArrayListToQueue(): void {\n  const arrayList = new ArrayList<string>();\n  arrayList.add('Element1');\n  arrayList.add('Element2');\n  arrayList.add('Element3');\n  arrayList.add('Element4');\n  arrayList.add('Element5');\n\n  const subList = arrayList.subArrayList(1, 3);\n  const queue = new Queue<string>();\n\n  for (const element of subList) {\n    queue.add(element);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirst` and `pop` methods of `Queue` (from @kit.ArkTS) to dequeue elements one by one, checks if each element exists in an `ArrayList` (from @kit.ArkTS) using its `has` method, and removes the element from the `ArrayList` using its `remove` method if found.",
    "input": "",
    "output": "import {ArrayList, Queue} from '@kit.ArkTS';\n\nexport function dequeueAndRemove(queue: Queue<number>, list: ArrayList<number>): void {\n  while (queue.length > 0) {\n    const element = queue.getFirst();\n    if (list.has(element)) {\n      list.remove(element);\n    }\n    queue.pop();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to run a background task (defined as a `CallbackFunction`), and then uses `GlobalScope.onerror` to handle any errors thrown by the task. The function should return the task's result if successful or the error message if it fails.",
    "input": "",
    "output": "import {GlobalScope, taskpool} from '@kit.ArkTS';\n\nexport async function executeTaskWithErrorHandling(task: taskpool.CallbackFunction<unknown>): Promise<string | unknown> {\n  return new Promise((resolve) => {\n    const errorHandler = (error: ErrorEvent) => {\n      GlobalScope.self.removeEventListener('error', errorHandler);\n      resolve(error.message);\n    };\n\n    GlobalScope.self.addEventListener('error', errorHandler);\n\n    taskpool.execute(task).then((result) => {\n      GlobalScope.self.removeEventListener('error', errorHandler);\n      resolve(result);\n    }).catch((error) => {\n      GlobalScope.self.removeEventListener('error', errorHandler);\n      resolve(error.message);\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that schedules a delayed task using `taskpool.executeDelayed` with a `Priority` of `High`, and then uses `GlobalScope.self` to compare the task's execution context with the global scope. The function should return `true` if they match, otherwise `false`.",
    "input": "",
    "output": "import {GlobalScope, taskpool} from '@kit.ArkTS';\n\nexport function compareContextWithGlobalScope(): Promise<boolean> {\n  return new Promise<boolean>((resolve) => {\n    const task = taskpool.executeDelayed(\n      () => {\n        return GlobalScope.self === this;\n      },\n      0,\n      taskpool.Priority.HIGH\n    );\n\n    task.then((result) => {\n      resolve(result);\n    }).catch(() => {\n      resolve(false);\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `taskpool.executePeriodically` to run a task every 2 seconds, and uses `GlobalScope.name` to log the task's execution time along with the global scope's name. The function should stop the periodic task after 10 seconds using `taskpool.cancel`.",
    "input": "",
    "output": "import {GlobalScope, taskpool} from '@kit.ArkTS';\n\nexport function executePeriodicTask(): void {\n  const task: taskpool.CallbackFunction = () => {\n    console.log(`Task executed at ${new Date().toISOString()} in scope: ${GlobalScope.name}`);\n  };\n\n  const taskId = taskpool.executePeriodically(task, 2000);\n\n  setTimeout(() => {\n    taskpool.cancel(taskId);\n    console.log('Periodic task stopped after 10 seconds');\n  }, 10000);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `WorkerEventTarget.addEventListener` to listen for a custom event in a worker thread, and upon receiving the event, uses `DedicatedWorkerGlobalScope.postMessage` to send a processed response back to the main thread. The function must also handle errors by using `WorkerEventTarget.removeEventListener` to clean up the listener if an error occurs.",
    "input": "",
    "output": "import {WorkerEventTarget, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerListener(workerScope: DedicatedWorkerGlobalScope, eventName: string): void {\n  const eventHandler = (event: Event) => {\n    try {\n      const customEvent = event as CustomEvent;\n      const processedData = processEventData(customEvent.detail);\n      workerScope.postMessage(processedData);\n    } catch (error) {\n      workerScope.removeEventListener(eventName, eventHandler);\n    }\n  };\n\n  workerScope.addEventListener(eventName, eventHandler);\n}\n\nfunction processEventData(data: unknown): unknown {\n  // Implement your data processing logic here\n  return data;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker that uses `DedicatedWorkerGlobalScope.onmessage` to receive data from the main thread, processes the data, and then uses `WorkerEventTarget.dispatchEvent` to trigger a custom event with the result. The main thread should use `WorkerEventTarget.addEventListener` to listen for this custom event and log the result.",
    "input": "",
    "output": "import {WorkerEventTarget, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createWorker() {\n  const worker = new DedicatedWorkerGlobalScope('worker.js');\n  \n  worker.onmessage = (event: MessageEvent<string>) => {\n    const processedData = event.data.toUpperCase();\n    const customEvent = new CustomEvent('processed', { detail: processedData });\n    worker.dispatchEvent(customEvent);\n  };\n  \n  return worker;\n}\n\nexport function setupMainThreadListener(worker: DedicatedWorkerGlobalScope) {\n  worker.addEventListener('processed', (event: CustomEvent) => {\n    console.log('Processed data:', event.detail);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a worker cleanup function that first uses `DedicatedWorkerGlobalScope.close` to terminate the worker, then uses `WorkerEventTarget.removeAllListener` to remove all event listeners associated with the worker to ensure no memory leaks occur.",
    "input": "",
    "output": "import {WorkerEventTarget, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function cleanupWorker(workerScope: DedicatedWorkerGlobalScope & WorkerEventTarget): void {\n  workerScope.close();\n  workerScope.removeAllListener();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to store a sequence of event names, then iterates over the list using `forEach` and dispatches each event using the `dispatchEvent` method of `WorkerEventTarget`. The function should return the number of events successfully dispatched.",
    "input": "",
    "output": "import {WorkerEventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function dispatchEvents(eventNames: string[], target: WorkerEventTarget): number {\n  const list = new LinkedList<string>();\n  let dispatchedCount = 0;\n\n  eventNames.forEach((eventName) => {\n    list.add(eventName);\n  });\n\n  list.forEach((eventName) => {\n    try {\n      target.dispatchEvent(eventName);\n      dispatchedCount++;\n    } catch (e) {\n      console.error(`Failed to dispatch event: ${eventName}`);\n    }\n  });\n\n  return dispatchedCount;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `convertToArray` method of `LinkedList` to transform a linked list of numbers into an array, then uses the `addEventListener` method of `WorkerEventTarget` to listen for a custom event that triggers the calculation of the sum of the array elements. The function should return the sum once the event is dispatched.",
    "input": "",
    "output": "import {WorkerEventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function calculateSumFromLinkedList(linkedList: LinkedList<number>, eventTarget: WorkerEventTarget): Promise<number> {\n  return new Promise((resolve) => {\n    const array = linkedList.convertToArray();\n    \n    const eventListener = () => {\n      const sum = array.reduce((acc, curr) => acc + curr, 0);\n      resolve(sum);\n      eventTarget.removeEventListener('calculate', eventListener);\n    };\n    \n    eventTarget.addEventListener('calculate', eventListener);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list, then uses the `removeEventListener` method of `WorkerEventTarget` to remove a specific event listener if the first and last elements are equal. The function should return a boolean indicating whether the listener was removed.",
    "input": "",
    "output": "import {WorkerEventTarget, LinkedList} from '@kit.ArkTS';\n\nexport function checkAndRemoveListener(list: LinkedList<number>, eventTarget: WorkerEventTarget, eventType: string, listener: EventListenerOrEventListenerObject): boolean {\n  const firstElement = list.getFirst();\n  const lastElement = list.getLast();\n  \n  if (firstElement === lastElement) {\n    eventTarget.removeEventListener(eventType, listener);\n    return true;\n  }\n  \n  return false;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a new Worker instance using the `WorkerOptions` API with the `name` property set to 'dataProcessor', and then uses the `url` API to construct a script URL for the Worker. The function should pass this URL to the Worker constructor to initialize the Worker with the specified script.",
    "input": "",
    "output": "import {url, WorkerOptions} from '@kit.ArkTS';\n\nexport function createDataProcessorWorker(scriptPath: string): Worker {\n  const workerOptions: WorkerOptions = {\n    name: 'dataProcessor'\n  };\n  const scriptUrl: string = url.URL(scriptPath).toString();\n  return new Worker(scriptUrl, workerOptions);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a shared Worker using the `WorkerOptions` API with the `shared` property set to true and the `name` property set to 'sharedWorker'. Then, use the `url` API to generate a dynamic URL for the Worker script based on the current environment (e.g., 'dev' or 'prod'). Pass this URL to the Worker constructor to start the shared Worker with the appropriate script.",
    "input": "",
    "output": "import {url, WorkerOptions} from '@kit.ArkTS';\n\nexport function initializeSharedWorker(env: 'dev' | 'prod'): Worker {\n  const workerOptions: WorkerOptions = {\n    name: 'sharedWorker',\n    shared: true\n  };\n\n  const scriptUrl = env === 'dev' ? 'devWorkerScript.js' : 'prodWorkerScript.js';\n  const workerScriptUrl = new url.URL(scriptUrl, import.meta.url).toString();\n\n  return new Worker(workerScriptUrl, workerOptions);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses the `url` API to parse a given URL string into its components (e.g., protocol, hostname, path), and then creates a new Worker instance using the `WorkerOptions` API. The Worker should be configured with the `name` property derived from the URL's hostname and the `shared` property set to false. The function should pass the parsed URL path as a message to the Worker for further processing.",
    "input": "",
    "output": "import {url, WorkerOptions} from '@kit.ArkTS';\n\nexport function createWorkerFromUrl(urlString: string): void {\n  const parsedUrl = url.parse(urlString);\n  const workerOptions: WorkerOptions = {\n    name: parsedUrl.hostname,\n    shared: false\n  };\n  const worker = new Worker('worker.ts', workerOptions);\n  worker.postMessage(parsedUrl.path);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `HashSet` to collect unique error messages from a worker thread, then passes the collected messages to the `onerror` event handler of `WorkerGlobalScope` to log and handle them asynchronously.",
    "input": "",
    "output": "import {WorkerGlobalScope, HashSet} from '@kit.ArkTS';\n\nexport function collectAndHandleErrors(errorMessages: string[]): void {\n  const uniqueErrors = new HashSet<string>();\n  \n  errorMessages.forEach((message) => {\n    uniqueErrors.add(message);\n  });\n  \n  const workerScope: WorkerGlobalScope = self;\n  \n  workerScope.onerror = (event: ErrorEvent) => {\n    uniqueErrors.forEach((error) => {\n      console.error(`Unique error: ${error}`);\n    });\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `has` method of `HashSet` to check if a specific worker name exists in a set of active workers, then uses the `name` property of `WorkerGlobalScope` to dynamically assign or verify the worker's identity before performing further operations.",
    "input": "",
    "output": "import {WorkerGlobalScope, HashSet} from '@kit.ArkTS';\n\nexport function checkWorkerIdentity(activeWorkers: HashSet<string>, workerScope: WorkerGlobalScope): boolean {\n  const workerName = workerScope.name;\n  if (activeWorkers.has(workerName)) {\n    return true;\n  }\n  return false;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `HashSet` to iterate over a collection of worker tasks, and for each task, uses the `self` property of `WorkerGlobalScope` to post a message back to the main thread with the task's completion status.",
    "input": "",
    "output": "import {WorkerGlobalScope, HashSet} from '@kit.ArkTS';\n\nexport function processWorkerTasks(tasks: HashSet<string>, workerScope: WorkerGlobalScope): void {\n  tasks.forEach((task: string) => {\n    workerScope.self.postMessage({ status: 'completed', task: task });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `self` property of `GlobalScope` to access the current global object, then passes it to a Worker thread using `WorkerGlobalScope`'s `name` property to identify the Worker. The function should then set up an error handler using the `onerror` property of both `GlobalScope` and `WorkerGlobalScope` to log errors from both contexts.",
    "input": "",
    "output": "import {GlobalScope, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerWithErrorHandling(): void {\n  const globalObj: GlobalScope = GlobalScope.self;\n  \n  // Create a new worker with a name\n  const worker: WorkerGlobalScope = new WorkerGlobalScope();\n  worker.name = 'errorHandlingWorker';\n  \n  // Set up error handler for the global scope\n  globalObj.onerror = (event: ErrorEvent) => {\n    console.error(`Global error: ${event.message}`);\n  };\n  \n  // Set up error handler for the worker scope\n  worker.onerror = (event: ErrorEvent) => {\n    console.error(`Worker error: ${event.message}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a program where the `name` property of `GlobalScope` is used to set a unique identifier for the main thread, and then this name is passed to a Worker thread via `WorkerGlobalScope`'s `name` property. The program should use the `onerror` property of `WorkerGlobalScope` to handle any errors in the Worker and propagate them back to the main thread using `GlobalScope`'s `onerror`.",
    "input": "",
    "output": "import {GlobalScope, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupMainThread() {\n  GlobalScope.name = 'MainThread';\n  \n  GlobalScope.onerror = (event: ErrorEvent) => {\n    console.error(`Main thread error: ${event.message}`);\n  };\n  \n  const worker = new Worker('worker.ts');\n  \n  worker.onmessage = (event: MessageEvent) => {\n    console.log(`Message from worker: ${event.data}`);\n  };\n  \n  worker.onerror = (event: ErrorEvent) => {\n    GlobalScope.onerror?.(event);\n  };\n}\n\nexport function setupWorkerThread() {\n  WorkerGlobalScope.name = 'WorkerThread';\n  \n  WorkerGlobalScope.onerror = (event: ErrorEvent) => {\n    WorkerGlobalScope.postMessage(`Worker error: ${event.message}`);\n    return true;\n  };\n  \n  WorkerGlobalScope.postMessage(`Worker thread name: ${WorkerGlobalScope.name}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a scenario where the `self` property of `WorkerGlobalScope` is used to access the Worker's global object, and then this object is compared with the `self` property of `GlobalScope` to verify if the code is running in the main thread or a Worker. The program should use the `onerror` properties of both APIs to handle and log any errors during this verification process.",
    "input": "",
    "output": "import {GlobalScope, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function checkThreadEnvironment(): void {\n  try {\n    const globalSelf = GlobalScope.self;\n    const workerSelf = WorkerGlobalScope.self;\n\n    if (globalSelf === workerSelf) {\n      console.log('Running in the main thread');\n    } else {\n      console.log('Running in a Worker thread');\n    }\n  } catch (error) {\n    if (GlobalScope.onerror) {\n      GlobalScope.onerror(error);\n    }\n    if (WorkerGlobalScope.onerror) {\n      WorkerGlobalScope.onerror(error);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.getUidForName` to retrieve the UID for a given process name, then stores the UID and process name as a key-value pair in a `LightWeightMap` using its `set` method. Finally, use `LightWeightMap.getValueAt` to verify the stored UID matches the original retrieval.",
    "input": "",
    "output": "import {process, LightWeightMap} from '@kit.ArkTS';\n\nexport function storeAndVerifyProcessUID(processName: string): boolean {\n  const uid = process.getUidForName(processName);\n  const map = new LightWeightMap<string, number>();\n  map.set(processName, uid);\n  const storedUid = map.getValueAt(map.getIndexOfKey(processName));\n  return storedUid === uid;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that collects the system environment variables using `process.getEnvironmentVar` and stores them in a `LightWeightMap` where the keys are the variable names and the values are the variable values. Use `LightWeightMap.forEach` to iterate over the entries and log each key-value pair to the console.",
    "input": "",
    "output": "import {process, LightWeightMap} from '@kit.ArkTS';\n\nexport function collectAndLogEnvironmentVars(): void {\n  const envVars = new LightWeightMap<string, string>();\n  const env = process.getEnvironmentVar();\n  \n  for (const key in env) {\n    if (Object.prototype.hasOwnProperty.call(env, key)) {\n      envVars.set(key, env[key]);\n    }\n  }\n  \n  envVars.forEach((value: string, key: string) => {\n    console.log(`Key: ${key}, Value: ${value}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if the current process is 64-bit using `process.is64Bit`, then stores the result (true/false) in a `LightWeightMap` with the key 'is64Bit'. Use `LightWeightMap.get` to retrieve the value and return it as the function's output.",
    "input": "",
    "output": "import {process, LightWeightMap} from '@kit.ArkTS';\n\nexport function checkIs64Bit(): boolean {\n  const is64Bit = process.is64Bit();\n  const map = new LightWeightMap();\n  map.set('is64Bit', is64Bit);\n  return map.get('is64Bit');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "",
    "input": "",
    "output": "",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `WorkerEventTarget.addEventListener` to listen for a custom event, then parses the event data using `json.parse` and checks if a specific key exists in the parsed object using `json.has`. The function should return the parsed object if the key exists, otherwise return null.",
    "input": "",
    "output": "import {WorkerEventTarget, json} from '@kit.ArkTS';\n\nexport function listenAndParseEvent(eventTarget: WorkerEventTarget, eventType: string, key: string): object | null {\n  let parsedData: object | null = null;\n  \n  const eventHandler = (event: { data: string }) => {\n    try {\n      const parsedObject = json.parse(event.data);\n      if (json.has(parsedObject, key)) {\n        parsedData = parsedObject;\n      } else {\n        parsedData = null;\n      }\n    } catch (e) {\n      parsedData = null;\n    }\n  };\n  \n  eventTarget.addEventListener(eventType, eventHandler);\n  \n  return parsedData;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses `json.stringify` to convert an object into a JSON string, then dispatches the string as part of a custom event using `WorkerEventTarget.dispatchEvent`. The function should also set up an event listener using `WorkerEventTarget.addEventListener` to log the dispatched event data.",
    "input": "",
    "output": "import {WorkerEventTarget, json} from '@kit.ArkTS';\n\nexport function handleCustomEvent(obj: object): void {\n  const jsonString = json.stringify(obj);\n  const event = { type: 'customEvent', data: jsonString };\n  const workerEventTarget = new WorkerEventTarget();\n  \n  workerEventTarget.addEventListener('customEvent', (eventData: { data: string }) => {\n    console.log(`Dispatched event data: ${eventData.data}`);\n  });\n  \n  workerEventTarget.dispatchEvent(event);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that removes all event listeners using `WorkerEventTarget.removeAllListener`, then uses `json.remove` to delete a specified key from a JSON object. The function should return the modified JSON object after the key has been removed.",
    "input": "",
    "output": "import {WorkerEventTarget, json} from '@kit.ArkTS';\n\nexport function removeKeyAndListeners(workerEventTarget: WorkerEventTarget, jsonObj: object, keyToRemove: string): object {\n  workerEventTarget.removeAllListener();\n  json.remove(jsonObj, keyToRemove);\n  return jsonObj;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onerror` property of `WorkerGlobalScope` to handle errors in a worker thread, and then logs the error details to a `LightWeightSet` instance using its `add` method. The function should also check if the `LightWeightSet` is empty using the `isEmpty` property before adding the error.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightSet} from '@kit.ArkTS';\n\nexport function handleWorkerError(workerScope: WorkerGlobalScope, errorSet: LightWeightSet<string>): void {\n  workerScope.onerror = (error: ErrorEvent) => {\n    if (errorSet.isEmpty()) {\n      errorSet.add(`Error: ${error.message}, Filename: ${error.filename}, Line: ${error.lineno}, Col: ${error.colno}`);\n    } else {\n      errorSet.add(`Error: ${error.message}, Filename: ${error.filename}, Line: ${error.lineno}, Col: ${error.colno}`);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `name` property from `WorkerGlobalScope` and stores it in a `LightWeightSet` using the `add` method. Then, use the `forEach` method of `LightWeightSet` to iterate over all stored names and print them to the console.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightSet} from '@kit.ArkTS';\n\nexport function retrieveAndStoreName(scope: WorkerGlobalScope): void {\n  const nameSet = new LightWeightSet<string>();\n  if (scope.name) {\n    nameSet.add(scope.name);\n  }\n  nameSet.forEach((value: string) => {\n    console.log(value);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `self` property of `WorkerGlobalScope` to get the current worker context, then passes this context to a `LightWeightSet` instance using its `addAll` method to store multiple worker contexts. Finally, use the `toArray` method of `LightWeightSet` to convert the stored contexts into an array and return it.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightSet} from '@kit.ArkTS';\n\nexport function storeWorkerContexts(): WorkerGlobalScope[] {\n  const workerContext = self;\n  const lightWeightSet = new LightWeightSet<WorkerGlobalScope>();\n  lightWeightSet.addAll([workerContext]);\n  return lightWeightSet.toArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first generates a random UUID using `util.generateRandomUUID()`, then converts it to a hash string using `util.getHash()`, and finally validates the hash format by parsing it back to a UUID using `util.parseUUID()`. Ensure the function returns true if the parsed UUID matches the original.",
    "input": "",
    "output": "import {util, xml} from '@kit.ArkTS';\n\nexport function validateUUIDHash(): boolean {\n  const originalUUID: string = util.generateRandomUUID();\n  const hash: string = util.getHash(originalUUID);\n  const parsedUUID: string = util.parseUUID(hash);\n  return originalUUID === parsedUUID;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that formats an error message using `util.format()` with a given error code, then converts the error code to a human-readable string using `util.errnoToString()`, and finally logs the formatted message along with the readable error string using `util.printf()`. The function should return the combined output string.",
    "input": "",
    "output": "import {util, xml} from '@kit.ArkTS';\n\nexport function formatAndLogError(errorCode: number, ...args: any[]): string {\n  const formattedMessage = util.format(...args);\n  const readableError = util.errnoToString(errorCode);\n  const combinedOutput = `${formattedMessage}: ${readableError}`;\n  util.printf(combinedOutput);\n  return combinedOutput;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses `util.promisify()` to convert a callback-based XML parsing operation (simulated) into a promise, then handles the parsed XML data by generating a random binary UUID using `util.generateRandomBinaryUUID()` as a mock session ID, and finally returns the session ID along with the parsed data in a structured object.",
    "input": "",
    "output": "import {util, xml} from '@kit.ArkTS';\n\nexport interface ParsedData {\n  sessionId: Uint8Array;\n  parsedXml: object;\n}\n\nexport async function parseXmlAndGenerateSessionId(xmlString: string): Promise<ParsedData> {\n  const parseXml = util.promisify(xml.parse);\n  const parsedXml = await parseXml(xmlString);\n  const sessionId = util.generateRandomBinaryUUID();\n  return {\n    sessionId,\n    parsedXml\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `ArrayList<string>` (from @kit.ArkTS) to collect a list of file names, then passes this list to the `forEach` method of `ArrayList<string>` to process each file name by converting it to uppercase and logging it to the console. Finally, use the `sort` method of `ArrayList<string>` to alphabetically sort the processed file names.",
    "input": "",
    "output": "import {ArrayList, stream} from '@kit.ArkTS';\n\nexport function processFileNames(): void {\n  const fileNames: ArrayList<string> = new ArrayList<string>();\n  \n  // Add file names to the ArrayList\n  fileNames.add('file1.txt');\n  fileNames.add('file2.txt');\n  fileNames.add('file3.txt');\n  \n  // Process each file name by converting to uppercase and logging\n  fileNames.forEach((fileName: string) => {\n    const upperCaseName: string = fileName.toUpperCase();\n    console.log(upperCaseName);\n  });\n  \n  // Sort the file names alphabetically\n  fileNames.sort((a: string, b: string) => {\n    return a.localeCompare(b);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes an `ArrayList<number>` (from @kit.ArkTS) with random numbers using the `add` method, then uses the `getIndexOf` method to find the index of a specific target number. Pass this index to the `removeByIndex` method to remove the target number from the list, and finally use the `trimToCurrentLength` method to optimize the list's capacity.",
    "input": "",
    "output": "import {ArrayList, stream} from '@kit.ArkTS';\n\nexport function processArrayList(target: number): void {\n  const list: ArrayList<number> = new ArrayList<number>();\n  \n  // Initialize the list with 10 random numbers between 1 and 100\n  for (let i = 0; i < 10; i++) {\n    list.add(Math.floor(Math.random() * 100) + 1);\n  }\n  \n  // Find the index of the target number\n  const index: number = list.getIndexOf(target);\n  \n  // Remove the target number if found\n  if (index !== -1) {\n    list.removeByIndex(index);\n  }\n  \n  // Optimize the list's capacity\n  list.trimToCurrentLength();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses the `insert` method of `ArrayList<string>` (from @kit.ArkTS) to build a list of sentences, then employs the `replaceAllElements` method to replace each sentence with its word count. Pass the resulting list of word counts to the `subArrayList` method to extract a subset of counts, and finally use the `convertToArray` method to convert this subset into a standard array for further processing.",
    "input": "",
    "output": "import {ArrayList, stream} from '@kit.ArkTS';\n\nexport function processSentences(sentences: string[], start: number, end: number): number[] {\n  const list: ArrayList<string> = new ArrayList();\n  \n  // Insert sentences into the ArrayList\n  sentences.forEach((sentence) => {\n    list.insert(sentence);\n  });\n  \n  // Replace each sentence with its word count\n  list.replaceAllElements((sentence: string) => {\n    return sentence.split(' ').length;\n  });\n  \n  // Extract a subset of word counts\n  const subList = list.subArrayList(start, end);\n  \n  // Convert the subset to a standard array\n  const result = subList.convertToArray();\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create 10 random UUIDs, then adds them to a `HashSet` using its `add` method. Finally, use the `forEach` method of `HashSet` to print each UUID in the set.",
    "input": "",
    "output": "import {HashSet, util} from '@kit.ArkTS';\n\nexport function generateAndPrintUUIDs(): void {\n  const uuidSet = new HashSet<string>();\n  \n  for (let i = 0; i < 10; i++) {\n    const uuid = util.generateRandomUUID();\n    uuidSet.add(uuid);\n  }\n  \n  uuidSet.forEach((value: string) => {\n    console.log(value);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getHash` method of `util` to compute the hash of a given string, then checks if the hash already exists in a `HashSet` using its `has` method. If it doesn't exist, add the hash to the `HashSet` using the `add` method and return true; otherwise, return false.",
    "input": "",
    "output": "import {HashSet, util} from '@kit.ArkTS';\n\nexport function checkAndAddHash(hashSet: HashSet<string>, inputString: string): boolean {\n  const hash = util.getHash(inputString);\n  if (!hashSet.has(hash)) {\n    hashSet.add(hash);\n    return true;\n  }\n  return false;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `values` method of `HashSet` to iterate over all elements in the set, then formats each element into a string using the `format` method of `util`. The formatted strings should be concatenated into a single string separated by commas and returned.",
    "input": "",
    "output": "import {HashSet, util} from '@kit.ArkTS';\n\nexport function formatHashSetElements(set: HashSet<unknown>): string {\n  const formattedElements: string[] = [];\n  const iterator = set.values();\n  let result = iterator.next();\n  while (!result.done) {\n    const element = result.value;\n    formattedElements.push(util.format('%s', element));\n    result = iterator.next();\n  }\n  return formattedElements.join(',');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to store a sequence of event objects (each with `type` and `timeStamp` properties from the `Event` API). Then, use the `getLastIndexOf` method of `LinkedList` to find the last occurrence of a specific event type, and return its `timeStamp` from the `Event` object.",
    "input": "",
    "output": "import {LinkedList, Event} from '@kit.ArkTS';\n\nexport function findLastEventTimestamp(events: LinkedList<Event>, eventType: string): number | undefined {\n  const lastIndex = events.getLastIndexOf((event: Event) => event.type === eventType);\n  if (lastIndex === -1) {\n    return undefined;\n  }\n  const lastEvent = events.get(lastIndex);\n  return lastEvent?.timeStamp;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `convertToArray` method of `LinkedList` to transform a linked list of events into an array. Then, iterate over this array using the `forEach` method of `LinkedList` to filter out events with a `timeStamp` (from `Event`) older than a given threshold, and return a new `LinkedList` containing only the recent events using the `add` method.",
    "input": "",
    "output": "import {LinkedList, Event} from '@kit.ArkTS';\n\nexport function filterRecentEvents(events: LinkedList<Event>, threshold: number): LinkedList<Event> {\n  const recentEvents = new LinkedList<Event>();\n  const eventsArray = events.convertToArray();\n  \n  eventsArray.forEach((event: Event) => {\n    if (event.timeStamp >= threshold) {\n      recentEvents.add(event);\n    }\n  });\n  \n  return recentEvents;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last event objects in the list. Then, compare their `timeStamp` properties (from `Event`) to calculate the duration between the first and last event, and return this duration along with the `type` of the first event.",
    "input": "",
    "output": "import {LinkedList, Event} from '@kit.ArkTS';\n\nexport function getEventDuration(events: LinkedList<Event>): {duration: number, type: string} | undefined {\n  if (events.length === 0) {\n    return undefined;\n  }\n\n  const firstEvent = events.getFirst();\n  const lastEvent = events.getLast();\n\n  if (!firstEvent || !lastEvent) {\n    return undefined;\n  }\n\n  const duration = lastEvent.timeStamp - firstEvent.timeStamp;\n  return {\n    duration: duration,\n    type: firstEvent.type\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `uri` API to parse a given URI string into its components, then uses the `EventTarget.addEventListener` method to listen for a custom event named 'uriParsed', and finally dispatches the parsed URI components as part of the event using `EventTarget.dispatchEvent`.",
    "input": "",
    "output": "import {EventTarget, uri} from '@kit.ArkTS';\n\nexport function parseAndDispatchUri(uriString: string, eventTarget: EventTarget): void {\n  const parsedUri = uri.parse(uriString);\n  const event = {\n    type: 'uriParsed',\n    detail: parsedUri\n  };\n  eventTarget.dispatchEvent(event);\n}\n\nexport function setupUriListener(eventTarget: EventTarget, callback: (event: {type: string, detail: any}) => void): void {\n  eventTarget.addEventListener('uriParsed', callback);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `uri` API to validate a given URI string, then uses `EventTarget.addEventListener` to listen for a 'validationComplete' event, and triggers the event using `EventTarget.dispatchEvent` with the validation result (true/false) as part of the event data.",
    "input": "",
    "output": "import {EventTarget, uri} from '@kit.ArkTS';\n\nexport function validateAndDispatchURI(uriString: string, eventTarget: EventTarget): void {\n  let isValid = false;\n  try {\n    new uri.URI(uriString);\n    isValid = true;\n  } catch (error) {\n    isValid = false;\n  }\n\n  const event = {\n    type: 'validationComplete',\n    data: isValid\n  };\n  eventTarget.dispatchEvent(event);\n}\n\nexport function setupValidationListener(eventTarget: EventTarget, callback: (isValid: boolean) => void): void {\n  eventTarget.addEventListener('validationComplete', (event) => {\n    callback(event.data);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `uri` API to extract the query parameters from a given URI string, then uses `EventTarget.removeEventListener` to remove a previously attached listener for a 'queryExtracted' event, and finally dispatches the extracted query parameters using `EventTarget.dispatchEvent`.",
    "input": "",
    "output": "import {EventTarget, uri} from '@kit.ArkTS';\n\nexport function extractAndDispatchQueryParams(uriString: string, eventTarget: EventTarget): void {\n  const parsedUri = new uri.URI(uriString);\n  const queryParams = parsedUri.getQuery();\n  \n  eventTarget.removeEventListener('queryExtracted', () => {});\n  \n  const event = {\n    type: 'queryExtracted',\n    detail: queryParams\n  };\n  \n  eventTarget.dispatchEvent(event);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `json.stringify` to convert an object into a JSON string, then posts this string to a dedicated worker using `DedicatedWorkerGlobalScope.postMessage`. The worker should parse the JSON string back into an object using `json.parse` and log the result.",
    "input": "",
    "output": "import {json, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function postObjectToWorker(obj: object, worker: DedicatedWorkerGlobalScope): void {\n  const jsonString = json.stringify(obj);\n  worker.postMessage(jsonString);\n}\n\nexport function setupWorker(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent<string>) => {\n    const parsedObj = json.parse(event.data);\n    console.log(parsedObj);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that sends a complex object to a dedicated worker using `DedicatedWorkerGlobalScope.postMessage`. The worker should use `json.has` to check if the object contains a specific property before processing it further. If the property exists, the worker should return a modified version of the object using `json.remove` to delete the property and then post the result back to the main thread.",
    "input": "",
    "output": "import {json, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendToWorker(worker: DedicatedWorkerGlobalScope, obj: object, propertyToCheck: string): void {\n  worker.postMessage({obj, propertyToCheck});\n}\n\nexport function setupWorker(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent) => {\n    const {obj, propertyToCheck} = event.data;\n    if (json.has(obj, propertyToCheck)) {\n      const modifiedObj = json.remove(obj, propertyToCheck);\n      worker.postMessage(modifiedObj);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where the main thread sends an array of numbers to a dedicated worker using `DedicatedWorkerGlobalScope.postMessage`. The worker should use `json.stringify` to convert the array into a JSON string, then the main thread should parse this string back into an array using `json.parse` and calculate the sum of the array elements.",
    "input": "",
    "output": "import {json, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendArrayToWorker(worker: DedicatedWorkerGlobalScope, numbers: number[]): void {\n  worker.postMessage(numbers);\n}\n\nexport function setupWorkerListener(worker: DedicatedWorkerGlobalScope, callback: (sum: number) => void): void {\n  worker.onmessage = (event: MessageEvent<number[]>) => {\n    const jsonString = json.stringify(event.data);\n    const parsedArray = json.parse(jsonString) as number[];\n    const sum = parsedArray.reduce((acc, num) => acc + num, 0);\n    callback(sum);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a sequence of key-value pairs representing task priorities (keys) and their corresponding callback functions (values). Then, use the `execute` method of `taskpool` to execute these tasks in parallel, passing the callback functions extracted from the `PlainArray` using the `getValueAt` method.",
    "input": "",
    "output": "import {PlainArray, taskpool} from '@kit.ArkTS';\n\nexport function executeTasksInParallel(): void {\n  const taskArray = new PlainArray<() => void>();\n  \n  // Add tasks with priorities (keys) and callback functions (values)\n  taskArray.add(1, () => {\n    console.log('Task 1 executed');\n  });\n  \n  taskArray.add(2, () => {\n    console.log('Task 2 executed');\n  });\n  \n  taskArray.add(3, () => {\n    console.log('Task 3 executed');\n  });\n  \n  // Execute tasks in parallel\n  for (let i = 0; i < taskArray.length; i++) {\n    const callback = taskArray.getValueAt(i);\n    if (callback) {\n      taskpool.execute(callback);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `PlainArray` with task data (keys as task IDs and values as task parameters) using the `add` method. Then, use the `forEach` method of `PlainArray` to iterate over the tasks and submit each one to the `taskpool` using the `executeDelayed` method, where the delay is determined by the task's priority (retrieved using `getKeyAt`).",
    "input": "",
    "output": "import {PlainArray, taskpool} from '@kit.ArkTS';\n\nexport function submitTasksWithDelay(): void {\n  const tasks = new PlainArray<object>();\n  \n  // Populate the PlainArray with task data\n  tasks.add(1, { priority: taskpool.Priority.HIGH, params: {} });\n  tasks.add(2, { priority: taskpool.Priority.MEDIUM, params: {} });\n  tasks.add(3, { priority: taskpool.Priority.LOW, params: {} });\n  \n  // Iterate over tasks and submit to taskpool with delay based on priority\n  tasks.forEach((value: object, index: number) => {\n    const taskId = tasks.getKeyAt(index);\n    const taskParams = value;\n    const priority = (taskParams as { priority: taskpool.Priority }).priority;\n    \n    let delay: number;\n    switch (priority) {\n      case taskpool.Priority.HIGH:\n        delay = 0; // No delay for high priority\n        break;\n      case taskpool.Priority.MEDIUM:\n        delay = 1000; // 1 second delay for medium priority\n        break;\n      case taskpool.Priority.LOW:\n        delay = 2000; // 2 seconds delay for low priority\n        break;\n      default:\n        delay = 0;\n    }\n    \n    taskpool.executeDelayed(() => {\n      // Task execution logic here\n    }, delay);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task management system where you use the `removeRangeFrom` method of `PlainArray` to clear completed tasks (identified by their keys). Then, use the `getTaskPoolInfo` method of `taskpool` to monitor the remaining tasks and log their statuses, ensuring the system only processes active tasks.",
    "input": "",
    "output": "import {PlainArray, taskpool} from '@kit.ArkTS';\n\nexport class TaskManagementSystem {\n  private tasks: PlainArray<number, string>;\n\n  constructor() {\n    this.tasks = new PlainArray<number, string>();\n  }\n\n  public addTask(key: number, value: string): void {\n    this.tasks.add(key, value);\n  }\n\n  public clearCompletedTasks(completedKeys: number[]): void {\n    if (completedKeys.length === 0) return;\n    \n    completedKeys.sort((a, b) => a - b);\n    const firstKey = completedKeys[0];\n    const lastKey = completedKeys[completedKeys.length - 1];\n    \n    this.tasks.removeRangeFrom(firstKey, lastKey);\n  }\n\n  public async monitorTasks(): Promise<void> {\n    const taskPoolInfo = taskpool.getTaskPoolInfo();\n    console.log(`Task pool state: ${taskPoolInfo.state}`);\n    console.log(`Active tasks: ${this.tasks.length}`);\n    \n    for (let i = 0; i < this.tasks.length; i++) {\n      const key = this.tasks.getKeyAt(i);\n      const value = this.tasks.getValueAt(i);\n      console.log(`Task ${key}: ${value}`);\n    }\n  }\n\n  public getActiveTasks(): PlainArray<number, string> {\n    return this.tasks;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of XML event types (from the `EventType` enum of `xml`), then passes the collected events to the `add` method of `TreeSet` to store and automatically sort them in ascending order. Finally, use the `getFirstValue` and `getLastValue` methods of `TreeSet` to determine the earliest and latest event types in the sequence.",
    "input": "",
    "output": "import {LinkedList, xml, TreeSet} from '@kit.ArkTS';\n\nexport function processXmlEventTypes(events: xml.EventType[]): {first: xml.EventType, last: xml.EventType} {\n  const linkedList = new LinkedList<xml.EventType>();\n  const treeSet = new TreeSet<xml.EventType>();\n\n  for (const event of events) {\n    linkedList.add(event);\n    treeSet.add(event);\n  }\n\n  const first = treeSet.getFirstValue();\n  const last = treeSet.getLastValue();\n\n  return {first, last};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `convertToArray` method of `LinkedList` to transform a linked list of strings into an array, then iterates over this array using the `forEach` method to check if each string contains XML-like tags (e.g., `<tag>`). Use the `has` method of `TreeSet` to track and count unique tags found in the strings, and finally return the count of unique tags using the `length` property of `TreeSet`.",
    "input": "",
    "output": "import {LinkedList, xml, TreeSet} from '@kit.ArkTS';\n\nexport function countUniqueXmlTags(linkedList: LinkedList<string>): number {\n  const array: string[] = linkedList.convertToArray();\n  const tagSet: TreeSet<string> = new TreeSet<string>();\n  \n  array.forEach((str: string) => {\n    const regex: RegExp = /<([^>]+)>/g;\n    let match: RegExpExecArray | null;\n    \n    while ((match = regex.exec(str)) !== null) {\n      const tag: string = match[1];\n      if (!tagSet.has(tag)) {\n        tagSet.add(tag);\n      }\n    }\n  });\n  \n  return tagSet.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `get` and `removeByIndex` methods of `LinkedList` to extract and remove every alternate element from the list, then inserts these elements into a `TreeSet` using the `add` method. Ensure the `TreeSet` remains sorted by using the `getHigherValue` method to verify the insertion order, and finally return the sorted `TreeSet` using the `values` method.",
    "input": "",
    "output": "import {LinkedList, xml, TreeSet} from '@kit.ArkTS';\n\nexport function extractAndSortAlternateElements(list: LinkedList<number>): TreeSet<number> {\n  const treeSet = new TreeSet<number>();\n  let index = 0;\n  while (index < list.length) {\n    const element = list.get(index);\n    list.removeByIndex(index);\n    if (treeSet.length === 0) {\n      treeSet.add(element);\n    } else {\n      const higherValue = treeSet.getHigherValue(element);\n      if (higherValue !== undefined) {\n        treeSet.add(element);\n      } else {\n        treeSet.add(element);\n      }\n    }\n    index += 1;\n  }\n  return treeSet;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `LightWeightMap` to iterate over key-value pairs, checks if each value meets a certain condition using the `hasValue` method, and then stores the filtered keys in a `PlainArray` using its `add` method. Finally, use the `getIndexOfKey` method of `PlainArray` to find the index of a specific key in the filtered list.",
    "input": "",
    "output": "import {stream, LightWeightMap, PlainArray} from '@kit.ArkTS';\n\nexport function filterAndFindIndex(lwMap: LightWeightMap<number, string>, condition: string, targetKey: number): number {\n  const plainArray = new PlainArray<number>();\n  \n  lwMap.forEach((value: string, key: number) => {\n    if (lwMap.hasValue(value) && value === condition) {\n      plainArray.add(key, key);\n    }\n  });\n  \n  return plainArray.getIndexOfKey(targetKey);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `PlainArray` with a sequence of numbers using its `add` method, then transfers these values to a `LightWeightMap` using its `set` method, where the keys are the indices from the `PlainArray`. Use the `entries` method of `LightWeightMap` to retrieve and print all key-value pairs.",
    "input": "",
    "output": "import {stream, LightWeightMap, PlainArray} from '@kit.ArkTS';\n\nexport function transferPlainArrayToLightWeightMap(): void {\n  const plainArray = new PlainArray<number>();\n  const lightWeightMap = new LightWeightMap<number, number>();\n\n  // Populate PlainArray with numbers\n  for (let i = 0; i < 5; i++) {\n    plainArray.add(i, i * 10);\n  }\n\n  // Transfer values to LightWeightMap\n  for (let i = 0; i < plainArray.length; i++) {\n    const key = plainArray.getKeyAt(i);\n    const value = plainArray.getValueAt(i);\n    if (key !== undefined && value !== undefined) {\n      lightWeightMap.set(key, value);\n    }\n  }\n\n  // Print all key-value pairs using entries\n  const iterator = lightWeightMap.entries();\n  let entry = iterator.next();\n  while (!entry.done) {\n    const [key, value] = entry.value;\n    console.log(`Key: ${key}, Value: ${value}`);\n    entry = iterator.next();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `keys` method of `LightWeightMap` to get all keys, then checks if any of these keys exist in a `PlainArray` using its `has` method. For each key that exists in both structures, use the `getValueAt` method of `PlainArray` to retrieve the corresponding value and store it in a new `LightWeightMap` using its `set` method.",
    "input": "",
    "output": "import {stream, LightWeightMap, PlainArray} from '@kit.ArkTS';\n\nexport function findCommonValues(lwm: LightWeightMap<number, any>, pa: PlainArray<any>): LightWeightMap<number, any> {\n  const result = new LightWeightMap<number, any>();\n  const keys = lwm.keys();\n  \n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (pa.has(key)) {\n      const value = pa.getValueAt(pa.getIndexOfKey(key));\n      result.set(key, value);\n    }\n  }\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a series of error messages, then dequeues them using `pop` and stores each message along with its line number (from `ErrorEvent.lineno`) in a `LightWeightMap`, where the key is the line number and the value is the error message. Finally, use `LightWeightMap.forEach` to print all key-value pairs.",
    "input": "",
    "output": "import {LightWeightMap, Queue, ErrorEvent} from '@kit.ArkTS';\n\nexport function processErrorMessages(errorEvents: ErrorEvent[]): void {\n  const queue = new Queue<string>();\n  const map = new LightWeightMap<number, string>();\n\n  // Enqueue error messages\n  errorEvents.forEach((event: ErrorEvent) => {\n    queue.add(event.message);\n  });\n\n  // Dequeue and store in LightWeightMap\n  while (queue.length > 0) {\n    const message = queue.pop();\n    const event = errorEvents.find((e: ErrorEvent) => e.message === message);\n    if (event) {\n      map.set(event.lineno, message);\n    }\n  }\n\n  // Print all key-value pairs\n  map.forEach((value: string, key: number) => {\n    console.log(`Line ${key}: ${value}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that processes an array of `ErrorEvent` objects by extracting their `message` and `filename` properties, then uses `Queue.add` to enqueue each message. Dequeue the messages using `Queue.pop` and store them in a `LightWeightMap` where the key is the filename and the value is an array of messages. Use `LightWeightMap.getKeyAt` and `getValueAt` to print the first entry.",
    "input": "",
    "output": "import {LightWeightMap, Queue, ErrorEvent} from '@kit.ArkTS';\n\nexport function processErrorEvents(errorEvents: ErrorEvent[]): void {\n  const queue = new Queue<string>();\n  const map = new LightWeightMap<string, string[]>();\n\n  // Enqueue messages\n  errorEvents.forEach((event: ErrorEvent) => {\n    queue.add(event.message);\n  });\n\n  // Dequeue messages and store in LightWeightMap\n  while (queue.length > 0) {\n    const message = queue.pop();\n    const event = errorEvents.find((e: ErrorEvent) => e.message === message);\n    if (event) {\n      const filename = event.filename;\n      if (map.hasKey(filename)) {\n        const messages = map.get(filename) as string[];\n        messages.push(message);\n        map.set(filename, messages);\n      } else {\n        map.set(filename, [message]);\n      }\n    }\n  }\n\n  // Print the first entry\n  if (map.length > 0) {\n    const firstKey = map.getKeyAt(0);\n    const firstValue = map.getValueAt(0);\n    console.log(`Key: ${firstKey}, Value: ${firstValue}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that initializes a `LightWeightMap` with keys as error codes (numbers) and values as `ErrorEvent` objects. Use `LightWeightMap.entries` to retrieve all entries, then enqueue each error code using `Queue.add`. Dequeue the codes and for each, use `LightWeightMap.get` to fetch the corresponding `ErrorEvent` and print its `message` and `lineno` properties.",
    "input": "",
    "output": "import {LightWeightMap, Queue, ErrorEvent} from '@kit.ArkTS';\n\nexport function processErrorEvents(): void {\n  const errorMap = new LightWeightMap<number, ErrorEvent>();\n  const errorQueue = new Queue<number>();\n\n  // Initialize LightWeightMap with error codes and ErrorEvent objects\n  const errorEvent1: ErrorEvent = { colno: 0, error: null, filename: 'file1', lineno: 10, message: 'Error 1 occurred' };\n  const errorEvent2: ErrorEvent = { colno: 0, error: null, filename: 'file2', lineno: 20, message: 'Error 2 occurred' };\n  const errorEvent3: ErrorEvent = { colno: 0, error: null, filename: 'file3', lineno: 30, message: 'Error 3 occurred' };\n\n  errorMap.set(1, errorEvent1);\n  errorMap.set(2, errorEvent2);\n  errorMap.set(3, errorEvent3);\n\n  // Retrieve all entries and enqueue error codes\n  const entries = errorMap.entries();\n  for (const entry of entries) {\n    errorQueue.add(entry[0]);\n  }\n\n  // Dequeue codes and print corresponding ErrorEvent properties\n  while (errorQueue.length > 0) {\n    const code = errorQueue.pop();\n    const errorEvent = errorMap.get(code);\n    if (errorEvent) {\n      console.log(`Message: ${errorEvent.message}, Line Number: ${errorEvent.lineno}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a Buffer from a string with 'utf-8' encoding, then passes this Buffer to a MessageEvent constructor to create an event, and finally accesses the event's data property to verify the original string content.",
    "input": "",
    "output": "import {buffer, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function verifyStringContent(originalString: string): boolean {\n  const buf = buffer.from(originalString, 'utf-8');\n  const event = new MessageEvent<string>('message', { data: buf.toString('utf-8') });\n  return event.data === originalString;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `buffer.concat` to merge two Buffers containing parts of a message, then constructs a MessageEvents object with the merged Buffer as data, and checks if the data property of the MessageEvents object matches the expected concatenated result.",
    "input": "",
    "output": "import {buffer, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function mergeAndCheckBuffers(buffer1: buffer.Buffer, buffer2: buffer.Buffer, expected: buffer.Buffer): boolean {\n  const mergedBuffer = buffer.concat([buffer1, buffer2]);\n  const messageEvents = new MessageEvents('message', { data: mergedBuffer });\n  return Buffer.compare(messageEvents.data as buffer.Buffer, expected) === 0;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `buffer.byteLength` to determine the size of a string in bytes, then creates a MessageEvent with the string as data, and verifies that the byte length of the event's data property matches the initially calculated size.",
    "input": "",
    "output": "import {buffer, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function verifyStringByteLength(str: string): boolean {\n  const byteLength = buffer.byteLength(str, 'utf-8');\n  const event = new MessageEvent<string>('message', { data: str });\n  const eventDataByteLength = buffer.byteLength(event.data, 'utf-8');\n  return byteLength === eventDataByteLength;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of URIs (as strings), then uses the `convertToArray` method of `LinkedList` to convert the list into an array, and finally passes this array to the `forEach` method of another `LinkedList` to iterate and log each URI.",
    "input": "",
    "output": "import {uri, LinkedList, LinkedList} from '@kit.ArkTS';\n\nexport function processURIs(uris: string[]): void {\n  const list = new LinkedList<string>();\n  uris.forEach(uri => list.add(uri));\n  const uriArray = list.convertToArray();\n  const anotherList = new LinkedList<string>();\n  anotherList.forEach = function(callback: (value: string) => void): void {\n    for (const item of uriArray) {\n      callback(item);\n    }\n  };\n  anotherList.forEach((uri: string) => {\n    console.log(uri);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list, then uses the `insert` method of another `LinkedList` to add these elements at specific positions in a second list, and finally returns the modified list using the `clone` method to ensure immutability.",
    "input": "",
    "output": "import {uri, LinkedList, LinkedList} from '@kit.ArkTS';\n\nexport function modifyLinkedList(sourceList: LinkedList<unknown>, targetList: LinkedList<unknown>, firstPos: number, lastPos: number): LinkedList<unknown> {\n  const firstElement = sourceList.getFirst();\n  const lastElement = sourceList.getLast();\n  \n  const clonedList = targetList.clone();\n  clonedList.insert(firstPos, firstElement);\n  clonedList.insert(lastPos, lastElement);\n  \n  return clonedList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a program that uses the `removeByIndex` method of `LinkedList` to remove an element at a given index, then uses the `getIndexOf` method of another `LinkedList` to find the position of a specific value, and finally uses the `set` method to update the value at that position in the first list.",
    "input": "",
    "output": "import { LinkedList } from '@kit.ArkTS';\n\nexport function manipulateLinkedLists(list1: LinkedList<string>, list2: LinkedList<string>, indexToRemove: number, valueToFind: string, newValue: string): void {\n  // Remove element at given index from list1\n  list1.removeByIndex(indexToRemove);\n\n  // Find the index of the specific value in list2\n  const foundIndex = list2.getIndexOf(valueToFind);\n\n  // If the value is found in list2, update the value at that position in list1\n  if (foundIndex !== -1) {\n    list1.set(foundIndex, newValue);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a new Worker using `WorkerOptions` with a specified `name` and `shared` property, then inside the worker, use `WorkerGlobalScope.self` to access the worker's global scope and log its `name` property to the console.",
    "input": "",
    "output": "import {WorkerGlobalScope, WorkerOptions, Queue} from '@kit.ArkTS';\n\nexport function createWorkerWithOptions(): void {\n  const workerOptions: WorkerOptions = {\n    name: 'testWorker',\n    shared: true\n  };\n\n  const worker = new Worker('worker.ts', workerOptions);\n\n  worker.onmessage = (event: MessageEvent): void => {\n    console.log('Message received from worker:', event.data);\n  };\n\n  worker.postMessage('start');\n}\n\n// worker.ts content:\n// import {WorkerGlobalScope} from '@kit.ArkTS';\n// const self: WorkerGlobalScope = globalThis as WorkerGlobalScope;\n// console.log('Worker name:', self.name);\n// self.postMessage('Worker is running');",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `Queue` object, uses its `add` method to enqueue a series of tasks, then starts a new Worker using `WorkerOptions` (with a unique `name`) and passes the queue's first task (obtained via `Queue.getFirst`) to the worker for processing.",
    "input": "",
    "output": "import {WorkerGlobalScope, WorkerOptions, Queue} from '@kit.ArkTS';\n\nexport function initializeQueueAndStartWorker(): void {\n  const queue = new Queue<string>();\n  queue.add('Task1');\n  queue.add('Task2');\n  queue.add('Task3');\n\n  const firstTask = queue.getFirst();\n  if (firstTask) {\n    const workerOptions: WorkerOptions = {\n      name: 'uniqueWorkerName'\n    };\n    const worker = new WorkerGlobalScope('workerScript.js', workerOptions);\n    worker.postMessage(firstTask);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that sets up an `onerror` event handler in `WorkerGlobalScope` to catch errors in a worker, then creates a worker with `WorkerOptions` (setting `shared` to true). Inside the worker, use `Queue.forEach` to iterate over a queue of tasks and handle any errors by propagating them to the parent thread via the `onerror` handler.",
    "input": "",
    "output": "import {WorkerGlobalScope, WorkerOptions, Queue} from '@kit.ArkTS';\n\nexport function setupWorkerWithErrorHandler(): void {\n  const workerOptions: WorkerOptions = {\n    name: 'errorHandlingWorker',\n    shared: true\n  };\n\n  const workerGlobalScope: WorkerGlobalScope = self as unknown as WorkerGlobalScope;\n\n  workerGlobalScope.onerror = (error: ErrorEvent): void => {\n    self.postMessage({ type: 'error', error: error.message });\n  };\n\n  const taskQueue: Queue<() => void> = new Queue<() => void>();\n\n  taskQueue.add(() => {\n    throw new Error('Task 1 failed');\n  });\n\n  taskQueue.add(() => {\n    console.log('Task 2 executed successfully');\n  });\n\n  taskQueue.forEach((task: () => void) => {\n    try {\n      task();\n    } catch (error) {\n      workerGlobalScope.onerror(new ErrorEvent('error', { error }));\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `from` method of `buffer` to create a Buffer from a given string, then passes this Buffer as the `data` property of a `MessageEvent` object, and finally checks if the Buffer encoding is valid using the `isEncoding` method of `buffer`.",
    "input": "",
    "output": "import {MessageEvent, buffer, url} from '@kit.ArkTS';\n\nexport function createAndCheckBufferEncoding(inputString: string, encoding: buffer.BufferEncoding): boolean {\n  const buf = buffer.from(inputString, encoding);\n  const messageEvent = new MessageEvent('data', { data: buf });\n  return buffer.isEncoding(encoding);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `alloc` method of `buffer` to create a Buffer of a specified size, then populates it with data from a `MessageEvent` object's `data` property, and finally converts the Buffer to a string using a specified encoding (e.g., 'utf8') which is validated using the `isEncoding` method of `buffer`.",
    "input": "",
    "output": "import {MessageEvent, buffer, url} from '@kit.ArkTS';\n\nexport function processMessageEvent(event: MessageEvent<Uint8Array>, size: number, encoding: buffer.BufferEncoding): string {\n  if (!buffer.isEncoding(encoding)) {\n    throw new Error('Invalid encoding specified');\n  }\n  \n  const buf = buffer.alloc(size);\n  const data = event.data;\n  \n  for (let i = 0; i < Math.min(data.length, size); i++) {\n    buf[i] = data[i];\n  }\n  \n  return buf.toString(encoding);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `concat` method of `buffer` to merge multiple Buffers created from strings, then passes the resulting Buffer as the `data` property of a `MessageEvent` object, and finally checks the byte length of the merged Buffer using the `byteLength` method of `buffer`.",
    "input": "",
    "output": "import {MessageEvent, buffer, url} from '@kit.ArkTS';\n\nexport function mergeBuffersAndCheckLength(strings: string[]): number {\n  const buffers: buffer.Buffer[] = strings.map(str => buffer.from(str));\n  const mergedBuffer: buffer.Buffer = buffer.concat(buffers);\n  const messageEvent: MessageEvent<buffer.Buffer> = new MessageEvent('data', { data: mergedBuffer });\n  return buffer.byteLength(messageEvent.data);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `util.generateRandomUUID()` to create a random UUID, then passes this UUID to `util.parseUUID()` to validate its format. If the UUID is invalid, use `GlobalScope.onerror` to handle the error by logging the error message and filename from an `ErrorEvent` object.",
    "input": "",
    "output": "import {util, ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function validateRandomUUID(): void {\n  const uuid: string = util.generateRandomUUID();\n  try {\n    util.parseUUID(uuid);\n  } catch (error) {\n    GlobalScope.onerror = (event: ErrorEvent) => {\n      console.error(`Error: ${event.message}, Filename: ${event.filename}`);\n    };\n    const errorEvent: ErrorEvent = {\n      message: 'Invalid UUID format',\n      filename: 'validateRandomUUID.ts',\n      error: error,\n      colno: 0,\n      lineno: 0\n    };\n    GlobalScope.onerror(errorEvent);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `util.promiseWrapper()` to wrap an asynchronous operation, and upon rejection, extract the error code using `util.errnoToString()`. Then, construct an `ErrorEvent` object with the error message and pass it to `GlobalScope.self.onerror` for global error handling.",
    "input": "",
    "output": "import {util, ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function handleAsyncOperation(asyncFunc: () => Promise<void>): void {\n  const wrappedPromise = util.promiseWrapper(asyncFunc)();\n  wrappedPromise.catch((error: Error) => {\n    const errorCode = util.errnoToString(error.errno);\n    const errorEvent = new ErrorEvent({\n      message: errorCode,\n      error: error\n    });\n    GlobalScope.self.onerror?.(errorEvent);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that uses `util.getHash()` to compute the hash of a given string, then checks if the hash matches an expected value. If not, use `util.format()` to create a detailed error message and pass it to `GlobalScope.onerror` along with the line number and filename from an `ErrorEvent` object.",
    "input": "",
    "output": "import {util, ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function checkHash(input: string, expectedHash: string): void {\n  const computedHash = util.getHash(input);\n  if (computedHash !== expectedHash) {\n    const errorMessage = util.format('Hash mismatch: expected %s, got %s', expectedHash, computedHash);\n    const errorEvent: ErrorEvent = {\n      colno: 0,\n      error: null,\n      filename: 'checkHash',\n      lineno: 0,\n      message: errorMessage\n    };\n    GlobalScope.onerror?.(errorEvent);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to collect error messages from an `ErrorEvent` (from @kit.ArkTS). Then, use the `peek` method of `Stack` to check the latest error message and log it along with the `filename` and `lineno` properties from the `ErrorEvent`.",
    "input": "",
    "output": "import {ErrorEvent, Stack, PostMessageOptions} from '@kit.ArkTS';\n\nexport function collectAndLogError(errorEvent: ErrorEvent, errorStack: Stack<string>): void {\n  errorStack.push(errorEvent.message);\n  const latestError = errorStack.peek();\n  console.log(`Error: ${latestError}, File: ${errorEvent.filename}, Line: ${errorEvent.lineno}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that processes an `ErrorEvent` (from @kit.ArkTS) by extracting its `message` and `error` properties, then uses the `push` method of `Stack` (from @kit.ArkTS) to store these values. Finally, use the `forEach` method of `Stack` to iterate and log all stored error details.",
    "input": "",
    "output": "import {ErrorEvent, Stack, PostMessageOptions} from '@kit.ArkTS';\n\nexport function processErrorEvent(errorEvent: ErrorEvent): void {\n  const errorStack = new Stack<{message: string, error: any}>();\n  \n  if (errorEvent.message && errorEvent.error) {\n    errorStack.push({message: errorEvent.message, error: errorEvent.error});\n  }\n  \n  errorStack.forEach((item, index) => {\n    console.log(`Error ${index}: Message - ${item.message}, Error - ${item.error}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `pop` method of `Stack` (from @kit.ArkTS) to retrieve and remove the top error message, then sends it to another context using `postMessage` with `PostMessageOptions` (from @kit.ArkTS) where the `transfer` property is set to ensure efficient data handling.",
    "input": "",
    "output": "import {ErrorEvent, Stack, PostMessageOptions} from '@kit.ArkTS';\n\nexport function popAndSendError(stack: Stack<ErrorEvent>, targetContext: any): void {\n  if (stack.isEmpty()) {\n    return;\n  }\n  const errorEvent: ErrorEvent | undefined = stack.pop();\n  if (errorEvent) {\n    const options: PostMessageOptions = {\n      transfer: [errorEvent.error]\n    };\n    targetContext.postMessage(errorEvent, options);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` to collect error messages from a worker thread, then uses the `postMessage` method of `ThreadWorkerGlobalScope` to send the collected messages to the main thread for logging. The function must also handle errors using the `onerror` property of `WorkerGlobalScope`.",
    "input": "",
    "output": "import {WorkerGlobalScope, Stack, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function collectAndSendErrorMessages(workerScope: WorkerGlobalScope & ThreadWorkerGlobalScope): void {\n  const errorStack = new Stack<string>();\n\n  workerScope.onerror = (event: ErrorEvent): void => {\n    errorStack.push(event.message);\n  };\n\n  // Function to send collected error messages to main thread\n  function sendErrorsToMainThread(): void {\n    if (!errorStack.isEmpty()) {\n      const errors: string[] = [];\n      while (!errorStack.isEmpty()) {\n        errors.push(errorStack.pop() as string);\n      }\n      workerScope.postMessage({ type: 'ERROR_LOG', messages: errors });\n    }\n  }\n\n  // Example trigger for sending errors (could be based on some condition or timer)\n  sendErrorsToMainThread();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `peek` method of `Stack` to check the top element of a stack containing shared data, then uses the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope` to send this element to another worker thread for processing. Ensure the function also checks if the stack is empty using the `isEmpty` property of `Stack` before proceeding.",
    "input": "",
    "output": "import {WorkerGlobalScope, Stack, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function checkAndSendTopElement(stack: Stack<number>, workerScope: ThreadWorkerGlobalScope): void {\n  if (!stack.isEmpty) {\n    const topElement = stack.peek();\n    workerScope.postMessageWithSharedSendable(topElement);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Stack` to iterate over a stack of worker names, then uses the `callGlobalCallObjectMethod` method of `ThreadWorkerGlobalScope` to invoke a global callback for each name. The function should also access the `self` property of `WorkerGlobalScope` to verify the current worker context before execution.",
    "input": "",
    "output": "import {WorkerGlobalScope, Stack, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processWorkerNames(stack: Stack<string>, callback: (name: string) => void): void {\n  if (!(self instanceof WorkerGlobalScope)) {\n    throw new Error('This function must be executed within a worker context.');\n  }\n\n  const workerScope: ThreadWorkerGlobalScope = self as ThreadWorkerGlobalScope;\n  \n  stack.forEach((name: string) => {\n    workerScope.callGlobalCallObjectMethod(callback, name);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to run a background task that fetches XML data, then uses the `EventType` enum from `xml` to filter specific events from the parsed data, and finally logs the filtered events' `type` and `timeStamp` properties from the `Event` API.",
    "input": "",
    "output": "import {Event, taskpool, xml} from '@kit.ArkTS';\n\nexport function fetchAndFilterXmlEvents(xmlData: string, eventTypes: xml.EventType[]): void {\n  const task = () => {\n    const parser = new xml.XmlPullParser(xmlData);\n    const events: Event[] = [];\n    \n    while (parser.next()) {\n      const eventType = parser.getEventType();\n      if (eventTypes.includes(eventType)) {\n        const event: Event = {\n          type: eventType,\n          timeStamp: Date.now()\n        };\n        events.push(event);\n      }\n    }\n    \n    events.forEach(event => {\n      console.log(`Event type: ${event.type}, timestamp: ${event.timeStamp}`);\n    });\n    \n    return events;\n  };\n  \n  taskpool.execute(task, taskpool.Priority.LOW).then(() => {\n    console.log('Task completed');\n  }).catch((error) => {\n    console.error('Task failed:', error);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that schedules a delayed task using the `executeDelayed` method of `taskpool` with a `Priority` enum value, and upon completion, uses the `Event` API to emit an event containing the task's execution details (e.g., `timeStamp` and custom `type`), which is then processed by an XML parser to generate a log entry.",
    "input": "",
    "output": "import {Event, taskpool, xml} from '@kit.ArkTS';\n\nexport function scheduleDelayedTask(priority: taskpool.Priority, delay: number, task: taskpool.CallbackFunction): void {\n  const taskId = taskpool.executeDelayed(task, delay, priority);\n  \n  const event = new Event('taskCompleted');\n  event.timeStamp = new Date().getTime();\n  event.type = 'delayedTask';\n  \n  const eventDetails = {\n    timeStamp: event.timeStamp,\n    type: event.type,\n    taskId: taskId\n  };\n  \n  const xmlParser = new xml.XmlParser();\n  const xmlBuilder = new xml.XmlBuilder();\n  const xmlString = xmlBuilder.build(eventDetails);\n  \n  console.log(`Task completed. Log entry: ${xmlString}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task that uses the `executePeriodically` method of `taskpool` to periodically check the state of a task (using the `State` enum), and for each state change, creates an `Event` object with the current `timeStamp` and task state, then serializes this event to XML format using the `xml` API's `EventType` for structuring the data.",
    "input": "",
    "output": "import {Event, taskpool, xml} from '@kit.ArkTS';\n\nexport function monitorTaskState(task: taskpool.Task, interval: number): void {\n  let previousState: taskpool.State = taskpool.State.INITIAL;\n  \n  taskpool.executePeriodically(() => {\n    const currentState: taskpool.State = task.getState();\n    \n    if (currentState !== previousState) {\n      const event: Event = {\n        timeStamp: new Date().getTime(),\n        type: currentState.toString()\n      };\n      \n      const eventXml: string = xml.convertToXml(event, xml.EventType.ELEMENT);\n      console.log(eventXml);\n      \n      previousState = currentState;\n    }\n  }, interval);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` to collect a sequence of numbers, then transfers these numbers to a `HashSet` using its `add` method to remove duplicates. Finally, use the `values` method of `HashSet` to iterate and print the unique numbers.",
    "input": "",
    "output": "import {Stack, HashSet, stream} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[]): void {\n  const stack = new Stack<number>();\n  numbers.forEach(num => stack.push(num));\n\n  const hashSet = new HashSet<number>();\n  while (!stack.isEmpty()) {\n    const num = stack.pop();\n    if (num !== undefined) {\n      hashSet.add(num);\n    }\n  }\n\n  const uniqueNumbers = hashSet.values();\n  for (const num of uniqueNumbers) {\n    console.log(num);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `peek` method of `Stack` to check the top element of the stack, then checks if this element exists in a `HashSet` using its `has` method. If it exists, remove the element from the stack using `pop` and from the `HashSet` using `remove`.",
    "input": "",
    "output": "import {Stack, HashSet, stream} from '@kit.ArkTS';\n\nexport function checkAndRemove(stack: Stack<number>, hashSet: HashSet<number>): void {\n  if (stack.isEmpty()) {\n    return;\n  }\n  const topElement = stack.peek();\n  if (hashSet.has(topElement)) {\n    stack.pop();\n    hashSet.remove(topElement);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `HashSet` to iterate over its elements and push each element into a `Stack` using its `push` method. Then, use the `length` property of both `Stack` and `HashSet` to verify that all elements were transferred correctly.",
    "input": "",
    "output": "import {Stack, HashSet, stream} from '@kit.ArkTS';\n\nexport function transferHashSetToStack(hashSet: HashSet<number>): Stack<number> {\n  const stack = new Stack<number>();\n  hashSet.forEach((value: number) => {\n    stack.push(value);\n  });\n  \n  if (stack.length === hashSet.length) {\n    console.log('All elements were transferred correctly.');\n  } else {\n    console.log('Elements transfer failed.');\n  }\n  \n  return stack;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `EventTarget.addEventListener` to listen for a custom event, then uses `util.callbackWrapper` to wrap the event handler callback, ensuring proper scope management. The function should dispatch the event using `EventTarget.dispatchEvent` after wrapping the callback.",
    "input": "",
    "output": "import {url, EventTarget, util} from '@kit.ArkTS';\n\nexport function listenAndDispatchCustomEvent(): void {\n  const eventTarget = new EventTarget();\n  const eventName = 'customEvent';\n  \n  const eventHandler = (event: Event): void => {\n    console.log('Custom event triggered:', event.type);\n  };\n  \n  const wrappedHandler = util.callbackWrapper(eventHandler);\n  \n  eventTarget.addEventListener(eventName, wrappedHandler);\n  \n  const customEvent = new Event(eventName);\n  eventTarget.dispatchEvent(customEvent);\n  \n  eventTarget.removeEventListener(eventName, wrappedHandler);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility function that generates a random UUID using `util.generateRandomUUID`, then uses `EventTarget.addEventListener` to listen for a 'uuid-generated' event. The function should dispatch the event with the generated UUID as the event detail using `EventTarget.dispatchEvent`.",
    "input": "",
    "output": "import {url, EventTarget, util} from '@kit.ArkTS';\n\nexport function generateAndDispatchUUID(): void {\n  const eventTarget = new EventTarget();\n  const uuid = util.generateRandomUUID();\n\n  eventTarget.addEventListener('uuid-generated', (event: CustomEvent) => {\n    console.log(`UUID generated: ${event.detail}`);\n  });\n\n  const customEvent = new CustomEvent('uuid-generated', {\n    detail: uuid\n  });\n\n  eventTarget.dispatchEvent(customEvent);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `util.promisify` to convert a callback-based function into a promise, then uses `EventTarget.addEventListener` to listen for a 'promise-resolved' event. The function should dispatch the event with the resolved value of the promise using `EventTarget.dispatchEvent`.",
    "input": "",
    "output": "import {url, EventTarget, util} from '@kit.ArkTS';\n\nexport function promisifyAndDispatch(callbackBasedFunc: (arg: string, callback: (error: Error | null, result: string) => void) => void, arg: string, eventTarget: EventTarget): void {\n  const promisifiedFunc = util.promisify(callbackBasedFunc);\n  promisifiedFunc(arg)\n    .then((result: string) => {\n      const event = { type: 'promise-resolved', detail: result };\n      eventTarget.dispatchEvent(event);\n    })\n    .catch((error: Error) => {\n      console.error('Promise rejected:', error);\n    });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send a `PlainArray` object to a worker thread, ensuring the transfer of ownership by setting the `transfer` property of `PostMessageOptions`. The worker thread should then use the `getValueAt` and `length` properties of the received `PlainArray` to process and return the sum of all values.",
    "input": "",
    "output": "import {PostMessageOptions, DedicatedWorkerGlobalScope, PlainArray} from '@kit.ArkTS';\n\nexport function sendPlainArrayToWorker(worker: DedicatedWorkerGlobalScope, plainArray: PlainArray<number>): void {\n  const buffer = new ArrayBuffer(plainArray.length * 4);\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  worker.postMessage(plainArray, options);\n}\n\nexport function processPlainArrayInWorker(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent<PlainArray<number>>) => {\n    const plainArray = event.data;\n    let sum = 0;\n    for (let i = 0; i < plainArray.length; i++) {\n      sum += plainArray.getValueAt(i);\n    }\n    worker.postMessage(sum);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function where a `PlainArray` is populated using its `add` method with key-value pairs, then passed to a worker thread via `DedicatedWorkerGlobalScope.postMessage`. The worker thread should use the `forEach` method of `PlainArray` to filter out entries with specific keys and return a new `PlainArray` containing only the filtered entries, which is then sent back to the main thread using `postMessage`.",
    "input": "",
    "output": "import {PostMessageOptions, DedicatedWorkerGlobalScope, PlainArray} from '@kit.ArkTS';\n\nexport function createAndFilterPlainArray(keysToFilter: number[]): void {\n  const plainArray = new PlainArray<number, string>();\n  plainArray.add(1, 'one');\n  plainArray.add(2, 'two');\n  plainArray.add(3, 'three');\n  plainArray.add(4, 'four');\n\n  const worker = new Worker('workers/worker.ts');\n  worker.postMessage({ plainArray, keysToFilter });\n\n  worker.onmessage = (event) => {\n    const filteredPlainArray: PlainArray<number, string> = event.data;\n    console.log('Filtered PlainArray:', filteredPlainArray);\n    worker.terminate();\n  };\n}\n\n// worker.ts\nexport function onmessage(event: MessageEvent<{ plainArray: PlainArray<number, string>, keysToFilter: number[] }>): void {\n  const { plainArray, keysToFilter } = event.data;\n  const filteredPlainArray = new PlainArray<number, string>();\n\n  plainArray.forEach((value: string, key: number) => {\n    if (!keysToFilter.includes(key)) {\n      filteredPlainArray.add(key, value);\n    }\n  });\n\n  postMessage(filteredPlainArray);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a scenario where a worker thread receives a `PlainArray` via `DedicatedWorkerGlobalScope.onmessage`, processes it by removing a range of elements using the `removeRangeFrom` method, and then sends the modified `PlainArray` back to the main thread. The main thread should use the `Symbol.iterator` method of `PlainArray` to iterate over the remaining elements and log each key-value pair.",
    "input": "",
    "output": "import {PostMessageOptions, DedicatedWorkerGlobalScope, PlainArray} from '@kit.ArkTS';\n\nexport function setupWorker() {\n  const worker = new Worker('workers/worker.ts');\n  \n  const plainArray = new PlainArray<number, string>();\n  plainArray.add(1, 'one');\n  plainArray.add(2, 'two');\n  plainArray.add(3, 'three');\n  plainArray.add(4, 'four');\n  plainArray.add(5, 'five');\n  \n  worker.postMessage(plainArray);\n  \n  worker.onmessage = (event: MessageEvent<PlainArray<number, string>>) => {\n    const modifiedArray = event.data;\n    for (const [key, value] of modifiedArray) {\n      console.log(`Key: ${key}, Value: ${value}`);\n    }\n    worker.terminate();\n  };\n}\n\nexport function workerScript() {\n  const workerScope = self as DedicatedWorkerGlobalScope;\n  \n  workerScope.onmessage = (event: MessageEvent<PlainArray<number, string>>) => {\n    const receivedArray = event.data;\n    receivedArray.removeRangeFrom(1, 3);\n    workerScope.postMessage(receivedArray);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `util.generateRandomUUID()` to create a unique identifier, then formats it into a human-readable string using `util.format()`, and finally logs the formatted UUID along with a timestamp using `Event.timeStamp`.",
    "input": "",
    "output": "import {uri, util, Event} from '@kit.ArkTS';\n\nexport function generateAndLogFormattedUUID(): void {\n  const uuid: string = util.generateRandomUUID();\n  const formattedUUID: string = util.format('Generated UUID: %s', uuid);\n  const timestamp: number = Event.timeStamp;\n  console.log(`${formattedUUID}, Timestamp: ${timestamp}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first generates a random binary UUID using `util.generateRandomBinaryUUID()`, converts it to a string representation using `util.parseUUID()`, and then creates an event object with the UUID string as the `Event.type` property and the current system time as `Event.timeStamp`.",
    "input": "",
    "output": "import {uri, util, Event} from '@kit.ArkTS';\n\nexport function createEventWithUUID(): Event {\n  const binaryUUID: Uint8Array = util.generateRandomBinaryUUID();\n  const uuidString: string = util.parseUUID(binaryUUID);\n  const event: Event = {\n    type: uuidString,\n    timeStamp: new Date().getTime()\n  };\n  return event;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `util.getHash()` to compute the hash of a given input string, then checks if the hash matches a predefined value. If it matches, generate a success event with `Event.type` set to 'SUCCESS' and `Event.timeStamp` recording the current time; otherwise, generate an error event with `Event.type` set to 'ERROR' and include the error code converted to a string using `util.errnoToString()`.",
    "input": "",
    "output": "import {uri, util, Event} from '@kit.ArkTS';\n\nexport function checkHashMatch(input: string, predefinedHash: string): Event {\n  const hash = util.getHash(input);\n  const event: Event = { timeStamp: Date.now() } as Event;\n  \n  if (hash === predefinedHash) {\n    event.type = 'SUCCESS';\n  } else {\n    event.type = 'ERROR';\n    const errorCode = -1; // Assuming a default error code for mismatch\n    event.error = util.errnoToString(errorCode);\n  }\n  \n  return event;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a series of tasks, then processes these tasks in a worker thread by passing the queue to `ThreadWorkerGlobalScope.postMessage`. The worker thread should use `getFirst` and `pop` methods of `Queue` to dequeue and process each task, and then send the results back to the main thread using `postMessage`.",
    "input": "",
    "output": "import {Queue, Deque, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function enqueueAndProcessTasks(tasks: string[]): void {\n  const taskQueue = new Queue<string>();\n  tasks.forEach(task => taskQueue.add(task));\n\n  const worker = new ThreadWorkerGlobalScope('workers/worker.js');\n  worker.postMessage(taskQueue);\n\n  worker.onmessage = (result: string) => {\n    console.log(`Result from worker: ${result}`);\n  };\n}\n\nexport function workerProcessTasks(): void {\n  const workerScope = self as ThreadWorkerGlobalScope;\n  workerScope.onmessage = (event: { data: Queue<string> }) => {\n    const taskQueue = event.data;\n    while (taskQueue.length > 0) {\n      const task = taskQueue.getFirst();\n      taskQueue.pop();\n      const result = `Processed: ${task}`;\n      workerScope.postMessage(result);\n    }\n    workerScope.close();\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that constructs a `Deque` using `insertFront` and `insertEnd` to store a sequence of priority values. Then, pass this deque to a worker thread via `ThreadWorkerGlobalScope.postMessageWithSharedSendable`. The worker thread should use `popFirst` and `popLast` to process high and low priority values respectively, and return the processed values to the main thread using `onmessage`.",
    "input": "",
    "output": "import {Queue, Deque, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createPriorityDeque(highPriorityValues: number[], lowPriorityValues: number[]): Deque<number> {\n  const deque = new Deque<number>();\n  \n  // Insert high priority values at the front\n  highPriorityValues.forEach(value => {\n    deque.insertFront(value);\n  });\n  \n  // Insert low priority values at the end\n  lowPriorityValues.forEach(value => {\n    deque.insertEnd(value);\n  });\n  \n  return deque;\n}\n\nexport function sendDequeToWorker(worker: ThreadWorkerGlobalScope, deque: Deque<number>): void {\n  worker.postMessageWithSharedSendable(deque);\n}\n\nexport function setupWorker(worker: ThreadWorkerGlobalScope): void {\n  worker.onmessage = (message: { data: Deque<number> }) => {\n    const deque = message.data;\n    const processedValues: number[] = [];\n    \n    // Process high priority values (pop from front)\n    while (deque.length > 0) {\n      const value = deque.popFirst();\n      if (value !== undefined) {\n        processedValues.push(value);\n      }\n    }\n    \n    // Send processed values back to main thread\n    worker.postMessage(processedValues);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task scheduler where a `Queue` is used to manage tasks (using `add` and `pop`), and a `Deque` is used to manage high-priority tasks (using `insertFront` and `popFirst`). The scheduler should post completed tasks to a worker thread using `ThreadWorkerGlobalScope.postMessage`, where the worker processes them and logs the results using `callGlobalCallObjectMethod`.",
    "input": "",
    "output": "import {Queue, Deque, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport class TaskScheduler {\n  private taskQueue: Queue<string>;\n  private highPriorityDeque: Deque<string>;\n  private worker: ThreadWorkerGlobalScope;\n\n  constructor() {\n    this.taskQueue = new Queue<string>();\n    this.highPriorityDeque = new Deque<string>();\n    this.worker = new ThreadWorkerGlobalScope();\n  }\n\n  public addTask(task: string): void {\n    this.taskQueue.add(task);\n  }\n\n  public addHighPriorityTask(task: string): void {\n    this.highPriorityDeque.insertFront(task);\n  }\n\n  public processTasks(): void {\n    while (this.highPriorityDeque.length > 0) {\n      const task = this.highPriorityDeque.popFirst();\n      if (task) {\n        this.worker.postMessage(task);\n      }\n    }\n\n    while (this.taskQueue.length > 0) {\n      const task = this.taskQueue.pop();\n      if (task) {\n        this.worker.postMessage(task);\n      }\n    }\n  }\n\n  public setupWorker(): void {\n    this.worker.onmessage = (message: string) => {\n      this.worker.callGlobalCallObjectMethod('log', message);\n    };\n  }\n\n  public closeWorker(): void {\n    this.worker.close();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getUidForName` method of `process` to retrieve the UID for a given username, then uses the `push` method of `Stack` to store the UID in a stack. Finally, use the `peek` method of `Stack` to verify the last stored UID and log it.",
    "input": "",
    "output": "import {process, Stack, EventTarget} from '@kit.ArkTS';\n\nexport function storeAndVerifyUid(username: string): void {\n  const uid = process.getUidForName(username);\n  const stack = new Stack<number>();\n  stack.push(uid);\n  const lastUid = stack.peek();\n  console.log(`Last stored UID: ${lastUid}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `getEnvironmentVar` method of `process` to fetch an environment variable, then uses the `addEventListener` method of `EventTarget` to listen for changes to that environment variable. When a change is detected, use the `dispatchEvent` method of `EventTarget` to trigger a custom event and log the new value.",
    "input": "",
    "output": "import {process, Stack, EventTarget} from '@kit.ArkTS';\n\nexport function monitorEnvironmentVariable(varName: string): void {\n  const eventTarget = new EventTarget();\n  let currentValue = process.getEnvironmentVar(varName);\n\n  eventTarget.addEventListener('change', (event: CustomEvent) => {\n    console.log(`Environment variable ${varName} changed to: ${event.detail.value}`);\n  });\n\n  setInterval(() => {\n    const newValue = process.getEnvironmentVar(varName);\n    if (newValue !== currentValue) {\n      currentValue = newValue;\n      eventTarget.dispatchEvent(new CustomEvent('change', {\n        detail: { value: newValue }\n      }));\n    }\n  }, 1000);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `uptime` method of `process` to get the system uptime, then uses the `push` method of `Stack` to store the uptime value. Next, use the `forEach` method of `Stack` to iterate over the stored values and log each one. Finally, use the `removeAllListener` method of `EventTarget` to clean up any event listeners that might have been added during the process.",
    "input": "",
    "output": "import {process, Stack, EventTarget} from '@kit.ArkTS';\n\nexport function handleUptime(): void {\n  const uptimeValue: number = process.uptime();\n  const stack: Stack<number> = new Stack<number>();\n  stack.push(uptimeValue);\n  \n  stack.forEach((value: number) => {\n    console.log(`Uptime value: ${value}`);\n  });\n  \n  const eventTarget: EventTarget = new EventTarget();\n  eventTarget.removeAllListener();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` (from @kit.ArkTS) to collect a sequence of numbers, then passes the collected numbers to the `sort` method of `List` (from @kit.ArkTS) to sort them in ascending order and return the sorted list.",
    "input": "",
    "output": "import {List, Deque, TreeMap} from '@kit.ArkTS';\n\nexport function collectAndSortNumbers(numbers: number[]): List<number> {\n  const deque: Deque<number> = new Deque();\n  \n  for (const num of numbers) {\n    deque.insertFront(num);\n    deque.insertEnd(num);\n  }\n  \n  const list: List<number> = new List();\n  \n  for (const num of deque) {\n    list.add(num);\n  }\n  \n  list.sort((a: number, b: number) => a - b);\n  \n  return list;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirstKey` and `getLastKey` methods of `TreeMap` (from @kit.ArkTS) to retrieve the smallest and largest keys, then passes these keys to the `getSubList` method of `List` (from @kit.ArkTS) to extract a sublist of values between these keys (inclusive) from a predefined list.",
    "input": "",
    "output": "import {List, Deque, TreeMap} from '@kit.ArkTS';\n\nexport function getSublistFromTreeMapKeys(list: List<number>, treeMap: TreeMap<number, unknown>): List<number> {\n  const firstKey = treeMap.getFirstKey();\n  const lastKey = treeMap.getLastKey();\n  \n  if (firstKey === undefined || lastKey === undefined) {\n    return new List<number>();\n  }\n  \n  const firstIndex = list.getIndexOf(firstKey);\n  const lastIndex = list.getIndexOf(lastKey);\n  \n  if (firstIndex === -1 || lastIndex === -1) {\n    return new List<number>();\n  }\n  \n  const startIndex = Math.min(firstIndex, lastIndex);\n  const endIndex = Math.max(firstIndex, lastIndex);\n  \n  return list.getSubList(startIndex, endIndex + 1);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `TreeMap` (from @kit.ArkTS) to retrieve all keys, then passes these keys to the `removeByIndex` method of `List` (from @kit.ArkTS) to remove elements at the indices corresponding to the keys from a predefined list and return the modified list.",
    "input": "",
    "output": "import {List, Deque, TreeMap} from '@kit.ArkTS';\n\nexport function removeElementsByKeys(list: List<number>, treeMap: TreeMap<number, number>): List<number> {\n  const keys = treeMap.keys();\n  const sortedKeys = Array.from(keys).sort((a, b) => b - a);\n  for (const key of sortedKeys) {\n    list.removeByIndex(key);\n  }\n  return list;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `Deque.insertFront` and `Deque.insertEnd` to build a deque of JSON objects, then converts the deque to a JSON string using `json.stringify` and validates if the string contains a specific key using `json.has`.",
    "input": "",
    "output": "import {json, util, Deque} from '@kit.ArkTS';\n\nexport function buildAndValidateDeque(key: string): boolean {\n  const deque = new Deque<Record<string, string>>();\n  deque.insertFront({ frontKey: 'frontValue' });\n  deque.insertEnd({ endKey: 'endValue' });\n  \n  const jsonString = json.stringify(Array.from(deque));\n  const jsonObj = json.parse(jsonString);\n  \n  return json.has(jsonObj, key);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that generates a random UUID using `util.generateRandomUUID`, parses it into its components using `util.parseUUID`, stores these components in a deque using `Deque.insertEnd`, and finally converts the deque to a JSON array using `json.stringify`.",
    "input": "",
    "output": "import {json, util, Deque} from '@kit.ArkTS';\n\nexport function generateAndParseUUID(): string {\n  const randomUUID: string = util.generateRandomUUID();\n  const uuidComponents: string[] = util.parseUUID(randomUUID);\n  const deque: Deque<string> = new Deque<string>();\n  \n  for (const component of uuidComponents) {\n    deque.insertEnd(component);\n  }\n  \n  const jsonArray: string = json.stringify(Array.from(deque));\n  return jsonArray;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `util.printf` to format a log message with dynamic values, stores the formatted message in a deque using `Deque.insertFront`, then checks if the deque contains the message using `Deque.has`, and finally converts the deque to a JSON object using `json.stringify` for storage.",
    "input": "",
    "output": "import {json, util, Deque} from '@kit.ArkTS';\n\nexport function formatAndStoreLogMessage(message: string, ...values: string[]): string {\n  const formattedMessage = util.printf(message, ...values);\n  const deque = new Deque<string>();\n  deque.insertFront(formattedMessage);\n  const containsMessage = deque.has(formattedMessage);\n  if (!containsMessage) {\n    throw new Error('Message not found in deque');\n  }\n  const jsonObject = {\n    message: formattedMessage,\n    dequeLength: deque.length\n  };\n  return json.stringify(jsonObject);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a set of key-value pairs representing product IDs and their prices, then uses the `convertToArray` method of `Vector` to convert the values into an array, and finally applies the `sort` method of `Vector` to sort the prices in ascending order.",
    "input": "",
    "output": "import {worker, PlainArray, Vector} from '@kit.ArkTS';\n\nexport function sortProductPrices(): number[] {\n  // Create a PlainArray to store product IDs and prices\n  const productPrices = new PlainArray<number>();\n  \n  // Add key-value pairs representing product IDs and their prices\n  productPrices.add(1, 99.99);\n  productPrices.add(2, 49.99);\n  productPrices.add(3, 149.99);\n  productPrices.add(4, 29.99);\n  \n  // Create a Vector to store the prices\n  const priceVector = new Vector<number>();\n  \n  // Convert the values from PlainArray to an array and add them to the Vector\n  for (let i = 0; i < productPrices.length; i++) {\n    priceVector.add(productPrices.getValueAt(i));\n  }\n  \n  // Convert the Vector to an array\n  const priceArray = priceVector.convertToArray();\n  \n  // Sort the prices in ascending order\n  priceVector.sort((a, b) => a - b);\n  \n  // Return the sorted array\n  return priceVector.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getValueAt` method of `PlainArray` to retrieve a specific value by index, then passes this value to the `insert` method of `Vector` to add it at a specified position, and finally uses the `toString` method of `Vector` to display the updated vector contents.",
    "input": "",
    "output": "import {worker, PlainArray, Vector} from '@kit.ArkTS';\n\nexport function processPlainArrayToVector(plainArray: PlainArray<number>, vector: Vector<number>, plainArrayIndex: number, vectorIndex: number): string {\n  const value = plainArray.getValueAt(plainArrayIndex);\n  vector.insert(vectorIndex, value);\n  return vector.toString();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Vector` to iterate over a list of employee IDs, checks if each ID exists in a `PlainArray` using its `has` method, and then uses the `remove` method of `PlainArray` to delete any IDs that are not found in the `Vector`.",
    "input": "",
    "output": "import {worker, PlainArray, Vector} from '@kit.ArkTS';\n\nexport function filterEmployeeIds(employeeIds: Vector<number>, idMap: PlainArray<number, any>): void {\n  const idsToRemove: number[] = [];\n  \n  idMap.forEach((value: any, key: number) => {\n    if (!employeeIds.has(key)) {\n      idsToRemove.push(key);\n    }\n  });\n  \n  idsToRemove.forEach((id: number) => {\n    idMap.remove(id);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method from `util` to create a unique identifier, then stores this UUID as a key in a `LightWeightMap` along with a corresponding value (e.g., a timestamp). Use the `set` method of `LightWeightMap` to insert the key-value pair and the `get` method to verify the insertion by retrieving the value.",
    "input": "",
    "output": "import {worker, LightWeightMap, util} from '@kit.ArkTS';\n\nexport function storeAndVerifyUUID(): void {\n  const uuidMap: LightWeightMap<string, string> = new LightWeightMap();\n  const uuid: string = util.generateRandomUUID();\n  const timestamp: string = new Date().toISOString();\n  \n  uuidMap.set(uuid, timestamp);\n  const retrievedValue: string | undefined = uuidMap.get(uuid);\n  \n  if (retrievedValue !== timestamp) {\n    throw new Error('Verification failed: The retrieved value does not match the stored timestamp.');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `forEach` method of `LightWeightMap` to iterate over all key-value pairs, and for each value, use the `printf` method from `util` to format and print the key-value pairs in a human-readable string format (e.g., 'Key: [UUID], Value: [timestamp]').",
    "input": "",
    "output": "import {worker, LightWeightMap, util} from '@kit.ArkTS';\n\nexport function printKeyValuePairs(map: LightWeightMap<string, string>): void {\n  map.forEach((value: string, key: string) => {\n    util.printf('Key: %s, Value: %s', key, value);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first generates multiple random UUIDs using the `generateRandomBinaryUUID` method from `util`, then stores them as keys in a `LightWeightMap` with sequential integer values (1, 2, 3, etc.). Use the `increaseCapacityTo` method of `LightWeightMap` to ensure sufficient capacity before insertion, and the `keys` method to retrieve and return all keys as an array.",
    "input": "",
    "output": "import {worker, LightWeightMap, util} from '@kit.ArkTS';\n\nexport function generateAndStoreUUIDs(count: number): Array<string> {\n  const map = new LightWeightMap<string, number>();\n  map.increaseCapacityTo(count);\n  \n  for (let i = 0; i < count; i++) {\n    const uuid = util.generateRandomUUID();\n    map.set(uuid, i + 1);\n  }\n  \n  return Array.from(map.keys());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `set` method of `LightWeightMap` to store key-value pairs of event IDs and their corresponding data, then retrieves the data using `get` and passes it to the `data` property of `MessageEvent` to create a new message event.",
    "input": "",
    "output": "import {LightWeightMap, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function createMessageEventWithLightWeightMap(): void {\n  const eventMap = new LightWeightMap<number, string>();\n  eventMap.set(1, 'Event Data 1');\n  eventMap.set(2, 'Event Data 2');\n  \n  const retrievedData = eventMap.get(1);\n  \n  if (retrievedData !== undefined) {\n    const messageEvent = new MessageEvent<string>();\n    messageEvent.data = retrievedData;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that iterates over the keys of a `LightWeightMap` using the `Symbol.iterator` method, filters out specific keys, and then uses the filtered keys to populate the `data` property of `MessageEvents` for batch processing.",
    "input": "",
    "output": "import {LightWeightMap, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function filterAndPopulateMessageEvents(\n  map: LightWeightMap<string, string>,\n  filterKeys: string[]\n): MessageEvents {\n  const messageEvents = new MessageEvents();\n  const filteredData: string[] = [];\n\n  for (const key of map[Symbol.iterator]()) {\n    if (!filterKeys.includes(key)) {\n      const value = map.get(key);\n      if (value !== undefined) {\n        filteredData.push(value);\n      }\n    }\n  }\n\n  messageEvents.data = filteredData;\n  return messageEvents;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that checks if a `LightWeightMap` contains a specific value using the `hasValue` method, and if found, retrieves the corresponding key using `getKeyAt` and passes it to the `data` property of `MessageEvent` to trigger an event with the key as the payload.",
    "input": "",
    "output": "import {LightWeightMap, MessageEvents, MessageEvent} from '@kit.ArkTS';\n\nexport function checkAndTriggerEvent(map: LightWeightMap<number, string>, value: string, event: MessageEvents): void {\n  if (map.hasValue(value)) {\n    const index = map.getIndexOfValue(value);\n    if (index !== -1) {\n      const key = map.getKeyAt(index);\n      event.data = new MessageEvent<number>(key);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to run a background task that processes a list of key-value pairs. The task should use the `setAll` method of `LightWeightMap` to store these pairs, and then the `postMessage` method of `DedicatedWorkerGlobalScope` to send the processed map back to the main thread.",
    "input": "",
    "output": "import {LightWeightMap, DedicatedWorkerGlobalScope, taskpool} from '@kit.ArkTS';\n\nexport function processKeyValuePairsInBackground(pairs: [string, string][]): void {\n  const task = new taskpool.Task((pairs: [string, string][]) => {\n    const map = new LightWeightMap<string, string>();\n    map.setAll(pairs);\n    const workerScope = globalThis as unknown as DedicatedWorkerGlobalScope;\n    workerScope.postMessage(map);\n    return map;\n  }, pairs);\n\n  taskpool.execute(task);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `keys` method of `LightWeightMap` to retrieve all keys from a map, then passes these keys to the `executeDelayed` method of `taskpool` to perform a delayed background task. The background task should use the `onmessage` property of `DedicatedWorkerGlobalScope` to listen for incoming messages and process the keys accordingly.",
    "input": "",
    "output": "import {LightWeightMap, DedicatedWorkerGlobalScope, taskpool} from '@kit.ArkTS';\n\nexport function processKeysInBackground(map: LightWeightMap<number, string>): void {\n  const keys = map.keys();\n  \n  const workerScript = `\n    self.onmessage = (event) => {\n      const keys = event.data;\n      keys.forEach((key) => {\n        console.log('Processing key:', key);\n      });\n    };\n  `;\n  \n  const blob = new Blob([workerScript], { type: 'application/javascript' });\n  const workerUrl = URL.createObjectURL(blob);\n  \n  const worker = new Worker(workerUrl);\n  \n  taskpool.executeDelayed(() => {\n    worker.postMessage(keys);\n  }, 0);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LightWeightMap` to iterate over its entries and perform a computation on each value. The results of these computations should be passed to the `executePeriodically` method of `taskpool` to schedule periodic background tasks, which then use the `close` method of `DedicatedWorkerGlobalScope` to terminate the worker after completing all tasks.",
    "input": "",
    "output": "import {LightWeightMap, DedicatedWorkerGlobalScope, taskpool} from '@kit.ArkTS';\n\nexport function processMapEntries(map: LightWeightMap<number, number>): void {\n  const results: number[] = [];\n  \n  map.forEach((value: number, key: number) => {\n    const computedValue = value * 2; // Example computation\n    results.push(computedValue);\n  });\n  \n  results.forEach((result) => {\n    const task: taskpool.Task = {\n      priority: taskpool.Priority.MEDIUM,\n      execute: (worker: DedicatedWorkerGlobalScope) => {\n        worker.postMessage(result);\n        worker.close();\n      }\n    };\n    \n    taskpool.executePeriodically(task, 1000, 1);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` to collect a sequence of binary data chunks (as strings), then converts each chunk to a `Buffer` using the `from` method of `buffer`, and finally concatenates all buffers into a single buffer using the `concat` method of `buffer`. The function should return the final buffer.",
    "input": "",
    "output": "import {Stack, buffer, TreeMap} from '@kit.ArkTS';\n\nexport function collectAndConcatBuffers(chunks: string[]): buffer.Buffer {\n  const stack = new Stack<string>();\n  chunks.forEach(chunk => stack.push(chunk));\n  \n  const buffers: buffer.Buffer[] = [];\n  while (!stack.isEmpty()) {\n    const chunk = stack.pop();\n    if (chunk) {\n      buffers.push(buffer.from(chunk));\n    }\n  }\n  \n  return buffer.concat(buffers);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirstKey` and `getLastKey` methods of `TreeMap` to retrieve the smallest and largest keys, then pushes these keys into a `Stack` using the `push` method, and finally iterates over the stack using the `Symbol.iterator` method to print all keys in reverse order (from largest to smallest).",
    "input": "",
    "output": "import {Stack, buffer, TreeMap} from '@kit.ArkTS';\n\nexport function processTreeMapKeys(treeMap: TreeMap<number, unknown>): void {\n  const stack = new Stack<number>();\n  \n  const firstKey = treeMap.getFirstKey();\n  const lastKey = treeMap.getLastKey();\n  \n  if (firstKey !== undefined) {\n    stack.push(firstKey);\n  }\n  \n  if (lastKey !== undefined) {\n    stack.push(lastKey);\n  }\n  \n  for (const key of stack) {\n    console.log(key);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that checks if a `TreeMap` is empty using the `isEmpty` method, and if it is not empty, iterates over its values using the `values` method, converts each value to a buffer using the `from` method of `buffer`, and checks if the buffer is valid using the `isBuffer` method. The function should return `true` only if all values are valid buffers.",
    "input": "",
    "output": "import {Stack, buffer, TreeMap} from '@kit.ArkTS';\n\nexport function checkTreeMapValuesAreBuffers(map: TreeMap<unknown, unknown>): boolean {\n  if (map.isEmpty()) {\n    return false;\n  }\n\n  const values = map.values();\n  for (const value of values) {\n    const buf = buffer.from(value);\n    if (!buffer.isBuffer(buf)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `parse` method of `json` to deserialize a JSON string into an object, then checks if the object contains an error property using the `has` method of `json`. If an error is found, create an `ErrorEvent` object using the `message` and `error` properties from the parsed object and throw it.",
    "input": "",
    "output": "import {ErrorEvent, MessageEvent, json} from '@kit.ArkTS';\n\nexport function checkJsonForError(jsonString: string): void {\n  const parsedObject = json.parse(jsonString);\n  if (json.has(parsedObject, 'error')) {\n    const message = json.has(parsedObject, 'message') ? parsedObject.message : '';\n    const error = parsedObject.error;\n    throw new ErrorEvent('error', {\n      message: message,\n      error: error\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that receives a `MessageEvent` object, extracts its `data` property (assumed to be a JSON string), and uses the `stringify` method of `json` to convert it into a formatted JSON string. Then, validate the JSON string by attempting to parse it using the `parse` method of `json`. If parsing fails, create an `ErrorEvent` with the error details and throw it.",
    "input": "",
    "output": "import {ErrorEvent, MessageEvent, json} from '@kit.ArkTS';\n\nexport function processMessageEvent(event: MessageEvent<string>): string {\n  try {\n    const formattedJson = json.stringify(json.parse(event.data));\n    return formattedJson;\n  } catch (error) {\n    const errorEvent = new ErrorEvent(\n      'JSONParseError',\n      {\n        error: error,\n        message: error.message,\n        filename: '',\n        lineno: 0,\n        colno: 0\n      }\n    );\n    throw errorEvent;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `remove` method of `json` to delete a specified property from an object, then creates a `MessageEvent` with the modified object as the `data` property. If the removal operation fails (e.g., the property does not exist), create an `ErrorEvent` with the appropriate error message and throw it.",
    "input": "",
    "output": "import {ErrorEvent, MessageEvent, json} from '@kit.ArkTS';\n\nexport function modifyAndCreateEvent(obj: object, prop: string): MessageEvent<object> | ErrorEvent {\n  try {\n    json.remove(obj, prop);\n    return new MessageEvent('modified', {data: obj});\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Failed to remove property';\n    return new ErrorEvent('error', {message: errorMessage});\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `List` to collect a sequence of numbers, then passes the resulting list to the `sort` method of `List` to sort the numbers in ascending order. Finally, use the `insertEnd` method of `Deque` to enqueue the sorted numbers into a deque for further processing.",
    "input": "",
    "output": "import {List, WorkerEventTarget, Deque} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[]): Deque<number> {\n  const list = new List<number>();\n  \n  // Add numbers to the list\n  numbers.forEach((num) => {\n    list.add(num);\n  });\n  \n  // Sort the list in ascending order\n  list.sort((a, b) => a - b);\n  \n  // Create a deque and insert the sorted numbers at the end\n  const deque = new Deque<number>();\n  for (const num of list) {\n    deque.insertEnd(num);\n  }\n  \n  return deque;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `getFirst` and `getLast` methods of `Deque` to retrieve the first and last elements of a deque, then checks if these elements exist in a `List` using the `has` method. If they do, dispatch an event using the `dispatchEvent` method of `WorkerEventTarget` to notify a worker thread.",
    "input": "",
    "output": "import {List, WorkerEventTarget, Deque} from '@kit.ArkTS';\n\nexport function checkAndDispatch(deque: Deque<number>, list: List<number>, eventTarget: WorkerEventTarget): void {\n  const firstElement = deque.getFirst();\n  const lastElement = deque.getLast();\n  \n  if (firstElement !== undefined && list.has(firstElement)) {\n    eventTarget.dispatchEvent(new Event('elementFound'));\n  }\n  \n  if (lastElement !== undefined && list.has(lastElement)) {\n    eventTarget.dispatchEvent(new Event('elementFound'));\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `convertToArray` method of `List` to convert a list of strings into an array, then iterates over the array using the `forEach` method of `List` to process each string. For each processed string, use the `addEventListener` method of `WorkerEventTarget` to register a callback that triggers when the string matches a certain condition.",
    "input": "",
    "output": "import {List, WorkerEventTarget, Deque} from '@kit.ArkTS';\n\nexport function processStrings(list: List<string>, eventTarget: WorkerEventTarget, condition: (str: string) => boolean): void {\n  const array: string[] = list.convertToArray();\n  array.forEach((str: string) => {\n    if (condition(str)) {\n      eventTarget.addEventListener(str, () => {\n        console.log(`Event triggered for string: ${str}`);\n      });\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` and `getFirst` methods of `LinkedList` to collect a sequence of messages, then passes the first message to the `transfer` property of `PostMessageOptions` to send it to another context.",
    "input": "",
    "output": "import {LinkedList, PostMessageOptions, xml} from '@kit.ArkTS';\n\nexport function sendFirstMessage(messages: string[]): PostMessageOptions {\n  const list = new LinkedList<string>();\n  messages.forEach((msg) => {\n    list.add(msg);\n  });\n  \n  const firstMessage = list.getFirst();\n  const buffer = new ArrayBuffer(firstMessage.length * 2);\n  const view = new Uint16Array(buffer);\n  for (let i = 0; i < firstMessage.length; i++) {\n    view[i] = firstMessage.charCodeAt(i);\n  }\n  \n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  \n  return options;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `convertToArray` method of `LinkedList` to transform a linked list of XML event data into an array, then processes this array to filter events based on the `EventType` enum from the `xml` API.",
    "input": "",
    "output": "import {LinkedList, PostMessageOptions, xml} from '@kit.ArkTS';\n\nexport function filterEventsByType(linkedList: LinkedList<xml.EventType>, filterType: xml.EventType): xml.EventType[] {\n  const eventArray: xml.EventType[] = linkedList.convertToArray();\n  return eventArray.filter((event: xml.EventType) => event === filterType);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LinkedList` to iterate over a list of XML nodes, checks each node's type using the `EventType` enum from the `xml` API, and then uses the `insert` method of `LinkedList` to reorganize the nodes based on their types.",
    "input": "",
    "output": "import {LinkedList, PostMessageOptions, xml} from '@kit.ArkTS';\n\nexport function reorganizeXmlNodes(nodes: LinkedList<xml.Element>): LinkedList<xml.Element> {\n  const reorganizedList = new LinkedList<xml.Element>();\n  const elementNodes = new LinkedList<xml.Element>();\n  const textNodes = new LinkedList<xml.Element>();\n  const commentNodes = new LinkedList<xml.Element>();\n  const otherNodes = new LinkedList<xml.Element>();\n\n  nodes.forEach((node: xml.Element) => {\n    switch (node.type) {\n      case xml.EventType.ELEMENT_NODE:\n        elementNodes.add(node);\n        break;\n      case xml.EventType.TEXT_NODE:\n        textNodes.add(node);\n        break;\n      case xml.EventType.COMMENT_NODE:\n        commentNodes.add(node);\n        break;\n      default:\n        otherNodes.add(node);\n        break;\n    }\n  });\n\n  elementNodes.forEach((node: xml.Element) => {\n    reorganizedList.add(node);\n  });\n\n  textNodes.forEach((node: xml.Element) => {\n    reorganizedList.add(node);\n  });\n\n  commentNodes.forEach((node: xml.Element) => {\n    reorganizedList.add(node);\n  });\n\n  otherNodes.forEach((node: xml.Element) => {\n    reorganizedList.add(node);\n  });\n\n  return reorganizedList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a unique identifier, then adds this UUID to a `LightWeightSet` using its `add` method. Finally, iterate over the set using the `[Symbol.iterator]` method of `LightWeightSet` and log each UUID using `console.log`.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightSet, util} from '@kit.ArkTS';\n\nexport function generateAndLogUUIDs(): void {\n  const uuidSet = new LightWeightSet<string>();\n  const uuid = util.generateRandomUUID();\n  uuidSet.add(uuid);\n\n  for (const value of uuidSet) {\n    console.log(value);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `promisify` method of `util` to convert a callback-based function into a promise, then use the `onerror` property of `WorkerGlobalScope` to handle any errors that might occur during the promise execution. Log the error message using `console.error` if an error occurs.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightSet, util} from '@kit.ArkTS';\n\nexport function promisifyAndHandleError(callbackBasedFunc: (...args: any[]) => void, context?: unknown): (...args: any[]) => Promise<void> {\n  const promisifiedFunc = util.promisify(callbackBasedFunc);\n  \n  return async (...args: any[]): Promise<void> => {\n    try {\n      await promisifiedFunc.call(context, ...args);\n    } catch (error) {\n      const workerScope: WorkerGlobalScope = self as unknown as WorkerGlobalScope;\n      if (workerScope.onerror) {\n        workerScope.onerror(error as ErrorEvent);\n      }\n      console.error((error as Error).message);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getHash` method of `util` to compute the hash of a given string, then store the hash value in a `LightWeightSet` using its `add` method. Check if the hash already exists in the set using the `has` method of `LightWeightSet` and return a boolean indicating whether the hash was newly added or already present.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightSet, util} from '@kit.ArkTS';\n\nexport function checkAndAddHash(inputString: string, hashSet: LightWeightSet<string>): boolean {\n  const hashValue = util.getHash(inputString);\n  if (hashSet.has(hashValue)) {\n    return false;\n  } else {\n    hashSet.add(hashValue);\n    return true;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirst` method of `Queue` to retrieve the first element in the queue, then checks if this element exists in a `List` using the `has` method. If it does, remove the element from the `List` using the `remove` method and return the updated `List`.",
    "input": "",
    "output": "import {List, url, Queue} from '@kit.ArkTS';\n\nexport function processQueueAndList(queue: Queue<number>, list: List<number>): List<number> {\n  const firstElement = queue.getFirst();\n  if (list.has(firstElement)) {\n    list.remove(firstElement);\n  }\n  return list;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that takes a `List` of URLs and a `Queue` of URL indices. Use the `get` method of `List` to retrieve each URL based on the indices obtained from the `pop` method of `Queue`. Store the retrieved URLs in a new `List` using the `add` method and return the final list of URLs.",
    "input": "",
    "output": "import {List, url, Queue} from '@kit.ArkTS';\n\nexport function retrieveUrls(urlList: List<string>, indexQueue: Queue<number>): List<string> {\n  const resultList: List<string> = new List();\n  while (indexQueue.length > 0) {\n    const index = indexQueue.pop();\n    if (index !== undefined) {\n      const url = urlList.get(index);\n      if (url !== undefined) {\n        resultList.add(url);\n      }\n    }\n  }\n  return resultList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `convertToArray` method of `List` to transform the list into an array, then iterates over this array using the `forEach` method of `Queue` to add each element to the queue. Finally, use the `length` property of both `List` and `Queue` to verify that all elements were transferred correctly and return the queue.",
    "input": "",
    "output": "import {List, url, Queue} from '@kit.ArkTS';\n\nexport function transferListToQueue(list: List<number>, queue: Queue<number>): Queue<number> {\n  const array = list.convertToArray();\n  array.forEach((element: number) => {\n    queue.add(element);\n  });\n  if (list.length === queue.length) {\n    return queue;\n  } else {\n    throw new Error('Transfer failed: list and queue lengths do not match');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a series of URIs from user input, then uses the `convertToArray` method of `LinkedList` to convert the list into an array, and finally passes this array to the `xml` API to generate an XML string where each URI is wrapped in a `<resource>` tag.",
    "input": "",
    "output": "import {uri, LinkedList, xml} from '@kit.ArkTS';\n\nexport function generateXmlFromUris(): string {\n  const uriList: LinkedList<string> = new LinkedList<string>();\n  \n  // Example of adding URIs to the LinkedList (in a real scenario, these would come from user input)\n  uriList.add('https://example.com/resource1');\n  uriList.add('https://example.com/resource2');\n  uriList.add('https://example.com/resource3');\n  \n  const uriArray: string[] = uriList.convertToArray();\n  \n  const xmlObj = {\n    resources: {\n      resource: uriArray.map(uri => ({ _: uri }))\n    }\n  };\n  \n  return xml.convert(xmlObj);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list of XML event types (from `xml.EventType`), then uses the `uri` API to construct a URI string by combining these event types as query parameters (e.g., `?first=EVENT_TYPE1&last=EVENT_TYPE2`).",
    "input": "",
    "output": "import {uri, LinkedList, xml} from '@kit.ArkTS';\n\nexport function constructUriFromEventTypes(eventList: LinkedList<xml.EventType>): string {\n  const firstEvent: xml.EventType | undefined = eventList.getFirst();\n  const lastEvent: xml.EventType | undefined = eventList.getLast();\n  \n  let uriString = '?';\n  if (firstEvent !== undefined) {\n    uriString += `first=${firstEvent}`;\n  }\n  if (lastEvent !== undefined) {\n    if (firstEvent !== undefined) {\n      uriString += '&';\n    }\n    uriString += `last=${lastEvent}`;\n  }\n  \n  return uriString;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LinkedList` to iterate over a list of XML strings, parses each string using the `xml` API to extract specific attributes, and then uses the `insert` method of `LinkedList` to add the extracted attributes into a new linked list in a sorted order based on the attribute values.",
    "input": "",
    "output": "import {uri, LinkedList, xml} from '@kit.ArkTS';\n\nexport function parseAndSortXMLAttributes(xmlStrings: LinkedList<string>, attributeName: string): LinkedList<string> {\n  const extractedAttributes: LinkedList<string> = new LinkedList();\n\n  xmlStrings.forEach((xmlString: string) => {\n    try {\n      const parsedXml = xml.parse(xmlString);\n      if (parsedXml && parsedXml[attributeName]) {\n        const attributeValue = parsedXml[attributeName];\n        let inserted = false;\n        for (let i = 0; i < extractedAttributes.length; i++) {\n          const currentValue = extractedAttributes.get(i);\n          if (attributeValue.localeCompare(currentValue) < 0) {\n            extractedAttributes.insert(i, attributeValue);\n            inserted = true;\n            break;\n          }\n        }\n        if (!inserted) {\n          extractedAttributes.add(attributeValue);\n        }\n      }\n    } catch (e) {\n      console.error(`Error parsing XML string: ${xmlString}`);\n    }\n  });\n\n  return extractedAttributes;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `HashSet` to store a collection of unique task IDs, then transfers these IDs to a `Queue` using its `add` method to process them in FIFO order. Finally, use the `getFirst` and `pop` methods of `Queue` to retrieve and remove the next task ID for execution.",
    "input": "",
    "output": "import {HashSet, Queue, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processTaskIds(taskIds: number[]): number | undefined {\n  const uniqueTaskIds = new HashSet<number>();\n  const taskQueue = new Queue<number>();\n\n  // Add task IDs to HashSet to ensure uniqueness\n  for (const id of taskIds) {\n    uniqueTaskIds.add(id);\n  }\n\n  // Transfer unique task IDs to Queue\n  for (const id of uniqueTaskIds) {\n    taskQueue.add(id);\n  }\n\n  // Process tasks in FIFO order\n  if (taskQueue.length > 0) {\n    const nextTaskId = taskQueue.getFirst();\n    taskQueue.pop();\n    return nextTaskId;\n  }\n\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `WorkerGlobalScope` and uses its `name` property to identify the worker. Then, use the `add` method of `HashSet` to store a set of worker names, and check if the current worker's name exists in the set using the `has` method of `HashSet`. If it does, log a message using `console.log`.",
    "input": "",
    "output": "import {HashSet, Queue, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function checkWorkerName(worker: WorkerGlobalScope): void {\n  const workerNames = new HashSet<string>();\n  workerNames.add('worker1');\n  workerNames.add('worker2');\n  workerNames.add('worker3');\n\n  if (workerNames.has(worker.name)) {\n    console.log(`Worker name ${worker.name} exists in the set.`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `entries` method of `HashSet` to iterate over a set of job IDs and their values. For each job ID, use the `add` method of `Queue` to enqueue the job. Then, use the `length` property of `Queue` to monitor the queue size and the `pop` method to dequeue jobs when the queue exceeds a certain size.",
    "input": "",
    "output": "import {HashSet, Queue, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processJobs(jobSet: HashSet<string>, maxQueueSize: number): void {\n  const jobQueue = new Queue<string>();\n  \n  for (const [jobId] of jobSet.entries()) {\n    jobQueue.add(jobId);\n    \n    if (jobQueue.length > maxQueueSize) {\n      jobQueue.pop();\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to asynchronously generate a list of random numbers, then passes the result to the `sort` method of `List` to arrange the numbers in ascending order, and finally uses the `getFirstValue` method of `TreeSet` to retrieve the smallest value from the sorted list.",
    "input": "",
    "output": "import {taskpool, List, TreeSet} from '@kit.ArkTS';\n\nexport async function getSmallestRandomNumber(count: number): Promise<number> {\n  const randomNumbers = await taskpool.execute(() => {\n    const list = new List<number>();\n    for (let i = 0; i < count; i++) {\n      list.add(Math.random());\n    }\n    list.sort((a, b) => a - b);\n    return list;\n  }, taskpool.Priority.LOW);\n\n  const treeSet = new TreeSet<number>();\n  for (let i = 0; i < randomNumbers.length; i++) {\n    treeSet.add(randomNumbers.get(i));\n  }\n  return treeSet.getFirstValue();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `add` method of `TreeSet` to store a collection of unique strings, then converts the set to an array using the `convertToArray` method of `List`, and finally uses the `forEach` method of `List` to print each string in the array.",
    "input": "",
    "output": "import {taskpool, List, TreeSet} from '@kit.ArkTS';\n\nexport function processUniqueStrings(strings: string[]): void {\n  const treeSet = new TreeSet<string>();\n  strings.forEach((str: string) => {\n    treeSet.add(str);\n  });\n\n  const list = new List<string>();\n  treeSet.forEach((value: string) => {\n    list.add(value);\n  });\n\n  const array = list.convertToArray();\n  array.forEach((str: string) => {\n    console.log(str);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `executePeriodically` method of `taskpool` to periodically fetch new data entries, adds each entry to a `List` using the `insert` method, and then checks if the `List` contains a specific value using the `has` method of `TreeSet` to filter out duplicates before processing further.",
    "input": "",
    "output": "import {taskpool, List, TreeSet} from '@kit.ArkTS';\n\nexport function fetchDataPeriodically(\n  fetchData: () => string[],\n  targetValue: string,\n  interval: number,\n  maxIterations: number\n): void {\n  const dataList: List<string> = new List();\n  const uniqueValues: TreeSet<string> = new TreeSet();\n  let iterations = 0;\n\n  const task = taskpool.executePeriodically(() => {\n    if (iterations >= maxIterations) {\n      return false;\n    }\n\n    const newData = fetchData();\n    newData.forEach((entry) => {\n      if (!uniqueValues.has(entry)) {\n        uniqueValues.add(entry);\n        dataList.insert(0, entry);\n      }\n    });\n\n    if (uniqueValues.has(targetValue)) {\n      // Process further if target value is found\n      console.log(`Found target value: ${targetValue}`);\n    }\n\n    iterations++;\n    return true;\n  }, interval);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `url` API to parse a given URL string into its components, then uses the `TreeSet` API to store and sort the query parameters alphabetically. Specifically, use `url.parse` to extract the query parameters and `TreeSet.add` to insert them into a `TreeSet`, then return the sorted parameters using `TreeSet.values`.",
    "input": "",
    "output": "import {worker, url, TreeSet} from '@kit.ArkTS';\n\nexport function parseAndSortQueryParams(urlString: string): string[] {\n  const parsedUrl = url.parse(urlString);\n  const queryParams = parsedUrl.query ? parsedUrl.query.split('&') : [];\n  const treeSet = new TreeSet<string>();\n  \n  for (const param of queryParams) {\n    treeSet.add(param);\n  }\n  \n  return Array.from(treeSet.values());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `worker` API to spawn a new worker thread, then passes a sorted list of numbers to the worker. The worker should use the `TreeSet` API to store these numbers, remove duplicates using `TreeSet.add`, and return the unique sorted list back to the main thread using `TreeSet.values`. The main thread should then log the result.",
    "input": "",
    "output": "import {worker, url, TreeSet} from '@kit.ArkTS';\n\nexport function spawnWorkerWithSortedNumbers(sortedNumbers: number[]): void {\n  const workerInstance = new worker.ThreadWorker(url.pathToFileURL('./worker.ts'));\n  \n  workerInstance.postMessage(sortedNumbers);\n  \n  workerInstance.onmessage = (message: { data: number[] }) => {\n    console.log('Unique sorted numbers:', message.data);\n    workerInstance.terminate();\n  };\n}\n\nexport class WorkerScript {\n  private treeSet: TreeSet<number> = new TreeSet<number>();\n  \n  constructor() {\n    worker.parentPort.onmessage = (message: { data: number[] }) => {\n      this.processNumbers(message.data);\n    };\n  }\n  \n  private processNumbers(numbers: number[]): void {\n    numbers.forEach((num) => {\n      this.treeSet.add(num);\n    });\n    \n    const uniqueSortedNumbers = Array.from(this.treeSet.values());\n    worker.parentPort.postMessage(uniqueSortedNumbers);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that takes an array of URLs, uses the `url` API to extract the domain names from each URL, and then stores these domains in a `TreeSet` to ensure they are unique and sorted. Use `url.parse` to get the domain and `TreeSet.add` to insert it into the set. Finally, return the sorted unique domains using `TreeSet.getFirstValue` and `TreeSet.getLastValue` to show the range of domains.",
    "input": "",
    "output": "import {worker, url, TreeSet} from '@kit.ArkTS';\n\nexport function extractAndSortDomains(urls: string[]): {first: string, last: string} {\n  const domainSet = new TreeSet<string>();\n  \n  for (const urlStr of urls) {\n    try {\n      const parsedUrl = url.parse(urlStr);\n      if (parsedUrl && parsedUrl.hostname) {\n        domainSet.add(parsedUrl.hostname);\n      }\n    } catch (e) {\n      console.error(`Failed to parse URL: ${urlStr}`);\n    }\n  }\n  \n  const first = domainSet.getFirstValue();\n  const last = domainSet.getLastValue();\n  \n  return {first, last};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a series of JSON strings, then dequeues them using `pop` and parses each string into an object using `json.parse`. Finally, store the parsed objects in a `Vector` using its `add` method and return the Vector.",
    "input": "",
    "output": "import {Queue, Vector, json} from '@kit.ArkTS';\n\nexport function processJsonStrings(jsonStrings: string[]): Vector<object> {\n  const queue = new Queue<string>();\n  const vector = new Vector<object>();\n\n  // Enqueue JSON strings\n  for (const str of jsonStrings) {\n    queue.add(str);\n  }\n\n  // Dequeue and parse JSON strings\n  while (queue.length > 0) {\n    const str = queue.pop();\n    if (str) {\n      const parsedObj = json.parse(str);\n      vector.add(parsedObj);\n    }\n  }\n\n  return vector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes a `Vector` of numbers, converts it to an array using `convertToArray`, then stringifies the array into a JSON string using `json.stringify`. Next, parse the JSON string back into an object using `json.parse` and check if a specific key exists using `json.has`.",
    "input": "",
    "output": "import {Queue, Vector, json} from '@kit.ArkTS';\n\nexport function checkKeyInJsonFromVector(vector: Vector<number>, key: string): boolean {\n  const array = vector.convertToArray();\n  const jsonString = json.stringify(array);\n  const parsedObject = json.parse(jsonString);\n  return json.has(parsedObject, key);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `Vector`'s `getFirstElement` to retrieve the first element, then checks if it is a JSON object using `json.has`. If it is, remove a specified property from the JSON object using `json.remove` and then re-insert the modified object back into the `Vector` at the first position using `Vector.insert`.",
    "input": "",
    "output": "import {Queue, Vector, json} from '@kit.ArkTS';\n\nexport function modifyFirstElement(vector: Vector<object>, propertyToRemove: string): void {\n  if (vector.isEmpty()) {\n    return;\n  }\n  \n  const firstElement = vector.getFirstElement();\n  \n  if (json.has(firstElement, propertyToRemove)) {\n    const modifiedElement = JSON.parse(JSON.stringify(firstElement));\n    json.remove(modifiedElement, propertyToRemove);\n    vector.removeByIndex(0);\n    vector.insert(0, modifiedElement);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect error messages from multiple `ErrorEvent` objects (using their `message` property), then uses the `convertToArray` method of `LinkedList` to convert the collected messages into an array for further processing.",
    "input": "",
    "output": "import {ErrorEvent, worker, LinkedList} from '@kit.ArkTS';\n\nexport function collectErrorMessages(errorEvents: ErrorEvent[]): string[] {\n  const messageList: LinkedList<string> = new LinkedList();\n  \n  for (const event of errorEvents) {\n    messageList.add(event.message);\n  }\n  \n  return messageList.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that processes a list of `ErrorEvent` objects by extracting their `filename` and `lineno` properties, then uses the `insert` method of `LinkedList` to insert these details at specific indices based on the error severity (e.g., line number). Finally, use the `forEach` method of `LinkedList` to log each entry.",
    "input": "",
    "output": "import {ErrorEvent, worker, LinkedList} from '@kit.ArkTS';\n\nexport function processErrorEvents(errorEvents: ErrorEvent[]): void {\n  const list = new LinkedList<{filename: string, lineno: number}>();\n  \n  errorEvents.forEach((event) => {\n    const {filename, lineno} = event;\n    const index = lineno % list.length;\n    list.insert(index, {filename, lineno});\n  });\n  \n  list.forEach((item, index) => {\n    console.log(`Index ${index}: Filename - ${item.filename}, Line Number - ${item.lineno}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last error messages from a list of `ErrorEvent` objects (using their `message` property). Then, compare these messages and use the `removeFirstFound` method of `LinkedList` to remove the first occurrence of the longer message if they are not equal.",
    "input": "",
    "output": "import {ErrorEvent, worker, LinkedList} from '@kit.ArkTS';\n\nexport function processErrorMessages(errorList: LinkedList<ErrorEvent>): void {\n  if (errorList.length === 0) {\n    return;\n  }\n\n  const firstError: ErrorEvent | undefined = errorList.getFirst();\n  const lastError: ErrorEvent | undefined = errorList.getLast();\n\n  if (firstError && lastError) {\n    const firstMessage: string = firstError.message;\n    const lastMessage: string = lastError.message;\n\n    if (firstMessage !== lastMessage) {\n      const longerMessage: string = firstMessage.length > lastMessage.length ? firstMessage : lastMessage;\n      errorList.removeFirstFound(longerMessage);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `EventTarget.addEventListener` to listen for a custom event, then dispatches the event using `EventTarget.dispatchEvent` with a `MessageEvent` containing some data in its `data` property. The function should then extract and return the `data` from the `MessageEvent`.",
    "input": "",
    "output": "import {EventTarget, MessageEvents, PostMessageOptions} from '@kit.ArkTS';\n\nexport function listenAndDispatchEvent(): string {\n  const eventTarget = new EventTarget();\n  const eventType = 'customEvent';\n  let receivedData: string = '';\n\n  const eventListener = (event: MessageEvents) => {\n    receivedData = event.data;\n  };\n\n  eventTarget.addEventListener(eventType, eventListener);\n\n  const message = 'Hello, World!';\n  const messageEvent = new MessageEvents(eventType, {\n    data: message\n  });\n\n  eventTarget.dispatchEvent(messageEvent);\n  eventTarget.removeEventListener(eventType, eventListener);\n\n  return receivedData;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that constructs a `MessageEvent` with a specific payload in its `data` property, then uses `EventTarget.dispatchEvent` to send the event. The function should also include `PostMessageOptions` with the `transfer` property set to specify which resources should be transferred during the event dispatch.",
    "input": "",
    "output": "import {EventTarget, MessageEvents, PostMessageOptions} from '@kit.ArkTS';\n\nexport function dispatchMessageEvent(eventTarget: EventTarget, payload: string, transferBuffers: ArrayBuffer[]): void {\n  const messageEvent = new MessageEvents('message', {\n    data: payload\n  });\n\n  const postMessageOptions: PostMessageOptions = {\n    transfer: transferBuffers\n  };\n\n  eventTarget.dispatchEvent(messageEvent, postMessageOptions);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that listens for a message event using `EventTarget.addEventListener`, processes the incoming `MessageEvent.data`, and then uses `EventTarget.removeEventListener` to clean up the listener after the message is received. The function should return the processed data from the `MessageEvent`.",
    "input": "",
    "output": "import {EventTarget, MessageEvents, PostMessageOptions} from '@kit.ArkTS';\n\nexport function listenForMessage(target: EventTarget, callback: (data: string) => void): void {\n  const messageHandler = (event: MessageEvents) => {\n    const processedData = event.data;\n    target.removeEventListener('message', messageHandler);\n    callback(processedData);\n  };\n  target.addEventListener('message', messageHandler);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to run a computationally intensive task in the background with `Priority.HIGH`, and then uses `EventTarget.addEventListener` to listen for a custom event signaling the task's completion. Once the event is received, use `EventTarget.removeEventListener` to clean up the listener.",
    "input": "",
    "output": "import {taskpool, EventTarget} from '@kit.ArkTS';\n\nexport function runIntensiveTaskWithEvent() {\n  const eventTarget = new EventTarget();\n  const eventName = 'taskCompleted';\n\n  const task = () => {\n    // Simulate a computationally intensive task\n    let sum = 0;\n    for (let i = 0; i < 1000000000; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n\n  const onTaskCompleted = () => {\n    console.log('Task completed');\n    eventTarget.removeEventListener(eventName, onTaskCompleted);\n  };\n\n  eventTarget.addEventListener(eventName, onTaskCompleted);\n\n  taskpool.execute(task, taskpool.Priority.HIGH).then(() => {\n    eventTarget.dispatchEvent(eventName);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that schedules a delayed task using `taskpool.executeDelayed` and stores the returned task ID. Then, use `EventTarget.dispatchEvent` to emit a custom event when the delayed task starts executing. Finally, use `taskpool.cancel` to cancel the task if the event is not received within a specified timeout.",
    "input": "",
    "output": "import {taskpool, EventTarget} from '@kit.ArkTS';\n\nexport function scheduleDelayedTask(delay: number, timeout: number): void {\n  const eventTarget = new EventTarget();\n  const eventName = 'taskStarted';\n  \n  let taskId: number | undefined;\n  \n  const task = () => {\n    eventTarget.dispatchEvent({ type: eventName });\n    return 'Task executed';\n  };\n  \n  taskId = taskpool.executeDelayed(task, delay);\n  \n  const timeoutId = setTimeout(() => {\n    if (taskId !== undefined) {\n      taskpool.cancel(taskId);\n    }\n  }, timeout);\n  \n  eventTarget.addEventListener(eventName, () => {\n    clearTimeout(timeoutId);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `taskpool.executePeriodically` to run a periodic task and `EventTarget.addEventListener` to listen for a custom event that stops the task. When the event is triggered, use `taskpool.terminateTask` to stop the periodic execution and `EventTarget.removeAllListener` to clean up all event listeners.",
    "input": "",
    "output": "import {taskpool, EventTarget} from '@kit.ArkTS';\n\nexport function startPeriodicTask(task: taskpool.CallbackFunction, interval: number, eventName: string): void {\n  const eventTarget = new EventTarget();\n  const taskId = taskpool.executePeriodically(task, interval);\n\n  const stopListener = () => {\n    taskpool.terminateTask(taskId);\n    eventTarget.removeAllListener();\n  };\n\n  eventTarget.addEventListener(eventName, stopListener);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `parse` method of `json` to convert a JSON string into an object, then checks if a specific key exists in the object using the `has` method of `json`, and finally removes that key using the `remove` method of `json` if it exists.",
    "input": "",
    "output": "import {stream, json} from '@kit.ArkTS';\n\nexport function processJson(jsonString: string, keyToCheck: string): object {\n  const parsedObject = json.parse(jsonString);\n  if (json.has(parsedObject, keyToCheck)) {\n    json.remove(parsedObject, keyToCheck);\n  }\n  return parsedObject;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `stringify` method of `json` to convert an object into a JSON string, then writes this string to a file using the `write` method of `stream` (assuming `stream` has a `write` method), and finally reads the file back using the `read` method of `stream` to verify the content.",
    "input": "",
    "output": "import {stream, json} from '@kit.ArkTS';\n\nexport function writeAndReadJsonFile(obj: object, filePath: string): void {\n  const jsonString = json.stringify(obj);\n  \n  // Write the JSON string to a file\n  const writableStream = new stream.Writable();\n  writableStream.write(jsonString, filePath);\n  \n  // Read the file back\n  const readableStream = new stream.Readable();\n  const content = readableStream.read(filePath);\n  \n  // Verify the content\n  if (content !== jsonString) {\n    throw new Error('Content verification failed');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `parse` method of `json` to convert a JSON string into an object, modifies the object by adding a new key-value pair, and then uses the `stringify` method of `json` to convert the modified object back into a JSON string, which is then written to a file using the `write` method of `stream`.",
    "input": "",
    "output": "import {stream, json} from '@kit.ArkTS';\n\nexport function modifyAndWriteJson(jsonString: string, newKey: string, newValue: string, filePath: string): void {\n  const parsedObj = json.parse(jsonString);\n  parsedObj[newKey] = newValue;\n  const modifiedJsonString = json.stringify(parsedObj);\n  \n  const writableStream = new stream.Writable();\n  writableStream.write(modifiedJsonString, filePath);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that listens for an error event using the `onerror` property of `GlobalScope` and logs the event's `type` and `timeStamp` properties from the `Event` object passed to the handler.",
    "input": "",
    "output": "import {GlobalScope, Event} from '@kit.ArkTS';\n\nexport function setupErrorListener(): void {\n  if (typeof GlobalScope !== 'undefined') {\n    GlobalScope.onerror = (event: Event) => {\n      console.log(`Error event type: ${event.type}, timestamp: ${event.timeStamp}`);\n    };\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks if the `name` property of `GlobalScope` matches a given string, and if so, triggers a custom event with the `type` property set to 'nameMatch' and the `timeStamp` property recorded from the `Event` API.",
    "input": "",
    "output": "import {GlobalScope, Event} from '@kit.ArkTS';\n\nexport function checkNameAndTriggerEvent(nameToCheck: string): void {\n  if (GlobalScope.name === nameToCheck) {\n    const customEvent = new Event('nameMatch');\n    customEvent.type = 'nameMatch';\n    customEvent.timeStamp = Date.now();\n    GlobalScope.dispatchEvent(customEvent);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `self` property of `GlobalScope` to compare with another object, and if they are not the same, dispatches an event with the `type` property set to 'selfMismatch' and includes the `timeStamp` from the `Event` API.",
    "input": "",
    "output": "import {GlobalScope, Event} from '@kit.ArkTS';\n\nexport function compareSelfWithObject(obj: object): void {\n  if (GlobalScope.self !== obj) {\n    const event = new Event('selfMismatch');\n    GlobalScope.dispatchEvent(event);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` method of `Deque` to store a sequence of numbers in reverse order, then transfers these numbers to a `HashSet` using its `add` method to eliminate duplicates. Finally, use the `values` method of `HashSet` to return the unique numbers as an array.",
    "input": "",
    "output": "import {Deque, HashSet} from '@kit.ArkTS';\n\nexport function reverseAndDeduplicate(numbers: number[]): number[] {\n  const deque = new Deque<number>();\n  for (const num of numbers) {\n    deque.insertFront(num);\n  }\n\n  const hashSet = new HashSet<number>();\n  for (const num of deque) {\n    hashSet.add(num);\n  }\n\n  const uniqueNumbers: number[] = [];\n  for (const num of hashSet.values()) {\n    uniqueNumbers.push(num);\n  }\n\n  return uniqueNumbers;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first populates a `HashSet` with a list of words using its `add` method, then checks if each word in a `Deque` (populated using `insertEnd`) exists in the `HashSet` using its `has` method. Return an array of words from the `Deque` that are not present in the `HashSet`.",
    "input": "",
    "output": "import {Deque, HashSet} from '@kit.ArkTS';\n\nexport function findMissingWords(hashSetWords: string[], dequeWords: string[]): string[] {\n  const hashSet = new HashSet<string>();\n  for (const word of hashSetWords) {\n    hashSet.add(word);\n  }\n\n  const deque = new Deque<string>();\n  for (const word of dequeWords) {\n    deque.insertEnd(word);\n  }\n\n  const missingWords: string[] = [];\n  for (const word of deque) {\n    if (!hashSet.has(word)) {\n      missingWords.push(word);\n    }\n  }\n\n  return missingWords;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `popFirst` method of `Deque` to process a queue of tasks, and for each task, checks if it has been completed (using `has` method of `HashSet`). If not completed, add it to the `HashSet` using `add` and log the task. Repeat until the `Deque` is empty (checked via `length` property).",
    "input": "",
    "output": "import {Deque, HashSet} from '@kit.ArkTS';\n\nexport function processTasks(taskQueue: Deque<string>, completedTasks: HashSet<string>): void {\n  while (taskQueue.length > 0) {\n    const task = taskQueue.popFirst();\n    if (task && !completedTasks.has(task)) {\n      completedTasks.add(task);\n      console.log(task);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `TreeMap` to retrieve all keys, then passes them to the `add` method of `List` to create a new list. Finally, use the `sort` method of `List` to sort the keys in ascending order.",
    "input": "",
    "output": "import {TreeMap, List} from '@kit.ArkTS';\n\nexport function sortTreeMapKeys<K, V>(treeMap: TreeMap<K, V>): List<K> {\n  const keys = treeMap.keys();\n  const list = new List<K>();\n  for (let key of keys) {\n    list.add(key);\n  }\n  list.sort();\n  return list;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getSubList` method of `List` to extract a sublist, then passes the sublist elements to the `setAll` method of `TreeMap` to update the map with new key-value pairs. Ensure the `TreeMap` is updated only if the sublist is not empty (checked using `isEmpty` method of `List`).",
    "input": "",
    "output": "import {TreeMap, List} from '@kit.ArkTS';\n\nexport function updateTreeMapWithSubList(treeMap: TreeMap<number, string>, list: List<[number, string]>, start: number, end: number): void {\n  const subList = list.getSubList(start, end);\n  if (!subList.isEmpty()) {\n    treeMap.setAll(subList);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirstKey` and `getLastKey` methods of `TreeMap` to find the smallest and largest keys, then passes these keys to the `insert` method of `List` to add them at the beginning and end of the list, respectively. Finally, use the `length` property of both APIs to verify the operations.",
    "input": "",
    "output": "import {TreeMap, List} from '@kit.ArkTS';\n\nexport function processTreeMapAndList(treeMap: TreeMap<number, string>, list: List<number>): void {\n  if (treeMap.length > 0) {\n    const firstKey = treeMap.getFirstKey();\n    const lastKey = treeMap.getLastKey();\n    \n    list.insert(0, firstKey);\n    list.insert(list.length, lastKey);\n    \n    console.log(`TreeMap length: ${treeMap.length}, List length: ${list.length}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addEventListener` method of `WorkerEventTarget` to listen for a custom event, and upon triggering, collects the event data into a `List` using its `add` method. Then, use the `sort` method of `List` to organize the collected data and return the sorted list.",
    "input": "",
    "output": "import {WorkerEventTarget, List} from '@kit.ArkTS';\n\nexport function listenAndSortEvents(eventTarget: WorkerEventTarget, eventName: string): List<unknown> {\n  const eventList: List<unknown> = new List<unknown>();\n\n  eventTarget.addEventListener(eventName, (event: { data: unknown }) => {\n    eventList.add(event.data);\n  });\n\n  eventList.sort((a: unknown, b: unknown) => {\n    if (a === b) {\n      return 0;\n    }\n    return a > b ? 1 : -1;\n  });\n\n  return eventList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `List` with some values using its `add` method, then uses the `dispatchEvent` method of `WorkerEventTarget` to send the list as event data. The event listener should use the `getSubList` method of `List` to extract a subset of the data and return it.",
    "input": "",
    "output": "import {WorkerEventTarget, List} from '@kit.ArkTS';\n\nexport function initializeAndDispatchList(): void {\n  const list = new List<number>();\n  list.add(1);\n  list.add(2);\n  list.add(3);\n  list.add(4);\n  list.add(5);\n\n  const workerEventTarget = new WorkerEventTarget();\n  \n  workerEventTarget.addEventListener('listEvent', (event) => {\n    const receivedList = event.data as List<number>;\n    const subList = receivedList.getSubList(1, 3);\n    return subList;\n  });\n\n  workerEventTarget.dispatchEvent({type: 'listEvent', data: list});\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `List` to iterate over its elements and dispatch a custom event for each element using the `dispatchEvent` method of `WorkerEventTarget`. The event listener should collect all dispatched events into a new `List` using its `add` method and return the final list.",
    "input": "",
    "output": "import {WorkerEventTarget, List} from '@kit.ArkTS';\n\nexport function dispatchEventsToList(eventTarget: WorkerEventTarget, list: List<number>): List<string> {\n  const eventList: List<string> = new List();\n  \n  list.forEach((element: number) => {\n    const event = { type: 'customEvent', data: element.toString() };\n    eventTarget.dispatchEvent(event);\n  });\n  \n  eventTarget.addEventListener('customEvent', (event: { type: string, data: string }) => {\n    eventList.add(event.data);\n  });\n  \n  return eventList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of error messages in a worker thread, then passes the collected messages to the `onerror` event handler of `WorkerGlobalScope` to log and handle the errors. The function should also use the `length` property of `LinkedList` to track the number of errors before passing them to the worker.",
    "input": "",
    "output": "import {WorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function collectAndHandleErrors(): void {\n  const errorList: LinkedList<string> = new LinkedList();\n  \n  // Simulate adding error messages to the LinkedList\n  errorList.add('Error 1: Invalid input');\n  errorList.add('Error 2: Network timeout');\n  errorList.add('Error 3: Resource not found');\n  \n  const workerScope: WorkerGlobalScope = self as WorkerGlobalScope;\n  \n  if (workerScope.onerror) {\n    const errorCount: number = errorList.length;\n    const errorMessages: string[] = [];\n    \n    for (const error of errorList) {\n      errorMessages.push(error);\n    }\n    \n    const errorEvent: ErrorEvent = new ErrorEvent('error', {\n      message: `Collected ${errorCount} errors: ${errorMessages.join(', ')}`,\n      filename: '',\n      lineno: 0,\n      colno: 0,\n      error: new Error('Worker error collection')\n    });\n    \n    workerScope.onerror(errorEvent);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `convertToArray` method of `LinkedList` to transform a linked list of worker names into an array, then passes this array to the `self` property of `WorkerGlobalScope` to broadcast the list to all worker threads. The function should also use the `forEach` method of `LinkedList` to iterate over the names before conversion.",
    "input": "",
    "output": "import {WorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function broadcastWorkerNames(workerNames: LinkedList<string>): void {\n  workerNames.forEach((name: string) => {\n    console.log(`Worker name: ${name}`);\n  });\n\n  const namesArray: string[] = workerNames.convertToArray();\n  WorkerGlobalScope.self = namesArray;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last items in a list, then passes these items to the `name` property of `WorkerGlobalScope` to dynamically set the worker's name based on the list contents. The function should also use the `removeFirst` and `removeLast` methods of `LinkedList` to clean up the list after retrieving the items.",
    "input": "",
    "output": "import {WorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function setWorkerNameFromLinkedList(list: LinkedList<string>, workerScope: WorkerGlobalScope): void {\n  if (list.length === 0) {\n    return;\n  }\n  \n  const firstName = list.getFirst();\n  const lastName = list.getLast();\n  \n  if (firstName !== undefined && lastName !== undefined) {\n    workerScope.name = `${firstName}_${lastName}`;\n  }\n  \n  list.removeFirst();\n  list.removeLast();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a sequence of numbers, then dequeues them using `pop` and inserts each into a `TreeMap` using the `set` method, where the key is the number and the value is its square. Finally, use the `keys` method of `TreeMap` to return a sorted list of the numbers.",
    "input": "",
    "output": "import {TreeMap, Queue} from '@kit.ArkTS';\n\nexport function processQueueToTreeMap(numbers: number[]): number[] {\n  const queue = new Queue<number>();\n  const treeMap = new TreeMap<number, number>();\n\n  // Enqueue numbers into the queue\n  for (const num of numbers) {\n    queue.add(num);\n  }\n\n  // Dequeue numbers and insert into TreeMap with key as number and value as its square\n  while (queue.length > 0) {\n    const num = queue.pop();\n    treeMap.set(num, num * num);\n  }\n\n  // Return sorted list of keys\n  return Array.from(treeMap.keys());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `TreeMap` with key-value pairs using the `setAll` method, then extracts all values using the `values` method and stores them in a `Queue` using the `add` method. The function should then dequeue and return the first 3 values using the `pop` method of `Queue`.",
    "input": "",
    "output": "import {TreeMap, Queue} from '@kit.ArkTS';\n\nexport function processTreeMapAndQueue(): Array<unknown> {\n  const treeMap = new TreeMap<number, string>();\n  treeMap.setAll([[1, 'one'], [2, 'two'], [3, 'three'], [4, 'four'], [5, 'five']]);\n  \n  const values = treeMap.values();\n  const queue = new Queue<string>();\n  \n  for (const value of values) {\n    queue.add(value);\n  }\n  \n  const result: Array<unknown> = [];\n  for (let i = 0; i < 3; i++) {\n    if (queue.length > 0) {\n      result.push(queue.pop());\n    }\n  }\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if a `Queue` is empty using the `length` property, and if not, dequeues all elements using `pop` and inserts them into a `TreeMap` with their string representations as keys (using `set`). The function should then use the `getFirstKey` method of `TreeMap` to return the smallest key.",
    "input": "",
    "output": "import {TreeMap, Queue} from '@kit.ArkTS';\n\nexport function processQueue(queue: Queue<number>): string | undefined {\n  const treeMap = new TreeMap<string, number>();\n  \n  if (queue.length === 0) {\n    return undefined;\n  }\n  \n  while (queue.length > 0) {\n    const element = queue.pop();\n    if (element !== undefined) {\n      treeMap.set(element.toString(), element);\n    }\n  }\n  \n  return treeMap.getFirstKey();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `name` property of `WorkerGlobalScope` to identify the current worker, then passes this name to the `self` property of another `WorkerGlobalScope` instance to verify if the worker is communicating with itself.",
    "input": "",
    "output": "import {WorkerGlobalScope, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function verifyWorkerSelfCommunication(workerScope: WorkerGlobalScope): boolean {\n  const currentWorkerName = workerScope.name;\n  const otherWorkerSelf = workerScope.self;\n  return currentWorkerName === otherWorkerSelf.name;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that sets up an error handler using the `onerror` property of `WorkerGlobalScope`, then triggers an error and uses the `self` property of another `WorkerGlobalScope` instance to log the error details to the main thread.",
    "input": "",
    "output": "import {WorkerGlobalScope, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupErrorHandler(workerScope: WorkerGlobalScope): void {\n  workerScope.onerror = (event: ErrorEvent): void => {\n    const errorDetails = {\n      message: event.message,\n      filename: event.filename,\n      lineno: event.lineno,\n      colno: event.colno,\n      error: event.error\n    };\n    workerScope.self.postMessage({ type: 'error', details: errorDetails });\n  };\n\n  // Trigger an error\n  throw new Error('This is a test error');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that retrieves the `name` property from one `WorkerGlobalScope` instance and compares it with the `name` property of another `WorkerGlobalScope` instance to determine if they belong to the same worker context, then uses the `onerror` property to handle any mismatches.",
    "input": "",
    "output": "import {WorkerGlobalScope, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function compareWorkerContexts(worker1: WorkerGlobalScope, worker2: WorkerGlobalScope): boolean {\n  if (worker1.name === worker2.name) {\n    return true;\n  } else {\n    worker1.onerror = (error: ErrorEvent) => {\n      console.error('Worker context mismatch:', error.message);\n    };\n    worker2.onerror = (error: ErrorEvent) => {\n      console.error('Worker context mismatch:', error.message);\n    };\n    return false;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `List` to collect a sequence of messages from `MessageEvents.data`, then uses the `sort` method of `List` to organize the messages alphabetically, and finally returns the sorted list.",
    "input": "",
    "output": "import {List, MessageEvents} from '@kit.ArkTS';\n\nexport function collectAndSortMessages(events: MessageEvents[]): List<string> {\n  const messageList: List<string> = new List();\n  for (const event of events) {\n    messageList.add(event.data);\n  }\n  messageList.sort((a: string, b: string) => a.localeCompare(b));\n  return messageList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that takes a `List` of `MessageEvents` objects, uses the `get` method of `List` to extract each `MessageEvents.data` property, and then uses the `convertToArray` method of `List` to transform the extracted data into an array for further processing.",
    "input": "",
    "output": "import {List, MessageEvents} from '@kit.ArkTS';\n\nexport function extractMessageData(messageList: List<MessageEvents>): Array<any> {\n  let dataArray: Array<any> = [];\n  for (let i = 0; i < messageList.length; i++) {\n    const messageEvent = messageList.get(i);\n    if (messageEvent) {\n      dataArray.push(messageEvent.data);\n    }\n  }\n  return messageList.convertToArray(dataArray);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `List` to iterate over a list of `MessageEvents` objects, checks if each message's `data` property meets a certain condition using the `has` method of `List`, and then uses the `removeByIndex` method of `List` to filter out messages that do not meet the condition.",
    "input": "",
    "output": "import {List, MessageEvents} from '@kit.ArkTS';\n\nexport function filterMessages(messages: List<MessageEvents>, condition: string): void {\n  const indicesToRemove: number[] = [];\n  \n  messages.forEach((message: MessageEvents, index: number) => {\n    if (!messages.has(condition, index)) {\n      indicesToRemove.push(index);\n    }\n  });\n  \n  for (let i = indicesToRemove.length - 1; i >= 0; i--) {\n    messages.removeByIndex(indicesToRemove[i]);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a custom event using the `Event` API (setting its `type` property) and dispatches it using the `dispatchEvent` method of `EventTarget`. The function should then log the `timeStamp` of the dispatched event to verify its execution.",
    "input": "",
    "output": "import {Event, EventTarget} from '@kit.ArkTS';\n\nexport function createAndDispatchEvent(): void {\n  const eventTarget = new EventTarget();\n  const customEvent = new Event('customEvent');\n  \n  eventTarget.dispatchEvent(customEvent);\n  console.log(`Event timestamp: ${customEvent.timeStamp}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that registers an event listener using `EventTarget.addEventListener` for a specific event type, dispatches a custom event of that type using `EventTarget.dispatchEvent`, and then removes the listener using `EventTarget.removeEventListener`. The event object passed to the listener should log its `type` property to confirm the event handling.",
    "input": "",
    "output": "import {Event, EventTarget} from '@kit.ArkTS';\n\nexport function handleEvent(event: Event): void {\n  console.log(`Event type: ${event.type}`);\n}\n\nexport function registerAndDispatchEvent(): void {\n  const eventTarget = new EventTarget();\n  const eventType = 'customEvent';\n\n  eventTarget.addEventListener(eventType, handleEvent);\n  \n  const customEvent = new Event(eventType);\n  eventTarget.dispatchEvent(customEvent);\n  \n  eventTarget.removeEventListener(eventType, handleEvent);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that sets up multiple event listeners using `EventTarget.addEventListener` for different event types, dispatches corresponding events using `EventTarget.dispatchEvent`, and then removes all listeners at once using `EventTarget.removeAllListener`. Each event object should have its `type` and `timeStamp` properties logged to demonstrate the event flow and timing.",
    "input": "",
    "output": "import {Event, EventTarget} from '@kit.ArkTS';\n\nexport function setupEventListeners(): void {\n  const eventTarget = new EventTarget();\n\n  const eventTypes = ['click', 'focus', 'blur'];\n\n  eventTypes.forEach((type) => {\n    const listener = (event: Event) => {\n      console.log(`Event type: ${event.type}, timestamp: ${event.timeStamp}`);\n    };\n    eventTarget.addEventListener(type, listener);\n  });\n\n  eventTypes.forEach((type) => {\n    const event = new Event(type);\n    eventTarget.dispatchEvent(event);\n  });\n\n  eventTarget.removeAllListener();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `HashSet` to collect a set of unique numbers, then converts the HashSet to an array using the `convertToArray` method of `Vector`, and finally sorts the array using the `sort` method of `Vector` to display the numbers in ascending order.",
    "input": "",
    "output": "import {Vector, HashSet} from '@kit.ArkTS';\n\nexport function collectAndSortUniqueNumbers(numbers: number[]): number[] {\n  const uniqueSet = new HashSet<number>();\n  numbers.forEach(num => {\n    uniqueSet.add(num);\n  });\n  \n  const vector = new Vector<number>();\n  uniqueSet.forEach(value => {\n    vector.add(value);\n  });\n  \n  const array = vector.convertToArray();\n  vector.sort((a, b) => a - b);\n  \n  return array;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirstElement` and `getLastElement` methods of `Vector` to retrieve the first and last elements of a list, then checks if these elements exist in a `HashSet` using its `has` method, and returns a boolean indicating whether both elements are present in the HashSet.",
    "input": "",
    "output": "import {Vector, HashSet} from '@kit.ArkTS';\n\nexport function checkElementsInHashSet(vector: Vector<number>, hashSet: HashSet<number>): boolean {\n  const firstElement = vector.getFirstElement();\n  const lastElement = vector.getLastElement();\n  \n  if (firstElement === undefined || lastElement === undefined) {\n    return false;\n  }\n  \n  return hashSet.has(firstElement) && hashSet.has(lastElement);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `HashSet` to iterate over a set of strings, filters out strings with length less than 5, and stores the remaining strings in a `Vector` using its `add` method. Finally, the function should use the `trimToCurrentLength` method of `Vector` to optimize the storage and return the filtered list.",
    "input": "",
    "output": "import {Vector, HashSet} from '@kit.ArkTS';\n\nexport function filterAndStoreStrings(set: HashSet<string>): Vector<string> {\n  const vector = new Vector<string>();\n  set.forEach((value: string) => {\n    if (value.length >= 5) {\n      vector.add(value);\n    }\n  });\n  vector.trimToCurrentLength();\n  return vector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `HashMap` to retrieve all keys, then converts these keys into a URI string using the `toString` method of `uri` (assuming it exists) and stores them in an array. Finally, use the `forEach` method of `HashMap` to log each key-value pair alongside its corresponding URI string.",
    "input": "",
    "output": "import {uri, HashMap} from '@kit.ArkTS';\n\nexport function processHashMapWithURI(map: HashMap<string, string>): void {\n  const keysArray: string[] = Array.from(map.keys());\n  const uriStrings: string[] = keysArray.map(key => {\n    return uri.toString(key);\n  });\n\n  map.forEach((value, key) => {\n    const index = keysArray.indexOf(key);\n    const uriString = uriStrings[index];\n    console.log(`Key: ${key}, Value: ${value}, URI: ${uriString}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if a `HashMap` is empty using the `isEmpty` method, and if not, uses the `entries` method to retrieve all entries. Then, construct a URI string for each entry's value (assuming `uri` has a constructor or method to create URIs from strings) and store these URIs in a new `HashMap` using the `set` method.",
    "input": "",
    "output": "import {uri, HashMap} from '@kit.ArkTS';\n\nexport function processHashMap(inputMap: HashMap<string, string>): HashMap<string, uri> {\n  const resultMap = new HashMap<string, uri>();\n  \n  if (!inputMap.isEmpty()) {\n    for (const [key, value] of inputMap.entries()) {\n      const newUri = new uri(value);\n      resultMap.set(key, newUri);\n    }\n  }\n  \n  return resultMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `hasKey` method of `HashMap` to verify the presence of a specific key. If the key exists, retrieve its value using the `get` method and pass this value to a URI processing function (assuming `uri` has a method to parse or manipulate strings). Then, update the original `HashMap` with the processed value using the `replace` method.",
    "input": "",
    "output": "import {uri, HashMap} from '@kit.ArkTS';\n\nexport function processHashMapValue(map: HashMap<string, string>, key: string): void {\n  if (map.hasKey(key)) {\n    const value = map.get(key);\n    if (value !== undefined) {\n      const processedValue = uri.parse(value);\n      map.replace(key, processedValue);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a buffer from a given string encoded in UTF-8, then uses `process.getUidForName` to retrieve the UID associated with the string's content, and finally compares the buffer's byte length (using `buffer.byteLength`) with the UID value (converted to a buffer) using `buffer.compare`.",
    "input": "",
    "output": "import {buffer, process} from '@kit.ArkTS';\n\nexport function compareBufferWithUid(inputString: string): number {\n  const inputBuffer: buffer.Buffer = buffer.from(inputString, 'utf-8');\n  const uid: number = process.getUidForName(inputString);\n  const uidBuffer: buffer.Buffer = buffer.from(uid.toString(), 'utf-8');\n  return buffer.compare(inputBuffer, uidBuffer);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.getEnvironmentVar` to fetch an environment variable as a string, then encodes it into a buffer using `buffer.from` with 'base64' encoding, and finally checks if the resulting buffer is valid using `buffer.isBuffer` and if the encoding is supported using `buffer.isEncoding`.",
    "input": "",
    "output": "import {buffer, process} from '@kit.ArkTS';\n\nexport function encodeAndCheckEnvVar(envVarName: string): boolean {\n  const envVar = process.getEnvironmentVar(envVarName);\n  if (envVar === undefined) {\n    return false;\n  }\n  \n  const encodedBuffer = buffer.from(envVar, 'base64');\n  const isBufferValid = buffer.isBuffer(encodedBuffer);\n  const isEncodingSupported = buffer.isEncoding('base64');\n  \n  return isBufferValid && isEncodingSupported;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.uptime` to get the system uptime in seconds, converts this value to a buffer using `buffer.alloc` and stores it as a 64-bit floating-point number, then uses `buffer.transcode` to convert the buffer from 'utf-8' to 'ascii' encoding, and finally logs the transcoded buffer's content.",
    "input": "",
    "output": "import {buffer, process} from '@kit.ArkTS';\n\nexport function logUptimeAsAscii(): void {\n  const uptime: number = process.uptime();\n  const buf: buffer.Buffer = buffer.alloc(8);\n  buf.writeDoubleBE(uptime, 0);\n  const transcodedBuf: buffer.Buffer = buffer.transcode(buf, 'utf-8', 'ascii');\n  console.log(transcodedBuf.toString('ascii'));\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of event names, then passes the collected list to the `dispatchEvent` method of `WorkerEventTarget` to trigger each event in the order they were added. The function should return the number of events dispatched.",
    "input": "",
    "output": "import {LinkedList, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function dispatchEvents(eventNames: string[]): number {\n  const list = new LinkedList<string>();\n  const eventTarget = new WorkerEventTarget();\n  \n  for (const name of eventNames) {\n    list.add(name);\n  }\n  \n  let count = 0;\n  for (const eventName of list) {\n    eventTarget.dispatchEvent(eventName);\n    count++;\n  }\n  \n  return count;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list, then uses the `addEventListener` method of `WorkerEventTarget` to set up listeners for these elements. The function should return the `LinkedList` length after the listeners are added.",
    "input": "",
    "output": "import {LinkedList, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function setupListenersAndGetLength(list: LinkedList<number>, eventTarget: WorkerEventTarget): number {\n  const firstElement = list.getFirst();\n  const lastElement = list.getLast();\n\n  eventTarget.addEventListener(firstElement.toString(), () => {});\n  eventTarget.addEventListener(lastElement.toString(), () => {});\n\n  return list.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `removeFirstFound` method of `LinkedList` to remove a specific event name from the list, then uses the `removeEventListener` method of `WorkerEventTarget` to remove the corresponding listener. The function should return `true` if both operations succeed, otherwise `false`.",
    "input": "",
    "output": "import {LinkedList, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function removeEventAndListener(eventList: LinkedList<string>, eventTarget: WorkerEventTarget, eventName: string): boolean {\n  const isRemovedFromList = eventList.removeFirstFound(eventName);\n  const isRemovedFromTarget = eventTarget.removeEventListener(eventName);\n  return isRemovedFromList && isRemovedFromTarget;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of JSON strings, then parses each string into an object using `json.parse`, and finally converts the parsed objects into an array using `LinkedList.convertToArray` for further processing.",
    "input": "",
    "output": "import {LinkedList, json} from '@kit.ArkTS';\n\nexport function processJsonStrings(jsonStrings: string[]): object[] {\n  const list = new LinkedList<string>();\n  \n  for (const str of jsonStrings) {\n    list.add(str);\n  }\n  \n  const parsedObjects: object[] = [];\n  \n  for (const str of list) {\n    const parsedObj = json.parse(str);\n    parsedObjects.push(parsedObj);\n  }\n  \n  return parsedObjects;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses `json.stringify` to convert a complex object into a JSON string, then inserts the string into a `LinkedList` using the `insert` method at a specified index, and finally retrieves the modified `LinkedList` using the `get` method to verify the insertion.",
    "input": "",
    "output": "import {LinkedList, json} from '@kit.ArkTS';\n\nexport function processComplexObjectWithLinkedList(obj: object, index: number): string | undefined {\n  const jsonString = json.stringify(obj);\n  const linkedList = new LinkedList<string>();\n  linkedList.insert(index, jsonString);\n  return linkedList.get(index);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `LinkedList.forEach` to iterate over a list of JSON strings, checks if each string contains a specific key using `json.has`, removes the entries that do not meet the condition using `LinkedList.removeFirstFound`, and returns the filtered list using `LinkedList.convertToArray`.",
    "input": "",
    "output": "import {LinkedList, json} from '@kit.ArkTS';\n\nexport function filterJsonStringsByKey(linkedList: LinkedList<string>, key: string): string[] {\n  const toRemove: string[] = [];\n  \n  linkedList.forEach((value: string) => {\n    try {\n      const parsed = json.parse(value);\n      if (!json.has(parsed, key)) {\n        toRemove.push(value);\n      }\n    } catch (e) {\n      toRemove.push(value);\n    }\n  });\n  \n  toRemove.forEach((value: string) => {\n    linkedList.removeFirstFound(value);\n  });\n  \n  return linkedList.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of XML event types (from `xml.EventType`), then iterates through the stack using the `[Symbol.iterator]` method of `Stack` to process each event type and log its details.",
    "input": "",
    "output": "import {xml, Stack} from '@kit.ArkTS';\n\nexport function processXmlEventTypes(): void {\n  const eventStack: Stack<xml.EventType> = new Stack<xml.EventType>();\n  \n  // Push some example XML event types into the stack\n  eventStack.push(xml.EventType.START_DOCUMENT);\n  eventStack.push(xml.EventType.START_ELEMENT);\n  eventStack.push(xml.EventType.END_ELEMENT);\n  eventStack.push(xml.EventType.END_DOCUMENT);\n  \n  // Iterate through the stack using Symbol.iterator\n  for (const eventType of eventStack) {\n    console.log(`Processing XML Event Type: ${eventType}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if a `Stack` (from @kit.ArkTS) is empty using the `isEmpty` method, and if not, pops the top element using the `pop` method and passes it to an XML event handler (using `xml.EventType`) to determine the next action based on the event type.",
    "input": "",
    "output": "import {xml, Stack} from '@kit.ArkTS';\n\nexport function processStackEvent(stack: Stack<number>, handler: (eventType: xml.EventType, value: number) => void): void {\n  if (!stack.isEmpty()) {\n    const topElement = stack.pop();\n    handler(xml.EventType.CHANGE, topElement);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to inspect the top element without removing it, then uses the `length` property of `Stack` to determine if the stack has more than 5 elements, and if so, processes the top element as an XML event type (from `xml.EventType`).",
    "input": "",
    "output": "import {xml, Stack} from '@kit.ArkTS';\n\nexport function processTopElementIfNeeded(stack: Stack<xml.EventType>): void {\n  const topElement = stack.peek();\n  if (stack.length > 5 && topElement !== undefined) {\n    // Process the top element as an XML event type\n    const processedEventType: xml.EventType = topElement;\n    // Add your processing logic here\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of numbers from user input, then passes the resulting `LinkedList` to a `ThreadWorkerGlobalScope` worker thread using `postMessage`. The worker thread should use the `get` and `length` properties of `LinkedList` to calculate the sum of all elements and return the result via `onmessage`.",
    "input": "",
    "output": "import {LinkedList, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function collectAndSumNumbers(): void {\n  const list = new LinkedList<number>();\n  \n  // Simulate user input by adding numbers to the LinkedList\n  list.add(1);\n  list.add(2);\n  list.add(3);\n  \n  const worker = new ThreadWorkerGlobalScope('workers/worker.ts');\n  \n  worker.onmessage = (message: {data: number}) => {\n    console.log(`Sum of numbers: ${message.data}`);\n    worker.close();\n  };\n  \n  worker.postMessage(list);\n}\n\n// worker.ts content (should be in a separate file)\n// import {LinkedList} from '@kit.ArkTS';\n// \n// const workerScope = new ThreadWorkerGlobalScope('self');\n// \n// workerScope.onmessage = (message: {data: LinkedList<number>}) => {\n//   const list = message.data;\n//   let sum = 0;\n//   for (let i = 0; i < list.length; i++) {\n//     sum += list.get(i);\n//   }\n//   workerScope.postMessage(sum);\n// };",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function where a `LinkedList` is populated using the `insert` method with a series of strings. Then, pass this `LinkedList` to a `ThreadWorkerGlobalScope` worker thread using `postMessageWithSharedSendable`. The worker thread should use the `removeFirstFound` method to remove a specific string (provided as input) and return the modified `LinkedList` via `onmessage`.",
    "input": "",
    "output": "import {LinkedList, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function populateAndProcessLinkedList(targetString: string): void {\n  const linkedList = new LinkedList<string>();\n  linkedList.insert('first');\n  linkedList.insert('second');\n  linkedList.insert('third');\n  linkedList.insert('fourth');\n\n  const worker = new ThreadWorkerGlobalScope('workers/worker.js');\n  worker.postMessageWithSharedSendable({list: linkedList, target: targetString});\n\n  worker.onmessage = (message: {data: LinkedList<string>}) => {\n    const modifiedList = message.data;\n    console.log('Modified LinkedList:', modifiedList.convertToArray());\n    worker.close();\n  };\n}\n\n// worker.js content (should be in a separate file)\n// import {LinkedList, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n// const worker = new ThreadWorkerGlobalScope();\n// worker.onmessage = (message: {data: {list: LinkedList<string>, target: string}}) => {\n//   const {list, target} = message.data;\n//   list.removeFirstFound(target);\n//   worker.postMessageWithSharedSendable(list);\n// };",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a program that initializes a `LinkedList` with integers using the `addFirst` and `addLast` methods. Then, pass this `LinkedList` to a `ThreadWorkerGlobalScope` worker thread using `postMessage`. The worker thread should use the `convertToArray` method of `LinkedList` to transform the list into an array, sort it, and return the sorted array via `onmessageerror` if an error occurs during processing.",
    "input": "",
    "output": "import {LinkedList, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function initializeLinkedList(): LinkedList<number> {\n  const list = new LinkedList<number>();\n  list.addFirst(3);\n  list.addFirst(1);\n  list.addLast(5);\n  list.addLast(2);\n  return list;\n}\n\nexport function createWorker(): ThreadWorkerGlobalScope {\n  const worker = new ThreadWorkerGlobalScope('workers/worker.ts');\n  return worker;\n}\n\nexport function sendListToWorker(worker: ThreadWorkerGlobalScope, list: LinkedList<number>): void {\n  worker.postMessage(list);\n}\n\n// worker.ts content (to be placed in a separate file 'workers/worker.ts')\n/*\nimport {LinkedList, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nconst worker = new ThreadWorkerGlobalScope();\n\nworker.onmessage = (list: LinkedList<number>) => {\n  try {\n    const array = list.convertToArray();\n    array.sort((a, b) => a - b);\n    worker.postMessage(array);\n  } catch (error) {\n    worker.onmessageerror(error);\n  }\n};\n*/\n",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a new worker thread using the `worker` API, assigns a name to the worker using the `name` property of `WorkerGlobalScope`, and sets up an error handler using the `onerror` property of `WorkerGlobalScope` to log any errors encountered in the worker thread.",
    "input": "",
    "output": "import {WorkerGlobalScope, worker} from '@kit.ArkTS';\n\nexport function createWorker(workerScriptURL: string, workerName: string): void {\n  const workerInstance = new worker.ThreadWorker(workerScriptURL);\n  workerInstance.onerror = (error: ErrorEvent) => {\n    console.error(`Error in worker thread: ${error.message}`);\n  };\n  workerInstance.workerGlobalScope.name = workerName;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a script where the `self` property of `WorkerGlobalScope` is used to check if the current context is a worker thread, and if so, use the `worker` API to post a message back to the main thread with the worker's name obtained from the `name` property of `WorkerGlobalScope`.",
    "input": "",
    "output": "import {WorkerGlobalScope, worker} from '@kit.ArkTS';\n\nexport function checkWorkerContext(): void {\n  if (WorkerGlobalScope.self !== undefined) {\n    const workerName: string = WorkerGlobalScope.name;\n    worker.postMessage(workerName);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a worker using the `worker` API, dynamically sets the worker's name via the `name` property of `WorkerGlobalScope`, and then uses the `onerror` property of `WorkerGlobalScope` to handle and forward any runtime errors from the worker to the main thread for logging.",
    "input": "",
    "output": "import {WorkerGlobalScope, worker} from '@kit.ArkTS';\n\nexport function initializeWorker(workerScriptURL: string, workerName: string): worker.ThreadWorker {\n  const workerInstance = new worker.ThreadWorker(workerScriptURL);\n\n  workerInstance.onmessage = (event: worker.MessageEvents): void => {\n    if (event.data === 'initialize') {\n      workerInstance.postMessage({ type: 'setName', name: workerName });\n    }\n  };\n\n  workerInstance.onerror = (error: Error): void => {\n    console.error(`Worker error: ${error.message}`);\n  };\n\n  workerInstance.postMessage('initialize');\n  return workerInstance;\n}\n\nexport function handleWorkerInitialization(workerScope: WorkerGlobalScope): void {\n  workerScope.onmessage = (event: MessageEvent): void => {\n    if (event.data.type === 'setName') {\n      workerScope.name = event.data.name;\n    }\n  };\n\n  workerScope.onerror = (error: ErrorEvent): void => {\n    workerScope.postMessage({ type: 'error', message: error.message });\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` to collect a sequence of URLs (as strings), then iterates over the deque using `forEach` to validate each URL by passing it to the `url` API's parsing logic (assuming `url` can parse strings). The function should return a new `Deque` containing only valid URLs.",
    "input": "",
    "output": "import {Deque, url} from '@kit.ArkTS';\n\nexport function validateURLs(urls: string[]): Deque<string> {\n  const deque = new Deque<string>();\n  urls.forEach((urlStr) => {\n    deque.insertEnd(urlStr);\n  });\n\n  const validDeque = new Deque<string>();\n  deque.forEach((urlStr) => {\n    try {\n      new url.URL(urlStr);\n      validDeque.insertEnd(urlStr);\n    } catch (e) {\n      // URL is invalid, skip\n    }\n  });\n\n  return validDeque;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `popFirst` method of `Deque` to retrieve a URL string, then processes it with the `url` API to extract the domain name. The function should then use the `insertEnd` method of `Deque` to store the extracted domains in a separate deque and return it.",
    "input": "",
    "output": "import {Deque, url} from '@kit.ArkTS';\n\nexport function processUrls(urlDeque: Deque<string>): Deque<string> {\n  const domainDeque = new Deque<string>();\n  \n  while (urlDeque.length > 0) {\n    const urlStr = urlDeque.popFirst();\n    if (urlStr) {\n      const parsedUrl = new url.URL(urlStr);\n      const domain = parsedUrl.hostname;\n      domainDeque.insertEnd(domain);\n    }\n  }\n  \n  return domainDeque;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes an array of URLs (as strings), uses the `Deque` constructor to create a deque from the array, then iterates over the deque using `Symbol.iterator` to filter out invalid URLs (by leveraging the `url` API's parsing). The function should return the filtered deque and its `length` property as an object.",
    "input": "",
    "output": "import {Deque, url} from '@kit.ArkTS';\n\nexport function filterValidUrls(urls: string[]): { filteredDeque: Deque<string>, length: number } {\n  const deque = new Deque(urls);\n  const filteredDeque = new Deque<string>();\n\n  for (const urlStr of deque) {\n    try {\n      new url.URL(urlStr);\n      filteredDeque.insertEnd(urlStr);\n    } catch (e) {\n      // Invalid URL, skip\n    }\n  }\n\n  return {\n    filteredDeque,\n    length: filteredDeque.length\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `self` property of `GlobalScope` to access the current global context, then passes this context to the `EventType` enum of `xml` to dynamically determine and log the type of event being handled (e.g., 'click', 'load').",
    "input": "",
    "output": "import {GlobalScope, xml} from '@kit.ArkTS';\n\nexport function logEventType(): void {\n  const globalContext = GlobalScope.self;\n  const eventType = xml.EventType;\n  console.log(`Current event type: ${eventType}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onerror` property of `GlobalScope` to set up a global error handler, which then uses the `EventType` enum from `xml` to categorize and log different types of errors (e.g., 'network', 'syntax') based on the error event.",
    "input": "",
    "output": "import {GlobalScope, xml} from '@kit.ArkTS';\n\nexport function setupGlobalErrorHandler(): void {\n  if (GlobalScope.onerror) {\n    GlobalScope.onerror = (event: ErrorEvent) => {\n      let errorType: xml.EventType;\n      \n      if (event.message.includes('network')) {\n        errorType = xml.EventType.NETWORK_ERROR;\n      } else if (event.message.includes('syntax')) {\n        errorType = xml.EventType.SYNTAX_ERROR;\n      } else {\n        errorType = xml.EventType.UNKNOWN_ERROR;\n      }\n      \n      console.log(`Error Type: ${errorType}, Message: ${event.message}`);\n      return true;\n    };\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a utility that first retrieves the `name` property from `GlobalScope` to identify the current execution environment, then uses this information to conditionally apply specific `EventType` values from `xml` for event handling (e.g., 'mobile' vs. 'desktop' environments).",
    "input": "",
    "output": "import {GlobalScope, xml} from '@kit.ArkTS';\n\nexport function getEnvironmentSpecificEventType(): xml.EventType {\n  const environment = GlobalScope.name;\n  \n  if (environment === 'mobile') {\n    return xml.EventType.TOUCH;\n  } else if (environment === 'desktop') {\n    return xml.EventType.CLICK;\n  } else {\n    return xml.EventType.UNKNOWN;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `generateRandomUUID` method of `util` to create a random UUID, then uses the `parseUUID` method of `util` to validate and parse the UUID into its binary components, and finally passes the parsed components to the `getHash` method of `util` to compute a hash value for the UUID.",
    "input": "",
    "output": "import {util, url} from '@kit.ArkTS';\n\nexport function processUUID(): Uint8Array {\n  const randomUUID: string = util.generateRandomUUID();\n  const parsedUUID: Uint8Array = util.parseUUID(randomUUID);\n  const hashValue: Uint8Array = util.getHash(parsedUUID);\n  return hashValue;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `printf` method of `util` to format a URL string with placeholders, then uses the `url` module to parse the formatted URL string into its components (e.g., protocol, hostname, path), and finally uses the `errnoToString` method of `util` to convert any parsing errors into human-readable error messages.",
    "input": "",
    "output": "import {util, url} from '@kit.ArkTS';\n\nexport function formatAndParseURL(formatString: string, ...args: string[]): url.URL | string {\n  try {\n    const formattedURL = util.printf(formatString, ...args);\n    const parsedURL = new url.URL(formattedURL);\n    return parsedURL;\n  } catch (error) {\n    return util.errnoToString(error.errno);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `promisify` method of `util` to convert a callback-based function (e.g., a simulated network request) into a promise-based one, then uses the `callbackWrapper` method of `util` to handle the promise result, and finally uses the `format` method of `util` to format the result or error message for display.",
    "input": "",
    "output": "import {util, url} from '@kit.ArkTS';\n\nexport function simulateNetworkRequest(callback: (error: Error | null, data: string) => void): void {\n  setTimeout(() => {\n    const random = Math.random();\n    if (random > 0.5) {\n      callback(null, 'Network request succeeded');\n    } else {\n      callback(new Error('Network request failed'), '');\n    }\n  }, 1000);\n}\n\nexport async function promisifyAndHandleRequest(): Promise<string> {\n  const promisifiedRequest = util.promisify(simulateNetworkRequest);\n  \n  try {\n    const result = await util.callbackWrapper(promisifiedRequest)();\n    return util.format('Success: %s', result);\n  } catch (error) {\n    return util.format('Error: %s', error.message);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `on` method of `MessageEvents` to listen for incoming messages, then processes the `data` property of the received event, and finally writes the processed data to a stream using the `write` method of `stream` (assumed to exist).",
    "input": "",
    "output": "import {stream, MessageEvents} from '@kit.ArkTS';\n\nexport function processMessageEvents(event: MessageEvents): void {\n  const processedData = event.data;\n  stream.write(processedData);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that reads data from a `stream` (assumed to have a `read` method) and uses the `emit` method of `MessageEvents` to send the read data as a message event, ensuring the `data` property of the event contains the stream content.",
    "input": "",
    "output": "import {stream, MessageEvents} from '@kit.ArkTS';\n\nexport function readAndEmitStreamData(stream: stream.Readable, messageEvents: MessageEvents): void {\n  const data = stream.read();\n  messageEvents.emit({ data });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that first captures multiple message events using the `on` method of `MessageEvents`, aggregates their `data` properties into a single buffer, and then writes the buffer to a `stream` (assumed to have a `write` method) for further processing.",
    "input": "",
    "output": "import {stream, MessageEvents} from '@kit.ArkTS';\n\nexport class MessageAggregator {\n  private buffer: string[] = [];\n  private targetStream: stream.Writable;\n\n  constructor(targetStream: stream.Writable) {\n    this.targetStream = targetStream;\n  }\n\n  public captureMessages(events: MessageEvents[]): void {\n    events.forEach((event: MessageEvents) => {\n      this.buffer.push(event.data);\n    });\n  }\n\n  public writeToStream(): void {\n    const aggregatedData = this.buffer.join('');\n    this.targetStream.write(aggregatedData);\n    this.buffer = [];\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `json.stringify` to convert an object containing user data into a JSON string, then passes this string to `DedicatedWorkerGlobalScope.postMessage` to send it to a worker thread for processing.",
    "input": "",
    "output": "import {json, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendUserDataToWorker(userData: object, workerScope: DedicatedWorkerGlobalScope): void {\n  const jsonString = json.stringify(userData);\n  workerScope.postMessage(jsonString);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that receives a JSON string via `DedicatedWorkerGlobalScope.onmessage`, parses it into an object using `json.parse`, modifies the object by removing a specified property using `json.remove`, and then sends the modified object back to the main thread using `DedicatedWorkerGlobalScope.postMessage`.",
    "input": "",
    "output": "import {json, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function modifyJsonObject(workerScope: DedicatedWorkerGlobalScope): void {\n  workerScope.onmessage = (event: MessageEvent<string>) => {\n    try {\n      const parsedObject = json.parse(event.data);\n      const propertyToRemove = 'specifiedProperty';\n      if (json.has(parsedObject, propertyToRemove)) {\n        json.remove(parsedObject, propertyToRemove);\n      }\n      workerScope.postMessage(parsedObject);\n    } catch (error) {\n      workerScope.postMessage({ error: 'Failed to parse or modify JSON' });\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a worker thread that listens for messages using `DedicatedWorkerGlobalScope.onmessage`, checks if the received message contains a specific property using `json.has`, and if found, processes the data and closes the worker using `DedicatedWorkerGlobalScope.close`.",
    "input": "",
    "output": "import {json, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorker() {\n  const workerScope: DedicatedWorkerGlobalScope = self as unknown as DedicatedWorkerGlobalScope;\n\n  workerScope.onmessage = (event: MessageEvent) => {\n    const message = event.data;\n    if (json.has(message, 'specificProperty')) {\n      // Process the data here\n      console.log('Processing data:', message.specificProperty);\n      workerScope.close();\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of URLs extracted from a string using the `url` API (from @kit.ArkTS). Then, use the `pop` method of `Stack` to retrieve and log the URLs in reverse order.",
    "input": "",
    "output": "import {Stack, url} from '@kit.ArkTS';\n\nexport function processUrls(urlString: string): void {\n  const urlStack = new Stack<string>();\n  const extractedUrls = urlString.match(/https?:\\/\\/[^\\s]+/g) || [];\n  \n  extractedUrls.forEach((url) => {\n    urlStack.push(url);\n  });\n  \n  while (!urlStack.isEmpty()) {\n    const poppedUrl = urlStack.pop();\n    console.log(poppedUrl);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that checks if a given URL (processed using the `url` API from @kit.ArkTS) is present in a `Stack` (from @kit.ArkTS) by iterating through the stack using the `forEach` method. Return `true` if the URL is found, otherwise `false`.",
    "input": "",
    "output": "import {Stack, url} from '@kit.ArkTS';\n\nexport function isUrlInStack(urlToCheck: url.URL, stack: Stack<url.URL>): boolean {\n  let found = false;\n  stack.forEach((urlInStack: url.URL) => {\n    if (urlInStack === urlToCheck) {\n      found = true;\n    }\n  });\n  return found;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `locate` method of `Stack` (from @kit.ArkTS) to find the position of a specific URL (processed using the `url` API from @kit.ArkTS) in the stack. If the URL is found, use the `peek` method to check if it is at the top of the stack; otherwise, push it to the stack using the `push` method.",
    "input": "",
    "output": "import {Stack, url} from '@kit.ArkTS';\n\nexport function processUrl(stack: Stack<string>, urlString: string): void {\n  const parsedUrl = url.parse(urlString);\n  const position = stack.locate(parsedUrl.toString());\n  if (position !== -1) {\n    const topElement = stack.peek();\n    if (topElement === parsedUrl.toString()) {\n      return;\n    }\n  } else {\n    stack.push(parsedUrl.toString());\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getKeyAt` method of `LightWeightMap` to retrieve all keys, then passes these keys to the `encode` method of `uri` to create a list of encoded URIs. Finally, use the `setAll` method of `LightWeightMap` to store the encoded URIs as values mapped to their original keys.",
    "input": "",
    "output": "import {uri, LightWeightMap} from '@kit.ArkTS';\n\nexport function encodeAndStoreURIs(map: LightWeightMap<string, string>): void {\n  const newMap = new LightWeightMap<string, string>();\n  const keys: string[] = [];\n  \n  for (let i = 0; i < map.length; i++) {\n    const key = map.getKeyAt(i);\n    if (key !== undefined) {\n      keys.push(key);\n    }\n  }\n  \n  keys.forEach(key => {\n    const encodedURI = uri.encode(key);\n    newMap.set(key, encodedURI);\n  });\n  \n  map.setAll(newMap);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if a `LightWeightMap` is empty using the `isEmpty` method. If it is not empty, use the `entries` method to retrieve all key-value pairs, then pass these pairs to the `decode` method of `uri` to decode any URIs in the values. Finally, use the `clear` and `setAll` methods of `LightWeightMap` to update the map with the decoded values.",
    "input": "",
    "output": "import {uri, LightWeightMap} from '@kit.ArkTS';\n\nexport function decodeAndUpdateMap(map: LightWeightMap<string, string>): void {\n  if (!map.isEmpty()) {\n    const entries = map.entries();\n    const decodedEntries = new LightWeightMap<string, string>();\n    \n    for (let i = 0; i < entries.length; i++) {\n      const key = entries.getKeyAt(i);\n      const value = entries.getValueAt(i);\n      const decodedValue = uri.decode(value);\n      decodedEntries.set(key, decodedValue);\n    }\n    \n    map.clear();\n    map.setAll(decodedEntries);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `hasKey` method of `LightWeightMap` to check for the presence of a specific key. If the key exists, use the `get` method to retrieve its value, then pass this value to the `parse` method of `uri` to extract and return the components of the URI. Use the `setValueAt` method of `LightWeightMap` to update the value if the URI components are modified.",
    "input": "",
    "output": "import {uri, LightWeightMap} from '@kit.ArkTS';\n\nexport function checkAndParseUri(map: LightWeightMap<string, string>, key: string): uri.URI | undefined {\n  if (map.hasKey(key)) {\n    const value = map.get(key);\n    if (value) {\n      const parsedUri = uri.parse(value);\n      return parsedUri;\n    }\n  }\n  return undefined;\n}\n\nexport function updateUriValue(map: LightWeightMap<string, string>, key: string, newValue: string): boolean {\n  if (map.hasKey(key)) {\n    const index = map.getIndexOfKey(key);\n    if (index !== -1) {\n      map.setValueAt(index, newValue);\n      return true;\n    }\n  }\n  return false;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `TreeMap` to retrieve all keys, then passes them to the `forEach` method of `stream` (assuming it's a stream-like API) to process each key by converting it to uppercase and logging the result.",
    "input": "",
    "output": "import {TreeMap, stream} from '@kit.ArkTS';\n\nexport function processTreeMapKeys(treeMap: TreeMap<string, unknown>): void {\n  const keys = treeMap.keys();\n  stream.forEach(keys, (key: string) => {\n    const upperCaseKey = key.toUpperCase();\n    console.log(upperCaseKey);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirstKey` and `getLastKey` methods of `TreeMap` to retrieve the smallest and largest keys, then uses the `stream` API (assuming it supports concatenation) to combine these keys into a single string separated by a hyphen and return the result.",
    "input": "",
    "output": "import {TreeMap, stream} from '@kit.ArkTS';\n\nexport function combineFirstAndLastKeys(map: TreeMap<any, any>): string {\n  const firstKey = map.getFirstKey();\n  const lastKey = map.getLastKey();\n  return stream.concat([firstKey, lastKey], '-');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `entries` method of `TreeMap` to retrieve all key-value pairs, then passes them to the `stream` API (assuming it supports filtering) to filter out entries where the value is null or undefined, and finally uses the `setAll` method of `TreeMap` to update the original map with the filtered entries.",
    "input": "",
    "output": "import {TreeMap, stream} from '@kit.ArkTS';\n\nexport function filterNullUndefinedValues<K, V>(map: TreeMap<K, V>): void {\n  const entries = map.entries();\n  const filteredEntries = Array.from(entries)\n    .filter(([_, value]) => value !== null && value !== undefined);\n  \n  const newMap = new TreeMap<K, V>();\n  newMap.setAll(filteredEntries);\n  \n  map.clear();\n  map.setAll(newMap.entries());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `generateRandomUUID` method of `util` to create a random UUID, then uses the `parseUUID` method of `util` to validate and parse the UUID into its binary components, and finally formats the parsed components into a human-readable string using the `format` method of `util`.",
    "input": "",
    "output": "import {uri, util} from '@kit.ArkTS';\n\nexport function processUUID(): string {\n  const randomUUID: string = util.generateRandomUUID();\n  const parsedUUID: Uint8Array = util.parseUUID(randomUUID);\n  const formattedUUID: string = util.format('Parsed UUID: %s', parsedUUID.toString());\n  return formattedUUID;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomBinaryUUID` method of `util` to generate a binary UUID, then passes this binary UUID to the `getHash` method of `util` to compute its hash value, and finally converts the hash value into a string representation using the `errnoToString` method of `util`.",
    "input": "",
    "output": "import {uri, util} from '@kit.ArkTS';\n\nexport function generateAndHashUUID(): string {\n  const binaryUUID: Uint8Array = util.generateRandomBinaryUUID();\n  const hashValue: number = util.getHash(binaryUUID);\n  const hashString: string = util.errnoToString(hashValue);\n  return hashString;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `printf` method of `util` to log a formatted error message, then uses the `getErrorString` method of `util` to retrieve the corresponding error string, and finally wraps the error string in a callback using the `callbackWrapper` method of `util` for asynchronous handling.",
    "input": "",
    "output": "import {uri, util} from '@kit.ArkTS';\n\nexport function handleError(errorCode: number, callback: (errorString: string) => void): void {\n  util.printf('Error occurred with code: %d', errorCode);\n  const errorString: string = util.getErrorString(errorCode);\n  util.callbackWrapper(callback)(errorString);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `TreeSet` to store a sequence of numbers, then creates a worker using `WorkerOptions` with the `name` property set to 'sort_worker'. The worker should receive the sorted values from the `TreeSet` (obtained using the `values` method) and return the sum of the first and last values (obtained using `getFirstValue` and `getLastValue`).",
    "input": "",
    "output": "import {WorkerOptions, TreeSet} from '@kit.ArkTS';\n\nexport function processTreeSetWithWorker(numbers: number[]): void {\n  const treeSet = new TreeSet<number>();\n  numbers.forEach(num => treeSet.add(num));\n  \n  const sortedValues = Array.from(treeSet.values());\n  \n  const workerOptions: WorkerOptions = {\n    name: 'sort_worker'\n  };\n  \n  const worker = new Worker('sort_worker', workerOptions);\n  \n  worker.postMessage(sortedValues);\n  \n  worker.onmessage = (event) => {\n    console.log(`Sum of first and last values: ${event.data}`);\n    worker.terminate();\n  };\n}\n\nexport function sortWorkerLogic(): void {\n  const worker = new Worker('sort_worker');\n  \n  worker.onmessage = (event) => {\n    const values = event.data as number[];\n    if (values.length > 0) {\n      const firstValue = values[0];\n      const lastValue = values[values.length - 1];\n      const sum = firstValue + lastValue;\n      worker.postMessage(sum);\n    } else {\n      worker.postMessage(0);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that initializes a `TreeSet` and populates it using the `add` method with a list of unsorted strings. Then, create a worker using `WorkerOptions` with the `shared` property set to `true`. The worker should receive the sorted strings (obtained using the `values` method of `TreeSet`) and return the concatenation of the first and last strings (obtained using `getFirstValue` and `getLastValue`).",
    "input": "",
    "output": "import {WorkerOptions, TreeSet} from '@kit.ArkTS';\n\nexport function initializeTreeSetAndStartWorker(strings: string[]): void {\n  const treeSet = new TreeSet<string>();\n  strings.forEach((str) => {\n    treeSet.add(str);\n  });\n\n  const sortedStrings = Array.from(treeSet.values());\n  const workerOptions: WorkerOptions = {\n    name: 'treeSetWorker',\n    shared: true\n  };\n\n  const worker = new Worker('workers/treeSetWorker.js', workerOptions);\n  worker.postMessage(sortedStrings);\n}\n\nexport function handleWorkerMessage(sortedStrings: string[]): string {\n  const treeSet = new TreeSet<string>();\n  sortedStrings.forEach((str) => {\n    treeSet.add(str);\n  });\n\n  const first = treeSet.getFirstValue();\n  const last = treeSet.getLastValue();\n  return first + last;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `TreeSet` to iterate over a set of timestamps and filter out any values older than a given threshold. Then, create a worker using `WorkerOptions` with the `name` property set to 'cleanup_worker'. The worker should receive the filtered timestamps (obtained using the `values` method of `TreeSet`) and return the count of remaining values (obtained using the `length` property).",
    "input": "",
    "output": "import {WorkerOptions, TreeSet} from '@kit.ArkTS';\n\nexport function filterAndCountTimestamps(timestamps: TreeSet<number>, threshold: number): number {\n  const filteredTimestamps = new TreeSet<number>();\n  timestamps.forEach((timestamp: number) => {\n    if (timestamp >= threshold) {\n      filteredTimestamps.add(timestamp);\n    }\n  });\n\n  const workerOptions: WorkerOptions = {\n    name: 'cleanup_worker'\n  };\n\n  const worker = new Worker('workers/worker.js', workerOptions);\n  worker.postMessage(Array.from(filteredTimestamps.values()));\n\n  let count = 0;\n  worker.onmessage = (event: MessageEvent<number>) => {\n    count = event.data;\n  };\n\n  return count;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `self` property of `WorkerGlobalScope` to access the worker's global scope, then sends a message containing the worker's `name` property to the main thread using the `data` property of `MessageEvents`.",
    "input": "",
    "output": "import {WorkerGlobalScope, MessageEvents} from '@kit.ArkTS';\n\nexport function sendWorkerNameToMainThread(): void {\n  const workerScope: WorkerGlobalScope = self as WorkerGlobalScope;\n  const message: MessageEvents = new MessageEvent('message', {\n    data: workerScope.name\n  });\n  workerScope.postMessage(message.data);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker that listens for errors using the `onerror` property of `WorkerGlobalScope`. When an error occurs, the worker should send the error details (e.g., message and stack trace) to the main thread via the `data` property of `MessageEvents`.",
    "input": "",
    "output": "import {WorkerGlobalScope, MessageEvents} from '@kit.ArkTS';\n\nexport class ErrorHandlingWorker {\n  private workerScope: WorkerGlobalScope;\n\n  constructor(workerScope: WorkerGlobalScope) {\n    this.workerScope = workerScope;\n    this.setupErrorListener();\n  }\n\n  private setupErrorListener(): void {\n    this.workerScope.onerror = (event: ErrorEvent) => {\n      const errorDetails = {\n        message: event.message,\n        stack: event.error?.stack\n      };\n      this.workerScope.postMessage(errorDetails);\n    };\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where the main thread sends a message to a worker using `MessageEvents.data`, and the worker processes the message, appends its `name` property (from `WorkerGlobalScope`) to the received data, and sends the modified message back to the main thread using `MessageEvents.data` again.",
    "input": "",
    "output": "import {WorkerGlobalScope, MessageEvents} from '@kit.ArkTS';\n\nexport function setupWorkerCommunication(worker: WorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvents) => {\n    const receivedData = event.data;\n    const modifiedData = {\n      ...receivedData,\n      workerName: worker.name\n    };\n    worker.postMessage(modifiedData);\n  };\n}\n\nexport function sendMessageToWorker(worker: WorkerGlobalScope, message: object): void {\n  worker.postMessage(message);\n}\n\nexport function handleWorkerResponse(callback: (data: object) => void): (event: MessageEvents) => void {\n  return (event: MessageEvents) => {\n    callback(event.data);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to run a computationally intensive task in the background with `Priority.HIGH`, and then uses `PostMessageOptions.transfer` to send the result back to the main thread with ownership transfer.",
    "input": "",
    "output": "import {taskpool, PostMessageOptions} from '@kit.ArkTS';\n\nexport function executeIntensiveTask(): void {\n  const task = () => {\n    // Simulate a computationally intensive task\n    let sum = 0;\n    for (let i = 0; i < 100000000; i++) {\n      sum += i;\n    }\n    const buffer = new ArrayBuffer(8);\n    const view = new Int32Array(buffer);\n    view[0] = sum;\n    return buffer;\n  };\n\n  taskpool.execute(task, { priority: taskpool.Priority.HIGH }).then((result: ArrayBuffer) => {\n    const options: PostMessageOptions = {\n      transfer: [result]\n    };\n    // Assuming there's a way to post message back to main thread\n    // This part is conceptual as actual implementation depends on context\n    postMessage(result, options);\n  }).catch((error: Error) => {\n    console.error(`Task execution failed: ${error.message}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that schedules a delayed task using `taskpool.executeDelayed` with a callback function (`CallbackFunction`), and upon completion, uses `PostMessageOptions.transfer` to send the task's output to another thread for further processing.",
    "input": "",
    "output": "import {taskpool, PostMessageOptions} from '@kit.ArkTS';\n\nexport function scheduleDelayedTask(callback: taskpool.CallbackFunction<ArrayBuffer>, delay: number, transferBuffer: ArrayBuffer): void {\n  const task = taskpool.executeDelayed(callback, delay);\n  task.then((result: ArrayBuffer) => {\n    const options: PostMessageOptions = {\n      transfer: [result]\n    };\n    // Assuming there's a target thread to post the message to\n    // For example: targetThread.postMessage(result, options);\n    // Note: The actual target thread implementation is not provided in the question\n  }).catch((error: Error) => {\n    console.error(`Task execution failed: ${error.message}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that periodically executes a task using `taskpool.executePeriodically` with a specified interval, and after each execution, uses `PostMessageOptions.transfer` to accumulate and transfer intermediate results to the main thread for real-time updates.",
    "input": "",
    "output": "import {taskpool, PostMessageOptions} from '@kit.ArkTS';\n\nexport function executePeriodicTask(\n  task: () => ArrayBuffer,\n  interval: number,\n  onUpdate: (result: ArrayBuffer) => void\n): number {\n  const options: PostMessageOptions = {\n    transfer: []\n  };\n\n  const periodicTask = taskpool.executePeriodically(\n    () => {\n      const result = task();\n      options.transfer = [result];\n      return result;\n    },\n    interval,\n    options\n  );\n\n  periodicTask.then((value: ArrayBuffer) => {\n    onUpdate(value);\n  }).catch((error: Error) => {\n    console.error(`Periodic task error: ${error.message}`);\n  });\n\n  return periodicTask.getId();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send a data object to a worker thread, and then uses the `onmessage` property of `ThreadWorkerGlobalScope` in the worker thread to receive and process the data. The processed result should be sent back to the main thread using `postMessageWithSharedSendable` of `ThreadWorkerGlobalScope`, and the main thread should use the `onmessage` property of `DedicatedWorkerGlobalScope` to receive and display the result.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendDataToWorker(worker: DedicatedWorkerGlobalScope, data: object): void {\n  worker.postMessage(data);\n}\n\nexport function setupWorkerListener(worker: DedicatedWorkerGlobalScope, callback: (data: object) => void): void {\n  worker.onmessage = (event: MessageEvent) => {\n    callback(event.data);\n  };\n}\n\nexport function processDataInWorker(workerScope: ThreadWorkerGlobalScope): void {\n  workerScope.onmessage = (event: MessageEvent) => {\n    const processedData = { ...event.data, processed: true };\n    workerScope.postMessageWithSharedSendable(processedData);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that uses the `callGlobalCallObjectMethod` of `ThreadWorkerGlobalScope` to invoke a global function in the main thread, passing a shared object. The main thread should modify the object and send it back to the worker thread using the `postMessage` method of `DedicatedWorkerGlobalScope`. The worker thread should then use the `onmessage` property of `ThreadWorkerGlobalScope` to receive the modified object and log its contents.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createWorkerThread(): void {\n  const worker: ThreadWorkerGlobalScope = new ThreadWorkerGlobalScope('script/worker.ts');\n\n  worker.onmessage = (event: MessageEvent): void => {\n    const modifiedObject = event.data;\n    console.log('Modified object received in worker:', modifiedObject);\n    worker.close();\n  };\n\n  const sharedObject = { key: 'initial value' };\n  worker.callGlobalCallObjectMethod('modifyObject', sharedObject);\n}\n\nexport function modifyObject(obj: Record<string, string>): void {\n  obj.key = 'modified value';\n  const workerScope: DedicatedWorkerGlobalScope = self as unknown as DedicatedWorkerGlobalScope;\n  workerScope.postMessage(obj);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task where the main thread uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send a large dataset to a worker thread. The worker thread should use the `close` method of `ThreadWorkerGlobalScope` to terminate itself after processing the dataset and sending the result back to the main thread using `postMessageWithSharedSendable`. The main thread should use the `onmessage` property of `DedicatedWorkerGlobalScope` to receive the result and the `onmessageerror` property to handle any errors during the process.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorker() {\n  const worker = new ThreadWorkerGlobalScope('scripts/worker.js');\n\n  worker.onmessage = (event: MessageEvent) => {\n    console.log('Received result from worker:', event.data);\n    worker.terminate();\n  };\n\n  worker.onmessageerror = (error: ErrorEvent) => {\n    console.error('Error in worker communication:', error.message);\n    worker.terminate();\n  };\n\n  const largeDataset = Array(10000).fill(0).map((_, index) => index);\n  worker.postMessage(largeDataset);\n}\n\nexport function workerScript() {\n  const self = new ThreadWorkerGlobalScope('self');\n\n  self.onmessage = (event: MessageEvent) => {\n    const data = event.data;\n    const processedData = data.map((item: number) => item * 2);\n    self.postMessageWithSharedSendable(processedData);\n    self.close();\n  };\n\n  self.onmessageerror = (error: ErrorEvent) => {\n    console.error('Error in worker processing:', error.message);\n    self.close();\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `Event` object with a specific `type` and `timeStamp`, then passes this event to a `MessageEvent` constructor to create a message event with the event's details stored in the `data` property. The function should return the message event with the combined information.",
    "input": "",
    "output": "import {Event, MessageEvent} from '@kit.ArkTS';\n\nexport function createMessageEvent(type: string, timeStamp: number): MessageEvent<Event> {\n  const event = new Event(type);\n  event.timeStamp = timeStamp;\n  return new MessageEvent(type, { data: event });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that listens for an `Event` with a specific `type`, extracts its `timeStamp`, and uses this timestamp to create a `MessageEvent` where the `data` property contains a formatted string combining the event type and timestamp (e.g., 'Event: type at timestamp').",
    "input": "",
    "output": "import {Event, MessageEvent} from '@kit.ArkTS';\n\nexport function createMessageEventFromEvent(event: Event): MessageEvent<string> {\n  const formattedData = `Event: ${event.type} at ${event.timeStamp}`;\n  return new MessageEvent(event.type, { data: formattedData });\n}\n\nexport function listenForEventAndCreateMessage(\n  target: EventTarget,\n  eventType: string,\n  callback: (messageEvent: MessageEvent<string>) => void\n): void {\n  target.addEventListener(eventType, (event: Event) => {\n    const messageEvent = createMessageEventFromEvent(event);\n    callback(messageEvent);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes an array of `Event` objects, filters them based on their `type`, and then creates a `MessageEvent` for each filtered event where the `data` property contains the event's `timeStamp` and type in a structured format (e.g., JSON). Return an array of these message events.",
    "input": "",
    "output": "import {Event, MessageEvent} from '@kit.ArkTS';\n\nexport function filterAndCreateMessageEvents(events: Event[], filterType: string): MessageEvent<{timeStamp: number, type: string}>[] {\n  const filteredEvents = events.filter((event) => event.type === filterType);\n  return filteredEvents.map((event) => {\n    const messageData = {\n      timeStamp: event.timeStamp,\n      type: event.type\n    };\n    return new MessageEvent(filterType, {data: messageData});\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a buffer from a string with 'utf-8' encoding, then uses `TreeMap.set` to store the buffer's byte length (obtained via `buffer.byteLength`) as a value associated with a given key in a TreeMap. Finally, use `TreeMap.get` to retrieve and return the stored byte length.",
    "input": "",
    "output": "import {buffer, TreeMap} from '@kit.ArkTS';\n\nexport function storeAndRetrieveByteLength(key: string, str: string): number | undefined {\n  const buf = buffer.from(str, 'utf-8');\n  const byteLength = buffer.byteLength(buf);\n  const treeMap = new TreeMap<string, number>();\n  treeMap.set(key, byteLength);\n  return treeMap.get(key);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `TreeMap.entries` to iterate over all key-value pairs in a TreeMap, then for each value (assumed to be a string), uses `buffer.from` to convert it to a buffer with 'utf-16le' encoding. Use `buffer.transcode` to convert each buffer to 'utf-8' encoding, then store the transcoded buffers back in the TreeMap using `TreeMap.replace`. Return the updated TreeMap.",
    "input": "",
    "output": "import {buffer, TreeMap} from '@kit.ArkTS';\n\nexport function transcodeTreeMapValues(originalMap: TreeMap<number, string>): TreeMap<number, string> {\n  const entries = originalMap.entries();\n  let entry = entries.next();\n  while (!entry.done) {\n    const [key, value] = entry.value;\n    const utf16Buffer = buffer.from(value, 'utf-16le');\n    const utf8Buffer = buffer.transcode(utf16Buffer, 'utf-16le', 'utf-8');\n    const transcodedValue = utf8Buffer.toString('utf-8');\n    originalMap.replace(key, transcodedValue);\n    entry = entries.next();\n  }\n  return originalMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.concat` to merge multiple buffers into one, then uses `TreeMap.setAll` to store each byte (as a key) and its corresponding ASCII character (as a value) in a TreeMap. Use `TreeMap.getFirstKey` and `TreeMap.getLastKey` to return the first and last ASCII characters in the merged buffer.",
    "input": "",
    "output": "import {buffer, TreeMap} from '@kit.ArkTS';\n\nexport function mergeAndStoreBuffers(buffers: buffer[]): {firstChar: string, lastChar: string} {\n  const mergedBuffer = buffer.concat(buffers);\n  const charMap = new TreeMap<number, string>();\n\n  for (let i = 0; i < mergedBuffer.byteLength; i++) {\n    const byte = mergedBuffer[i];\n    charMap.set(byte, String.fromCharCode(byte));\n  }\n\n  const firstKey = charMap.getFirstKey();\n  const lastKey = charMap.getLastKey();\n  \n  return {\n    firstChar: charMap.get(firstKey) || '',\n    lastChar: charMap.get(lastKey) || ''\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a custom event listener using `EventTarget.addEventListener` to listen for a 'message' event, and upon receiving the event, extracts the event data using `MessageEvent.data` to process and log the received message.",
    "input": "",
    "output": "import {MessageEvent, EventTarget} from '@kit.ArkTS';\n\nexport function setupMessageEventListener(eventTarget: EventTarget): void {\n  eventTarget.addEventListener('message', (event: MessageEvent<string>) => {\n    const messageData: string = event.data;\n    console.log(`Received message: ${messageData}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that dispatches a custom message event using `EventTarget.dispatchEvent` with a `MessageEvent` containing some data, and then removes the event listener using `EventTarget.removeEventListener` after the event has been processed.",
    "input": "",
    "output": "import {MessageEvent, EventTarget} from '@kit.ArkTS';\n\nexport function dispatchAndRemoveEvent(): void {\n  const eventTarget = new EventTarget();\n  const eventData = { message: 'Hello, World!' };\n  \n  const eventListener = (event: MessageEvent<{ message: string }>) => {\n    console.log(event.data.message);\n    eventTarget.removeEventListener('customEvent', eventListener);\n  };\n  \n  eventTarget.addEventListener('customEvent', eventListener);\n  \n  const messageEvent = new MessageEvent('customEvent', {\n    data: eventData\n  });\n  \n  eventTarget.dispatchEvent(messageEvent);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that sets up multiple event listeners using `EventTarget.addEventListener` for different event types, processes the incoming `MessageEvent.data` from each event, and then removes all listeners at once using `EventTarget.removeAllListener` when a specific condition is met.",
    "input": "",
    "output": "import {MessageEvent, EventTarget} from '@kit.ArkTS';\n\nexport function setupEventListeners(eventTarget: EventTarget, conditionCallback: () => boolean): void {\n  const messageHandler = (event: MessageEvent<string>) => {\n    console.log(`MessageEvent data: ${event.data}`);\n    if (conditionCallback()) {\n      eventTarget.removeAllListener();\n    }\n  };\n\n  const errorHandler = (event: MessageEvent<string>) => {\n    console.error(`ErrorEvent data: ${event.data}`);\n    if (conditionCallback()) {\n      eventTarget.removeAllListener();\n    }\n  };\n\n  eventTarget.addEventListener('message', messageHandler);\n  eventTarget.addEventListener('error', errorHandler);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addAll` method of `LightWeightSet` to merge two sets of employee IDs, then passes the merged set to a worker thread using the `worker` API to perform a time-consuming operation (e.g., sorting or filtering) on the data. The worker should return the processed data back to the main thread.",
    "input": "",
    "output": "import {LightWeightSet, worker} from '@kit.ArkTS';\n\nexport function mergeAndProcessEmployeeIds(set1: LightWeightSet<number>, set2: LightWeightSet<number>): void {\n  const mergedSet = new LightWeightSet<number>();\n  mergedSet.addAll(set1);\n  mergedSet.addAll(set2);\n\n  const workerInstance = new worker.ThreadWorker('scripts/worker.js');\n\n  workerInstance.onmessage = (message: worker.MessageEvents): void => {\n    console.log('Processed data from worker:', message.data);\n    workerInstance.terminate();\n  };\n\n  workerInstance.onerror = (error: worker.ErrorEvent): void => {\n    console.error('Worker error:', error.message);\n    workerInstance.terminate();\n  };\n\n  workerInstance.postMessage(mergedSet.toArray());\n}\n\n// worker.js content (for reference, not part of the output)\n/*\nimport {worker} from '@kit.ArkTS';\n\nconst workerPort = worker.workerPort;\n\nworkerPort.onmessage = (message: worker.MessageEvents): void => {\n  const data = message.data as number[];\n  // Perform time-consuming operation (e.g., sorting)\n  const processedData = data.sort((a, b) => a - b);\n  workerPort.postMessage(processedData);\n};\n*/\n",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `LightWeightSet` with values using the `add` method, then uses the `Symbol.iterator` method to iterate over the set and pass each value to a worker thread (using the `worker` API) for parallel processing (e.g., calculating a hash). Collect all results from the worker threads and store them in a new `LightWeightSet`.",
    "input": "",
    "output": "import {LightWeightSet, worker} from '@kit.ArkTS';\n\nexport function processWithWorkerThreads(): void {\n  const inputSet = new LightWeightSet<number>();\n  inputSet.add(1);\n  inputSet.add(2);\n  inputSet.add(3);\n\n  const resultSet = new LightWeightSet<string>();\n  const workerScript = `\n    self.onmessage = (e) => {\n      const value = e.data;\n      // Example processing: calculate a simple hash (for demonstration)\n      const hash = value.toString().split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n      self.postMessage(hash.toString());\n    };\n  `;\n\n  const workerPromises: Promise<string>[] = [];\n  for (const value of inputSet) {\n    const workerInstance = new worker.ThreadWorker(workerScript);\n    const promise = new Promise<string>((resolve) => {\n      workerInstance.onmessage = (e) => {\n        resolve(e.data);\n        workerInstance.terminate();\n      };\n      workerInstance.postMessage(value);\n    });\n    workerPromises.push(promise);\n  }\n\n  Promise.all(workerPromises).then((results) => {\n    results.forEach((result) => {\n      resultSet.add(result);\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a worker thread (using the `worker` API) generates a large dataset, which is then passed to the main thread and stored in a `LightWeightSet` using the `addAll` method. The main thread should then use the `forEach` method of `LightWeightSet` to process each item in the set (e.g., logging or validation).",
    "input": "",
    "output": "import {LightWeightSet, worker} from '@kit.ArkTS';\n\nexport function generateDataInWorker(): void {\n  const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n  \n  workerInstance.onmessage = (message: worker.MessageEvents): void => {\n    const data: number[] = message.data;\n    const lightWeightSet = new LightWeightSet<number>();\n    lightWeightSet.addAll(data);\n    \n    lightWeightSet.forEach((value: number): void => {\n      console.log(`Processing value: ${value}`);\n    });\n    \n    workerInstance.terminate();\n  };\n  \n  workerInstance.postMessage('generate');\n}\n\nexport class Worker {\n  constructor() {\n    worker.parentPort.onmessage = (message: worker.MessageEvents): void => {\n      if (message.data === 'generate') {\n        const largeDataset: number[] = this.generateLargeDataset();\n        worker.parentPort.postMessage(largeDataset);\n      }\n    };\n  }\n  \n  private generateLargeDataset(): number[] {\n    const dataset: number[] = [];\n    for (let i = 0; i < 1000; i++) {\n      dataset.push(i);\n    }\n    return dataset;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then transfers all elements from the `Stack` to a `Vector` (from @kit.ArkTS) using the `pop` method of `Stack` and the `add` method of `Vector`. Finally, use the `sort` method of `Vector` to arrange the numbers in ascending order.",
    "input": "",
    "output": "import {Stack, Vector} from '@kit.ArkTS';\n\nexport function transferAndSortNumbers(numbers: number[]): Vector<number> {\n  const stack = new Stack<number>();\n  const vector = new Vector<number>();\n\n  // Push numbers into the stack\n  for (const num of numbers) {\n    stack.push(num);\n  }\n\n  // Transfer elements from stack to vector\n  while (!stack.isEmpty()) {\n    const poppedValue = stack.pop();\n    if (poppedValue !== undefined) {\n      vector.add(poppedValue);\n    }\n  }\n\n  // Sort the vector in ascending order\n  vector.sort((a: number, b: number) => a - b);\n\n  return vector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks if a `Stack` (from @kit.ArkTS) is empty using the `isEmpty` method, and if it is not, transfers all its elements to a `Vector` (from @kit.ArkTS) using the `pop` method of `Stack` and the `insert` method of `Vector` at index 0 (to reverse the order). Then, use the `getLastElement` method of `Vector` to return the last element (originally the first element of the `Stack`).",
    "input": "",
    "output": "import {Stack, Vector} from '@kit.ArkTS';\n\nexport function transferAndGetLastElement(stack: Stack<number>): number | undefined {\n  const vector = new Vector<number>();\n  \n  while (!stack.isEmpty()) {\n    const element = stack.pop();\n    if (element !== undefined) {\n      vector.insert(0, element);\n    }\n  }\n  \n  return vector.getLastElement();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the top element without removing it, and if it matches a given value, transfers all elements from the `Stack` to a `Vector` (from @kit.ArkTS) using the `pop` method of `Stack` and the `copyToArray` method of `Vector`. Finally, use the `trimToCurrentLength` method of `Vector` to optimize its capacity.",
    "input": "",
    "output": "import {Stack, Vector} from '@kit.ArkTS';\n\nexport function transferStackToVectorIfTopMatches(stack: Stack<number>, value: number): Vector<number> {\n  const vector = new Vector<number>();\n  if (!stack.isEmpty() && stack.peek() === value) {\n    while (!stack.isEmpty()) {\n      const element = stack.pop();\n      vector.add(element);\n    }\n    vector.trimToCurrentLength();\n  }\n  return vector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a large array buffer to a worker thread, and then uses the `transfer` property of `PostMessageOptions` to transfer ownership of the buffer to optimize performance. The worker thread should then use the `onmessage` property of `ThreadWorkerGlobalScope` to receive and process the transferred data.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport function sendLargeArrayBufferToWorker(worker: ThreadWorkerGlobalScope, buffer: ArrayBuffer): void {\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  worker.postMessage(buffer, options);\n}\n\nexport function setupWorkerMessageHandler(worker: ThreadWorkerGlobalScope, callback: (data: ArrayBuffer) => void): void {\n  worker.onmessage = (event: MessageEvent<ArrayBuffer>) => {\n    callback(event.data);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that uses the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope` to send a shared object to the main thread, and then uses the `onmessageerror` property of `ThreadWorkerGlobalScope` in the main thread to handle any potential errors during the message transfer. The main thread should also use the `transfer` property of `PostMessageOptions` to manage shared resources efficiently.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\n// Worker thread implementation\nexport function workerThreadCode(workerScope: ThreadWorkerGlobalScope): void {\n  const sharedBuffer = new ArrayBuffer(8);\n  const sharedArray = new Int32Array(sharedBuffer);\n  sharedArray[0] = 42;\n\n  try {\n    workerScope.postMessageWithSharedSendable({\n      message: 'Shared data',\n      buffer: sharedBuffer\n    });\n  } catch (error) {\n    console.error('Error in worker thread:', error);\n  }\n}\n\n// Main thread implementation\nexport class MainThread {\n  private worker: ThreadWorkerGlobalScope;\n\n  constructor(worker: ThreadWorkerGlobalScope) {\n    this.worker = worker;\n    this.setupMessageHandlers();\n  }\n\n  private setupMessageHandlers(): void {\n    this.worker.onmessage = (event: MessageEvent) => {\n      console.log('Received message from worker:', event.data);\n    };\n\n    this.worker.onmessageerror = (error: ErrorEvent) => {\n      console.error('Message error from worker:', error);\n    };\n  }\n\n  public sendMessageToWorker(): void {\n    const transferBuffer = new ArrayBuffer(8);\n    const options: PostMessageOptions = {\n      transfer: [transferBuffer]\n    };\n\n    this.worker.postMessage({\n      message: 'Main thread data',\n      buffer: transferBuffer\n    }, options);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a worker thread uses the `callGlobalCallObjectMethod` method of `ThreadWorkerGlobalScope` to invoke a global method, and then uses the `postMessage` method to send the result back to the main thread. The main thread should use the `onmessage` property of `ThreadWorkerGlobalScope` to receive the result and the `close` method to terminate the worker thread after processing is complete.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport function setupWorker(workerScope: ThreadWorkerGlobalScope): void {\n  workerScope.onmessage = (message: string): void => {\n    const result = workerScope.callGlobalCallObjectMethod('globalMethod', message);\n    const options: PostMessageOptions = { transfer: [] };\n    workerScope.postMessage(result, options);\n    workerScope.close();\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a list of employee IDs (keys) and their corresponding names (values). Then, pass this `PlainArray` to a worker thread using the `worker` API to process the data (e.g., filter out inactive employees) and return the filtered list back to the main thread. The main thread should then use the `getValueAt` method of `PlainArray` to retrieve and display the filtered names.",
    "input": "",
    "output": "import {PlainArray, worker} from '@kit.ArkTS';\n\nexport function setupEmployeeData(): PlainArray<string> {\n  const employees = new PlainArray<string>();\n  employees.add(1, 'Alice');\n  employees.add(2, 'Bob');\n  employees.add(3, 'Charlie');\n  employees.add(4, 'David');\n  return employees;\n}\n\nexport function createWorker(): worker.ThreadWorker {\n  return new worker.ThreadWorker('entry/ets/workers/EmployeeWorker.js');\n}\n\nexport function sendDataToWorker(workerInstance: worker.ThreadWorker, employees: PlainArray<string>): void {\n  workerInstance.postMessage(employees);\n}\n\nexport function handleWorkerResponse(workerInstance: worker.ThreadWorker, callback: (filteredEmployees: PlainArray<string>) => void): void {\n  workerInstance.onmessage = (message: worker.MessageEvents): void => {\n    const filteredEmployees = message.data as PlainArray<string>;\n    callback(filteredEmployees);\n  };\n}\n\nexport function displayFilteredEmployees(filteredEmployees: PlainArray<string>): void {\n  for (let i = 0; i < filteredEmployees.length; i++) {\n    const name = filteredEmployees.getValueAt(i);\n    console.log(`Employee: ${name}`);\n  }\n}\n\n// EmployeeWorker.js content (to be placed in entry/ets/workers/EmployeeWorker.js)\n/*\nimport {worker} from '@kit.ArkTS';\n\nconst workerPort = worker.workerPort;\n\nworkerPort.onmessage = (message: worker.MessageEvents): void => {\n  const employees = message.data as PlainArray<string>;\n  const filteredEmployees = new PlainArray<string>();\n  \n  for (let i = 0; i < employees.length; i++) {\n    const id = employees.getKeyAt(i);\n    const name = employees.getValueAt(i);\n    \n    // Example filter: exclude employee with ID 2 (Bob)\n    if (id !== 2) {\n      filteredEmployees.add(id, name);\n    }\n  }\n  \n  workerPort.postMessage(filteredEmployees);\n};\n*/\n",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `PlainArray` with product IDs and prices using the `add` method. Then, spawn a worker thread using the `worker` API to calculate the total price of all products by iterating through the `PlainArray` (using `getValueAt`). The worker should return the total price to the main thread, which then uses the `toString` method of `PlainArray` to log the original array and the calculated total.",
    "input": "",
    "output": "import {PlainArray, worker} from '@kit.ArkTS';\n\nexport function initializePlainArray(): PlainArray<number, number> {\n  const plainArray = new PlainArray<number, number>();\n  plainArray.add(1, 100);\n  plainArray.add(2, 200);\n  plainArray.add(3, 300);\n  return plainArray;\n}\n\nexport function calculateTotalPrice(plainArray: PlainArray<number, number>): number {\n  let total = 0;\n  for (let i = 0; i < plainArray.length; i++) {\n    total += plainArray.getValueAt(i);\n  }\n  return total;\n}\n\nexport function spawnWorker(plainArray: PlainArray<number, number>): void {\n  const workerInstance = new worker.ThreadWorker('entry/ets/workers/worker.ts');\n  workerInstance.postMessage(plainArray);\n  workerInstance.onmessage = (message: worker.MessageEvents): void => {\n    console.log(`PlainArray: ${plainArray.toString()}`);\n    console.log(`Total Price: ${message.data}`);\n    workerInstance.terminate();\n  };\n}\n\n// worker.ts content (should be in a separate file)\n// import {PlainArray} from '@kit.ArkTS';\n// const workerPort = worker.workerPort;\n// workerPort.onmessage = (message: worker.MessageEvents): void => {\n//   const plainArray: PlainArray<number, number> = message.data;\n//   let total = 0;\n//   for (let i = 0; i < plainArray.length; i++) {\n//     total += plainArray.getValueAt(i);\n//   }\n//   workerPort.postMessage(total);\n// };",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `PlainArray` to iterate over a list of task IDs and their priorities. For each task, spawn a worker thread (using the `worker` API) to simulate processing the task based on its priority. The main thread should use the `removeAt` method of `PlainArray` to remove completed tasks and log the remaining tasks using the `length` property.",
    "input": "",
    "output": "import {PlainArray, worker} from '@kit.ArkTS';\n\nexport function processTasksWithWorkers(taskArray: PlainArray<number, string>): void {\n  taskArray.forEach((value: string, key: number) => {\n    const workerInstance = new worker.ThreadWorker('entry/ets/workers/worker.ts');\n    workerInstance.postMessage({ taskId: key, priority: value });\n\n    workerInstance.onmessage = (message: worker.MessageEvents) => {\n      if (message.data === 'completed') {\n        const index = taskArray.getIndexOfKey(key);\n        if (index !== -1) {\n          taskArray.removeAt(index);\n          console.log(`Task ${key} completed. Remaining tasks: ${taskArray.length}`);\n        }\n      }\n      workerInstance.terminate();\n    };\n\n    workerInstance.onerror = (error: Error) => {\n      console.error(`Worker error for task ${key}:`, error);\n      workerInstance.terminate();\n    };\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` and `getFirst` methods of `LinkedList` to build a list of numbers, then passes the list to a worker thread using the `postMessage` method of `ThreadWorkerGlobalScope` to perform a parallel computation (e.g., sum or average) and return the result.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function buildListAndCompute(): void {\n  const list = new LinkedList<number>();\n  list.add(1);\n  list.add(2);\n  list.add(3);\n  list.add(4);\n  list.add(5);\n\n  const worker = new ThreadWorkerGlobalScope();\n  worker.onmessage = (message: {data: number}) => {\n    console.log(`Result from worker: ${message.data}`);\n    worker.close();\n  };\n\n  worker.postMessage({data: list});\n}\n\nexport function workerFunction(): void {\n  const workerScope = new ThreadWorkerGlobalScope();\n  workerScope.onmessage = (message: {data: LinkedList<number>}) => {\n    const list = message.data;\n    let sum = 0;\n    let count = 0;\n    for (const num of list) {\n      sum += num;\n      count++;\n    }\n    const average = sum / count;\n    workerScope.postMessage({data: average});\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that constructs a `LinkedList` of strings using the `addFirst` and `addLast` methods, then iterates over the list using the `[Symbol.iterator]` method and sends each string to a worker thread via `postMessageWithSharedSendable` of `ThreadWorkerGlobalScope` for processing (e.g., uppercase conversion). The worker should return the processed strings, which are then collected and logged.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function processLinkedListWithWorker() {\n  const list = new LinkedList<string>();\n  list.addFirst('first');\n  list.addLast('second');\n  list.addLast('third');\n\n  const worker = new ThreadWorkerGlobalScope('workers/worker.js');\n  const processedStrings: string[] = [];\n\n  worker.onmessage = (event: MessageEvent<string>) => {\n    processedStrings.push(event.data);\n    if (processedStrings.length === list.length) {\n      console.log('Processed strings:', processedStrings);\n      worker.close();\n    }\n  };\n\n  for (const item of list) {\n    worker.postMessageWithSharedSendable(item);\n  }\n}\n\nexport class WorkerScript {\n  static run() {\n    const workerScope = new ThreadWorkerGlobalScope('self');\n    workerScope.onmessage = (event: MessageEvent<string>) => {\n      const processed = event.data.toUpperCase();\n      workerScope.postMessage(processed);\n    };\n  }\n}\n\nWorkerScript.run();",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task where a `LinkedList` of objects is manipulated using the `removeByIndex` and `insert` methods, then the modified list is converted to an array using the `convertToArray` method and sent to a worker thread using `postMessage` of `ThreadWorkerGlobalScope`. The worker should validate the array (e.g., check for duplicates) and return the validation result, which is then handled by the `onmessage` property of the worker scope.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport class LinkedListHandler {\n  private linkedList: LinkedList<number>;\n\n  constructor() {\n    this.linkedList = new LinkedList<number>();\n  }\n\n  public addElements(elements: number[]): void {\n    for (const element of elements) {\n      this.linkedList.add(element);\n    }\n  }\n\n  public removeByIndex(index: number): void {\n    this.linkedList.removeByIndex(index);\n  }\n\n  public insert(index: number, element: number): void {\n    this.linkedList.insert(index, element);\n  }\n\n  public convertToArray(): number[] {\n    return this.linkedList.convertToArray();\n  }\n}\n\nexport function createWorker(): ThreadWorkerGlobalScope {\n  const worker = new ThreadWorkerGlobalScope();\n\n  worker.onmessage = (message: { data: number[] }): void => {\n    const array = message.data;\n    const hasDuplicates = new Set(array).size !== array.length;\n    worker.postMessage({ isValid: !hasDuplicates });\n  };\n\n  return worker;\n}\n\nexport function main(): void {\n  const handler = new LinkedListHandler();\n  handler.addElements([1, 2, 3, 4, 5]);\n  handler.removeByIndex(2);\n  handler.insert(2, 10);\n  const array = handler.convertToArray();\n\n  const worker = createWorker();\n  worker.postMessage(array);\n\n  worker.onmessage = (message: { data: { isValid: boolean } }): void => {\n    console.log(`Validation result: ${message.data.isValid}`);\n    worker.close();\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of `Event` objects (from @kit.ArkTS), then iterates through the stack using the `[Symbol.iterator]` method to filter and print only those events where the `timeStamp` property is greater than a given threshold.",
    "input": "",
    "output": "import {Event, Stack} from '@kit.ArkTS';\n\nexport function filterEventsByTimestamp(events: Event[], threshold: number): void {\n  const stack = new Stack<Event>();\n  \n  for (const event of events) {\n    stack.push(event);\n  }\n  \n  for (const event of stack) {\n    if (event.timeStamp > threshold) {\n      console.log(event);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that checks if a `Stack` (from @kit.ArkTS) is empty using the `isEmpty` method, and if not, it pops the top element using the `pop` method and creates a new `Event` (from @kit.ArkTS) with the popped value as the `type` property and the current timestamp as the `timeStamp` property.",
    "input": "",
    "output": "import {Event, Stack} from '@kit.ArkTS';\n\nexport function popAndCreateEvent(stack: Stack<number>): Event | undefined {\n  if (!stack.isEmpty()) {\n    const poppedValue = stack.pop();\n    const event: Event = {\n      type: poppedValue,\n      timeStamp: new Date().getTime()\n    };\n    return event;\n  }\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `Stack` (from @kit.ArkTS) to iterate over its elements and for each element, creates an `Event` (from @kit.ArkTS) where the `type` property is set to the stack element's value and the `timeStamp` property is set to the current time. The function should then return an array of these events.",
    "input": "",
    "output": "import {Event, Stack} from '@kit.ArkTS';\n\nexport function createEventsFromStack(stack: Stack<string>): Event[] {\n  const events: Event[] = [];\n  stack.forEach((element: string) => {\n    const event: Event = {\n      type: element,\n      timeStamp: new Date().getTime()\n    };\n    events.push(event);\n  });\n  return events;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `HashSet` to store a collection of unique URLs (from `url` API), then checks if a specific URL exists in the set using the `has` method of `HashSet`, and finally removes it using the `remove` method if found.",
    "input": "",
    "output": "import {url, HashSet} from '@kit.ArkTS';\n\nexport function manageUrlSet(urls: string[], targetUrl: string): boolean {\n  const urlSet = new HashSet<string>();\n  \n  urls.forEach((url) => {\n    urlSet.add(url);\n  });\n  \n  const hasUrl = urlSet.has(targetUrl);\n  \n  if (hasUrl) {\n    urlSet.remove(targetUrl);\n  }\n  \n  return hasUrl;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that iterates over a `HashSet` of URLs (from `url` API) using the `Symbol.iterator` method, filters out invalid URLs (based on a custom validation logic), and stores the valid URLs in a new `HashSet` using its `add` method.",
    "input": "",
    "output": "import {url, HashSet} from '@kit.ArkTS';\n\nexport function filterValidUrls(urlSet: HashSet<string>): HashSet<string> {\n  const validUrls = new HashSet<string>();\n  const iterator = urlSet[Symbol.iterator]();\n  let next = iterator.next();\n  while (!next.done) {\n    const currentUrl = next.value;\n    if (isValidUrl(currentUrl)) {\n      validUrls.add(currentUrl);\n    }\n    next = iterator.next();\n  }\n  return validUrls;\n}\n\nexport function isValidUrl(urlString: string): boolean {\n  try {\n    // Custom validation logic here\n    return urlString.startsWith('http://') || urlString.startsWith('https://');\n  } catch (e) {\n    return false;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes an array of URLs (from `url` API), converts it into a `HashSet` using the `constructor` and `add` methods to eliminate duplicates, and then returns the size of the set using the `length` property of `HashSet`.",
    "input": "",
    "output": "import {url, HashSet} from '@kit.ArkTS';\n\nexport function getUniqueUrlCount(urls: string[]): number {\n  const urlSet = new HashSet<string>();\n  urls.forEach((url) => {\n    urlSet.add(url);\n  });\n  return urlSet.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that processes a series of `MessageEvents` by extracting their `data` properties and stores the unique values in a `HashSet`. Use the `add` method of `HashSet` to ensure uniqueness and the `values` method to return the collected unique data as an array.",
    "input": "",
    "output": "import {MessageEvents, HashSet} from '@kit.ArkTS';\n\nexport function processMessageEvents(events: MessageEvents[]): string[] {\n  const uniqueData = new HashSet<string>();\n  for (const event of events) {\n    uniqueData.add(event.data);\n  }\n  return Array.from(uniqueData.values());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks if any `data` from a list of `MessageEvents` is missing in a `HashSet`. Use the `has` method of `HashSet` to verify presence and the `data` property of `MessageEvents` to access the values. Return the missing data as an array.",
    "input": "",
    "output": "import {MessageEvents, HashSet} from '@kit.ArkTS';\n\nexport function findMissingData(events: MessageEvents[], hashSet: HashSet<string>): string[] {\n  const missingData: string[] = [];\n  for (const event of events) {\n    if (!hashSet.has(event.data)) {\n      missingData.push(event.data);\n    }\n  }\n  return missingData;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that filters out duplicate `data` values from an array of `MessageEvents` by first adding them to a `HashSet` (using the `add` method) and then converting the `HashSet` back to an array (using the `values` method). Return the filtered array.",
    "input": "",
    "output": "import {MessageEvents, HashSet} from '@kit.ArkTS';\n\nexport function filterDuplicateMessages(messages: MessageEvents[]): MessageEvents[] {\n  const uniqueData = new HashSet<string>();\n  const filteredMessages: MessageEvents[] = [];\n\n  for (const message of messages) {\n    if (!uniqueData.has(message.data)) {\n      uniqueData.add(message.data);\n      filteredMessages.push(message);\n    }\n  }\n\n  return filteredMessages;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a DedicatedWorker and uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send a URL string to the worker. The worker should then use the `URL` API to parse the URL and return the hostname back to the main thread using the `onmessage` property of `DedicatedWorkerGlobalScope`.",
    "input": "",
    "output": "import {url, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createWorkerAndSendUrl(): void {\n  const worker: DedicatedWorkerGlobalScope = new DedicatedWorkerGlobalScope();\n  \n  worker.onmessage = (event: MessageEvent<string>): void => {\n    console.log(`Hostname received from worker: ${event.data}`);\n    worker.close();\n  };\n  \n  worker.onmessageerror = (): void => {\n    console.error('An error occurred while receiving message from worker');\n    worker.close();\n  };\n  \n  const urlString: string = 'https://www.example.com/path';\n  worker.postMessage(urlString);\n}\n\n// Worker script (to be executed in the worker context)\nexport function workerScript(): void {\n  const workerScope: DedicatedWorkerGlobalScope = self as DedicatedWorkerGlobalScope;\n  \n  workerScope.onmessage = (event: MessageEvent<string>): void => {\n    try {\n      const parsedUrl: URL = new URL(event.data);\n      const hostname: string = parsedUrl.hostname;\n      workerScope.postMessage(hostname);\n    } catch (error) {\n      console.error('Error parsing URL:', error);\n      workerScope.postMessage('');\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task where the main thread sends an array of URLs to a DedicatedWorker using the `postMessage` method of `DedicatedWorkerGlobalScope`. The worker should use the `URL` API to validate each URL, filter out invalid ones, and send the valid URLs back to the main thread using the `onmessage` property of `DedicatedWorkerGlobalScope`.",
    "input": "",
    "output": "import {url, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\n// Main thread code\nexport function sendUrlsToWorker(worker: DedicatedWorkerGlobalScope, urls: string[]): void {\n  worker.postMessage(urls);\n}\n\n// Worker thread code\nexport function setupWorker(workerScope: DedicatedWorkerGlobalScope): void {\n  workerScope.onmessage = (event: MessageEvent<string[]>) => {\n    const urls = event.data;\n    const validUrls: string[] = [];\n\n    for (const urlStr of urls) {\n      try {\n        new url.URL(urlStr);\n        validUrls.push(urlStr);\n      } catch (e) {\n        // URL is invalid, skip\n      }\n    }\n\n    workerScope.postMessage(validUrls);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function where the main thread sends a message to a DedicatedWorker using the `postMessage` method of `DedicatedWorkerGlobalScope`. The worker should process the message (e.g., converting it to uppercase) and then use the `close` method of `DedicatedWorkerGlobalScope` to terminate itself after sending the processed message back to the main thread via the `onmessage` property.",
    "input": "",
    "output": "import {url, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createWorker(): DedicatedWorkerGlobalScope {\n  const worker: DedicatedWorkerGlobalScope = new DedicatedWorkerGlobalScope();\n  \n  worker.onmessage = (event: MessageEvent<string>) => {\n    const processedMessage = event.data.toUpperCase();\n    worker.postMessage(processedMessage);\n    worker.close();\n  };\n  \n  return worker;\n}\n\nexport function sendMessageToWorker(worker: DedicatedWorkerGlobalScope, message: string): void {\n  worker.postMessage(message);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `getUidForName` method of `process` to retrieve the UID for a given process name, and then uses the `isAppUid` method of `process` to verify if the retrieved UID belongs to an application process. Return a boolean indicating the result.",
    "input": "",
    "output": "import {process} from '@kit.ArkTS';\n\nexport function isAppProcess(processName: string): boolean {\n  const uid = process.getUidForName(processName);\n  return process.isAppUid(uid);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getEnvironmentVar` method of `process` to fetch the value of a specified environment variable, and then passes this value to the `getThreadPriority` method of `process` to check the thread priority associated with the environment variable's value. Return the thread priority as an integer.",
    "input": "",
    "output": "import {process, process} from '@kit.ArkTS';\n\nexport function getThreadPriorityFromEnv(envVar: string): number {\n  const envValue = process.getEnvironmentVar(envVar);\n  return process.getThreadPriority(envValue);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `getStartRealtime` method of `process` to get the start time of the current process, and then uses the `uptime` method of `process` to calculate the elapsed time since the process started. Return the elapsed time in milliseconds.",
    "input": "",
    "output": "import {process} from '@kit.ArkTS';\n\nexport function getElapsedTime(): number {\n  const startTime: number = process.getStartRealtime();\n  const uptime: number = process.uptime() * 1000; // Convert seconds to milliseconds\n  const currentTime: number = startTime + uptime;\n  const elapsedTime: number = currentTime - startTime;\n  return elapsedTime;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a data object to a worker thread, and then uses the `data` property of `MessageEvents` to receive and process the response from the worker thread.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, MessageEvents} from '@kit.ArkTS';\n\nexport function sendDataToWorker(worker: ThreadWorkerGlobalScope, data: object): void {\n  worker.postMessage(data);\n}\n\nexport function setupWorkerResponseHandler(worker: ThreadWorkerGlobalScope, callback: (data: object) => void): void {\n  worker.onmessage = (event: MessageEvents) => {\n    callback(event.data);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that uses the `onmessage` property of `ThreadWorkerGlobalScope` to listen for incoming messages, processes the data using a custom function, and then uses the `postMessageWithSharedSendable` method to send the result back to the main thread, where the `data` property of `MessageEvents` is used to display the result.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, MessageEvents} from '@kit.ArkTS';\n\nexport function processData(data: string): string {\n  return `Processed: ${data}`;\n}\n\nexport const workerScope: ThreadWorkerGlobalScope = {\n  onmessage: (event: MessageEvents) => {\n    const processedData = processData(event.data);\n    workerScope.postMessageWithSharedSendable(processedData);\n  }\n};",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a communication loop between a main thread and a worker thread where the main thread uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a request, the worker thread uses the `onmessage` property to receive the request and the `postMessage` method to send a response, and the main thread uses the `data` property of `MessageEvents` to handle the response and then closes the worker thread using the `close` method of `ThreadWorkerGlobalScope`.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, MessageEvents} from '@kit.ArkTS';\n\nexport function createWorker(): ThreadWorkerGlobalScope {\n  const worker = new ThreadWorkerGlobalScope('script/worker.ts');\n  return worker;\n}\n\nexport function setupMainThreadCommunication(worker: ThreadWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvents) => {\n    const response = event.data;\n    console.log('Main thread received:', response);\n    worker.close();\n  };\n\n  const request = { message: 'Hello from main thread' };\n  worker.postMessage(request);\n}\n\nexport function setupWorkerThreadCommunication(worker: ThreadWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvents) => {\n    const request = event.data;\n    console.log('Worker thread received:', request);\n    const response = { message: 'Hello from worker thread' };\n    worker.postMessage(response);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `ArrayList` (from @kit.ArkTS) to collect a list of numbers, then passes this list to the `sort` method of `ArrayList` to sort the numbers in ascending order, and finally uses the `convertToArray` method to return the sorted array.",
    "input": "",
    "output": "import {ArrayList, stream} from '@kit.ArkTS';\n\nexport function sortNumbers(numbers: number[]): number[] {\n  const list = new ArrayList<number>();\n  for (const num of numbers) {\n    list.add(num);\n  }\n  list.sort((a, b) => a - b);\n  return list.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insert` method of `ArrayList` (from @kit.ArkTS) to build a list of strings, then uses the `forEach` method to iterate over the list and pass each string to a stream processing function (from @kit.ArkTS) that logs each string in uppercase.",
    "input": "",
    "output": "import {ArrayList, stream} from '@kit.ArkTS';\n\nexport function processStrings(): void {\n  const list: ArrayList<string> = new ArrayList();\n  list.insert(0, 'hello');\n  list.insert(1, 'world');\n  list.insert(2, 'arkts');\n\n  list.forEach((item: string) => {\n    const uppercaseStr = item.toUpperCase();\n    console.log(uppercaseStr);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `removeByRange` method of `ArrayList` (from @kit.ArkTS) to remove a subset of elements from a list, then uses the `trimToCurrentLength` method to optimize the list's capacity, and finally passes the trimmed list to a stream processing function (from @kit.ArkTS) that calculates and returns the sum of the remaining elements.",
    "input": "",
    "output": "import {ArrayList, stream} from '@kit.ArkTS';\n\nexport function processArrayList(list: ArrayList<number>, start: number, end: number): number {\n  list.removeByRange(start, end);\n  list.trimToCurrentLength();\n  \n  let sum = 0;\n  for (const item of list) {\n    sum += item;\n  }\n  \n  return sum;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a set of key-value pairs, then converts the values to an array using the `convertToArray` method of `ArrayList` and sorts them in ascending order using the `sort` method of `ArrayList`.",
    "input": "",
    "output": "import {PlainArray, ArrayList} from '@kit.ArkTS';\n\nexport function processAndSortKeyValuePairs(): number[] {\n  const plainArray = new PlainArray<number>();\n  plainArray.add(1, 10);\n  plainArray.add(2, 30);\n  plainArray.add(3, 20);\n  plainArray.add(4, 40);\n\n  const arrayList = new ArrayList<number>();\n  for (let i = 0; i < plainArray.length; i++) {\n    arrayList.add(plainArray.getValueAt(i));\n  }\n\n  const valuesArray = arrayList.convertToArray();\n  arrayList.sort((a: number, b: number) => a - b);\n\n  return arrayList.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getValueAt` method of `PlainArray` to retrieve values at even indices, then passes these values to the `insert` method of `ArrayList` to create a new list, and finally trims the list to its current length using the `trimToCurrentLength` method of `ArrayList`.",
    "input": "",
    "output": "import {PlainArray, ArrayList} from '@kit.ArkTS';\n\nexport function processEvenIndices(plainArray: PlainArray<number, any>, arrayList: ArrayList<any>): ArrayList<any> {\n  const newArrayList = new ArrayList<any>();\n  for (let i = 0; i < plainArray.length; i += 2) {\n    const value = plainArray.getValueAt(i);\n    if (value !== undefined) {\n      newArrayList.insert(newArrayList.length, value);\n    }\n  }\n  newArrayList.trimToCurrentLength();\n  return newArrayList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `removeRangeFrom` method of `PlainArray` to remove a subset of key-value pairs, then transfers the remaining values to an `ArrayList` using the `add` method of `ArrayList`, and checks for duplicates using the `getIndexOf` and `getLastIndexOf` methods of `ArrayList`.",
    "input": "",
    "output": "import {PlainArray, ArrayList} from '@kit.ArkTS';\n\nexport function processPlainArrayToArrayList(plainArray: PlainArray<number, string>, start: number, end: number): ArrayList<string> {\n  // Remove the range from the PlainArray\n  plainArray.removeRangeFrom(start, end);\n  \n  // Create a new ArrayList to store the remaining values\n  const arrayList = new ArrayList<string>();\n  \n  // Transfer remaining values from PlainArray to ArrayList\n  for (let i = 0; i < plainArray.length; i++) {\n    const value = plainArray.getValueAt(i);\n    if (value !== undefined) {\n      arrayList.add(value);\n    }\n  }\n  \n  // Check for duplicates in the ArrayList\n  for (let i = 0; i < arrayList.length; i++) {\n    const currentValue = arrayList.get(i);\n    const firstIndex = arrayList.getIndexOf(currentValue);\n    const lastIndex = arrayList.getLastIndexOf(currentValue);\n    \n    if (firstIndex !== lastIndex) {\n      console.log(`Duplicate value found: ${currentValue}`);\n    }\n  }\n  \n  return arrayList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `LightWeightMap` to iterate over key-value pairs, and for each pair, creates an `Event` object where the `type` property is set to the key and the `timeStamp` property is set to the value. Store all generated `Event` objects in an array and return it.",
    "input": "",
    "output": "import {Event, LightWeightMap} from '@kit.ArkTS';\n\nexport function createEventsFromMap(lightWeightMap: LightWeightMap<string, number>): Event[] {\n  const events: Event[] = [];\n  lightWeightMap.forEach((value: number, key: string) => {\n    const event: Event = new Event();\n    event.type = key;\n    event.timeStamp = value;\n    events.push(event);\n  });\n  return events;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that takes an array of `Event` objects and uses the `set` method of `LightWeightMap` to store each event's `type` as the key and `timeStamp` as the value. Then, use the `getIndexOfValue` method of `LightWeightMap` to find the index of the earliest timestamp (smallest value) and return the corresponding key.",
    "input": "",
    "output": "import {Event, LightWeightMap} from '@kit.ArkTS';\n\nexport function findEarliestEventType(events: Event[]): string | undefined {\n  const map = new LightWeightMap<string, number>();\n  \n  for (const event of events) {\n    map.set(event.type, event.timeStamp);\n  }\n  \n  if (map.length === 0) {\n    return undefined;\n  }\n  \n  let minIndex = 0;\n  let minValue = map.getValueAt(0);\n  \n  for (let i = 1; i < map.length; i++) {\n    const currentValue = map.getValueAt(i);\n    if (currentValue < minValue) {\n      minValue = currentValue;\n      minIndex = i;\n    }\n  }\n  \n  return map.getKeyAt(minIndex);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `entries` method of `LightWeightMap` to get an iterator of key-value pairs, and for each pair, checks if the value is greater than a given threshold using the `hasValue` method. If true, create an `Event` object with the `type` property set to the key and the `timeStamp` property set to the threshold value. Collect all such `Event` objects in an array and return it.",
    "input": "",
    "output": "import {Event, LightWeightMap} from '@kit.ArkTS';\n\nexport function getEventsAboveThreshold(map: LightWeightMap<number, number>, threshold: number): Event[] {\n  const events: Event[] = [];\n  const iterator = map.entries();\n  let entry = iterator.next();\n  while (!entry.done) {\n    const [key, value] = entry.value;\n    if (map.hasValue(value) && value > threshold) {\n      const event = new Event();\n      event.type = key.toString();\n      event.timeStamp = threshold;\n      events.push(event);\n    }\n    entry = iterator.next();\n  }\n  return events;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `convertToArray` method of `Vector` to transform a vector of numbers into an array, then passes this array to the `sort` method of `Vector` to sort the elements in ascending order. Finally, use the `toString` method of `Vector` to return the sorted elements as a string.",
    "input": "",
    "output": "import {stream, Vector} from '@kit.ArkTS';\n\nexport function sortVectorToString(vector: Vector<number>): string {\n  const array = vector.convertToArray();\n  vector.sort((a: number, b: number) => a - b);\n  return vector.toString();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `get` and `length` properties of `Vector` to iterate over its elements and filter out even numbers, then uses the `add` method of another `Vector` to store these filtered numbers. Return the new vector containing only even numbers.",
    "input": "",
    "output": "import {stream, Vector} from '@kit.ArkTS';\n\nexport function filterEvenNumbers(inputVector: Vector<number>): Vector<number> {\n  const evenNumbersVector = new Vector<number>();\n  \n  for (let i = 0; i < inputVector.length; i++) {\n    const element = inputVector.get(i);\n    if (element % 2 === 0) {\n      evenNumbersVector.add(element);\n    }\n  }\n  \n  return evenNumbersVector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses the `subVector` method of `Vector` to extract a subset of elements, then passes this subset to the `forEach` method of `Vector` to apply a transformation (e.g., squaring each element). Store the transformed elements in a new vector using the `add` method and return it.",
    "input": "",
    "output": "import {stream, Vector} from '@kit.ArkTS';\n\nexport function transformSubVector(vector: Vector<number>, start: number, end: number): Vector<number> {\n  const subVector = vector.subVector(start, end);\n  const transformedVector = new Vector<number>();\n  \n  subVector.forEach((element: number) => {\n    const transformedElement = element * element;\n    transformedVector.add(transformedElement);\n  });\n  \n  return transformedVector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `HashMap<string, number>` to retrieve all keys, then passes them to the `addAll` method of `ArrayList<string>` to store and sort the keys in alphabetical order using the `sort` method of `ArrayList`.",
    "input": "",
    "output": "import {HashMap, ArrayList} from '@kit.ArkTS';\n\nexport function sortHashMapKeys(map: HashMap<string, number>): ArrayList<string> {\n  const keys = map.keys();\n  const list = new ArrayList<string>();\n  list.addAll(keys);\n  list.sort();\n  return list;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `forEach` method of `ArrayList<number>` to iterate over a list of numbers, checks if each number exists as a value in a `HashMap<string, number>` using the `hasValue` method, and stores the matching numbers in a new `ArrayList<number>` using its `add` method.",
    "input": "",
    "output": "import {HashMap, ArrayList} from '@kit.ArkTS';\n\nexport function findMatchingNumbers(list: ArrayList<number>, map: HashMap<string, number>): ArrayList<number> {\n  const result = new ArrayList<number>();\n  list.forEach((value: number) => {\n    if (map.hasValue(value)) {\n      result.add(value);\n    }\n  });\n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `entries` method of `HashMap<string, string>` to retrieve key-value pairs, filters the pairs based on a condition using the `has` method of `ArrayList<string>` to check for specific keys, and then constructs a new `HashMap<string, string>` using the `set` method to store the filtered pairs.",
    "input": "",
    "output": "import {HashMap, ArrayList} from '@kit.ArkTS';\n\nexport function filterHashMapByKeys(originalMap: HashMap<string, string>, keysToFilter: ArrayList<string>): HashMap<string, string> {\n  const filteredMap = new HashMap<string, string>();\n  \n  for (const [key, value] of originalMap.entries()) {\n    if (keysToFilter.has(key)) {\n      filteredMap.set(key, value);\n    }\n  }\n  \n  return filteredMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` method of `Deque` to store a sequence of strings representing binary data, then converts each string to a buffer using the `from` method of `buffer` (with encoding 'utf-8'), and finally checks if all buffers are valid using the `isBuffer` method of `buffer`.",
    "input": "",
    "output": "import {Deque, buffer} from '@kit.ArkTS';\n\nexport function processBinaryStrings(strings: string[]): boolean {\n  const deque = new Deque<string>();\n  \n  // Insert each string to the front of the deque\n  for (const str of strings) {\n    deque.insertFront(str);\n  }\n  \n  // Convert each string in the deque to a buffer and check if all are valid\n  let allValid = true;\n  for (const str of deque) {\n    const buf = buffer.from(str, 'utf-8');\n    if (!buffer.isBuffer(buf)) {\n      allValid = false;\n      break;\n    }\n  }\n  \n  return allValid;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first allocates a buffer of size 10 using the `alloc` method of `buffer`, then inserts the buffer into a `Deque` using the `insertEnd` method, and later retrieves the last buffer from the `Deque` using the `getLast` method to verify its length using the `byteLength` method of `buffer`.",
    "input": "",
    "output": "import {Deque, buffer} from '@kit.ArkTS';\n\nexport function testDequeWithBuffer(): void {\n  const deque = new Deque<buffer.Buffer>();\n  const buf = buffer.alloc(10);\n  deque.insertEnd(buf);\n  const lastBuf = deque.getLast();\n  const length = buffer.byteLength(lastBuf);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes an array of strings, converts each string to a buffer using the `from` method of `buffer` (with encoding 'utf-8'), stores these buffers in a `Deque` using the `insertFront` method, and then iterates over the `Deque` using the `forEach` method to compare each buffer with a reference buffer using the `compare` method of `buffer`.",
    "input": "",
    "output": "import {Deque, buffer} from '@kit.ArkTS';\n\nexport function processStringArray(strings: string[], referenceString: string): void {\n  const deque = new Deque<buffer.Buffer>();\n  const referenceBuffer = buffer.from(referenceString, 'utf-8');\n\n  strings.forEach((str: string) => {\n    const strBuffer = buffer.from(str, 'utf-8');\n    deque.insertFront(strBuffer);\n  });\n\n  deque.forEach((buf: buffer.Buffer) => {\n    const comparisonResult = buffer.compare(buf, referenceBuffer);\n    console.log(`Comparison result: ${comparisonResult}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addAll` method of `LightWeightSet` to merge two sets of product IDs, then passes the merged set to the `TreeSet` constructor to create a sorted collection. Finally, use the `getFirstValue` and `getLastValue` methods of `TreeSet` to find the smallest and largest product IDs in the sorted set.",
    "input": "",
    "output": "import {LightWeightSet, TreeSet} from '@kit.ArkTS';\n\nexport function mergeAndSortProductIds(set1: LightWeightSet<number>, set2: LightWeightSet<number>): { smallest: number, largest: number } {\n  const mergedSet = new LightWeightSet<number>();\n  mergedSet.addAll(set1);\n  mergedSet.addAll(set2);\n  \n  const sortedSet = new TreeSet<number>(mergedSet);\n  const smallest = sortedSet.getFirstValue();\n  const largest = sortedSet.getLastValue();\n  \n  return { smallest, largest };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `values` method of `LightWeightSet` to extract all elements from a set of student scores, then pass these values to the `add` method of `TreeSet` to build a sorted collection. Use the `getLowerValue` and `getHigherValue` methods of `TreeSet` to find the nearest lower and higher scores relative to a given threshold score.",
    "input": "",
    "output": "import {LightWeightSet, TreeSet} from '@kit.ArkTS';\n\nexport function processStudentScores(studentScores: LightWeightSet<number>, threshold: number): {lower: number | undefined, higher: number | undefined} {\n  const treeSet = new TreeSet<number>();\n  const scoreValues = studentScores.values();\n  \n  for (const score of scoreValues) {\n    treeSet.add(score);\n  }\n  \n  const lower = treeSet.getLowerValue(threshold);\n  const higher = treeSet.getHigherValue(threshold);\n  \n  return {lower, higher};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `removeAt` method of `LightWeightSet` to delete elements at specific indices from a set of transaction IDs, then transfer the remaining elements to a `TreeSet` using its `constructor`. Use the `popFirst` and `popLast` methods of `TreeSet` to remove and return the smallest and largest transaction IDs from the sorted set.",
    "input": "",
    "output": "import {LightWeightSet, TreeSet} from '@kit.ArkTS';\n\nexport function processTransactionIDs(transactionIDs: LightWeightSet<number>, indicesToRemove: number[]): { smallest: number | undefined, largest: number | undefined } {\n  // Remove elements at specified indices\n  indicesToRemove.sort((a, b) => b - a); // Sort in descending order to avoid index shifting\n  for (const index of indicesToRemove) {\n    if (index >= 0 && index < transactionIDs.length) {\n      transactionIDs.removeAt(index);\n    }\n  }\n\n  // Transfer remaining elements to TreeSet\n  const treeSet = new TreeSet<number>();\n  for (let i = 0; i < transactionIDs.length; i++) {\n    const value = transactionIDs.getValueAt(i);\n    if (value !== undefined) {\n      treeSet.add(value);\n    }\n  }\n\n  // Pop smallest and largest values\n  const smallest = treeSet.popFirst();\n  const largest = treeSet.popLast();\n\n  return { smallest, largest };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses `util.generateRandomUUID()` to generate a random UUID, then uses `json.stringify()` to convert the UUID into a JSON string, and finally uses `util.getHash()` to compute the SHA-256 hash of the JSON string.",
    "input": "",
    "output": "import {util, json} from '@kit.ArkTS';\n\nexport function generateAndHashUUID(): string {\n  const uuid: string = util.generateRandomUUID();\n  const jsonString: string = json.stringify(uuid);\n  const hash: string = util.getHash(jsonString, 'SHA-256');\n  return hash;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `json.parse()` to parse a JSON string containing user data, then uses `util.format()` to format the parsed data into a readable string, and finally uses `util.printf()` to print the formatted string to the console.",
    "input": "",
    "output": "import {util, json} from '@kit.ArkTS';\n\nexport function parseAndFormatUserData(jsonString: string): void {\n  const parsedData = json.parse(jsonString);\n  const formattedString = util.format('User Data: %j', parsedData);\n  util.printf(formattedString);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses `util.promiseWrapper()` to wrap an asynchronous operation, then uses `json.has()` to check if the resolved result contains a specific property, and finally uses `util.errnoToString()` to convert any error code into a human-readable error message.",
    "input": "",
    "output": "import {util, json} from '@kit.ArkTS';\n\nexport async function checkPropertyInAsyncResult(asyncOperation: () => Promise<object>, property: string): Promise<string> {\n  try {\n    const wrappedOperation = util.promiseWrapper(asyncOperation);\n    const result = await wrappedOperation();\n    if (json.has(result, property)) {\n      return `Property '${property}' exists in the result.`;\n    } else {\n      return `Property '${property}' does not exist in the result.`;\n    }\n  } catch (error) {\n    if (typeof error === 'number') {\n      return util.errnoToString(error);\n    } else {\n      return 'An unknown error occurred.';\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates two `EventTarget` objects, `source` and `listener`. Use `source.addEventListener` to register a custom event listener on `source` that triggers a callback function. Then, use `listener.dispatchEvent` to dispatch a custom event from `listener`, which should be captured and processed by the callback function registered on `source`.",
    "input": "",
    "output": "import { EventTarget } from '@kit.ArkTS';\n\nexport function setupEventTargets(): void {\n  const source: EventTarget = new EventTarget();\n  const listener: EventTarget = new EventTarget();\n\n  const callback = (event: CustomEvent): void => {\n    console.log('Custom event captured:', event.type);\n  };\n\n  source.addEventListener('customEvent', callback);\n\n  const customEvent: CustomEvent = new CustomEvent('customEvent');\n  listener.dispatchEvent(customEvent);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `EventTarget.addEventListener` to register multiple event listeners on an `EventTarget` object, each with a unique event type. Then, use `EventTarget.dispatchEvent` to trigger all registered events in sequence, ensuring each listener's callback is executed. Finally, use `EventTarget.removeAllListener` to clean up all event listeners.",
    "input": "",
    "output": "import {EventTarget} from '@kit.ArkTS';\n\nexport function registerAndTriggerEvents(): void {\n  const eventTarget = new EventTarget();\n  \n  const eventTypes = ['click', 'mouseover', 'keydown'];\n  \n  eventTypes.forEach((eventType) => {\n    const listener = () => {\n      console.log(`Event ${eventType} triggered`);\n    };\n    eventTarget.addEventListener(eventType, listener);\n  });\n  \n  eventTypes.forEach((eventType) => {\n    const event = { type: eventType };\n    eventTarget.dispatchEvent(event);\n  });\n  \n  eventTarget.removeAllListener();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `EventTarget` object and uses `addEventListener` to register a one-time event listener (i.e., the listener removes itself after execution). Use `dispatchEvent` to trigger the event, and verify the listener is automatically removed by attempting to trigger the event again and confirming the callback is not executed. Use `removeEventListener` to manually remove the listener if needed.",
    "input": "",
    "output": "import {EventTarget} from '@kit.ArkTS';\n\nexport function testOneTimeEventListener(): void {\n  const eventTarget = new EventTarget();\n  let callbackCount = 0;\n\n  const listener = (): void => {\n    callbackCount++;\n    eventTarget.removeEventListener('test', listener);\n  };\n\n  eventTarget.addEventListener('test', listener);\n  eventTarget.dispatchEvent('test');\n  eventTarget.dispatchEvent('test');\n\n  if (callbackCount !== 1) {\n    throw new Error('One-time event listener did not work as expected');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a Buffer from a string with 'utf-8' encoding, then checks if the encoding is valid using `buffer.isEncoding`, and finally sends the Buffer data as part of a message using `MessageEvents.data`.",
    "input": "",
    "output": "import {buffer, MessageEvents} from '@kit.ArkTS';\n\nexport function processAndSendMessage(message: string): void {\n  const buf = buffer.from(message, 'utf-8');\n  const isValidEncoding = buffer.isEncoding('utf-8');\n  if (isValidEncoding) {\n    const messageEvent = new MessageEvents('data');\n    messageEvent.data = buf;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.alloc` to create a new Buffer of a specified size, fills it with data, then compares it with another Buffer using `buffer.compare`, and sends the comparison result (a number) via `MessageEvents.data`.",
    "input": "",
    "output": "import {buffer, MessageEvents} from '@kit.ArkTS';\n\nexport function compareBuffers(size: number, fillValue: number, otherBuffer: buffer.Buffer): MessageEvents {\n  const newBuffer = buffer.alloc(size, fillValue);\n  const comparisonResult = buffer.compare(newBuffer, otherBuffer);\n  const messageEvent = new MessageEvents('data');\n  messageEvent.data = comparisonResult;\n  return messageEvent;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that concatenates multiple Buffers using `buffer.concat`, checks if the result is a valid Buffer using `buffer.isBuffer`, and then sends the concatenated Buffer's byte length (obtained via `buffer.byteLength`) through `MessageEvents.data`.",
    "input": "",
    "output": "import {buffer, MessageEvents} from '@kit.ArkTS';\n\nexport function concatenateAndSendBuffers(buffers: buffer.Buffer[]): void {\n  const concatenatedBuffer = buffer.concat(buffers);\n  if (buffer.isBuffer(concatenatedBuffer)) {\n    const byteLength = buffer.byteLength(concatenatedBuffer);\n    const messageEvent = new MessageEvents('data');\n    messageEvent.data = byteLength;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` to store a sequence of environment variable names, then iterates over the stack using `forEach` to retrieve each variable's value using `process.getEnvironmentVar`, and finally checks if the process is 64-bit using `process.is64Bit` before returning the collected values.",
    "input": "",
    "output": "import {process, Stack} from '@kit.ArkTS';\n\nexport function getEnvironmentValues(envVars: string[]): string[] {\n  const stack = new Stack<string>();\n  envVars.forEach(envVar => stack.push(envVar));\n  \n  const values: string[] = [];\n  stack.forEach(envVar => {\n    const value = process.getEnvironmentVar(envVar);\n    if (value !== undefined) {\n      values.push(value);\n    }\n  });\n  \n  const is64Bit = process.is64Bit();\n  console.log(`Process is 64-bit: ${is64Bit}`);\n  \n  return values;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes `process.getStartRealtime` to measure the time elapsed since process start, then uses `Stack.peek` to check the top element of a stack containing timestamps, and if the stack is not empty (verified with `Stack.isEmpty`), calculates the time difference between the current realtime and the top timestamp.",
    "input": "",
    "output": "import {process, Stack} from '@kit.ArkTS';\n\nexport function calculateTimeDifference(stack: Stack<number>): number | undefined {\n  const currentTime = process.getStartRealtime();\n  if (!stack.isEmpty()) {\n    const topTimestamp = stack.peek();\n    return currentTime - topTimestamp;\n  }\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first checks if the current process is isolated using `process.isIsolatedProcess`, then creates a `Stack` instance and pushes a series of thread priorities (obtained via `process.getThreadPriority`) into it, and finally iterates through the stack using `[Symbol.iterator]` to log each priority level.",
    "input": "",
    "output": "import {process, Stack} from '@kit.ArkTS';\n\nexport function checkIsolatedAndLogThreadPriorities(): void {\n  const isIsolated: boolean = process.isIsolatedProcess();\n  console.log(`Is process isolated: ${isIsolated}`);\n\n  const threadPriorityStack: Stack<number> = new Stack<number>();\n  const priorities: number[] = [\n    process.getThreadPriority(process.pid),\n    process.getThreadPriority(process.pid),\n    process.getThreadPriority(process.pid)\n  ];\n\n  priorities.forEach((priority: number) => {\n    threadPriorityStack.push(priority);\n  });\n\n  for (const priority of threadPriorityStack) {\n    console.log(`Thread priority: ${priority}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a DedicatedWorkerGlobalScope and uses its `postMessage` method to send data to the worker. Then, use the `addEventListener` method of EventTarget to listen for a response message from the worker and log the received data.",
    "input": "",
    "output": "import {EventTarget, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function createWorkerAndCommunicate(): void {\n  const workerGlobalScope: DedicatedWorkerGlobalScope = new DedicatedWorkerGlobalScope();\n  \n  workerGlobalScope.addEventListener('message', (event: MessageEvent) => {\n    console.log('Received message from worker:', event.data);\n  });\n  \n  workerGlobalScope.postMessage('Hello from main thread!');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a DedicatedWorkerGlobalScope is initialized, and its `onmessage` property is set to handle incoming messages. Use the `dispatchEvent` method of EventTarget to trigger a custom event in the main thread when a specific message is received from the worker.",
    "input": "",
    "output": "import {EventTarget, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function initializeWorker(): void {\n  const workerGlobalScope = new DedicatedWorkerGlobalScope();\n  \n  workerGlobalScope.onmessage = (event: MessageEvent): void => {\n    if (event.data === 'triggerEvent') {\n      const eventTarget = new EventTarget();\n      const customEvent = new CustomEvent('customEvent', { detail: 'Event triggered from worker' });\n      eventTarget.dispatchEvent(customEvent);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `removeEventListener` method of EventTarget to stop listening for messages from a DedicatedWorkerGlobalScope after a certain condition is met (e.g., after receiving a specific message). Then, use the `close` method of DedicatedWorkerGlobalScope to terminate the worker.",
    "input": "",
    "output": "import {EventTarget, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function handleWorkerMessages(workerScope: DedicatedWorkerGlobalScope, targetMessage: string): void {\n  const messageHandler = (event: MessageEvent): void => {\n    if (event.data === targetMessage) {\n      workerScope.removeEventListener('message', messageHandler);\n      workerScope.close();\n    }\n  };\n  workerScope.addEventListener('message', messageHandler);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirstKey` method of `TreeMap` to retrieve the smallest key, then passes this key to the `get` method of `TreeMap` to fetch its corresponding value, and finally checks if this value exists in another `TreeMap` instance using the `hasValue` method.",
    "input": "",
    "output": "import {url, TreeMap} from '@kit.ArkTS';\n\nexport function getAndCheckValue(map1: TreeMap<number, string>, map2: TreeMap<number, string>): boolean {\n  const firstKey = map1.getFirstKey();\n  if (firstKey === undefined) {\n    return false;\n  }\n  const value = map1.get(firstKey);\n  if (value === undefined) {\n    return false;\n  }\n  return map2.hasValue(value);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that iterates over the keys of a `TreeMap` using the `Symbol.iterator` method, collects all keys greater than a given threshold using the `getHigherKey` method, and then uses the `setAll` method to add these keys with their corresponding values to a new `TreeMap` instance.",
    "input": "",
    "output": "import {url, TreeMap} from '@kit.ArkTS';\n\nexport function filterAndSetHigherKeys<K, V>(originalMap: TreeMap<K, V>, threshold: K): TreeMap<K, V> {\n  const newMap = new TreeMap<K, V>();\n  const higherKeys: K[] = [];\n  \n  for (const key of originalMap[Symbol.iterator]()) {\n    const higherKey = originalMap.getHigherKey(key);\n    if (higherKey !== undefined && higherKey > threshold) {\n      higherKeys.push(higherKey);\n    }\n  }\n  \n  for (const key of higherKeys) {\n    const value = originalMap.get(key);\n    if (value !== undefined) {\n      newMap.set(key, value);\n    }\n  }\n  \n  return newMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first checks if a `TreeMap` is empty using the `isEmpty` method, and if not, retrieves the last key using the `getLastKey` method, then uses the `remove` method to delete this key-value pair, and finally passes the removed value to the `set` method of another `TreeMap` instance to store it under a new key.",
    "input": "",
    "output": "import {url, TreeMap} from '@kit.ArkTS';\n\nexport function transferLastKeyValue(sourceMap: TreeMap<string, string>, targetMap: TreeMap<string, string>, newKey: string): void {\n  if (!sourceMap.isEmpty()) {\n    const lastKey = sourceMap.getLastKey();\n    if (lastKey !== undefined) {\n      const value = sourceMap.get(lastKey);\n      if (value !== undefined) {\n        sourceMap.remove(lastKey);\n        targetMap.set(newKey, value);\n      }\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a buffer from a string, then uses `buffer.byteLength` to get its size, and finally inserts this size into a `Deque` using `Deque.insertFront`. The function should return the Deque.",
    "input": "",
    "output": "import {buffer, Deque} from '@kit.ArkTS';\n\nexport function createBufferAndGetSize(inputString: string): Deque<number> {\n  const buf = buffer.from(inputString);\n  const size = buffer.byteLength(buf);\n  const deque = new Deque<number>();\n  deque.insertFront(size);\n  return deque;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes an array of strings, converts each string to a buffer using `buffer.from`, compares them pairwise using `buffer.compare`, and stores the comparison results (0, 1, or -1) in a `Deque` using `Deque.insertEnd`. The function should return the Deque with the comparison results.",
    "input": "",
    "output": "import {buffer, Deque} from '@kit.ArkTS';\n\nexport function compareStringsToDeque(strings: string[]): Deque<number> {\n  const resultDeque = new Deque<number>();\n  \n  for (let i = 0; i < strings.length - 1; i++) {\n    const buf1 = buffer.from(strings[i]);\n    const buf2 = buffer.from(strings[i + 1]);\n    const comparisonResult = buffer.compare(buf1, buf2);\n    resultDeque.insertEnd(comparisonResult);\n  }\n  \n  return resultDeque;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that reads the first and last elements of a `Deque` using `Deque.getFirst` and `Deque.getLast`, converts these elements to buffers using `buffer.from`, concatenates them using `buffer.concat`, and checks if the result is a valid buffer using `buffer.isBuffer`. The function should return the concatenated buffer if valid, or `null` otherwise.",
    "input": "",
    "output": "import {buffer, Deque} from '@kit.ArkTS';\n\nexport function concatFirstAndLast(deque: Deque<number | string>): buffer.Buffer | null {\n    if (deque.length === 0) {\n        return null;\n    }\n\n    const firstElement = deque.getFirst();\n    const lastElement = deque.getLast();\n\n    if (firstElement === undefined || lastElement === undefined) {\n        return null;\n    }\n\n    const firstBuffer = buffer.from(firstElement);\n    const lastBuffer = buffer.from(lastElement);\n\n    const concatenatedBuffer = buffer.concat([firstBuffer, lastBuffer]);\n\n    if (buffer.isBuffer(concatenatedBuffer)) {\n        return concatenatedBuffer;\n    }\n\n    return null;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Vector` to collect a sequence of numbers, then passes the resulting `Vector` to the `convertToArray` method to create an array, and finally uses the `sort` method of `ArrayList` to sort the array in ascending order.",
    "input": "",
    "output": "import {Vector, ArrayList} from '@kit.ArkTS';\n\nexport function collectSortNumbers(numbers: number[]): number[] {\n  const vector = new Vector<number>();\n  for (const num of numbers) {\n    vector.add(num);\n  }\n  const array = vector.convertToArray();\n  const arrayList = new ArrayList(array);\n  arrayList.sort((a: number, b: number) => a - b);\n  return arrayList.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirstElement` method of `Vector` to retrieve the first element of a given `Vector`, then checks if this element exists in an `ArrayList` using the `has` method. The function should return `true` if the element is found in the `ArrayList`, otherwise `false`.",
    "input": "",
    "output": "import {Vector, ArrayList} from '@kit.ArkTS';\n\nexport function checkFirstElementInArrayList(vector: Vector<number>, arrayList: ArrayList<number>): boolean {\n  const firstElement = vector.getFirstElement();\n  return arrayList.has(firstElement);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `subVector` method of `Vector` to extract a sub-vector from a given `Vector` based on a specified range, then converts this sub-vector to an `ArrayList` using the `convertToArray` method, and finally uses the `replaceAllElements` method of `ArrayList` to replace all elements in the `ArrayList` with their squared values.",
    "input": "",
    "output": "import {Vector, ArrayList} from '@kit.ArkTS';\n\nexport function processSubVectorToSquaredArrayList(vector: Vector<number>, start: number, end: number): ArrayList<number> {\n  const subVec = vector.subVector(start, end);\n  const arrayList = subVec.convertToArray();\n  arrayList.replaceAllElements((value: number) => value * value);\n  return arrayList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a Worker using `WorkerOptions` with a specified `name` and `shared` property, then listens for an event from the Worker using the `type` and `timeStamp` properties of `Event` to log the event details.",
    "input": "",
    "output": "import {WorkerOptions, Event} from '@kit.ArkTS';\n\nexport function createAndListenWorker(name: string, shared: boolean): void {\n  const options: WorkerOptions = {\n    name: name,\n    shared: shared\n  };\n\n  const worker = new Worker('worker.js', options);\n\n  worker.onmessage = (event: Event) => {\n    console.log(`Event type: ${event.type}, timestamp: ${event.timeStamp}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a Worker with `WorkerOptions` where the `name` property is dynamically set based on an event's `type` received from another Worker, and then uses the `timeStamp` from the `Event` to measure the Worker's startup time.",
    "input": "",
    "output": "import {WorkerOptions, Event} from '@kit.ArkTS';\n\nexport function initializeWorkerWithEvent(event: Event): void {\n  const workerOptions: WorkerOptions = {\n    name: event.type\n  };\n  \n  const startTime = event.timeStamp;\n  const worker = new Worker('worker.ts', workerOptions);\n  \n  worker.onmessage = (e: MessageEvent) => {\n    const endTime = performance.now();\n    const startupTime = endTime - startTime;\n    console.log(`Worker startup time: ${startupTime}ms`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that configures a Worker using `WorkerOptions` with `shared` set to true, then dispatches a custom event using `Event` where the `type` is derived from the Worker's `name` property and the `timeStamp` is used to track the event's creation time.",
    "input": "",
    "output": "import {WorkerOptions, Event} from '@kit.ArkTS';\n\nexport function configureWorkerAndDispatchEvent(workerName: string): void {\n  const options: WorkerOptions = {\n    name: workerName,\n    shared: true\n  };\n\n  const eventType = options.name;\n  const event = new Event(eventType);\n  event.timeStamp = Date.now();\n\n  dispatchEvent(event);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirstKey` method of `TreeMap` to retrieve the earliest key, then creates an `Event` object with the retrieved key as the `timeStamp` and a custom type (e.g., 'firstKeyEvent'). The function must then log the `type` and `timeStamp` properties of the generated `Event`.",
    "input": "",
    "output": "import {Event, TreeMap} from '@kit.ArkTS';\n\nexport function logFirstKeyEvent(treeMap: TreeMap<number, unknown>): void {\n  const firstKey = treeMap.getFirstKey();\n  const event: Event = {\n    timeStamp: firstKey,\n    type: 'firstKeyEvent'\n  };\n  console.log(`Event type: ${event.type}, timeStamp: ${event.timeStamp}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that iterates over a `TreeMap` using the `[Symbol.iterator]` method, collects all keys, and for each key, creates an `Event` object where the `timeStamp` is the key and the `type` is 'treeMapIteration'. The function must then use the `forEach` method of `TreeMap` to log each `Event`'s `type` and `timeStamp` properties.",
    "input": "",
    "output": "import {Event, TreeMap} from '@kit.ArkTS';\n\nexport function iterateAndLogTreeMap(treeMap: TreeMap<number, unknown>): void {\n  const events: Event[] = [];\n  \n  for (const key of treeMap[Symbol.iterator]()) {\n    const event: Event = {\n      timeStamp: key,\n      type: 'treeMapIteration'\n    };\n    events.push(event);\n  }\n  \n  treeMap.forEach((value, key) => {\n    const event: Event = {\n      timeStamp: key,\n      type: 'treeMapIteration'\n    };\n    console.log(`Event type: ${event.type}, timeStamp: ${event.timeStamp}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that checks if a `TreeMap` is empty using the `isEmpty` method. If the `TreeMap` is not empty, the function must use the `getLastKey` method to retrieve the last key, create an `Event` object with the last key as the `timeStamp` and 'lastKeyEvent' as the `type`, and then log the `Event`'s properties. If the `TreeMap` is empty, the function should create an `Event` with `timeStamp` 0 and `type` 'emptyTreeMap' and log it.",
    "input": "",
    "output": "import {Event, TreeMap} from '@kit.ArkTS';\n\nexport function checkTreeMapEmpty(treeMap: TreeMap<number, unknown>): void {\n  if (treeMap.isEmpty()) {\n    const event: Event = { timeStamp: 0, type: 'emptyTreeMap' };\n    console.log(`Event: timeStamp=${event.timeStamp}, type=${event.type}`);\n  } else {\n    const lastKey = treeMap.getLastKey();\n    const event: Event = { timeStamp: lastKey, type: 'lastKeyEvent' };\n    console.log(`Event: timeStamp=${event.timeStamp}, type=${event.type}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `generateRandomUUID` method of `util` to create a random UUID, then passes this UUID to the `parseUUID` method of `util` to convert it into a human-readable string format, and finally uses the `printf` method of `util` to log the parsed UUID string.",
    "input": "",
    "output": "import {worker, util} from '@kit.ArkTS';\n\nexport function logParsedUUID(): void {\n  const randomUUID: string = util.generateRandomUUID();\n  const parsedUUID: string = util.parseUUID(randomUUID);\n  util.printf('%s', parsedUUID);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `callbackWrapper` method of `util` to wrap a callback function, then passes the wrapped callback to a hypothetical worker thread (using `worker` API) for execution, and finally uses the `promisify` method of `util` to convert the worker's callback-based result into a promise for easier handling.",
    "input": "",
    "output": "import {worker, util} from '@kit.ArkTS';\n\nexport function executeWithWorker(callback: (err: Error | null, result: string) => void): Promise<string> {\n  const wrappedCallback = util.callbackWrapper(callback);\n  \n  // Hypothetical worker thread execution\n  // Note: Since worker API details are not provided, this is a placeholder\n  // Assuming worker.postMessage and worker.onmessage are available\n  worker.postMessage({ callback: wrappedCallback });\n  \n  worker.onmessage = (event: { data: { err: Error | null, result: string } }) => {\n    wrappedCallback(event.data.err, event.data.result);\n  };\n  \n  return util.promisify(wrappedCallback)();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `getHash` method of `util` to compute the hash of a given string, then uses the `errnoToString` method of `util` to check for any errors during the hash computation, and finally passes the resulting hash to a worker thread (using `worker` API) for further processing or validation.",
    "input": "",
    "output": "import {worker, util} from '@kit.ArkTS';\n\nexport function processStringWithHash(input: string): void {\n  const hashResult = util.getHash(input);\n  const errorString = util.errnoToString(hashResult.errno);\n  \n  if (errorString !== 'Success') {\n    throw new Error(`Hash computation failed: ${errorString}`);\n  }\n  \n  const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n  workerInstance.postMessage(hashResult.hash);\n  \n  workerInstance.onmessage = (message: worker.MessageEvents): void => {\n    console.log(`Worker response: ${message.data}`);\n    workerInstance.terminate();\n  };\n  \n  workerInstance.onerror = (error: worker.ErrorEvent): void => {\n    console.error(`Worker error: ${error.message}`);\n    workerInstance.terminate();\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.getEnvironmentVar` to retrieve environment variables and stores them as key-value pairs in a `HashMap` using the `set` method. Then, use `HashMap.keys` to list all environment variable names and `process.getUidForName` to fetch the UID for each name, storing the results back in the HashMap with `replace`.",
    "input": "",
    "output": "import {process, HashMap} from '@kit.ArkTS';\n\nexport function processEnvironmentVars(): HashMap<string, number> {\n  const envVars = new HashMap<string, string>();\n  const envKeys = Object.keys(process.getEnvironmentVar());\n  \n  envKeys.forEach((key: string) => {\n    const value = process.getEnvironmentVar(key);\n    if (value !== undefined) {\n      envVars.set(key, value);\n    }\n  });\n  \n  const result = new HashMap<string, number>();\n  const keys = envVars.keys();\n  \n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const uid = process.getUidForName(key);\n    result.set(key, uid);\n  }\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if the current process is 64-bit using `process.is64Bit`, then initializes a `HashMap` to store system information. Use `process.getSystemConfig` to populate the HashMap with configuration details via `setAll`, and finally, use `HashMap.values` to extract and return all system configuration values as an array.",
    "input": "",
    "output": "import {process, HashMap} from '@kit.ArkTS';\n\nexport function getSystemConfigValues(): Array<string> {\n  const is64Bit = process.is64Bit();\n  const systemInfoMap = new HashMap<string, string>();\n  const systemConfig = process.getSystemConfig();\n  systemInfoMap.setAll(systemConfig);\n  return systemInfoMap.values();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that measures the uptime of the current process using `process.uptime` and stores it in a `HashMap` with the key 'uptime' using `set`. Then, use `process.getPastCpuTime` to get CPU usage data and store it in the same HashMap with the key 'cpu_time'. Finally, use `HashMap.length` to verify the number of entries and return the HashMap.",
    "input": "",
    "output": "import {process, HashMap} from '@kit.ArkTS';\n\nexport function measureProcessStats(): HashMap<string, number> {\n  const statsMap = new HashMap<string, number>();\n  \n  const uptime = process.uptime();\n  statsMap.set('uptime', uptime);\n  \n  const cpuTime = process.getPastCpuTime();\n  statsMap.set('cpu_time', cpuTime);\n  \n  const entriesCount = statsMap.length;\n  return statsMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a list of 5 random UUIDs, stores them in a `Vector` using the `add` method, and then sorts the UUIDs alphabetically using the `sort` method of `Vector`.",
    "input": "",
    "output": "import {Vector, util} from '@kit.ArkTS';\n\nexport function generateAndSortUUIDs(): Vector<string> {\n  const uuidVector = new Vector<string>();\n  for (let i = 0; i < 5; i++) {\n    uuidVector.add(util.generateRandomUUID());\n  }\n  uuidVector.sort();\n  return uuidVector;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getHash` method of `util` to compute the hash of each string in a `Vector` (populated using the `add` method), then filters out any hashes that start with '0x' using the `removeByIndex` method of `Vector`, and finally converts the remaining hashes to an array using the `convertToArray` method.",
    "input": "",
    "output": "import {Vector, util} from '@kit.ArkTS';\n\nexport function filterAndConvertHashes(strings: string[]): string[] {\n  const vector = new Vector<string>();\n  \n  // Populate the Vector with strings\n  strings.forEach(str => {\n    vector.add(str);\n  });\n  \n  // Compute hashes and filter out those starting with '0x'\n  for (let i = vector.length - 1; i >= 0; i--) {\n    const hash = util.getHash(vector.get(i));\n    if (hash.startsWith('0x')) {\n      vector.removeByIndex(i);\n    }\n  }\n  \n  // Convert the remaining hashes to an array\n  return vector.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `Vector` to iterate over a list of error codes, passes each code to the `errnoToString` method of `util` to get the corresponding error message, and then builds a new `Vector` (using the `add` method) containing only the error messages that include the word 'invalid'.",
    "input": "",
    "output": "import {Vector, util} from '@kit.ArkTS';\n\nexport function filterInvalidErrorMessages(errorCodes: Vector<number>): Vector<string> {\n  const invalidMessages: Vector<string> = new Vector();\n  errorCodes.forEach((code: number) => {\n    const message: string = util.errnoToString(code);\n    if (message.includes('invalid')) {\n      invalidMessages.add(message);\n    }\n  });\n  return invalidMessages;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to run a computationally intensive task in the background with `Priority.HIGH`, and then uses `MessageEvents.data` to receive and process the result of the task once it completes. The function should handle errors by logging them if the task fails.",
    "input": "",
    "output": "import {taskpool, MessageEvents} from '@kit.ArkTS';\n\nexport function runIntensiveTask(): void {\n  const task = () => {\n    // Simulate a computationally intensive task\n    let result = 0;\n    for (let i = 0; i < 100000000; i++) {\n      result += i;\n    }\n    return result;\n  };\n\n  const messageEvents = new MessageEvents();\n  messageEvents.on('data', (event: { data: number }) => {\n    console.log(`Task completed with result: ${event.data}`);\n  });\n\n  messageEvents.on('error', (error: Error) => {\n    console.error(`Task failed with error: ${error.message}`);\n  });\n\n  taskpool.execute(task, Priority.HIGH).then((result: number) => {\n    messageEvents.emit('data', { data: result });\n  }).catch((error: Error) => {\n    messageEvents.emit('error', error);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that schedules a delayed task using `taskpool.executeDelayed` and monitors its state. If the task is still in `State.RUNNING` after a certain timeout, cancel it using `taskpool.cancel` and send a cancellation message via `MessageEvents.data` to notify the user.",
    "input": "",
    "output": "import {taskpool, MessageEvents} from '@kit.ArkTS';\n\nexport function scheduleDelayedTask(task: taskpool.CallbackFunction, delay: number, timeout: number): void {\n  const taskId = taskpool.executeDelayed(task, delay);\n  \n  setTimeout(() => {\n    const state = taskpool.getTaskPoolInfo(taskId).state;\n    if (state === taskpool.State.RUNNING) {\n      taskpool.cancel(taskId);\n      const messageEvent = new MessageEvents('cancel');\n      messageEvent.data = 'Task was canceled due to timeout';\n    }\n  }, timeout);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a periodic task using `taskpool.executePeriodically` that generates data every 5 seconds. Use `MessageEvents.data` to emit the generated data to a listener, and provide a way to stop the periodic task using `taskpool.terminateTask` when a stop condition is met.",
    "input": "",
    "output": "import {taskpool, MessageEvents} from '@kit.ArkTS';\n\nexport class PeriodicDataGenerator {\n  private taskId: number | undefined;\n  private messageEvents: MessageEvents = new MessageEvents();\n  private stopCondition: boolean = false;\n\n  public startGeneratingData(): void {\n    this.taskId = taskpool.executePeriodically(() => {\n      if (this.stopCondition) {\n        taskpool.terminateTask(this.taskId as number);\n        return;\n      }\n      const generatedData: string = `Data generated at ${new Date().toISOString()}`;\n      this.messageEvents.data = generatedData;\n    }, 5000);\n  }\n\n  public setStopCondition(condition: boolean): void {\n    this.stopCondition = condition;\n  }\n\n  public getMessageEvents(): MessageEvents {\n    return this.messageEvents;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.getUidForName` to retrieve the UID for a given process name, then checks if the process is isolated using `process.isIsolatedProcess`, and finally sends the result as a message using `MessageEvents.data` to another part of the application.",
    "input": "",
    "output": "import {process, MessageEvents} from '@kit.ArkTS';\n\nexport function checkProcessIsolation(processName: string, messageEvent: MessageEvents): void {\n  const uid = process.getUidForName(processName);\n  const isIsolated = process.isIsolatedProcess(uid);\n  messageEvent.data = isIsolated;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that calculates the uptime of a process using `process.uptime`, checks if the process is running in a 64-bit environment using `process.is64Bit`, and then sends both pieces of information as a structured message via `MessageEvents.data`.",
    "input": "",
    "output": "import {process, MessageEvents} from '@kit.ArkTS';\n\nexport function getProcessInfoAndSend(): void {\n  const uptime: number = process.uptime();\n  const is64Bit: boolean = process.is64Bit();\n  \n  const message: MessageEvents = new MessageEvents('processInfo');\n  message.data = {\n    uptime: uptime,\n    is64Bit: is64Bit\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that retrieves the CPU time of a process using `process.getPastCpuTime`, checks the thread priority using `process.getThreadPriority`, and then combines these metrics into a performance report sent through `MessageEvents.data`.",
    "input": "",
    "output": "import {process, MessageEvents} from '@kit.ArkTS';\n\nexport function getProcessPerformanceReport(): void {\n  const cpuTime: number = process.getPastCpuTime();\n  const threadPriority: number = process.getThreadPriority(process.pid);\n  \n  const performanceReport: { cpuTime: number, threadPriority: number } = {\n    cpuTime,\n    threadPriority\n  };\n  \n  const messageEvent: MessageEvents = new MessageEvents('performanceReport');\n  messageEvent.data = JSON.stringify(performanceReport);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `parse` method of `xml` to parse an XML string containing a list of URIs, then extracts the URIs using `getElementsByTagName`, and finally validates each URI using the `isValid` method of `uri` to filter out invalid URIs.",
    "input": "",
    "output": "import {xml, uri} from '@kit.ArkTS';\n\nexport function filterValidURIs(xmlString: string): string[] {\n  const parsedXml = xml.parse(xmlString);\n  const uriElements = parsedXml.getElementsByTagName('uri');\n  const validURIs: string[] = [];\n\n  for (let i = 0; i < uriElements.length; i++) {\n    const uriText = uriElements[i].textContent;\n    if (uriText && uri.isValid(uriText)) {\n      validURIs.push(uriText);\n    }\n  }\n\n  return validURIs;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `createElement` method of `xml` to generate an XML element representing a URI resource, then uses the `toString` method of `uri` to convert the URI into a string, and finally appends this string as a child node to the XML element using `appendChild` from `xml`.",
    "input": "",
    "output": "import {xml, uri} from '@kit.ArkTS';\n\nexport function createUriXmlElement(): xml.Element {\n  const xmlElement: xml.Element = xml.createElement('Resource');\n  const uriInstance: uri.URI = new uri.URI('https://example.com/resource');\n  const uriString: string = uriInstance.toString();\n  const uriNode: xml.Node = xml.createTextNode(uriString);\n  xmlElement.appendChild(uriNode);\n  return xmlElement;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that reads an XML file using the `parse` method of `xml`, extracts attribute values using `getAttribute`, converts these values into URIs using the `parse` method of `uri`, and then checks if each URI is absolute using the `isAbsolute` method of `uri`.",
    "input": "",
    "output": "import {xml, uri} from '@kit.ArkTS';\n\nexport function processXmlFile(xmlContent: string): boolean[] {\n  const parser = new xml.XmlPullParser(xmlContent);\n  const uriResults: boolean[] = [];\n\n  while (parser.next() !== xml.EventType.END_DOCUMENT) {\n    if (parser.getEventType() === xml.EventType.START_TAG) {\n      const attributeCount = parser.getAttributeCount();\n      for (let i = 0; i < attributeCount; i++) {\n        const attributeValue = parser.getAttributeValue(i);\n        if (attributeValue) {\n          const parsedUri = uri.parse(attributeValue);\n          uriResults.push(parsedUri.isAbsolute());\n        }\n      }\n    }\n  }\n  return uriResults;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `from` method of `buffer` to create a buffer from a string, then uses the `convertToArray` method of `Vector` to convert the buffer into a byte array, and finally uses the `sort` method of `Vector` to sort the byte array in ascending order.",
    "input": "",
    "output": "import {buffer, Vector} from '@kit.ArkTS';\n\nexport function sortBufferBytes(inputString: string): number[] {\n  const buf = buffer.from(inputString);\n  const vec = new Vector<number>();\n  const byteArray = vec.convertToArray(buf);\n  vec.sort((a, b) => a - b);\n  return byteArray;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `alloc` method of `buffer` to create a buffer of a specified size, then uses the `add` method of `Vector` to populate the buffer with random bytes, and finally uses the `byteLength` method of `buffer` to verify the buffer's length matches the expected size.",
    "input": "",
    "output": "import {buffer, Vector} from '@kit.ArkTS';\n\nexport function createAndVerifyBuffer(size: number): boolean {\n  const buf = buffer.alloc(size);\n  const vec = new Vector<number>();\n  \n  for (let i = 0; i < size; i++) {\n    vec.add(Math.floor(Math.random() * 256));\n  }\n  \n  for (let i = 0; i < size; i++) {\n    buf[i] = vec.get(i);\n  }\n  \n  return buffer.byteLength(buf) === size;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `concat` method of `buffer` to merge multiple buffers into one, then uses the `subVector` method of `Vector` to extract a specific range of bytes from the merged buffer, and finally uses the `toString` method of `Vector` to convert the extracted bytes into a string for display.",
    "input": "",
    "output": "import {buffer, Vector} from '@kit.ArkTS';\n\nexport function mergeAndExtractToString(buffers: buffer[], start: number, end: number): string {\n  const mergedBuffer = buffer.concat(buffers);\n  const vector = new Vector<number>();\n  for (let i = 0; i < mergedBuffer.length; i++) {\n    vector.add(mergedBuffer[i]);\n  }\n  const subVector = vector.subVector(start, end);\n  return subVector.toString();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `List` to collect a sequence of messages from `MessageEvents.data`, then uses the `sort` method of `List` to organize the messages alphabetically, and finally returns the sorted list.",
    "input": "",
    "output": "import {List, MessageEvents} from '@kit.ArkTS';\n\nexport function collectAndSortMessages(events: MessageEvents[]): List<string> {\n  const messageList: List<string> = new List();\n  \n  for (const event of events) {\n    messageList.add(event.data);\n  }\n  \n  messageList.sort((a: string, b: string) => {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n  \n  return messageList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that takes a `List` of `MessageEvents` objects, extracts the `data` property from each event, uses the `convertToArray` method of `List` to transform the data into an array, and then uses the `getSubList` method of `List` to return a sublist of the first 5 messages.",
    "input": "",
    "output": "import {List, MessageEvents} from '@kit.ArkTS';\n\nexport function getFirstFiveMessages(events: List<MessageEvents>): List<string> {\n  const dataArray: string[] = events.convertToArray().map((event: MessageEvents) => event.data);\n  const dataList: List<string> = new List(dataArray);\n  return dataList.getSubList(0, 5);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `List` to iterate over a list of `MessageEvents` objects, checks if each event's `data` property meets a certain condition (e.g., contains a specific keyword), and uses the `removeByIndex` method of `List` to filter out events that do not meet the condition, returning the filtered list.",
    "input": "",
    "output": "import {List, MessageEvents} from '@kit.ArkTS';\n\nexport function filterMessageEvents(events: List<MessageEvents>, keyword: string): List<MessageEvents> {\n  const indicesToRemove: number[] = [];\n  events.forEach((event: MessageEvents, index: number) => {\n    if (!event.data.includes(keyword)) {\n      indicesToRemove.push(index);\n    }\n  });\n  \n  for (let i = indicesToRemove.length - 1; i >= 0; i--) {\n    events.removeByIndex(indicesToRemove[i]);\n  }\n  \n  return events;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `hasKey` method of `LightWeightMap` to check if an error code exists in a map of error events, and if found, uses the `message` property of the corresponding `ErrorEvent` to log the error details.",
    "input": "",
    "output": "import {ErrorEvent, LightWeightMap} from '@kit.ArkTS';\n\nexport function checkAndLogError(errorMap: LightWeightMap<number, ErrorEvent>, errorCode: number): void {\n  if (errorMap.hasKey(errorCode)) {\n    const errorEvent: ErrorEvent | undefined = errorMap.get(errorCode);\n    if (errorEvent && errorEvent.message) {\n      console.log(`Error details: ${errorEvent.message}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that iterates over a `LightWeightMap` using the `[Symbol.iterator]` method to extract all error codes (keys) and then uses the `getKeyAt` and `getValueAt` methods to pair each error code with its corresponding `ErrorEvent`'s `filename` and `lineno` properties, storing the results in a new array.",
    "input": "",
    "output": "import {ErrorEvent, LightWeightMap} from '@kit.ArkTS';\n\nexport function extractErrorCodesWithDetails(errorMap: LightWeightMap<number, ErrorEvent>): Array<{errorCode: number, filename: string, lineno: number}> {\n  const result: Array<{errorCode: number, filename: string, lineno: number}> = [];\n  \n  for (const [errorCode, _] of errorMap[Symbol.iterator]()) {\n    const index = errorMap.getIndexOfKey(errorCode);\n    if (index !== -1) {\n      const errorEvent = errorMap.getValueAt(index);\n      if (errorEvent) {\n        result.push({\n          errorCode,\n          filename: errorEvent.filename,\n          lineno: errorEvent.lineno\n        });\n      }\n    }\n  }\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first uses the `forEach` method of `LightWeightMap` to process each `ErrorEvent` in the map, checking the `error` property, and then uses the `remove` method to delete any entries where the error is null or undefined.",
    "input": "",
    "output": "import {ErrorEvent, LightWeightMap} from '@kit.ArkTS';\n\nexport function processErrorEvents(map: LightWeightMap<number, ErrorEvent>): void {\n  const keysToRemove: number[] = [];\n  \n  map.forEach((value: ErrorEvent, key: number) => {\n    if (value.error === null || value.error === undefined) {\n      keysToRemove.push(key);\n    }\n  });\n  \n  keysToRemove.forEach((key: number) => {\n    map.remove(key);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `worker` API to send a message containing a key-value pair to a worker thread, then uses the `LightWeightMap` API's `set` method to store the received data (accessed via `MessageEvents.data`) in a LightWeightMap instance, and finally retrieves the value using the `get` method and returns it.",
    "input": "",
    "output": "import {worker, LightWeightMap, MessageEvents} from '@kit.ArkTS';\n\nexport function sendAndStoreInWorker(key: string, value: string): string {\n  const workerInstance = new worker.ThreadWorker('workers/worker.ts');\n  const lightWeightMap = new LightWeightMap<string, string>();\n  \n  workerInstance.postMessage({key, value});\n  \n  workerInstance.onmessage = (event: MessageEvents) => {\n    const receivedData = event.data;\n    lightWeightMap.set(receivedData.key, receivedData.value);\n  };\n  \n  const retrievedValue = lightWeightMap.get(key);\n  workerInstance.terminate();\n  \n  return retrievedValue;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `LightWeightMap` instance, populates it with key-value pairs using the `setAll` method, then uses the `worker` API to send the entire map (accessed via `LightWeightMap.entries`) to a worker thread, where the worker processes the data and sends back a modified version (accessed via `MessageEvents.data`) to be stored in a new LightWeightMap instance using the `setAll` method again.",
    "input": "",
    "output": "import {worker, LightWeightMap, MessageEvents} from '@kit.ArkTS';\n\nexport function initializeAndProcessMap(): void {\n  // Initialize the LightWeightMap\n  const originalMap = new LightWeightMap<number, string>();\n  originalMap.setAll([\n    {key: 1, value: 'one'},\n    {key: 2, value: 'two'},\n    {key: 3, value: 'three'}\n  ]);\n\n  // Create a worker instance\n  const workerInstance = new worker.ThreadWorker('workers/worker.js');\n\n  // Send the entries of the map to the worker\n  workerInstance.postMessage(Array.from(originalMap.entries()));\n\n  // Receive the modified data from the worker\n  workerInstance.onmessage = (event: MessageEvents): void => {\n    const modifiedData = event.data;\n    const modifiedMap = new LightWeightMap<number, string>();\n    modifiedMap.setAll(modifiedData);\n    \n    // Terminate the worker\n    workerInstance.terminate();\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a worker thread sends multiple messages (using `worker` API) containing key-value pairs, which are collected in the main thread using `MessageEvents.data` and stored in a `LightWeightMap` instance via the `set` method. Then, use the `LightWeightMap` API's `forEach` method to iterate over the entries and send each key-value pair back to the worker thread for further processing.",
    "input": "",
    "output": "import {worker, LightWeightMap, MessageEvents} from '@kit.ArkTS';\n\nexport function setupWorkerCommunication() {\n  const workerInstance = new worker.ThreadWorker('workers/worker.ts');\n  const lightWeightMap = new LightWeightMap<number, string>();\n\n  workerInstance.onmessage = (event: MessageEvents) => {\n    const { key, value } = event.data;\n    lightWeightMap.set(key, value);\n  };\n\n  workerInstance.onmessage = (event: MessageEvents) => {\n    lightWeightMap.forEach((value: string, key: number) => {\n      workerInstance.postMessage({ key, value });\n    });\n  };\n\n  return workerInstance;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `name` property of `WorkerOptions` to create a new Worker in `GlobalScope`, and then uses the `add` method of `ArrayList<string>` to store the Worker's name in a list of active worker names. Finally, use the `sort` method of `ArrayList<string>` to alphabetically organize the worker names.",
    "input": "",
    "output": "import {GlobalScope, WorkerOptions, ArrayList} from '@kit.ArkTS';\n\nexport function manageWorkers(workerName: string): ArrayList<string> {\n  const workerOptions: WorkerOptions = { name: workerName };\n  const worker = new GlobalScope.Worker('', workerOptions);\n  const activeWorkerNames: ArrayList<string> = new ArrayList();\n  activeWorkerNames.add(workerOptions.name);\n  activeWorkerNames.sort();\n  return activeWorkerNames;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes an `ArrayList<number>` with the `constructor` method, populates it using the `add` method, and then passes the list to a Worker (created using `GlobalScope` with `WorkerOptions` where `shared` is set to true) for parallel processing. The Worker should use the `forEach` method of `ArrayList<number>` to log each element.",
    "input": "",
    "output": "import {GlobalScope, WorkerOptions, ArrayList} from '@kit.ArkTS';\n\nexport function initializeAndProcessArrayList(): void {\n  const list: ArrayList<number> = new ArrayList<number>();\n  list.add(1);\n  list.add(2);\n  list.add(3);\n  \n  const workerOptions: WorkerOptions = {\n    name: 'arrayListWorker',\n    shared: true\n  };\n  \n  const worker: Worker = GlobalScope.startWorker('./workers/arrayListWorker', workerOptions);\n  worker.postMessage(list);\n}\n\n// arrayListWorker.ts (separate file in workers directory)\n// import {ArrayList} from '@kit.ArkTS';\n// \n// const workerPort: MessagePort = self as unknown as MessagePort;\n// workerPort.onmessage = (event: MessageEvent<ArrayList<number>>): void => {\n//   const list: ArrayList<number> = event.data;\n//   list.forEach((item: number) => {\n//     console.log(item);\n//   });\n// };",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses the `getIndexOf` method of `ArrayList<string>` to find the position of a specific string in a list, and then passes this index to a Worker (created using `GlobalScope` with `WorkerOptions` where `name` is set to 'indexFinder'). The Worker should use the `get` method of `ArrayList<string>` to retrieve and return the string at the given index.",
    "input": "",
    "output": "import {GlobalScope, WorkerOptions, ArrayList} from '@kit.ArkTS';\n\nexport function findStringIndexAndPassToWorker(list: ArrayList<string>, target: string): void {\n  const index = list.getIndexOf(target);\n  if (index === -1) {\n    return;\n  }\n  \n  const workerOptions: WorkerOptions = {\n    name: 'indexFinder'\n  };\n  \n  const worker = new GlobalScope('workers/worker.js', workerOptions);\n  worker.postMessage(index);\n}\n\n// worker.js content (should be in a separate file)\n// import {ArrayList, GlobalScope} from '@kit.ArkTS';\n// \n// const workerPort = GlobalScope.self;\n// workerPort.onmessage = (event: MessageEvent<number>) => {\n//   const index = event.data;\n//   const list = new ArrayList<string>();\n//   // Assuming the list is populated elsewhere or passed via another message\n//   const result = list.get(index);\n//   workerPort.postMessage(result);\n// };",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a Buffer from a string with 'utf-8' encoding, then passes this Buffer as the `data` property of a new `MessageEvent` object. Finally, log the `type` property of the `MessageEvent` and the byte length of the Buffer (using `buffer.byteLength`).",
    "input": "",
    "output": "import {buffer, Event, MessageEvent} from '@kit.ArkTS';\n\nexport function createAndLogMessageEvent(): void {\n  const str = 'example string';\n  const buf = buffer.from(str, 'utf-8');\n  const messageEvent = new MessageEvent('message', { data: buf });\n  console.log(`Type: ${messageEvent.type}`);\n  console.log(`Byte length: ${buffer.byteLength(buf)}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that generates a Buffer using `buffer.alloc` with a specified size, then compares it with another Buffer created using `buffer.from` (using `buffer.compare`). Based on the comparison result, dispatch an `Event` with a `type` property set to 'equal' or 'not-equal' and log the `timeStamp` of the event.",
    "input": "",
    "output": "import {buffer, Event, MessageEvent} from '@kit.ArkTS';\n\nexport function compareBuffers(size: number, data: string): void {\n  const buf1: buffer.Buffer = buffer.alloc(size);\n  const buf2: buffer.Buffer = buffer.from(data);\n  \n  const comparisonResult: number = buffer.compare(buf1, buf2);\n  const eventType: string = comparisonResult === 0 ? 'equal' : 'not-equal';\n  \n  const event: Event = new Event(eventType);\n  const messageEvent: MessageEvent<string> = new MessageEvent<string>(eventType, {\n    data: eventType,\n    timeStamp: event.timeStamp\n  });\n  \n  console.log(`Event timeStamp: ${messageEvent.timeStamp}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that concatenates two Buffers using `buffer.concat`, then creates a `MessageEvent` with the concatenated Buffer as its `data` property. Check if the `data` is a Buffer using `buffer.isBuffer` and log the result along with the `type` property of the `MessageEvent`.",
    "input": "",
    "output": "import {buffer, Event, MessageEvent} from '@kit.ArkTS';\n\nexport function concatenateAndCreateMessageEvent(buffer1: buffer.Buffer, buffer2: buffer.Buffer, eventType: string): void {\n  const concatenatedBuffer = buffer.concat([buffer1, buffer2]);\n  const messageEvent = new MessageEvent(concatenatedBuffer);\n  messageEvent.type = eventType;\n  \n  const isBuffer = buffer.isBuffer(messageEvent.data);\n  console.log(`Is data a Buffer: ${isBuffer}`);\n  console.log(`MessageEvent type: ${messageEvent.type}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "",
    "input": "",
    "output": "",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a Buffer from a string with UTF-8 encoding, then uses `HashMap.set` to store the Buffer as a value with a specified key, and finally checks if the HashMap contains the key using `HashMap.hasKey`.",
    "input": "",
    "output": "import {buffer, HashMap, MessageEvents} from '@kit.ArkTS';\n\nexport function storeAndCheckBuffer(key: string, value: string): boolean {\n  const buf = buffer.from(value, 'utf-8');\n  const map = new HashMap<string, buffer.Buffer>();\n  map.set(key, buf);\n  return map.hasKey(key);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.concat` to merge multiple Buffers into one, then uses `MessageEvents.data` to send the merged Buffer as part of a message event, and finally verifies the data property of the received MessageEvents object.",
    "input": "",
    "output": "import {buffer, HashMap, MessageEvents} from '@kit.ArkTS';\n\nexport function mergeAndSendBuffers(buffers: buffer.Buffer[]): MessageEvents {\n  const mergedBuffer = buffer.concat(buffers);\n  const messageEvent = new MessageEvents('data');\n  messageEvent.data = mergedBuffer;\n  return messageEvent;\n}\n\nexport function verifyMessageEventData(messageEvent: MessageEvents): buffer.Buffer | null {\n  return messageEvent.data as buffer.Buffer;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `HashMap.entries` to iterate over key-value pairs, converts each value (assumed to be a string) to a Buffer using `buffer.from`, and then checks if the Buffer is valid using `buffer.isBuffer`.",
    "input": "",
    "output": "import {buffer, HashMap, MessageEvents} from '@kit.ArkTS';\n\nexport function processHashMapEntries(hashMap: HashMap<string, string>): boolean {\n  const entries = hashMap.entries();\n  let allBuffersValid = true;\n\n  for (const [key, value] of entries) {\n    const buf = buffer.from(value);\n    if (!buffer.isBuffer(buf)) {\n      allBuffersValid = false;\n      break;\n    }\n  }\n\n  return allBuffersValid;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to store a sequence of URIs, then iterates through the list using `Symbol.iterator` to convert each URI to a buffer using `buffer.from` (with UTF-8 encoding), and finally checks if all buffers are valid using `buffer.isBuffer`.",
    "input": "",
    "output": "import {LinkedList, uri, buffer} from '@kit.ArkTS';\n\nexport function processURIs(uris: string[]): boolean {\n  const list = new LinkedList<string>();\n  \n  // Add URIs to the LinkedList\n  for (const uri of uris) {\n    list.add(uri);\n  }\n  \n  // Iterate through the LinkedList using Symbol.iterator\n  for (const uri of list) {\n    // Convert each URI to a buffer with UTF-8 encoding\n    const buf = buffer.from(uri, 'utf-8');\n    \n    // Check if the buffer is valid\n    if (!buffer.isBuffer(buf)) {\n      return false;\n    }\n  }\n  \n  return true;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes a `LinkedList` of strings, uses the `convertToArray` method to transform it into an array, then uses `buffer.concat` to merge all strings into a single buffer after encoding each with `buffer.from` (using 'base64' encoding). Finally, return the length of the concatenated buffer using the `length` property of `LinkedList` to verify the count of original elements.",
    "input": "",
    "output": "import {LinkedList, uri, buffer} from '@kit.ArkTS';\n\nexport function processLinkedList(list: LinkedList<string>): number {\n  const array: string[] = list.convertToArray();\n  const buffers: buffer.Buffer[] = [];\n  \n  for (const str of array) {\n    const encodedBuffer = buffer.from(str, 'base64');\n    buffers.push(encodedBuffer);\n  }\n  \n  const concatenatedBuffer = buffer.concat(buffers);\n  return list.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that reads a `LinkedList` of binary data (as strings), uses `getFirst` and `getLast` to extract the first and last elements, then compares them using `buffer.compare`. If the comparison returns 0, use `LinkedList.clear` to empty the list; otherwise, use `buffer.transcode` to convert the last element from 'utf-8' to 'ascii' and re-insert it into the list with `insert` at index 0.",
    "input": "",
    "output": "import {LinkedList, uri, buffer} from '@kit.ArkTS';\n\nexport function processBinaryLinkedList(list: LinkedList<string>): void {\n  if (list.length === 0) {\n    return;\n  }\n\n  const firstElement = list.getFirst();\n  const lastElement = list.getLast();\n\n  const firstBuffer = buffer.from(firstElement, 'utf-8');\n  const lastBuffer = buffer.from(lastElement, 'utf-8');\n\n  const comparisonResult = buffer.compare(firstBuffer, lastBuffer);\n\n  if (comparisonResult === 0) {\n    list.clear();\n  } else {\n    const transcodedBuffer = buffer.transcode(lastBuffer, 'utf-8', 'ascii');\n    const transcodedString = transcodedBuffer.toString('ascii');\n    list.insert(0, transcodedString);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `popLast` methods of `Deque` to reverse a sequence of URLs (stored as strings), then passes the reversed URLs to the `postMessage` method of `DedicatedWorkerGlobalScope` to send them to a worker thread for processing.",
    "input": "",
    "output": "import {Deque, url, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function reverseAndSendUrls(urls: string[], workerScope: DedicatedWorkerGlobalScope): void {\n  const deque = new Deque<string>();\n  \n  // Insert URLs into the front of the deque\n  for (const url of urls) {\n    deque.insertFront(url);\n  }\n  \n  const reversedUrls: string[] = [];\n  \n  // Pop URLs from the end of the deque to reverse the sequence\n  while (deque.length > 0) {\n    reversedUrls.push(deque.popLast());\n  }\n  \n  // Send the reversed URLs to the worker thread\n  workerScope.postMessage(reversedUrls);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that collects URLs from a `Deque` using the `getFirst` and `getLast` methods, validates them by checking their structure (e.g., ensuring they start with 'http://' or 'https://'), and then uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send only the valid URLs to a worker thread.",
    "input": "",
    "output": "import {Deque, url, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function collectAndValidateUrls(deque: Deque<string>, workerScope: DedicatedWorkerGlobalScope): void {\n  const validUrls: string[] = [];\n  \n  while (deque.length > 0) {\n    const firstUrl = deque.getFirst();\n    const lastUrl = deque.getLast();\n    \n    if (firstUrl && (firstUrl.startsWith('http://') || firstUrl.startsWith('https://'))) {\n      validUrls.push(firstUrl);\n    }\n    \n    if (lastUrl && lastUrl !== firstUrl && (lastUrl.startsWith('http://') || lastUrl.startsWith('https://'))) {\n      validUrls.push(lastUrl);\n    }\n    \n    deque.popFirst();\n    if (deque.length > 0) {\n      deque.popLast();\n    }\n  }\n  \n  workerScope.postMessage(validUrls);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a worker thread receives messages via the `onmessage` property of `DedicatedWorkerGlobalScope`, processes the data (e.g., extracting URLs), and stores the results in a `Deque` using the `insertEnd` method. The function should then use the `forEach` method of `Deque` to log each processed item.",
    "input": "",
    "output": "import {Deque, url, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processWorkerMessages(workerScope: DedicatedWorkerGlobalScope): void {\n  const deque = new Deque<string>();\n\n  workerScope.onmessage = (event: MessageEvent<string>) => {\n    const message = event.data;\n    // Process the data (e.g., extracting URLs)\n    const processedData = message; // Placeholder for actual processing\n    deque.insertEnd(processedData);\n\n    // Log each processed item using forEach\n    deque.forEach((item: string) => {\n      console.log(item);\n    });\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that captures a user interaction event (using `Event.type` and `Event.timeStamp`), converts the event data to a JSON string (using `json.stringify`), and then appends this string to a URI query parameter (using `uri` to construct the final URL).",
    "input": "",
    "output": "import {Event, json, uri} from '@kit.ArkTS';\n\nexport function captureAndConstructUrl(event: Event, baseUrl: string): string {\n  const eventData = {\n    type: event.type,\n    timeStamp: event.timeStamp\n  };\n  const jsonString = json.stringify(eventData);\n  const encodedJson = encodeURIComponent(jsonString);\n  return `${baseUrl}?event=${encodedJson}`;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that parses a JSON string (using `json.parse`) containing a list of URIs, filters out invalid URIs (using `uri` validation), and logs the remaining URIs along with a timestamp (using `Event.timeStamp`) for each valid entry.",
    "input": "",
    "output": "import {Event, json, uri} from '@kit.ArkTS';\n\nexport function parseAndFilterURIs(jsonString: string): void {\n  try {\n    const parsedData = json.parse(jsonString);\n    if (Array.isArray(parsedData)) {\n      parsedData.forEach((uriString: string) => {\n        try {\n          new uri.URI(uriString);\n          console.log(`Valid URI: ${uriString}, Timestamp: ${Event.timeStamp}`);\n        } catch (e) {\n          // Invalid URI, skip\n        }\n      });\n    }\n  } catch (e) {\n    console.error('Invalid JSON string');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that takes a JSON object (using `json.has` to check for required fields), validates its structure, and then triggers a custom event (using `Event.type`) with the validated data, including a timestamp (using `Event.timeStamp`) for tracking.",
    "input": "",
    "output": "import {Event, json, uri} from '@kit.ArkTS';\n\nexport function validateAndTriggerEvent(data: object, requiredFields: string[], eventType: string): void {\n  // Validate required fields\n  for (const field of requiredFields) {\n    if (!json.has(data, field)) {\n      throw new Error(`Missing required field: ${field}`);\n    }\n  }\n\n  // Create event with validated data and timestamp\n  const event: Event = {\n    type: eventType,\n    timeStamp: Date.now(),\n    data: data\n  };\n\n  // Trigger custom event (simulated since actual event triggering mechanism isn't specified)\n  // In a real implementation, this would use the system's event dispatching mechanism\n  console.log(`Event triggered: ${JSON.stringify(event)}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "",
    "input": "",
    "output": "",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a `PlainArray` object containing key-value pairs to a worker thread. The worker thread should then use the `getKeyAt` and `getValueAt` methods of `PlainArray` to process each pair and return the results via the `onmessage` property of `ThreadWorkerGlobalScope`.",
    "input": "",
    "output": "import {WorkerGlobalScope, ThreadWorkerGlobalScope, PlainArray} from '@kit.ArkTS';\n\nexport function sendPlainArrayToWorker(worker: ThreadWorkerGlobalScope, plainArray: PlainArray<number, string>): void {\n  worker.postMessage(plainArray);\n}\n\nexport function setupWorkerProcessing(worker: ThreadWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent<PlainArray<number, string>>) => {\n    const receivedArray = event.data;\n    const results: string[] = [];\n    \n    for (let i = 0; i < receivedArray.length; i++) {\n      const key = receivedArray.getKeyAt(i);\n      const value = receivedArray.getValueAt(i);\n      results.push(`Key: ${key}, Value: ${value}`);\n    }\n    \n    worker.postMessage(results);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that initializes a `PlainArray` using its `constructor` and populates it with data using the `add` method. The worker should then use the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope` to send the `PlainArray` back to the main thread, where the main thread uses the `forEach` method of `PlainArray` to log each key-value pair.",
    "input": "",
    "output": "import {WorkerGlobalScope, ThreadWorkerGlobalScope, PlainArray} from '@kit.ArkTS';\n\n// Worker thread implementation\nexport const workerCode = `\n  import {ThreadWorkerGlobalScope, PlainArray} from '@kit.ArkTS';\n\n  const workerScope = self as unknown as ThreadWorkerGlobalScope;\n\n  workerScope.onmessage = () => {\n    const plainArray = new PlainArray<number, string>();\n    plainArray.add(1, 'Value1');\n    plainArray.add(2, 'Value2');\n    plainArray.add(3, 'Value3');\n    workerScope.postMessageWithSharedSendable(plainArray);\n  };\n`;\n\n// Main thread implementation\nexport class MainThread {\n  private worker: WorkerGlobalScope;\n\n  constructor() {\n    this.worker = new WorkerGlobalScope('data:application/javascript,' + encodeURIComponent(workerCode));\n    this.worker.onmessage = (event: MessageEvent) => {\n      const plainArray: PlainArray<number, string> = event.data;\n      plainArray.forEach((value: string, key: number) => {\n        console.log(`Key: ${key}, Value: ${value}`);\n      });\n    };\n    this.worker.postMessage('start');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where the main thread creates a `PlainArray` and uses the `setValueAt` method to update values based on certain conditions. The updated `PlainArray` is then passed to a worker thread using the `postMessage` method of `ThreadWorkerGlobalScope`. The worker thread processes the array using the `getIndexOfKey` and `removeAt` methods of `PlainArray` and sends the modified array back to the main thread via the `onmessage` property of `ThreadWorkerGlobalScope`.",
    "input": "",
    "output": "import {WorkerGlobalScope, ThreadWorkerGlobalScope, PlainArray} from '@kit.ArkTS';\n\nexport function mainThreadFunction(): void {\n  const worker = new ThreadWorkerGlobalScope('workers/worker.ts');\n  const plainArray = new PlainArray<number, string>();\n  \n  // Populate the PlainArray with some initial values\n  plainArray.add(1, 'One');\n  plainArray.add(2, 'Two');\n  plainArray.add(3, 'Three');\n  \n  // Update values based on conditions\n  if (plainArray.get(1) === 'One') {\n    plainArray.setValueAt(plainArray.getIndexOfKey(1), 'Updated One');\n  }\n  \n  // Send the PlainArray to the worker thread\n  worker.postMessage(plainArray);\n  \n  // Receive the modified PlainArray from the worker thread\n  worker.onmessage = (modifiedArray: PlainArray<number, string>) => {\n    console.log('Modified PlainArray from worker:', modifiedArray.toString());\n    worker.terminate();\n  };\n}\n\nexport function workerThreadFunction(): void {\n  const workerScope = self as ThreadWorkerGlobalScope;\n  \n  workerScope.onmessage = (plainArray: PlainArray<number, string>) => {\n    // Process the PlainArray\n    const index = plainArray.getIndexOfKey(2);\n    if (index !== -1) {\n      plainArray.removeAt(index);\n    }\n    \n    // Send the modified PlainArray back to the main thread\n    workerScope.postMessage(plainArray);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getValueAt` method of `LightWeightMap` to retrieve a URI string, then passes this URI to the `uri` API to parse and extract the protocol (e.g., 'http', 'https'). Finally, use the `setValueAt` method of `LightWeightMap` to update the original value with the extracted protocol.",
    "input": "",
    "output": "import {LightWeightMap, url, uri} from '@kit.ArkTS';\n\nexport function extractAndUpdateProtocol(lwm: LightWeightMap<number, string>, index: number): void {\n  const uriString: string | undefined = lwm.getValueAt(index);\n  if (uriString === undefined) {\n    return;\n  }\n  const parsedUri = uri.parse(uriString);\n  const protocol: string = parsedUri.protocol;\n  lwm.setValueAt(index, protocol);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that iterates over the keys of a `LightWeightMap` using the `keys` method, converts each key to a URL string using the `url` API, and then checks if the URL is valid by using the `hasKey` method of `LightWeightMap` to verify the existence of the converted URL as a key in another `LightWeightMap` instance.",
    "input": "",
    "output": "import {LightWeightMap, url, uri} from '@kit.ArkTS';\n\nexport function validateUrls(sourceMap: LightWeightMap<string, any>, targetMap: LightWeightMap<string, any>): boolean {\n  const keys = sourceMap.keys();\n  for (const key of keys) {\n    const urlString = url.toString(key);\n    if (!targetMap.hasKey(urlString)) {\n      return false;\n    }\n  }\n  return true;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LightWeightMap` to process each key-value pair, where the value is a URI string. For each URI, use the `uri` API to extract the hostname, and then use the `set` method of `LightWeightMap` to store the hostname as a new key with the original URI as its value.",
    "input": "",
    "output": "import {LightWeightMap, url, uri} from '@kit.ArkTS';\n\nexport function processURIs(uriMap: LightWeightMap<string, string>): LightWeightMap<string, string> {\n  const hostnameMap = new LightWeightMap<string, string>();\n  uriMap.forEach((value: string, key: string) => {\n    try {\n      const parsedUri = uri.parse(value);\n      const hostname = parsedUri.hostname;\n      if (hostname) {\n        hostnameMap.set(hostname, value);\n      }\n    } catch (e) {\n      console.error(`Failed to parse URI: ${value}`);\n    }\n  });\n  return hostnameMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of event names, then iterates through the stack using `[Symbol.iterator]`, and dispatches each event using the `dispatchEvent` method of `EventTarget` (from @kit.ArkTS). The function should return the number of events successfully dispatched.",
    "input": "",
    "output": "import {EventTarget, LightWeightMap, Stack} from '@kit.ArkTS';\n\nexport function dispatchEvents(eventNames: string[]): number {\n  const stack = new Stack<string>();\n  const eventTarget = new EventTarget();\n  \n  for (const name of eventNames) {\n    stack.push(name);\n  }\n  \n  let dispatchedCount = 0;\n  \n  for (const eventName of stack) {\n    const event = { type: eventName };\n    if (eventTarget.dispatchEvent(event)) {\n      dispatchedCount++;\n    }\n  }\n  \n  return dispatchedCount;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `LightWeightMap` (from @kit.ArkTS) with key-value pairs using the `set` method, then transfers all keys to a `Stack` (from @kit.ArkTS) using the `keys` method of `LightWeightMap` and the `push` method of `Stack`. The function should return the stack's `length` property after the transfer.",
    "input": "",
    "output": "import {EventTarget, LightWeightMap, Stack} from '@kit.ArkTS';\n\nexport function transferKeysToStack(): number {\n  const map = new LightWeightMap<number, string>();\n  map.set(1, 'one');\n  map.set(2, 'two');\n  map.set(3, 'three');\n\n  const stack = new Stack<number>();\n  const keys = map.keys();\n  for (const key of keys) {\n    stack.push(key);\n  }\n\n  return stack.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the top element, then checks if this element exists as a key in a `LightWeightMap` (from @kit.ArkTS) using the `hasKey` method. If the key exists, the function should return the corresponding value using the `get` method; otherwise, it should return `undefined`.",
    "input": "",
    "output": "import {EventTarget, LightWeightMap, Stack} from '@kit.ArkTS';\n\nexport function checkTopElement(stack: Stack<number>, map: LightWeightMap<number, string>): string | undefined {\n  if (stack.isEmpty()) {\n    return undefined;\n  }\n  const topElement = stack.peek();\n  if (map.hasKey(topElement)) {\n    return map.get(topElement);\n  }\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.getEnvironmentVar` to retrieve the current environment variables, then parses the resulting string using `xml.EventType` to identify and extract specific environment-related events (e.g., 'LOAD', 'ERROR') for logging purposes.",
    "input": "",
    "output": "import {process, url, xml} from '@kit.ArkTS';\n\nexport function parseEnvironmentEvents(): void {\n  const envVars: string = process.getEnvironmentVar();\n  const parser: xml.XmlPullParser = new xml.XmlPullParser(envVars);\n  \n  let eventType: xml.EventType = parser.getEventType();\n  \n  while (eventType !== xml.EventType.END_DOCUMENT) {\n    switch (eventType) {\n      case xml.EventType.START_TAG:\n        const tagName: string = parser.getName();\n        if (tagName === 'LOAD' || tagName === 'ERROR') {\n          console.log(`Environment Event: ${tagName}`);\n        }\n        break;\n      case xml.EventType.TEXT:\n        const text: string = parser.getText();\n        console.log(`Event Text: ${text}`);\n        break;\n    }\n    eventType = parser.next();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility that first checks if the current process is 64-bit using `process.is64Bit`, then uses this information to dynamically construct a URL (using `url.URLSearchParams` or similar) to fetch architecture-specific resources, ensuring the correct binary version is retrieved.",
    "input": "",
    "output": "import {process, url, xml} from '@kit.ArkTS';\n\nexport function getArchitectureSpecificResourceUrl(baseUrl: string): string {\n  const is64Bit: boolean = process.is64Bit();\n  const arch: string = is64Bit ? 'x64' : 'x86';\n  \n  const resourceUrl = new url.URL(baseUrl);\n  const params = new url.URLSearchParams(resourceUrl.search);\n  params.set('arch', arch);\n  resourceUrl.search = params.toString();\n  \n  return resourceUrl.toString();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a process monitor that uses `process.uptime` to track the runtime duration of the application, and if the uptime exceeds a certain threshold, uses `xml.EventType` to trigger a custom event (e.g., 'LONG_RUNNING') for logging or alerting purposes.",
    "input": "",
    "output": "import {process, url, xml} from '@kit.ArkTS';\n\nexport class ProcessMonitor {\n  private threshold: number;\n  private eventType: xml.EventType;\n  private eventListener: process.EventListener;\n\n  constructor(threshold: number, eventType: xml.EventType, eventListener: process.EventListener) {\n    this.threshold = threshold;\n    this.eventType = eventType;\n    this.eventListener = eventListener;\n  }\n\n  public startMonitoring(): void {\n    const uptime = process.uptime();\n    if (uptime > this.threshold) {\n      this.eventListener(this.eventType);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `LightWeightMap` to retrieve all keys, then adds them to a `TreeSet` using the `add` method. Finally, use the `getFirstValue` and `getLastValue` methods of `TreeSet` to find the smallest and largest keys from the original `LightWeightMap`.",
    "input": "",
    "output": "import {LightWeightMap, TreeSet, uri} from '@kit.ArkTS';\n\nexport function getMinMaxKeysFromLightWeightMap<K>(map: LightWeightMap<K, any>): {min: K, max: K} | undefined {\n  if (map.isEmpty()) {\n    return undefined;\n  }\n  \n  const keys = map.keys();\n  const treeSet = new TreeSet<K>();\n  \n  for (const key of keys) {\n    treeSet.add(key);\n  }\n  \n  const min = treeSet.getFirstValue();\n  const max = treeSet.getLastValue();\n  \n  return {min, max};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `values` method of `TreeSet` to retrieve all values, then stores them in a `LightWeightMap` using the `set` method, where the keys are the indices of the values. Finally, use the `getValueAt` method of `LightWeightMap` to retrieve and return the value at a specified index.",
    "input": "",
    "output": "import {LightWeightMap, TreeSet, uri} from '@kit.ArkTS';\n\nexport function storeAndRetrieveValue(treeSet: TreeSet<number>, index: number): number | undefined {\n  const lightWeightMap = new LightWeightMap<number, number>();\n  const values = treeSet.values();\n  let i = 0;\n  for (const value of values) {\n    lightWeightMap.set(i, value);\n    i++;\n  }\n  return lightWeightMap.getValueAt(index);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `hasKey` method of `LightWeightMap` to check if a specific key exists, and if not, adds it to a `TreeSet` using the `add` method. Then, use the `remove` method of `TreeSet` to remove the key if it meets a certain condition (e.g., being even). Finally, return the updated `TreeSet`.",
    "input": "",
    "output": "import {LightWeightMap, TreeSet, uri} from '@kit.ArkTS';\n\nexport function checkAndUpdateSet(lwm: LightWeightMap<number, any>, ts: TreeSet<number>, key: number): TreeSet<number> {\n  if (!lwm.hasKey(key)) {\n    ts.add(key);\n  }\n  \n  if (key % 2 === 0) {\n    ts.remove(key);\n  }\n  \n  return ts;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then transfers these numbers to a `List` (from @kit.ArkTS) using its `add` method. Finally, use the `sort` method of `List` to arrange the numbers in ascending order.",
    "input": "",
    "output": "import {List, HashMap, Stack} from '@kit.ArkTS';\n\nexport function transferAndSortNumbers(numbers: number[]): List<number> {\n  const stack = new Stack<number>();\n  const list = new List<number>();\n\n  // Push numbers into the stack\n  for (const num of numbers) {\n    stack.push(num);\n  }\n\n  // Transfer numbers from stack to list\n  while (!stack.isEmpty()) {\n    list.add(stack.pop());\n  }\n\n  // Sort the list in ascending order\n  list.sort((a, b) => a - b);\n\n  return list;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first populates a `HashMap` (from @kit.ArkTS) with key-value pairs using the `set` method, then extracts all keys using the `keys` method and stores them in a `List` (from @kit.ArkTS) using its `add` method. Finally, use the `getSubList` method of `List` to create a sublist of the first half of the keys.",
    "input": "",
    "output": "import {List, HashMap, Stack} from '@kit.ArkTS';\n\nexport function processHashMapKeys(): List<string> {\n  const hashMap = new HashMap<string, string>();\n  hashMap.set('key1', 'value1');\n  hashMap.set('key2', 'value2');\n  hashMap.set('key3', 'value3');\n  hashMap.set('key4', 'value4');\n\n  const keys = hashMap.keys();\n  const keyList = new List<string>();\n  for (const key of keys) {\n    keyList.add(key);\n  }\n\n  const subListSize = Math.floor(keyList.length / 2);\n  return keyList.getSubList(0, subListSize);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `get` method of `List` (from @kit.ArkTS) to retrieve elements at even indices, then stores these elements in a `Stack` (from @kit.ArkTS) using the `push` method. Finally, use the `peek` method of `Stack` to check the top element without removing it.",
    "input": "",
    "output": "import {List, HashMap, Stack} from '@kit.ArkTS';\n\nexport function processEvenIndices(list: List<number>): number | undefined {\n  const stack = new Stack<number>();\n  \n  for (let i = 0; i < list.length; i += 2) {\n    const element = list.get(i);\n    if (element !== undefined) {\n      stack.push(element);\n    }\n  }\n  \n  return stack.peek();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then iterates through the stack using `Symbol.iterator` to populate a `LightWeightMap` (from @kit.ArkTS) where the keys are the numbers from the stack and the values are their indices in the stack. Finally, use the `getValueAt` method of `LightWeightMap` to retrieve and return the value at the middle index of the map.",
    "input": "",
    "output": "import {Stack, LightWeightMap, TreeSet} from '@kit.ArkTS';\n\nexport function processStackAndMap(): number | undefined {\n  const stack = new Stack<number>();\n  stack.push(10);\n  stack.push(20);\n  stack.push(30);\n  stack.push(40);\n  stack.push(50);\n\n  const map = new LightWeightMap<number, number>();\n  let index = 0;\n  for (const value of stack) {\n    map.set(value, index);\n    index++;\n  }\n\n  const middleIndex = Math.floor(map.length / 2);\n  return map.getValueAt(middleIndex);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `add` method of `TreeSet` (from @kit.ArkTS) to collect a set of unique strings, then transfers these strings to a `Stack` (from @kit.ArkTS) using the `push` method. After transferring, use the `peek` method of `Stack` to check the top element and the `getLastValue` method of `TreeSet` to compare it with the largest value in the original set. Return `true` if they match, otherwise `false`.",
    "input": "",
    "output": "import {Stack, LightWeightMap, TreeSet} from '@kit.ArkTS';\n\nexport function compareTopWithLargestValue(strings: string[]): boolean {\n  const treeSet = new TreeSet<string>();\n  const stack = new Stack<string>();\n\n  // Add all strings to the TreeSet to ensure uniqueness\n  for (const str of strings) {\n    treeSet.add(str);\n  }\n\n  // Transfer all unique strings from TreeSet to Stack\n  const values = treeSet.values();\n  for (const value of values) {\n    stack.push(value);\n  }\n\n  // Get the top element from Stack and the largest value from TreeSet\n  const topElement = stack.peek();\n  const largestValue = treeSet.getLastValue();\n\n  // Compare and return the result\n  return topElement === largestValue;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `set` method of `LightWeightMap` (from @kit.ArkTS) to store key-value pairs of product IDs (keys) and their prices (values). Then, extract all prices using the `values` method and add them to a `TreeSet` (from @kit.ArkTS) using the `add` method to eliminate duplicates. Finally, use the `getFirstValue` method of `TreeSet` to return the lowest unique price.",
    "input": "",
    "output": "import {Stack, LightWeightMap, TreeSet} from '@kit.ArkTS';\n\nexport function getLowestUniquePrice(productPrices: LightWeightMap<number, number>): number | undefined {\n  const priceSet = new TreeSet<number>();\n  const prices = productPrices.values();\n  \n  for (let i = 0; i < prices.length; i++) {\n    priceSet.add(prices[i]);\n  }\n  \n  return priceSet.getFirstValue();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` to collect a sequence of URIs, then iterates over the deque using the `Symbol.iterator` method to pass each URI to the `parse` method of `uri` (assuming it exists) for validation, and finally stores the valid URIs in an array.",
    "input": "",
    "output": "import {uri, Deque, xml} from '@kit.ArkTS';\n\nexport function validateAndStoreURIs(uriStrings: string[]): string[] {\n  const deque = new Deque<string>();\n  const validURIs: string[] = [];\n\n  // Insert URIs into the deque\n  for (const uriString of uriStrings) {\n    deque.insertFront(uriString);\n    deque.insertEnd(uriString);\n  }\n\n  // Iterate over the deque and validate URIs\n  for (const uriString of deque) {\n    try {\n      // Assuming uri.parse exists and throws an error for invalid URIs\n      uri.parse(uriString);\n      validURIs.push(uriString);\n    } catch (error) {\n      // Skip invalid URIs\n    }\n  }\n\n  return validURIs;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getFirst` and `getLast` methods of `Deque` to retrieve the first and last elements of a deque containing XML event types (from the `EventType` enum of `xml`), then compares these event types and returns a boolean indicating whether they are the same.",
    "input": "",
    "output": "import {uri, Deque, xml} from '@kit.ArkTS';\n\nexport function compareFirstAndLastEventTypes(deque: Deque<xml.EventType>): boolean {\n  const firstEvent = deque.getFirst();\n  const lastEvent = deque.getLast();\n  return firstEvent === lastEvent;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Deque` to process a deque of XML event types (from the `EventType` enum of `xml`), filters out specific event types, and then uses the `popFirst` method to remove and return the remaining events from the deque.",
    "input": "",
    "output": "import {uri, Deque, xml} from '@kit.ArkTS';\n\nexport function processDeque(events: Deque<xml.EventType>, filterTypes: xml.EventType[]): xml.EventType[] {\n  const filteredEvents: xml.EventType[] = [];\n  \n  events.forEach((event: xml.EventType) => {\n    if (!filterTypes.includes(event)) {\n      filteredEvents.push(event);\n    }\n  });\n  \n  const result: xml.EventType[] = [];\n  while (events.length > 0) {\n    const event = events.popFirst();\n    if (event && !filterTypes.includes(event)) {\n      result.push(event);\n    }\n  }\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `PlainArray.forEach` to iterate over key-value pairs, filters out entries where the value matches a condition, and then uses `HashMap.setAll` to merge the filtered entries into a new HashMap. The function must explicitly use `PlainArray.forEach` and `HashMap.setAll`.",
    "input": "",
    "output": "import {PlainArray, EventTarget, HashMap} from '@kit.ArkTS';\n\nexport function filterAndMerge(plainArray: PlainArray<number, string>, condition: (value: string) => boolean): HashMap<number, string> {\n  const filteredEntries: PlainArray<number, string> = new PlainArray<number, string>();\n  \n  plainArray.forEach((value: string, key: number) => {\n    if (condition(value)) {\n      filteredEntries.add(key, value);\n    }\n  });\n  \n  const resultMap: HashMap<number, string> = new HashMap<number, string>();\n  resultMap.setAll(filteredEntries);\n  \n  return resultMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that listens for custom events using `EventTarget.addEventListener`, processes the event data to extract key-value pairs, and stores them in a PlainArray using `PlainArray.add`. The function must explicitly use `EventTarget.addEventListener` and `PlainArray.add`.",
    "input": "",
    "output": "import {PlainArray, EventTarget, HashMap} from '@kit.ArkTS';\n\nexport function listenAndStoreCustomEvents(eventTarget: EventTarget, eventName: string): PlainArray<number, string> {\n  const plainArray = new PlainArray<number, string>();\n\n  const eventHandler = (event: CustomEvent) => {\n    if (event.detail && typeof event.detail === 'object') {\n      const hashMap = new HashMap<number, string>();\n      \n      for (const [key, value] of Object.entries(event.detail)) {\n        const numKey = Number(key);\n        if (!isNaN(numKey) && typeof value === 'string') {\n          hashMap.set(numKey, value);\n        }\n      }\n\n      hashMap.forEach((value, key) => {\n        plainArray.add(key, value);\n      });\n    }\n  };\n\n  eventTarget.addEventListener(eventName, eventHandler as EventListener);\n\n  return plainArray;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that retrieves all keys from a HashMap using `HashMap.keys`, checks if each key exists in a PlainArray using `PlainArray.has`, and then dispatches an event with the results using `EventTarget.dispatchEvent`. The function must explicitly use `HashMap.keys`, `PlainArray.has`, and `EventTarget.dispatchEvent`.",
    "input": "",
    "output": "import {PlainArray, EventTarget, HashMap} from '@kit.ArkTS';\n\nexport function checkKeysInPlainArray(hashMap: HashMap<number, unknown>, plainArray: PlainArray<unknown>, eventTarget: EventTarget): void {\n  const keys = hashMap.keys();\n  const results: boolean[] = [];\n  \n  for (const key of keys) {\n    results.push(plainArray.has(key));\n  }\n  \n  const event = {\n    type: 'checkKeysResults',\n    results: results\n  };\n  \n  eventTarget.dispatchEvent(event);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a sequence of numbers, then transfers all elements from the `Queue` to a `LinkedList` using the `getFirst` and `pop` methods of `Queue` and the `add` method of `LinkedList`. Finally, use the `convertToArray` method of `LinkedList` to return the elements as an array.",
    "input": "",
    "output": "import {Queue, LinkedList} from '@kit.ArkTS';\n\nexport function transferQueueToLinkedList(numbers: number[]): number[] {\n  const queue = new Queue<number>();\n  const linkedList = new LinkedList<number>();\n\n  // Enqueue all numbers into the Queue\n  numbers.forEach(num => queue.add(num));\n\n  // Transfer all elements from Queue to LinkedList\n  while (queue.length > 0) {\n    const firstElement = queue.getFirst();\n    if (firstElement !== undefined) {\n      linkedList.add(firstElement);\n      queue.pop();\n    }\n  }\n\n  // Convert LinkedList to array and return\n  return linkedList.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `TreeSet` with a list of strings using the `add` method, then retrieves the first and last values using `getFirstValue` and `getLastValue` of `TreeSet`, and adds them to a `LinkedList` using its `addFirst` and `add` methods. The function should return the `LinkedList`.",
    "input": "",
    "output": "import {Queue, LinkedList, TreeSet} from '@kit.ArkTS';\n\nexport function processTreeSetAndLinkedList(strings: string[]): LinkedList<string> {\n  const treeSet = new TreeSet<string>();\n  strings.forEach(str => treeSet.add(str));\n  \n  const linkedList = new LinkedList<string>();\n  const firstValue = treeSet.getFirstValue();\n  const lastValue = treeSet.getLastValue();\n  \n  if (firstValue !== undefined) {\n    linkedList.addFirst(firstValue);\n  }\n  \n  if (lastValue !== undefined) {\n    linkedList.add(lastValue);\n  }\n  \n  return linkedList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `insert` method of `LinkedList` to build a list of integers, then transfers all elements from the `LinkedList` to a `TreeSet` using the `get` method of `LinkedList` and the `add` method of `TreeSet`. Finally, use the `values` method of `TreeSet` to return an iterator of the sorted unique elements.",
    "input": "",
    "output": "import {Queue, LinkedList, TreeSet} from '@kit.ArkTS';\n\nexport function transferLinkedListToTreeSet(numbers: number[]): IterableIterator<number> {\n  const linkedList = new LinkedList<number>();\n  for (const num of numbers) {\n    linkedList.insert(num, linkedList.length);\n  }\n\n  const treeSet = new TreeSet<number>();\n  for (let i = 0; i < linkedList.length; i++) {\n    treeSet.add(linkedList.get(i));\n  }\n\n  return treeSet.values();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a series of event names, then uses the `getFirst` method of `Queue` to retrieve the next event and dispatch it using the `dispatchEvent` method of `EventTarget`. The function should continue this process until the queue is empty (checked via the `length` property of `Queue`).",
    "input": "",
    "output": "import {EventTarget, Queue, Deque} from '@kit.ArkTS';\n\nexport function processEvents(eventNames: string[]): void {\n  const eventTarget = new EventTarget();\n  const queue = new Queue<string>();\n\n  // Enqueue all event names\n  for (const eventName of eventNames) {\n    queue.add(eventName);\n  }\n\n  // Process events until the queue is empty\n  while (queue.length > 0) {\n    const nextEvent = queue.getFirst();\n    if (nextEvent) {\n      eventTarget.dispatchEvent(nextEvent);\n      queue.pop();\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `insertFront` and `insertEnd` methods of `Deque` to build a list of event listeners. Then, iterate over the deque using the `forEach` method of `Deque` to register each listener with the `addEventListener` method of `EventTarget`. Finally, use the `dispatchEvent` method of `EventTarget` to trigger all registered listeners.",
    "input": "",
    "output": "import {EventTarget, Queue, Deque} from '@kit.ArkTS';\n\nexport function registerAndTriggerListeners(): void {\n  const eventTarget = new EventTarget();\n  const deque = new Deque<() => void>();\n\n  // Insert listeners into the deque\n  deque.insertFront(() => {\n    console.log('Listener 1 triggered');\n  });\n  deque.insertEnd(() => {\n    console.log('Listener 2 triggered');\n  });\n  deque.insertFront(() => {\n    console.log('Listener 3 triggered');\n  });\n\n  // Register each listener with the EventTarget\n  deque.forEach((listener) => {\n    eventTarget.addEventListener('customEvent', listener);\n  });\n\n  // Dispatch the event to trigger all listeners\n  eventTarget.dispatchEvent('customEvent');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `popFirst` method of `Deque` to remove and process the first item in the deque, then checks if the deque still contains items using the `has` method of `Deque`. If items remain, use the `getLast` method of `Deque` to retrieve the last item and add it to a `Queue` using the `add` method of `Queue`. Repeat this process until the deque is empty.",
    "input": "",
    "output": "import {EventTarget, Queue, Deque} from '@kit.ArkTS';\n\nexport function processDeque(deque: Deque<number>, queue: Queue<number>): void {\n  while (deque.has()) {\n    const firstItem = deque.popFirst();\n    // Process the first item here if needed\n    \n    if (deque.has()) {\n      const lastItem = deque.getLast();\n      queue.add(lastItem);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `ArrayList<string>` to collect a list of error messages, then passes this list to the `onerror` property of `GlobalScope` to handle and display the errors. Ensure the `length` property of `ArrayList` is used to check if there are any errors before triggering the handler.",
    "input": "",
    "output": "import {ArrayList, GlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport function collectAndHandleErrors(errorMessages: string[]): void {\n  const errorList: ArrayList<string> = new ArrayList();\n  \n  for (const message of errorMessages) {\n    errorList.add(message);\n  }\n  \n  if (errorList.length > 0) {\n    const globalScope: GlobalScope = globalThis as unknown as GlobalScope;\n    globalScope.onerror = (event: ErrorEvent) => {\n      console.error('Error occurred:', event.message);\n    };\n    \n    const options: PostMessageOptions = {\n      transfer: []\n    };\n    \n    globalScope.postMessage(errorList.convertToArray(), options);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `sort` method of `ArrayList<number>` to organize a list of numerical IDs, then uses the `PostMessageOptions` API with the `transfer` property to send the sorted list to another context (e.g., a worker thread). The function should also use the `trimToCurrentLength` method of `ArrayList` to optimize the list before transfer.",
    "input": "",
    "output": "import {ArrayList, GlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport function sortAndTransferIDs(ids: ArrayList<number>, target: GlobalScope): void {\n  ids.sort((a: number, b: number) => a - b);\n  ids.trimToCurrentLength();\n  const arrayBuffer: ArrayBuffer = new ArrayBuffer(ids.length * 4);\n  const dataView = new DataView(arrayBuffer);\n  for (let i = 0; i < ids.length; i++) {\n    dataView.setInt32(i * 4, ids[i], true);\n  }\n  const options: PostMessageOptions = {\n    transfer: [arrayBuffer]\n  };\n  target.postMessage(arrayBuffer, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getIndexOf` and `getLastIndexOf` methods of `ArrayList<string>` to find duplicate entries in a list, then uses the `self` property of `GlobalScope` to post a message (with `PostMessageOptions` and its `transfer` property) containing the indices of the duplicates to the parent window.",
    "input": "",
    "output": "import {ArrayList, GlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport function findAndPostDuplicates(list: ArrayList<string>): void {\n  const duplicates: number[][] = [];\n  const processedIndices: Set<number> = new Set();\n\n  for (let i = 0; i < list.length; i++) {\n    if (processedIndices.has(i)) {\n      continue;\n    }\n\n    const item = list[i];\n    const firstIndex = list.getIndexOf(item);\n    const lastIndex = list.getLastIndexOf(item);\n\n    if (firstIndex !== lastIndex) {\n      const duplicateIndices: number[] = [];\n      for (let j = firstIndex; j <= lastIndex; j++) {\n        if (list[j] === item) {\n          duplicateIndices.push(j);\n          processedIndices.add(j);\n        }\n      }\n      duplicates.push(duplicateIndices);\n    }\n  }\n\n  if (duplicates.length > 0) {\n    const options: PostMessageOptions = {\n      transfer: []\n    };\n    GlobalScope.self.postMessage(duplicates, options);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `util.generateRandomUUID()` to create a unique identifier, then passes this UUID to `xml.EventType` to log an event with the generated UUID as part of the event data. The function should return the event type along with the UUID.",
    "input": "",
    "output": "import {util, MessageEvent, xml} from '@kit.ArkTS';\n\nexport function generateAndLogEvent(): {eventType: xml.EventType, uuid: string} {\n  const uuid: string = util.generateRandomUUID();\n  const eventType: xml.EventType = xml.EventType.EVENT;\n  const eventData: MessageEvent<string> = new MessageEvent(eventType, {data: uuid});\n  return {eventType, uuid};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes `util.errnoToString()` to convert an error number into a readable string, then constructs a `MessageEvent` object where the `data` property is set to this error string. The function should return the `MessageEvent` object with the formatted error message.",
    "input": "",
    "output": "import {util, MessageEvent, xml} from '@kit.ArkTS';\n\nexport function createErrorMessageEvent(errno: number): MessageEvent<string> {\n  const errorString: string = util.errnoToString(errno);\n  const messageEvent: MessageEvent<string> = new MessageEvent('error', {\n    data: errorString\n  });\n  return messageEvent;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `util.getHash()` to compute the hash of a given input string, then formats the hash result into a human-readable string using `util.format()`. The formatted hash string should then be used as the `data` property in a new `MessageEvent` object, which the function should return.",
    "input": "",
    "output": "import {util, MessageEvent, xml} from '@kit.ArkTS';\n\nexport function createHashedMessageEvent(input: string): MessageEvent<string> {\n  const hash = util.getHash(input);\n  const formattedHash = util.format('Hash: %s', hash);\n  return new MessageEvent('hashed', { data: formattedHash });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of strings, then converts the LinkedList to an array using `convertToArray`, and finally uses the `concat` method of `buffer` to merge all strings into a single buffer. The function should return the merged buffer.",
    "input": "",
    "output": "import { LinkedList } from '@kit.ArkTS';\nimport { buffer } from '@kit.ArkTS';\n\nexport function mergeStringsToBuffer(strings: string[]): buffer.Buffer {\n  const list = new LinkedList<string>();\n  strings.forEach((str) => {\n    list.add(str);\n  });\n  const stringArray = list.convertToArray();\n  const buffers = stringArray.map((str) => buffer.from(str));\n  return buffer.concat(buffers);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `from` method of `buffer` to create a buffer from a given string, then iterates over the buffer's bytes using a `for...of` loop (via `Symbol.iterator`), and stores each byte value in a `LinkedList` using the `add` method. The function should return the LinkedList containing the byte values.",
    "input": "",
    "output": "import {LinkedList, buffer} from '@kit.ArkTS';\n\nexport function stringToByteLinkedList(input: string): LinkedList<number> {\n  const buf = buffer.from(input);\n  const byteList = new LinkedList<number>();\n  for (const byte of buf) {\n    byteList.add(byte);\n  }\n  return byteList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `alloc` method of `buffer` to create a buffer of a specified size, then populates it with values from a `LinkedList` (using the `get` method to retrieve values). The function should then use the `compare` method of `buffer` to compare this buffer with another buffer created from a different LinkedList. The function should return the comparison result.",
    "input": "",
    "output": "import {LinkedList, buffer} from '@kit.ArkTS';\n\nexport function compareBuffersFromLinkedLists(list1: LinkedList<number>, list2: LinkedList<number>, size: number): number {\n  const buf1 = buffer.alloc(size);\n  const buf2 = buffer.alloc(size);\n\n  for (let i = 0; i < size; i++) {\n    const val1 = list1.get(i);\n    const val2 = list2.get(i);\n    \n    if (val1 !== undefined) {\n      buf1[i] = val1;\n    }\n    \n    if (val2 !== undefined) {\n      buf2[i] = val2;\n    }\n  }\n\n  return buffer.compare(buf1, buf2);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `set` method of `TreeMap` to store key-value pairs of worker names and their error counts, then uses the `onerror` property of `WorkerGlobalScope` to increment the error count in the `TreeMap` whenever an error occurs in the worker. Finally, use the `getFirstKey` method of `TreeMap` to retrieve the worker with the lowest error count.",
    "input": "",
    "output": "import {TreeMap, PostMessageOptions, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerErrorTracking(workerScope: WorkerGlobalScope): TreeMap<string, number> {\n  const errorCountMap: TreeMap<string, number> = new TreeMap();\n\n  workerScope.onerror = (event: ErrorEvent) => {\n    const workerName = workerScope.name;\n    const currentCount = errorCountMap.get(workerName) || 0;\n    errorCountMap.set(workerName, currentCount + 1);\n  };\n\n  return errorCountMap;\n}\n\nexport function getWorkerWithLowestErrorCount(errorCountMap: TreeMap<string, number>): string | undefined {\n  return errorCountMap.getFirstKey();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `entries` method of `TreeMap` to iterate over a collection of worker names and their message transfer options, then uses the `transfer` property of `PostMessageOptions` to send each worker's data to another worker via `WorkerGlobalScope.self.postMessage`. Ensure the function also uses the `length` property of `TreeMap` to log the total number of workers processed.",
    "input": "",
    "output": "import {TreeMap, PostMessageOptions, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processWorkers(workers: TreeMap<string, PostMessageOptions>): void {\n  const entries = workers.entries();\n  let count = 0;\n  \n  for (const [name, options] of entries) {\n    WorkerGlobalScope.self.postMessage({name, data: options}, options.transfer);\n    count++;\n  }\n  \n  console.log(`Total workers processed: ${workers.length}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getHigherKey` method of `TreeMap` to find the next worker name in alphabetical order, then uses the `name` property of `WorkerGlobalScope` to verify if the current worker matches the retrieved name. If it does, use the `postMessage` method (via `WorkerGlobalScope.self`) to send a confirmation message with the `transfer` property of `PostMessageOptions` set to transfer ownership of the message data.",
    "input": "",
    "output": "import {TreeMap, PostMessageOptions, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function findAndPostNextWorkerName(treeMap: TreeMap<string, unknown>, currentWorker: WorkerGlobalScope): void {\n  const currentName = currentWorker.name;\n  const nextKey = treeMap.getHigherKey(currentName);\n  \n  if (nextKey !== undefined && currentWorker.name === nextKey) {\n    const messageData = new ArrayBuffer(1);\n    const options: PostMessageOptions = {\n      transfer: [messageData]\n    };\n    currentWorker.self.postMessage('Confirmation', [messageData]);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addAll` method of `LightWeightSet` to collect a set of event types from an array of `Event` objects, then uses the `toArray` method of `LightWeightSet` to convert the set into an array, and finally passes this array to the `insertEnd` method of `Deque` to store the event types in chronological order.",
    "input": "",
    "output": "import {LightWeightSet, Event, Deque} from '@kit.ArkTS';\n\nexport function processEvents(events: Event[]): void {\n  const eventTypeSet = new LightWeightSet<string>();\n  eventTypeSet.addAll(events.map(event => event.type));\n  const eventTypeArray = eventTypeSet.toArray();\n  const deque = new Deque<string>();\n  eventTypeArray.forEach(type => deque.insertEnd(type));\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getFirst` and `getLast` methods of `Deque` to retrieve the oldest and newest timestamps from a sequence of `Event` objects stored in the `Deque`, then uses the `add` method of `LightWeightSet` to store these timestamps, and finally checks if the `LightWeightSet` contains any duplicate timestamps using the `has` method.",
    "input": "",
    "output": "import {LightWeightSet, Event, Deque} from '@kit.ArkTS';\n\nexport function processEvents(deque: Deque<Event>): boolean {\n  const lws = new LightWeightSet<number>();\n  \n  if (deque.length > 0) {\n    const firstEvent = deque.getFirst();\n    const lastEvent = deque.getLast();\n    \n    lws.add(firstEvent.timeStamp);\n    lws.add(lastEvent.timeStamp);\n    \n    return lws.length !== 2;\n  }\n  \n  return false;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Deque` to iterate over a sequence of `Event` objects, extracts the `type` property of each `Event`, and then uses the `add` method of `LightWeightSet` to build a unique set of event types. Finally, use the `values` method of `LightWeightSet` to return an iterator of these unique event types.",
    "input": "",
    "output": "import {LightWeightSet, Event, Deque} from '@kit.ArkTS';\n\nexport function getUniqueEventTypes(events: Deque<Event>): IterableIterator<string> {\n  const uniqueTypes = new LightWeightSet<string>();\n  events.forEach((event: Event) => {\n    uniqueTypes.add(event.type);\n  });\n  return uniqueTypes.values();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `TreeSet` to store a sequence of event timestamps (from the `timeStamp` property of `Event` objects), then uses the `getFirstValue` and `getLastValue` methods of `TreeSet` to determine the earliest and latest timestamps in the set.",
    "input": "",
    "output": "import {stream, Event, TreeSet} from '@kit.ArkTS';\n\nexport function getEarliestAndLatestTimestamps(events: Event[]): {earliest: number, latest: number} {\n  const timestampSet = new TreeSet<number>();\n  \n  for (const event of events) {\n    timestampSet.add(event.timeStamp);\n  }\n  \n  const earliest = timestampSet.getFirstValue();\n  const latest = timestampSet.getLastValue();\n  \n  return {earliest, latest};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that iterates over a `TreeSet` of `Event` objects using the `Symbol.iterator` method, filters events based on their `type` property, and then uses the `forEach` method of `TreeSet` to log the filtered events in chronological order (sorted by `timeStamp`).",
    "input": "",
    "output": "import {stream, Event, TreeSet} from '@kit.ArkTS';\n\nexport function filterAndLogEvents(events: TreeSet<Event>, filterType: string): void {\n  const filteredEvents: Event[] = [];\n  \n  for (const event of events[Symbol.iterator]()) {\n    if (event.type === filterType) {\n      filteredEvents.push(event);\n    }\n  }\n  \n  filteredEvents.sort((a, b) => a.timeStamp - b.timeStamp);\n  \n  const sortedTreeSet = new TreeSet<Event>();\n  filteredEvents.forEach(event => sortedTreeSet.add(event));\n  \n  sortedTreeSet.forEach((event) => {\n    console.log(`Event - Type: ${event.type}, Timestamp: ${event.timeStamp}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if a `TreeSet` (using the `isEmpty` method) contains any events with a specific `type` (using the `has` method after iterating with `values`), and if not, adds a new `Event` object to the `TreeSet` using the `add` method.",
    "input": "",
    "output": "import {stream, Event, TreeSet} from '@kit.ArkTS';\n\nexport function checkAndAddEvent(eventSet: TreeSet<Event>, eventType: string): void {\n  if (eventSet.isEmpty()) {\n    const newEvent: Event = { timeStamp: Date.now(), type: eventType };\n    eventSet.add(newEvent);\n    return;\n  }\n\n  let hasType: boolean = false;\n  for (const event of eventSet.values()) {\n    if (event.type === eventType) {\n      hasType = true;\n      break;\n    }\n  }\n\n  if (!hasType) {\n    const newEvent: Event = { timeStamp: Date.now(), type: eventType };\n    eventSet.add(newEvent);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `execute` method of `taskpool` to run a background task which fetches a URI string from `GlobalScope.self`, then processes the URI string to extract its components using the `uri` API (e.g., parsing the protocol and hostname). The parsed components should be returned as an object.",
    "input": "",
    "output": "import {GlobalScope, taskpool, uri} from '@kit.ArkTS';\n\nexport interface UriComponents {\n  protocol: string;\n  hostname: string;\n}\n\nexport async function parseUriInBackground(): Promise<UriComponents> {\n  const task = new taskpool.Task(() => {\n    const uriString = GlobalScope.self as string;\n    const parsedUri = new uri.URI(uriString);\n    return {\n      protocol: parsedUri.protocol,\n      hostname: parsedUri.hostname\n    };\n  });\n\n  return await taskpool.execute(task);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that schedules a delayed task using `taskpool.executeDelayed` with a callback function (defined using `taskpool.CallbackFunction`). The callback should check `GlobalScope.onerror` for any global errors and log them before performing a URI validation check using the `uri` API. The function should return the validation result.",
    "input": "",
    "output": "import {GlobalScope, taskpool, uri} from '@kit.ArkTS';\n\nexport function scheduleDelayedTask(delay: number, uriToValidate: string): Promise<boolean> {\n  const callback: taskpool.CallbackFunction = () => {\n    if (GlobalScope.onerror) {\n      console.error('Global error detected:', GlobalScope.onerror);\n    }\n    \n    try {\n      uri.parse(uriToValidate);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  };\n  \n  return taskpool.executeDelayed(callback, delay);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task that uses `taskpool.executePeriodically` to periodically monitor a URI stored in `GlobalScope.name`. Each execution should fetch the URI, validate it using the `uri` API, and if invalid, trigger `GlobalScope.onerror` with a custom error message. The task should be cancellable using `taskpool.cancel` based on a condition.",
    "input": "",
    "output": "import {GlobalScope, taskpool, uri} from '@kit.ArkTS';\n\nexport function startPeriodicMonitoring(interval: number, condition: () => boolean): void {\n  const task: taskpool.CallbackFunction = () => {\n    try {\n      const currentUri = GlobalScope.name;\n      if (!currentUri) {\n        throw new Error('URI is empty');\n      }\n      \n      // Validate URI (assuming uri.parse throws if invalid)\n      uri.parse(currentUri);\n    } catch (error) {\n      if (GlobalScope.onerror) {\n        GlobalScope.onerror(error as Error);\n      }\n    }\n    \n    if (condition()) {\n      taskpool.cancel(task);\n    }\n  };\n  \n  taskpool.executePeriodically(task, interval);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a set of unique IDs, then stores them in a `Stack` using the `push` method. Finally, iterate over the `Stack` using `forEach` and print each ID using `util.printf`.",
    "input": "",
    "output": "import {util, Stack, LightWeightSet} from '@kit.ArkTS';\n\nexport function generateAndPrintUUIDs(count: number): void {\n  const stack = new Stack<string>();\n  \n  for (let i = 0; i < count; i++) {\n    const uuid = util.generateRandomUUID();\n    stack.push(uuid);\n  }\n  \n  stack.forEach((uuid: string) => {\n    util.printf('%s', uuid);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `LightWeightSet` with values using the `addAll` method, then transfers these values to a `Stack` using the `push` method (one by one after converting the `LightWeightSet` to an array via `toArray`). Ensure the `Stack` is not empty by checking its `length` property before proceeding.",
    "input": "",
    "output": "import {util, Stack, LightWeightSet} from '@kit.ArkTS';\n\nexport function transferValuesToStack(): void {\n  const lightWeightSet = new LightWeightSet<number>();\n  const valuesToAdd = [1, 2, 3, 4, 5];\n  lightWeightSet.addAll(valuesToAdd);\n  \n  const stack = new Stack<number>();\n  const valuesArray = lightWeightSet.toArray();\n  \n  for (const value of valuesArray) {\n    stack.push(value);\n  }\n  \n  if (stack.length > 0) {\n    console.log('Stack is not empty');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that generates a random binary UUID using `util.generateRandomBinaryUUID`, adds it to a `LightWeightSet` via the `add` method, and then checks if the set contains the UUID using `has`. If found, print the UUID's string representation using `util.errnoToString` (assuming the UUID is treated as an error code for demonstration purposes).",
    "input": "",
    "output": "import {util, Stack, LightWeightSet} from '@kit.ArkTS';\n\nexport function handleRandomUUID(): void {\n  const uuid: Uint8Array = util.generateRandomBinaryUUID();\n  const set: LightWeightSet<Uint8Array> = new LightWeightSet<Uint8Array>();\n  set.add(uuid);\n  if (set.has(uuid)) {\n    const uuidString: string = util.errnoToString(uuid);\n    console.log(uuidString);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` (from @kit.ArkTS) to collect a sequence of XML event types (from `EventType` enum in `xml`), then passes the collected events to the `replaceAllElements` method of `ArrayList<EventType>` (from @kit.ArkTS) to normalize and store the event sequence.",
    "input": "",
    "output": "import {xml, Deque, ArrayList} from '@kit.ArkTS';\n\nexport function collectAndNormalizeEvents(): ArrayList<xml.EventType> {\n  const deque = new Deque<xml.EventType>();\n  const eventList = new ArrayList<xml.EventType>();\n\n  // Example usage of insertFront and insertEnd\n  deque.insertFront(xml.EventType.START_ELEMENT);\n  deque.insertEnd(xml.EventType.END_ELEMENT);\n  deque.insertFront(xml.EventType.START_DOCUMENT);\n  deque.insertEnd(xml.EventType.END_DOCUMENT);\n\n  // Convert deque to array for replaceAllElements\n  const events: xml.EventType[] = [];\n  for (const event of deque) {\n    events.push(event);\n  }\n\n  // Normalize and store the event sequence\n  eventList.replaceAllElements((index: number) => {\n    return events[index];\n  }, events.length);\n\n  return eventList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `getFirst` and `getLast` methods of `Deque<string>` (from @kit.ArkTS) to retrieve the oldest and newest log entries, then passes these entries to the `add` method of `ArrayList<string>` (from @kit.ArkTS) to compile a summary list of log boundaries.",
    "input": "",
    "output": "import {xml, Deque, ArrayList} from '@kit.ArkTS';\n\nexport function compileLogBoundaries(logDeque: Deque<string>, summaryList: ArrayList<string>): void {\n  if (logDeque.length > 0) {\n    const oldestLog = logDeque.getFirst();\n    const newestLog = logDeque.getLast();\n    summaryList.add(oldestLog);\n    summaryList.add(newestLog);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `popFirst` method of `Deque<number>` (from @kit.ArkTS) to process a queue of numeric IDs, checks for duplicates using the `has` method of `ArrayList<number>` (from @kit.ArkTS), and inserts unique IDs into the ArrayList using the `insert` method.",
    "input": "",
    "output": "import {xml, Deque, ArrayList} from '@kit.ArkTS';\n\nexport function processUniqueIDs(queue: Deque<number>, uniqueList: ArrayList<number>): void {\n  while (queue.length > 0) {\n    const id = queue.popFirst();\n    if (!uniqueList.has(id)) {\n      uniqueList.insert(id, uniqueList.length);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `TreeMap` to retrieve all keys, then passes these keys to the `setAll` method of `LightWeightMap` to initialize a new map with the same keys and default values.",
    "input": "",
    "output": "import {stream, TreeMap, LightWeightMap} from '@kit.ArkTS';\n\nexport function transferKeysToLightWeightMap(treeMap: TreeMap<number, string>, defaultValue: string): LightWeightMap<number, string> {\n  const keys = treeMap.keys();\n  const lightWeightMap = new LightWeightMap<number, string>();\n  const keysArray: number[] = [];\n  for (const key of keys) {\n    keysArray.push(key);\n  }\n  lightWeightMap.setAll(keysArray.map(key => [key, defaultValue]));\n  return lightWeightMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getValueAt` method of `LightWeightMap` to retrieve values at specific indices, then uses the `set` method of `TreeMap` to store these values with their corresponding keys in a sorted manner.",
    "input": "",
    "output": "import {stream, TreeMap, LightWeightMap} from '@kit.ArkTS';\n\nexport function transferValuesToTreeMap(lwm: LightWeightMap<number, string>, indices: number[], tm: TreeMap<number, string>): void {\n  indices.forEach((index) => {\n    const value = lwm.getValueAt(index);\n    if (value !== undefined) {\n      tm.set(index, value);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `entries` method of `TreeMap` to get key-value pairs, filters these pairs based on a condition, and then uses the `removeAt` method of `LightWeightMap` to remove entries at the filtered indices from another map.",
    "input": "",
    "output": "import {stream, TreeMap, LightWeightMap} from '@kit.ArkTS';\n\nexport function filterAndRemoveEntries(\n  sourceMap: TreeMap<number, string>,\n  targetMap: LightWeightMap<number, string>,\n  condition: (key: number, value: string) => boolean\n): void {\n  const entries = sourceMap.entries();\n  const indicesToRemove: number[] = [];\n\n  for (const [key, value] of entries) {\n    if (condition(key, value)) {\n      const index = targetMap.getIndexOfKey(key);\n      if (index !== -1) {\n        indicesToRemove.push(index);\n      }\n    }\n  }\n\n  // Sort indices in descending order to avoid index shifting during removal\n  indicesToRemove.sort((a, b) => b - a);\n  \n  for (const index of indicesToRemove) {\n    targetMap.removeAt(index);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getEnvironmentVar` method of `process` to retrieve environment variables, then stores them as key-value pairs in a `HashMap` using its `set` method. Finally, iterate over the `HashMap` using its `forEach` method to print each key-value pair.",
    "input": "",
    "output": "import {Deque, HashMap, process} from '@kit.ArkTS';\n\nexport function storeAndPrintEnvVars(): void {\n  const envVars = new HashMap<string, string>();\n  \n  // Assuming we know some environment variable names to retrieve\n  // For demonstration, we'll try to get a few common ones\n  const envVarNames = ['PATH', 'HOME', 'USER', 'LANG'];\n  \n  envVarNames.forEach((key: string) => {\n    const value = process.getEnvironmentVar(key);\n    if (value !== undefined) {\n      envVars.set(key, value);\n    }\n  });\n  \n  envVars.forEach((value: string, key: string) => {\n    console.log(`${key}=${value}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirst` and `getLast` methods of `Deque` to retrieve the first and last elements of a sequence, then passes these elements to the `set` method of `HashMap` to store them as key-value pairs (e.g., 'first' and 'last' as keys). Use the `keys` method of `HashMap` to verify the stored keys.",
    "input": "",
    "output": "import {Deque, HashMap, process} from '@kit.ArkTS';\n\nexport function storeFirstAndLastElements(deque: Deque<number>): HashMap<string, number> {\n  const hashMap = new HashMap<string, number>();\n  const firstElement = deque.getFirst();\n  const lastElement = deque.getLast();\n  \n  hashMap.set('first', firstElement);\n  hashMap.set('last', lastElement);\n  \n  const keys = hashMap.keys();\n  console.log('Stored keys:', Array.from(keys));\n  \n  return hashMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `uptime` method of `process` to get the system uptime, then inserts this value into a `Deque` using its `insertFront` method. Next, use the `popFirst` method of `Deque` to retrieve the uptime value and pass it to the `replace` method of `HashMap` to update a predefined key (e.g., 'system_uptime').",
    "input": "",
    "output": "import {Deque, HashMap, process} from '@kit.ArkTS';\n\nexport function updateSystemUptimeInHashMap(): void {\n  const uptimeValue: number = process.uptime();\n  const deque: Deque<number> = new Deque<number>();\n  deque.insertFront(uptimeValue);\n  const retrievedUptime: number | undefined = deque.popFirst();\n  \n  const hashMap: HashMap<string, number> = new HashMap<string, number>();\n  hashMap.set('system_uptime', 0);\n  \n  if (retrievedUptime !== undefined) {\n    hashMap.replace('system_uptime', retrievedUptime);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "",
    "input": "",
    "output": "",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then transfers these numbers to a `HashSet` (from @kit.ArkTS) using the `add` method to eliminate duplicates. Finally, use the `values` method of `HashSet` to return the unique values as an array.",
    "input": "",
    "output": "import {HashSet, Stack, WorkerOptions} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[]): number[] {\n  const stack = new Stack<number>();\n  numbers.forEach(num => stack.push(num));\n  \n  const hashSet = new HashSet<number>();\n  while (!stack.isEmpty()) {\n    hashSet.add(stack.pop());\n  }\n  \n  return Array.from(hashSet.values());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a `WorkerOptions` (from @kit.ArkTS) object with a `name` property and passes it to a worker thread. The worker thread should use the `push` method of `Stack` (from @kit.ArkTS) to collect data received from the main thread, then use the `forEach` method of `Stack` to process each item and return the results.",
    "input": "",
    "output": "import {HashSet, Stack, WorkerOptions} from '@kit.ArkTS';\n\nexport function createWorkerOptions(name: string): WorkerOptions {\n  return { name };\n}\n\nexport function setupWorker(workerOptions: WorkerOptions): void {\n  const worker = new Worker('worker.ts', workerOptions);\n  worker.onmessage = (event) => {\n    const stack = new Stack<number>();\n    stack.push(event.data);\n    const results: number[] = [];\n    stack.forEach((item: number) => {\n      results.push(item * 2);\n    });\n    worker.postMessage(results);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the top element of the stack, then uses the `has` method of `HashSet` (from @kit.ArkTS) to verify if the element exists in a predefined set of allowed values. If it exists, the function should use the `pop` method of `Stack` to remove the element; otherwise, it should use the `clear` method of `Stack` to empty the stack.",
    "input": "",
    "output": "import {HashSet, Stack, WorkerOptions} from '@kit.ArkTS';\n\nexport function processStack(stack: Stack<number>, allowedValues: HashSet<number>): void {\n  if (!stack.isEmpty()) {\n    const topElement = stack.peek();\n    if (allowedValues.has(topElement)) {\n      stack.pop();\n    } else {\n      stack.clear();\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addEventListener` method of `EventTarget` to listen for a custom event, and upon triggering the event, uses the `add` and `sort` methods of `List` to collect and sort the event data in a list. The sorted list should then be dispatched as part of another custom event using the `dispatchEvent` method of `EventTarget`.",
    "input": "",
    "output": "import {EventTarget, List, stream} from '@kit.ArkTS';\n\nexport function setupEventListeners(eventTarget: EventTarget): void {\n  const dataList: List<number> = new List();\n\n  eventTarget.addEventListener('collectData', (event: CustomEvent) => {\n    if (event.detail && typeof event.detail === 'number') {\n      dataList.add(event.detail);\n      dataList.sort((a: number, b: number) => a - b);\n\n      const sortedEvent = new CustomEvent('sortedData', {\n        detail: dataList.convertToArray()\n      });\n      eventTarget.dispatchEvent(sortedEvent);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `List` with a sequence of numbers using the `add` method, then uses the `forEach` method of `List` to iterate over the elements and dispatch a custom event for each element using the `dispatchEvent` method of `EventTarget`. The event should contain the current element and its index in the list.",
    "input": "",
    "output": "import {EventTarget, List, stream} from '@kit.ArkTS';\n\nexport function initializeAndDispatchEvents(): void {\n  const eventTarget = new EventTarget();\n  const numberList = new List<number>();\n\n  // Initialize the list with numbers\n  numberList.add(1);\n  numberList.add(2);\n  numberList.add(3);\n\n  // Iterate over the list and dispatch events\n  numberList.forEach((value: number, index: number) => {\n    const event = {\n      type: 'customEvent',\n      detail: {\n        value,\n        index\n      }\n    };\n    eventTarget.dispatchEvent(event);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `removeEventListener` method of `EventTarget` to stop listening to a specific event after it has been triggered once. Before removing the listener, the function should use the `getSubList` method of `List` to extract a subset of data from a predefined list and include this subset in the event payload dispatched via `dispatchEvent` of `EventTarget`.",
    "input": "",
    "output": "import {EventTarget, List, stream} from '@kit.ArkTS';\n\nexport function setupSingleEventListener(eventTarget: EventTarget, eventName: string, list: List<number>, start: number, end: number): void {\n  const eventListener = (event: CustomEvent) => {\n    console.log('Event received:', event.detail);\n    eventTarget.removeEventListener(eventName, eventListener);\n  };\n\n  eventTarget.addEventListener(eventName, eventListener);\n\n  const subList = list.getSubList(start, end);\n  const event = new CustomEvent(eventName, { detail: subList });\n  eventTarget.dispatchEvent(event);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a series of event names, then iterates over the queue using `[Symbol.iterator]` to dispatch each event via the `dispatchEvent` method of `WorkerEventTarget`. The function should also log the length of the queue before and after dispatching events using the `length` property of `Queue`.",
    "input": "",
    "output": "import {WorkerEventTarget, Queue, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function dispatchEventsFromQueue(eventNames: string[], eventTarget: WorkerEventTarget): void {\n  const queue = new Queue<string>();\n  \n  // Enqueue event names\n  eventNames.forEach(eventName => {\n    queue.add(eventName);\n  });\n  \n  // Log initial queue length\n  console.log(`Initial queue length: ${queue.length}`);\n  \n  // Dispatch events using iterator\n  for (const eventName of queue) {\n    eventTarget.dispatchEvent(eventName);\n  }\n  \n  // Log final queue length\n  console.log(`Final queue length: ${queue.length}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `Queue` using its `constructor`, adds error event listeners via the `addEventListener` method of `WorkerEventTarget`, and then triggers an error event by setting the `onerror` property of `WorkerGlobalScope`. The function should use the `getFirst` method of `Queue` to retrieve and log the first error event details.",
    "input": "",
    "output": "import {WorkerEventTarget, Queue, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function initializeAndTriggerErrorEvent(): void {\n  const queue = new Queue<ErrorEvent>();\n  const workerEventTarget = new WorkerEventTarget();\n  const workerGlobalScope = new WorkerGlobalScope();\n\n  workerEventTarget.addEventListener('error', (event: ErrorEvent) => {\n    queue.add(event);\n  });\n\n  workerGlobalScope.onerror = (event: ErrorEvent) => {\n    workerEventTarget.dispatchEvent(event);\n  };\n\n  const errorEvent = new ErrorEvent('error', { message: 'An error occurred' });\n  workerGlobalScope.onerror(errorEvent);\n\n  const firstErrorEvent = queue.getFirst();\n  if (firstErrorEvent) {\n    console.log(`Error event details: ${firstErrorEvent.message}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Queue` to process a list of worker names, checks if the current worker name matches the `name` property of `WorkerGlobalScope`, and removes all event listeners via the `removeAllListener` method of `WorkerEventTarget` if a match is found. The function should also use the `self` property of `WorkerGlobalScope` to verify the worker context.",
    "input": "",
    "output": "import {WorkerEventTarget, Queue, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processWorkerNames(queue: Queue<string>, workerScope: WorkerGlobalScope): void {\n  queue.forEach((workerName: string) => {\n    if (workerName === workerScope.name) {\n      const eventTarget: WorkerEventTarget = workerScope.self as WorkerEventTarget;\n      eventTarget.removeAllListener();\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onerror` property of `WorkerGlobalScope` to handle errors in a worker thread, and then logs the error messages to an `ArrayList<string>` using its `add` method for further analysis.",
    "input": "",
    "output": "import {WorkerGlobalScope, stream, ArrayList} from '@kit.ArkTS';\n\nexport function setupWorkerErrorHandling(errorList: ArrayList<string>): void {\n  const workerScope: WorkerGlobalScope = self as WorkerGlobalScope;\n  workerScope.onerror = (errorEvent: ErrorEvent): void => {\n    errorList.add(errorEvent.message);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that reads data from a stream and stores each chunk of data in an `ArrayList<Uint8Array>` using its `add` method. Then, use the `length` property of `ArrayList` to determine the total number of chunks processed and log the result.",
    "input": "",
    "output": "import {WorkerGlobalScope, stream, ArrayList} from '@kit.ArkTS';\n\nexport function processStreamData(readableStream: stream.Readable): void {\n  const chunks: ArrayList<Uint8Array> = new ArrayList<Uint8Array>();\n\n  readableStream.on('data', (chunk: Uint8Array) => {\n    chunks.add(chunk);\n  });\n\n  readableStream.on('end', () => {\n    console.log(`Total chunks processed: ${chunks.length}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `ArrayList<number>` to iterate over a list of numbers, and for each number, checks if it is even using a worker thread (via `WorkerGlobalScope.self`). The results (even or odd) should be stored in another `ArrayList<string>` using its `add` method.",
    "input": "",
    "output": "import {WorkerGlobalScope, stream, ArrayList} from '@kit.ArkTS';\n\nexport function checkEvenNumbers(numbers: ArrayList<number>): ArrayList<string> {\n  const results: ArrayList<string> = new ArrayList();\n  \n  numbers.forEach((num: number) => {\n    const workerScope: WorkerGlobalScope = WorkerGlobalScope.self;\n    workerScope.onmessage = (event: MessageEvent<number>) => {\n      const isEven = event.data % 2 === 0;\n      results.add(isEven ? 'even' : 'odd');\n    };\n    workerScope.postMessage(num);\n  });\n  \n  return results;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `TreeSet` to store a sequence of timestamps, then retrieves the first and last timestamps using `getFirstValue` and `getLastValue`, and finally passes these values to the `data` property of a `MessageEvent` to create an event object representing the time range.",
    "input": "",
    "output": "import {TreeSet, MessageEvent} from '@kit.ArkTS';\n\nexport function createTimeRangeEvent(timestamps: number[]): MessageEvent<number[]> {\n  const treeSet = new TreeSet<number>();\n  \n  for (const timestamp of timestamps) {\n    treeSet.add(timestamp);\n  }\n  \n  const firstTimestamp = treeSet.getFirstValue();\n  const lastTimestamp = treeSet.getLastValue();\n  \n  return new MessageEvent('timeRange', {\n    data: [firstTimestamp, lastTimestamp]\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that populates a `TreeSet` with numeric values using the `add` method, checks if a specific value exists using the `has` method, and then sends the result (true/false) as part of the `data` property of a `MessageEvent` to notify whether the value was found in the set.",
    "input": "",
    "output": "import {TreeSet, MessageEvent} from '@kit.ArkTS';\n\nexport function checkValueInTreeSet(value: number, valuesToAdd: number[]): MessageEvent<boolean> {\n  const treeSet = new TreeSet<number>();\n  \n  for (const val of valuesToAdd) {\n    treeSet.add(val);\n  }\n  \n  const hasValue = treeSet.has(value);\n  \n  return new MessageEvent<boolean>('checkValue', { data: hasValue });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `TreeSet` to iterate over a set of error codes, filters out duplicates, and then constructs a `MessageEvent` where the `data` property contains the unique error codes as an array, ensuring no duplicates are reported.",
    "input": "",
    "output": "import {TreeSet, MessageEvent} from '@kit.ArkTS';\n\nexport function processErrorCodes(errorCodes: TreeSet<number>): MessageEvent<number[]> {\n  const uniqueErrorCodes: number[] = [];\n  errorCodes.forEach((code: number) => {\n    if (!uniqueErrorCodes.includes(code)) {\n      uniqueErrorCodes.push(code);\n    }\n  });\n  return new MessageEvent('errorCodes', {data: uniqueErrorCodes});\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onerror` property of `GlobalScope` to listen for errors, and then extracts the error details (such as `message`, `filename`, `lineno`, and `colno`) from the `ErrorEvent` object passed to the handler to log them in a structured format.",
    "input": "",
    "output": "import {ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function setupErrorListener(): void {\n  GlobalScope.onerror = (event: ErrorEvent) => {\n    const errorDetails = {\n      message: event.message,\n      filename: event.filename,\n      lineno: event.lineno,\n      colno: event.colno\n    };\n    console.log(JSON.stringify(errorDetails));\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks if the `self` property of `GlobalScope` matches the current context, and if an error occurs (captured via `onerror`), it uses the `error` property of `ErrorEvent` to determine the type of error and take appropriate action based on the error type.",
    "input": "",
    "output": "import {ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function checkGlobalScopeContext(globalScope: GlobalScope): boolean {\n  try {\n    return globalScope.self === globalScope;\n  } catch (error) {\n    globalScope.onerror = (event: ErrorEvent) => {\n      const errorType = event.error;\n      if (errorType instanceof TypeError) {\n        console.error('TypeError occurred:', errorType.message);\n      } else if (errorType instanceof ReferenceError) {\n        console.error('ReferenceError occurred:', errorType.message);\n      } else {\n        console.error('Unknown error occurred:', errorType);\n      }\n    };\n    return false;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `name` property of `GlobalScope` to identify the current context, and when an error is triggered (handled via `onerror`), it uses the `message` and `filename` properties of `ErrorEvent` to create a custom error report specific to the context.",
    "input": "",
    "output": "import {ErrorEvent, GlobalScope} from '@kit.ArkTS';\n\nexport function setupErrorHandler(globalScope: GlobalScope): void {\n  globalScope.onerror = (event: ErrorEvent) => {\n    const contextName = globalScope.name;\n    const errorMessage = event.message;\n    const fileName = event.filename;\n    \n    const customErrorReport = {\n      context: contextName,\n      message: errorMessage,\n      filename: fileName\n    };\n    \n    console.error('Custom Error Report:', customErrorReport);\n    return true;\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a sequence of key-value pairs, then transfers all the keys to a `TreeSet` using its `add` method, and finally uses the `getHigherValue` method of `TreeSet` to find the smallest key in the `TreeSet` that is greater than a given threshold.",
    "input": "",
    "output": "import {PlainArray, TreeSet} from '@kit.ArkTS';\n\nexport function findSmallestKeyGreaterThanThreshold(keys: number[], values: number[], threshold: number): number | undefined {\n  const plainArray = new PlainArray<number, number>();\n  for (let i = 0; i < keys.length; i++) {\n    plainArray.add(keys[i], values[i]);\n  }\n\n  const treeSet = new TreeSet<number>();\n  for (let i = 0; i < plainArray.length; i++) {\n    treeSet.add(plainArray.getKeyAt(i));\n  }\n\n  return treeSet.getHigherValue(threshold);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `getValueAt` method of `PlainArray` to retrieve all values, then adds these values to a `TreeSet` using its `add` method, and finally uses the `popFirst` method of `TreeSet` to remove and return the smallest value from the set.",
    "input": "",
    "output": "import {PlainArray, TreeSet} from '@kit.ArkTS';\n\nexport function processPlainArrayToTreeSet(plainArray: PlainArray<number>): number | undefined {\n  const treeSet = new TreeSet<number>();\n  const length = plainArray.length;\n  \n  for (let i = 0; i < length; i++) {\n    const value = plainArray.getValueAt(i);\n    treeSet.add(value);\n  }\n  \n  return treeSet.popFirst();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `PlainArray` to iterate over all key-value pairs, checks if each value exists in a `TreeSet` using its `has` method, and then uses the `remove` method of `TreeSet` to delete any values that are found in the `PlainArray`.",
    "input": "",
    "output": "import {PlainArray, TreeSet} from '@kit.ArkTS';\n\nexport function removeValuesFromTreeSet(plainArray: PlainArray<number, unknown>, treeSet: TreeSet<unknown>): void {\n  plainArray.forEach((value: unknown, key: number) => {\n    if (treeSet.has(value)) {\n      treeSet.remove(value);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to asynchronously process a list of numbers by squaring each element, then stores the squared values in a `LightWeightSet` using its `addAll` method. Finally, use `LightWeightSet.toArray` to return the processed array.",
    "input": "",
    "output": "import {taskpool, LightWeightSet} from '@kit.ArkTS';\n\nexport async function processNumbers(numbers: number[]): Promise<number[]> {\n  const squaredNumbers = await taskpool.execute(() => {\n    return numbers.map(num => num * num);\n  }, taskpool.Priority.LOW);\n\n  const lightWeightSet = new LightWeightSet<number>();\n  lightWeightSet.addAll(squaredNumbers);\n  \n  return lightWeightSet.toArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses `LightWeightSet.forEach` to iterate over a set of strings and applies a transformation (e.g., converting to uppercase) in a `taskpool.executeDelayed` callback with a 1-second delay. The transformed strings should be collected into a new `LightWeightSet` using its `add` method.",
    "input": "",
    "output": "import {taskpool, LightWeightSet} from '@kit.ArkTS';\n\nexport function transformStringsWithDelay(originalSet: LightWeightSet<string>): Promise<LightWeightSet<string>> {\n  return new Promise((resolve) => {\n    const transformedSet = new LightWeightSet<string>();\n    \n    originalSet.forEach((value: string) => {\n      taskpool.executeDelayed(() => {\n        const transformedValue = value.toUpperCase();\n        transformedSet.add(transformedValue);\n        \n        if (transformedSet.length === originalSet.length) {\n          resolve(transformedSet);\n        }\n      }, 1000);\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task where `taskpool.executePeriodically` is used to periodically (every 2 seconds) check if a `LightWeightSet` (initialized with some values) is empty using its `isEmpty` property. If the set becomes empty, cancel the periodic task using `taskpool.cancel` and log a completion message.",
    "input": "",
    "output": "import {taskpool, LightWeightSet} from '@kit.ArkTS';\n\nexport function executePeriodicCheck(): void {\n  const lightWeightSet = new LightWeightSet<number>();\n  lightWeightSet.add(1);\n  lightWeightSet.add(2);\n  lightWeightSet.add(3);\n\n  const taskId = taskpool.executePeriodically(() => {\n    if (lightWeightSet.isEmpty()) {\n      taskpool.cancel(taskId);\n      console.log('LightWeightSet is empty. Periodic task canceled.');\n    } else {\n      lightWeightSet.removeAt(0);\n    }\n  }, 2000);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of numbers, then passes the resulting `LinkedList` to the `convertToArray` method to create an array, and finally uses the `sort` method of `List` to sort the array in ascending order.",
    "input": "",
    "output": "import {LinkedList, List} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[]): number[] {\n  const linkedList = new LinkedList<number>();\n  for (const num of numbers) {\n    linkedList.add(num);\n  }\n  const array = linkedList.convertToArray();\n  const list = new List<number>();\n  for (const num of array) {\n    list.add(num);\n  }\n  list.sort((a, b) => a - b);\n  return list.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getSubList` method of `List` to extract a sublist of elements, then passes this sublist to the `addFirst` method of `LinkedList` to prepend it to an existing `LinkedList`, and finally uses the `forEach` method of `LinkedList` to print all elements.",
    "input": "",
    "output": "import {LinkedList, List} from '@kit.ArkTS';\n\nexport function processSublistAndLinkedList(sourceList: List<number>, start: number, end: number, targetLinkedList: LinkedList<number>): void {\n  const subList = sourceList.getSubList(start, end);\n  targetLinkedList.addFirst(subList);\n  targetLinkedList.forEach((value: number) => {\n    console.log(value);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `removeFirstFound` method of `LinkedList` to remove a specific element, then checks if the element was successfully removed using the `has` method of `List`, and finally uses the `length` property of both `LinkedList` and `List` to compare their sizes and return the difference.",
    "input": "",
    "output": "import {LinkedList, List} from '@kit.ArkTS';\n\nexport function removeAndCompare(linkedList: LinkedList<number>, list: List<number>, element: number): number {\n  linkedList.removeFirstFound(element);\n  const wasRemoved = !list.has(element);\n  if (wasRemoved) {\n    list.remove(element);\n  }\n  return linkedList.length - list.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to store a sequence of error messages, then iterates through the list using `forEach` to create an `ErrorEvent` object for each message (using the `message` property) and logs the `filename` and `lineno` properties of each error event.",
    "input": "",
    "output": "import {ErrorEvent, LinkedList} from '@kit.ArkTS';\n\nexport function logErrorEvents(messages: string[]): void {\n  const errorList: LinkedList<string> = new LinkedList<string>();\n  \n  messages.forEach((message: string) => {\n    errorList.add(message);\n  });\n  \n  errorList.forEach((message: string) => {\n    const errorEvent: ErrorEvent = new ErrorEvent('error', {\n      message: message,\n      filename: 'script.js',\n      lineno: 1\n    });\n    \n    console.log(`Filename: ${errorEvent.filename}, Line: ${errorEvent.lineno}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that collects error details (message, filename, lineno) into an `ErrorEvent` object, then uses the `insert` method of `LinkedList` to add the error event at a specific index. Finally, use the `get` method of `LinkedList` to retrieve and display the error event's `message` and `colno` properties.",
    "input": "",
    "output": "import {ErrorEvent, LinkedList} from '@kit.ArkTS';\n\nexport function collectAndDisplayError() {\n  const errorList = new LinkedList<ErrorEvent>();\n  \n  // Create an ErrorEvent object\n  const errorEvent = new ErrorEvent('error', {\n    message: 'An error occurred',\n    filename: 'app.ets',\n    lineno: 10,\n    colno: 5,\n    error: null\n  });\n  \n  // Insert the error event at index 0\n  errorList.insert(0, errorEvent);\n  \n  // Retrieve the error event at index 0\n  const retrievedError = errorList.get(0);\n  \n  // Display the message and colno properties\n  if (retrievedError) {\n    console.log(`Message: ${retrievedError.message}`);\n    console.log(`Column Number: ${retrievedError.colno}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `removeFirstFound` method of `LinkedList` to remove an error event based on its `message` property, then checks if the removal was successful using the `has` method. If successful, create a new `ErrorEvent` with the same message and add it back to the end of the list using the `addLast` method.",
    "input": "",
    "output": "import {ErrorEvent, LinkedList} from '@kit.ArkTS';\n\nexport function removeAndReaddErrorEvent(list: LinkedList<ErrorEvent>, message: string): void {\n  const eventToRemove = new ErrorEvent();\n  eventToRemove.message = message;\n  \n  const wasRemoved = list.removeFirstFound(eventToRemove);\n  \n  if (wasRemoved && !list.has(eventToRemove)) {\n    const newEvent = new ErrorEvent();\n    newEvent.message = message;\n    list.addLast(newEvent);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `LightWeightMap` to iterate over key-value pairs and dispatch each key as an event using the `dispatchEvent` method of `WorkerEventTarget`. The function should then use the `clear` method of `LightWeightMap` to empty the map after all events are dispatched.",
    "input": "",
    "output": "import {LightWeightMap, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function dispatchAndClear(map: LightWeightMap<string, string>, eventTarget: WorkerEventTarget): void {\n  map.forEach((value: string, key: string) => {\n    eventTarget.dispatchEvent({type: key, data: value});\n  });\n  map.clear();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if a `LightWeightMap` is empty using the `isEmpty` method, and if it is not, it uses the `keys` method to retrieve all keys and passes them to the `addEventListener` method of `WorkerEventTarget` to register event listeners for each key. The function should then use the `removeAt` method of `LightWeightMap` to remove the first key-value pair after registering the listeners.",
    "input": "",
    "output": "import {LightWeightMap, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function registerAndRemoveFirstKey(lwMap: LightWeightMap<string, unknown>, eventTarget: WorkerEventTarget): void {\n  if (!lwMap.isEmpty()) {\n    const keys = lwMap.keys();\n    for (const key of keys) {\n      eventTarget.addEventListener(key, () => {});\n    }\n    if (lwMap.length > 0) {\n      lwMap.removeAt(0);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getValueAt` method of `LightWeightMap` to retrieve a value at a specific index and then uses the `removeEventListener` method of `WorkerEventTarget` to remove an event listener based on the retrieved value. The function should then update the `LightWeightMap` using the `setValueAt` method to modify the value at the same index.",
    "input": "",
    "output": "import {LightWeightMap, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function updateMapAndRemoveListener(\n  map: LightWeightMap<string, string>,\n  eventTarget: WorkerEventTarget,\n  index: number\n): void {\n  const value = map.getValueAt(index);\n  if (value) {\n    eventTarget.removeEventListener(value, () => {});\n    map.setValueAt(index, `updated_${value}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `self` property of `WorkerGlobalScope` to access the worker's global scope, then constructs a URI using the `uri` API to create a resource path, and finally passes this URI to the `onerror` handler of `WorkerGlobalScope` to handle potential loading errors.",
    "input": "",
    "output": "import {WorkerGlobalScope, uri} from '@kit.ArkTS';\n\nexport function handleWorkerError(): void {\n  const workerScope: WorkerGlobalScope = self;\n  const resourcePath: string = uri.resolve('path/to/resource');\n  \n  workerScope.onerror = (event: ErrorEvent): void => {\n    console.error(`Error loading resource: ${resourcePath}`, event.message);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility that first retrieves the `name` property of `WorkerGlobalScope` to identify the worker context, then uses the `uri` API to encode this name into a URI component, and finally logs the encoded URI component using the `self` property of `WorkerGlobalScope` for debugging purposes.",
    "input": "",
    "output": "import {WorkerGlobalScope, uri} from '@kit.ArkTS';\n\nexport function logEncodedWorkerName(): void {\n  const workerScope: WorkerGlobalScope = self as WorkerGlobalScope;\n  const workerName: string = workerScope.name;\n  const encodedName: string = uri.encodeURIComponent(workerName);\n  workerScope.self.console.log(encodedName);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `uri` API to parse a given URI string into its components, then passes the parsed hostname to the `onerror` property of `WorkerGlobalScope` to simulate a network error scenario, and finally uses the `self` property to verify the error handling flow.",
    "input": "",
    "output": "import {WorkerGlobalScope, uri} from '@kit.ArkTS';\n\nexport function parseUriAndSimulateError(uriString: string): void {\n  const parsedUri = uri.parse(uriString);\n  const workerScope: WorkerGlobalScope = self as WorkerGlobalScope;\n  \n  if (parsedUri.hostname) {\n    workerScope.onerror = (event: ErrorEvent) => {\n      console.error(`Simulated network error for hostname: ${parsedUri.hostname}`);\n      return true; // Indicates the error is handled\n    };\n    \n    // Simulate an error event\n    const errorEvent = new ErrorEvent('error', {\n      message: `Network error for hostname: ${parsedUri.hostname}`,\n      filename: '',\n      lineno: 0,\n      colno: 0,\n      error: new Error('Simulated network error')\n    });\n    \n    workerScope.dispatchEvent(errorEvent);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of messages received from a worker thread via the `onmessage` property of `DedicatedWorkerGlobalScope` (from @kit.ArkTS). After collecting all messages, use the `peek` method of `Stack` to check the last message and post it back to the worker using the `postMessage` method of `DedicatedWorkerGlobalScope`.",
    "input": "",
    "output": "import {Stack, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function handleWorkerMessages(workerScope: DedicatedWorkerGlobalScope): void {\n  const messageStack = new Stack<string>();\n\n  workerScope.onmessage = (event: MessageEvent<string>) => {\n    messageStack.push(event.data);\n  };\n\n  workerScope.onmessage = (event: MessageEvent<string>) => {\n    if (event.data === 'done') {\n      const lastMessage = messageStack.peek();\n      if (lastMessage !== undefined) {\n        workerScope.postMessage(lastMessage);\n      }\n    } else {\n      messageStack.push(event.data);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that initializes a `Stack` (from @kit.ArkTS) and uses its `push` method to store error messages. Then, use the `forEach` method of `Stack` to iterate over the messages and send each one to a worker thread using the `postMessage` method of `DedicatedWorkerGlobalScope` (from @kit.ArkTS). Finally, close the worker using the `close` method of `DedicatedWorkerGlobalScope`.",
    "input": "",
    "output": "import {Stack, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processErrorMessages(worker: DedicatedWorkerGlobalScope): void {\n  const errorStack = new Stack<string>();\n  errorStack.push('Error 1: Invalid input');\n  errorStack.push('Error 2: Network timeout');\n  errorStack.push('Error 3: Resource not found');\n\n  errorStack.forEach((message: string) => {\n    worker.postMessage(message);\n  });\n\n  worker.close();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `length` property of `Stack` (from @kit.ArkTS) to check if the stack is empty. If it is not empty, use the `pop` method to retrieve the top item and send it to a worker thread using the `postMessage` method of `DedicatedWorkerGlobalScope` (from @kit.ArkTS). Repeat this process until the stack is empty, then close the worker using the `close` method of `DedicatedWorkerGlobalScope`.",
    "input": "",
    "output": "import {Stack, DedicatedWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processStack(worker: DedicatedWorkerGlobalScope, stack: Stack<unknown>): void {\n  while (stack.length > 0) {\n    const item = stack.pop();\n    worker.postMessage(item);\n  }\n  worker.close();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `TreeMap<string, number>` (from @kit.ArkTS) to extract all keys, then passes them to the `addAll` method of `ArrayList<string>` (from @kit.ArkTS) to store and sort them in alphabetical order using the `sort` method of `ArrayList`.",
    "input": "",
    "output": "import {ArrayList, TreeMap} from '@kit.ArkTS';\n\nexport function extractAndSortKeys(treeMap: TreeMap<string, number>): ArrayList<string> {\n  const keys = treeMap.keys();\n  const arrayList = new ArrayList<string>();\n  arrayList.addAll(keys);\n  arrayList.sort();\n  return arrayList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `getFirstKey` and `getLastKey` methods of `TreeMap<number, string>` (from @kit.ArkTS) to retrieve the smallest and largest keys, then inserts these values into an `ArrayList<number>` (from @kit.ArkTS) using the `insert` method, and finally trims the ArrayList to its current length using `trimToCurrentLength`.",
    "input": "",
    "output": "import {ArrayList, TreeMap} from '@kit.ArkTS';\n\nexport function processTreeMapKeys(treeMap: TreeMap<number, string>): ArrayList<number> {\n  const firstKey: number | undefined = treeMap.getFirstKey();\n  const lastKey: number | undefined = treeMap.getLastKey();\n  const arrayList = new ArrayList<number>();\n  \n  if (firstKey !== undefined) {\n    arrayList.insert(firstKey, 0);\n  }\n  \n  if (lastKey !== undefined) {\n    arrayList.insert(lastKey, arrayList.length);\n  }\n  \n  arrayList.trimToCurrentLength();\n  return arrayList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `values` method of `TreeMap<string, boolean>` (from @kit.ArkTS) to collect all values, then checks if any of these values are `true` using the `has` method of `ArrayList<boolean>` (from @kit.ArkTS), and returns the result.",
    "input": "",
    "output": "import {ArrayList, TreeMap} from '@kit.ArkTS';\n\nexport function hasTrueValue(map: TreeMap<string, boolean>): boolean {\n  const values: ArrayList<boolean> = map.values();\n  return values.has(true);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addEventListener` method of `WorkerEventTarget` to listen for a 'message' event, and then uses the `transfer` property of `PostMessageOptions` to send the received data to another worker with ownership transfer.",
    "input": "",
    "output": "import {PostMessageOptions, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function listenAndTransferMessage(sourceWorker: WorkerEventTarget, targetWorker: Worker): void {\n  sourceWorker.addEventListener('message', (event: MessageEvent) => {\n    if (event.data instanceof ArrayBuffer) {\n      const options: PostMessageOptions = {\n        transfer: [event.data]\n      };\n      targetWorker.postMessage(event.data, options);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first dispatches a custom event using the `dispatchEvent` method of `WorkerEventTarget`, and then uses the `transfer` property of `PostMessageOptions` to send the event details to a main thread, ensuring the data is transferred efficiently.",
    "input": "",
    "output": "import {PostMessageOptions, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function dispatchAndTransferEvent(eventTarget: WorkerEventTarget, eventType: string, eventDetail: ArrayBuffer, postMessageOptions: PostMessageOptions): void {\n  const event = { type: eventType, detail: eventDetail };\n  eventTarget.dispatchEvent(event);\n  postMessageOptions.transfer = [eventDetail];\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `removeEventListener` method of `WorkerEventTarget` to stop listening for a specific event, and then uses the `transfer` property of `PostMessageOptions` to send a confirmation message to another worker, indicating the listener has been removed.",
    "input": "",
    "output": "import {PostMessageOptions, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function removeListenerAndConfirm(\n  eventTarget: WorkerEventTarget,\n  eventType: string,\n  listener: EventListener,\n  targetWorker: Worker,\n  transferBuffer: ArrayBuffer\n): void {\n  eventTarget.removeEventListener(eventType, listener);\n  \n  const options: PostMessageOptions = {\n    transfer: [transferBuffer]\n  };\n  \n  targetWorker.postMessage('Listener removed', options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getSubList` method of `List` to extract a subset of elements, then converts this subset to an array using `convertToArray`, and finally parses the array into an XML string using the `xml` API to store the data in a structured format.",
    "input": "",
    "output": "import {xml, List} from '@kit.ArkTS';\n\nexport function processSubListToXml(list: List<string>, start: number, end: number): string {\n  const subList = list.getSubList(start, end);\n  const subArray = subList.convertToArray();\n  const xmlString = xml.parse(subArray);\n  return xmlString;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `forEach` method of `List` to iterate over its elements and apply a transformation, then checks if the transformed list is empty using `isEmpty`, and finally generates an XML event log entry using the `EventType` enum from the `xml` API to categorize the operation.",
    "input": "",
    "output": "import {xml, List} from '@kit.ArkTS';\n\nexport function processListAndLogEvent<T, U>(list: List<T>, transform: (value: T) => U): void {\n  const transformedList: List<U> = new List<U>();\n  \n  list.forEach((value: T) => {\n    transformedList.add(transform(value));\n  });\n  \n  const isEmpty: boolean = transformedList.isEmpty();\n  \n  const eventType: xml.EventType = isEmpty ? xml.EventType.EMPTY : xml.EventType.NON_EMPTY;\n  \n  // Log the event (assuming there's a method to log events in the xml module)\n  // This part is hypothetical since the actual logging method isn't specified in the API\n  console.log(`Event logged with type: ${eventType}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `sort` method of `List` to order a list of items, then retrieves the first and last items using `getFirst` and `getLast`, and constructs an XML structure using the `xml` API to represent the sorted list along with its boundary values.",
    "input": "",
    "output": "import {xml, List} from '@kit.ArkTS';\n\nexport function sortAndGetBoundaries<T>(list: List<T>, compareFn?: (a: T, b: T) => number): xml.Element {\n  const sortedList = new List<T>();\n  for (const item of list) {\n    sortedList.add(item);\n  }\n  sortedList.sort(compareFn);\n  \n  const firstItem = sortedList.getFirst();\n  const lastItem = sortedList.getLast();\n  \n  const xmlBuilder = new xml.Element('SortedList');\n  const boundaries = new xml.Element('Boundaries');\n  boundaries.setAttribute('first', String(firstItem));\n  boundaries.setAttribute('last', String(lastItem));\n  xmlBuilder.appendChild(boundaries);\n  \n  const itemsElement = new xml.Element('Items');\n  for (const item of sortedList) {\n    const itemElement = new xml.Element('Item');\n    itemElement.textContent = String(item);\n    itemsElement.appendChild(itemElement);\n  }\n  xmlBuilder.appendChild(itemsElement);\n  \n  return xmlBuilder;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `name` property of `GlobalScope` to retrieve the current context name, then passes this name as a parameter to the `url` API to construct a complete URL string. The function should return the constructed URL.",
    "input": "",
    "output": "import {GlobalScope, url} from '@kit.ArkTS';\n\nexport function constructUrl(): string {\n  const contextName = GlobalScope.name;\n  const completeUrl = url.URL(contextName);\n  return completeUrl.toString();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that sets up an error handler using the `onerror` property of `GlobalScope` to capture any runtime errors, then uses the `url` API to log the error details (including the error message and stack trace) to a remote error tracking service by constructing a specific error-reporting URL.",
    "input": "",
    "output": "import {GlobalScope, url} from '@kit.ArkTS';\n\nexport function setupErrorHandler(remoteServiceUrl: string): void {\n  GlobalScope.onerror = (error: ErrorEvent) => {\n    const errorDetails = {\n      message: error.message,\n      stack: error.error?.stack || 'No stack trace available'\n    };\n\n    const queryParams = new url.URLSearchParams();\n    queryParams.append('message', errorDetails.message);\n    queryParams.append('stack', errorDetails.stack);\n\n    const errorReportingUrl = `${remoteServiceUrl}?${queryParams.toString()}`;\n    console.log(`Error reported to: ${errorReportingUrl}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if the `self` property of `GlobalScope` matches a given URL (constructed using the `url` API). The function should return `true` if the URLs match (after normalization) and `false` otherwise.",
    "input": "",
    "output": "import {GlobalScope, url} from '@kit.ArkTS';\n\nexport function checkUrlMatch(givenUrl: string): boolean {\n  const selfUrl = GlobalScope.self.toString();\n  const normalizedSelfUrl = new url.URL(selfUrl).toString();\n  const normalizedGivenUrl = new url.URL(givenUrl).toString();\n  return normalizedSelfUrl === normalizedGivenUrl;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to run a background task (defined by `CallbackFunction`), and then logs the `timeStamp` and `type` properties of the `Event` object emitted when the task completes. The function should handle errors using `CallbackFunctionWithError` and log the error event details.",
    "input": "",
    "output": "import {Event, taskpool} from '@kit.ArkTS';\n\nexport function runBackgroundTask(task: taskpool.CallbackFunction, errorHandler: taskpool.CallbackFunctionWithError): void {\n  taskpool.execute(task, {\n    onSuccess: (event: Event) => {\n      console.log(`Task completed with timeStamp: ${event.timeStamp}, type: ${event.type}`);\n    },\n    onError: (errorEvent: Event) => {\n      console.log(`Error occurred with timeStamp: ${errorEvent.timeStamp}, type: ${errorEvent.type}`);\n      errorHandler(errorEvent);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a task scheduler that uses `taskpool.executePeriodically` to run a function every 5 seconds, and for each execution, log the `timeStamp` of the `Event` object generated at the start of the task. The scheduler should also use `taskpool.getTaskPoolInfo` to monitor the task pool state and terminate the task if the pool exceeds a certain threshold using `taskpool.terminateTask`.",
    "input": "",
    "output": "import {Event, taskpool} from '@kit.ArkTS';\n\nexport function logTimeStamp(event: Event): void {\n  console.log(`Task executed at timestamp: ${event.timeStamp}`);\n}\n\nexport function monitorTaskPool(): void {\n  const taskInfo = taskpool.getTaskPoolInfo();\n  const threshold = 100; // Example threshold\n  if (taskInfo.runningCount > threshold) {\n    console.log(`Task pool exceeded threshold: ${taskInfo.runningCount}`);\n    taskpool.terminateTask();\n  }\n}\n\nexport function startPeriodicTask(): void {\n  const taskId = taskpool.executePeriodically(\n    (event: Event) => {\n      logTimeStamp(event);\n      monitorTaskPool();\n    },\n    5000 // 5 seconds\n  );\n}\n\nexport function stopPeriodicTask(taskId: number): void {\n  taskpool.cancel(taskId);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a delayed task execution system where `taskpool.executeDelayed` is used to schedule a task after a 3-second delay, and upon completion, the task emits an `Event` whose `type` property is checked to determine if the task succeeded. If the event type indicates success, use `taskpool.isConcurrent` to verify if the task ran concurrently and log the result.",
    "input": "",
    "output": "import {Event, taskpool} from '@kit.ArkTS';\n\nexport function executeDelayedTask(): void {\n  const task = () => {\n    return 'Task completed successfully';\n  };\n\n  taskpool.executeDelayed(task, 3000).then((event: Event) => {\n    if (event.type === 'success') {\n      const isConcurrent = taskpool.isConcurrent();\n      console.log(`Task succeeded. Ran concurrently: ${isConcurrent}`);\n    } else {\n      console.log('Task failed');\n    }\n  }).catch((error: Error) => {\n    console.error(`Error executing task: ${error.message}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a list of 5 unique UUIDs, then stores them in a `LinkedList` using its `add` method. Finally, iterate over the `LinkedList` using `Symbol.iterator` and print each UUID using `util.printf`.",
    "input": "",
    "output": "import {LinkedList, util} from '@kit.ArkTS';\n\nexport function generateAndPrintUUIDs(): void {\n  const uuidList: LinkedList<string> = new LinkedList<string>();\n  \n  for (let i = 0; i < 5; i++) {\n    const uuid: string = util.generateRandomUUID();\n    uuidList.add(uuid);\n  }\n  \n  const iterator: IterableIterator<string> = uuidList[Symbol.iterator]();\n  for (const uuid of iterator) {\n    util.printf('%s', uuid);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a `LinkedList` of strings using its `addFirst` and `addLast` methods, then converts the list to an array using `convertToArray`. Pass this array to `util.getHash` to compute a hash value for the entire collection and return it.",
    "input": "",
    "output": "import {LinkedList, util} from '@kit.ArkTS';\n\nexport function computeLinkedListHash(): string {\n  const list = new LinkedList<string>();\n  list.addFirst('first');\n  list.addLast('last');\n  const array = list.convertToArray();\n  return util.getHash(array);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `util.callbackWrapper` to asynchronously fetch a list of numbers, then inserts them into a `LinkedList` using its `insert` method at specific indices. Finally, use the `LinkedList`'s `removeFirstFound` and `removeLastFound` methods to clean up any duplicate values and return the modified list.",
    "input": "",
    "output": "import {LinkedList, util} from '@kit.ArkTS';\n\nexport async function processNumbersAsync(numbers: number[], indices: number[]): Promise<LinkedList<number>> {\n  const list = new LinkedList<number>();\n  \n  // Asynchronously fetch numbers using callbackWrapper\n  const fetchNumbers = util.callbackWrapper(async (callback: (nums: number[]) => void) => {\n    callback(numbers);\n  });\n  \n  const fetchedNumbers = await new Promise<number[]>((resolve) => {\n    fetchNumbers((nums: number[]) => {\n      resolve(nums);\n    });\n  });\n  \n  // Insert numbers at specified indices\n  for (let i = 0; i < fetchedNumbers.length; i++) {\n    const num = fetchedNumbers[i];\n    const index = indices[i % indices.length];\n    list.insert(index, num);\n  }\n  \n  // Remove duplicates\n  const uniqueNumbers = new Set<number>();\n  const duplicates = new Set<number>();\n  \n  for (const num of list) {\n    if (uniqueNumbers.has(num)) {\n      duplicates.add(num);\n    } else {\n      uniqueNumbers.add(num);\n    }\n  }\n  \n  for (const num of duplicates) {\n    list.removeFirstFound(num);\n    list.removeLastFound(num);\n  }\n  \n  return list;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `parse` method of `json` to convert a JSON string into an object, then checks if a specific key exists in the object using the `has` method of `json`, and finally sends the result as part of a `MessageEvent` by setting the `data` property.",
    "input": "",
    "output": "import {json, MessageEvent} from '@kit.ArkTS';\n\nexport function checkKeyInJson(jsonString: string, key: string): MessageEvent<boolean> {\n  const parsedObject = json.parse(jsonString);\n  const hasKey = json.has(parsedObject, key);\n  const messageEvent = new MessageEvent<boolean>('keyCheck', {data: hasKey});\n  return messageEvent;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first removes a specified key from an object using the `remove` method of `json`, then converts the modified object back to a JSON string using the `stringify` method of `json`, and finally sends this string as the `data` property of a `MessageEvent`.",
    "input": "",
    "output": "import {json, MessageEvent} from '@kit.ArkTS';\n\nexport function processAndSendEvent(obj: object, key: string): MessageEvent<string> {\n  json.remove(obj, key);\n  const jsonString = json.stringify(obj);\n  return new MessageEvent('message', {data: jsonString});\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that receives a `MessageEvent`, parses its `data` property (assumed to be a JSON string) into an object using the `parse` method of `json`, then checks if the parsed object contains a specific key using the `has` method of `json`, and returns the result.",
    "input": "",
    "output": "import {json, MessageEvent} from '@kit.ArkTS';\n\nexport function checkMessageEventForKey(event: MessageEvent<string>, key: string): boolean {\n  const parsedData = json.parse(event.data);\n  return json.has(parsedData, key);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `taskpool.execute` to asynchronously process a list of key-value pairs by inserting them into a `LightWeightMap`. The function should then use `LightWeightMap.forEach` to log all key-value pairs after the asynchronous insertion is complete. The task must be executed with `Priority.HIGH`.",
    "input": "",
    "output": "import {taskpool, LightWeightMap} from '@kit.ArkTS';\n\nexport function processKeyValuePairsAsync(keyValuePairs: [string, number][]): void {\n  const map = new LightWeightMap<string, number>();\n  \n  const task = new taskpool.Task(() => {\n    keyValuePairs.forEach(([key, value]) => {\n      map.set(key, value);\n    });\n    return map;\n  });\n  \n  taskpool.execute(task, taskpool.Priority.HIGH).then(() => {\n    map.forEach((value, key) => {\n      console.log(`Key: ${key}, Value: ${value}`);\n    });\n  }).catch((error) => {\n    console.error(`Error processing key-value pairs: ${error}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses `LightWeightMap.keys` to retrieve all keys from a map, then schedules a delayed task using `taskpool.executeDelayed` to remove each key from the `LightWeightMap` after a 2-second delay. The delayed task should use `LightWeightMap.remove` for each key.",
    "input": "",
    "output": "import {taskpool, LightWeightMap} from '@kit.ArkTS';\n\nexport function removeKeysAfterDelay(map: LightWeightMap<number, unknown>): void {\n  const keys = map.keys();\n  taskpool.executeDelayed(() => {\n    for (const key of keys) {\n      map.remove(key);\n    }\n  }, 2000);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if a `LightWeightMap` is empty using `LightWeightMap.isEmpty`. If the map is not empty, use `taskpool.executePeriodically` to log the map's `length` property every second until the map is cleared using `LightWeightMap.clear`.",
    "input": "",
    "output": "import {taskpool, LightWeightMap} from '@kit.ArkTS';\n\nexport function checkAndLogMap(map: LightWeightMap<unknown, unknown>): void {\n  if (map.isEmpty()) {\n    console.log('Map is empty');\n  } else {\n    const taskId = taskpool.executePeriodically(() => {\n      console.log(`Map length: ${map.length}`);\n      if (map.isEmpty()) {\n        taskpool.cancel(taskId);\n      }\n    }, 1000);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Vector` to collect a sequence of numbers, then passes the resulting Vector to the `setAll` method of `TreeMap` to store the numbers as keys with their squares as values. Finally, use the `getHigherKey` method of `TreeMap` to find the smallest key greater than a given threshold.",
    "input": "",
    "output": "import {Vector, TreeMap} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[], threshold: number): number | undefined {\n  const vector = new Vector<number>();\n  numbers.forEach(num => vector.add(num));\n\n  const treeMap = new TreeMap<number, number>();\n  treeMap.setAll(vector);\n\n  vector.forEach(key => {\n    treeMap.set(key, key * key);\n  });\n\n  return treeMap.getHigherKey(threshold);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `getFirstElement` and `getLastElement` methods of `Vector` to extract the first and last elements, then inserts them into a `TreeMap` using the `set` method with custom values. Use the `entries` method of `TreeMap` to iterate and print all key-value pairs.",
    "input": "",
    "output": "import {Vector, TreeMap} from '@kit.ArkTS';\n\nexport function processVectorToTreeMap(vector: Vector<number>): void {\n  if (vector.isEmpty()) {\n    return;\n  }\n\n  const firstElement = vector.getFirstElement();\n  const lastElement = vector.getLastElement();\n\n  const treeMap = new TreeMap<number, string>();\n  treeMap.set(firstElement, `First: ${firstElement}`);\n  treeMap.set(lastElement, `Last: ${lastElement}`);\n\n  const iterator = treeMap.entries();\n  let entry = iterator.next();\n  while (!entry.done) {\n    const [key, value] = entry.value;\n    console.log(`Key: ${key}, Value: ${value}`);\n    entry = iterator.next();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `convertToArray` method of `Vector` to transform a Vector of strings into an array, then passes this array to the `replaceAllElements` method of another Vector. Use the `sort` method of the second Vector to alphabetize the strings, and then the `values` method of `TreeMap` to store the sorted strings as values with their lengths as keys.",
    "input": "",
    "output": "import {Vector, TreeMap} from '@kit.ArkTS';\n\nexport function transformAndSortStrings(sourceVector: Vector<string>, targetVector: Vector<string>, treeMap: TreeMap<number, string>): void {\n  const stringArray: string[] = sourceVector.convertToArray();\n  targetVector.replaceAllElements(stringArray);\n  targetVector.sort();\n  \n  for (const value of targetVector) {\n    treeMap.set(value.length, value);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `stream` API to read data from a file and then passes the read data as a message using the `PostMessageOptions` API, ensuring the data is transferred efficiently by setting the `transfer` property appropriately.",
    "input": "",
    "output": "import {stream, PostMessageOptions} from '@kit.ArkTS';\n\nexport function readFileAndPostMessage(filePath: string, target: Worker): void {\n  const readableStream = stream.createReadableStream(filePath);\n  const buffer = new ArrayBuffer(1024);\n  \n  readableStream.read(buffer).then((bytesRead: number) => {\n    if (bytesRead > 0) {\n      const options: PostMessageOptions = {\n        transfer: [buffer]\n      };\n      target.postMessage(buffer, options);\n    }\n  }).catch((error: Error) => {\n    console.error(`Error reading file: ${error.message}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `stream` API to write data to a file, then sends a confirmation message using the `PostMessageOptions` API, where the message includes the file handle and the `transfer` property is used to transfer ownership of the file handle.",
    "input": "",
    "output": "import {stream, PostMessageOptions} from '@kit.ArkTS';\n\nexport function writeAndTransfer(filePath: string, data: string): void {\n  const writableStream = stream.createWritableStream(filePath);\n  writableStream.write(data, (err) => {\n    if (err) {\n      console.error(`Failed to write data: ${err.message}`);\n      return;\n    }\n    writableStream.close((closeErr) => {\n      if (closeErr) {\n        console.error(`Failed to close stream: ${closeErr.message}`);\n        return;\n      }\n      const options: PostMessageOptions = {\n        transfer: [writableStream.buffer]\n      };\n      const message = {\n        fileHandle: writableStream,\n        status: 'Data written successfully'\n      };\n      postMessage(message, options);\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that reads data from a stream using the `stream` API, processes the data to extract specific information, and then sends the processed data as a message using the `PostMessageOptions` API, with the `transfer` property set to optimize performance.",
    "input": "",
    "output": "import {stream, PostMessageOptions} from '@kit.ArkTS';\n\nexport function processStreamData(readableStream: stream.Readable): void {\n  const chunks: ArrayBuffer[] = [];\n\n  readableStream.on('data', (chunk: ArrayBuffer) => {\n    chunks.push(chunk);\n  });\n\n  readableStream.on('end', () => {\n    const combinedData = concatenateBuffers(chunks);\n    const processedData = extractInformation(combinedData);\n    \n    const options: PostMessageOptions = {\n      transfer: [processedData.buffer]\n    };\n    \n    postMessage(processedData, options);\n  });\n\n  readableStream.on('error', (error: Error) => {\n    console.error(`Stream error: ${error.message}`);\n  });\n}\n\nfunction concatenateBuffers(buffers: ArrayBuffer[]): Uint8Array {\n  let totalLength = 0;\n  buffers.forEach(buffer => {\n    totalLength += buffer.byteLength;\n  });\n  \n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  buffers.forEach(buffer => {\n    result.set(new Uint8Array(buffer), offset);\n    offset += buffer.byteLength;\n  });\n  \n  return result;\n}\n\nfunction extractInformation(data: Uint8Array): ArrayBuffer {\n  // Example processing: extract first 100 bytes\n  const extractedData = data.slice(0, 100);\n  return extractedData.buffer;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertEnd` method of `Deque` (from @kit.ArkTS) to collect a sequence of numbers, then passes the deque to the `Symbol.iterator` method of `Deque` to iterate over the elements and calculate their sum using a loop.",
    "input": "",
    "output": "import {stream, Deque} from '@kit.ArkTS';\n\nexport function calculateSum(numbers: number[]): number {\n  const deque = new Deque<number>();\n  \n  for (const num of numbers) {\n    deque.insertEnd(num);\n  }\n  \n  let sum = 0;\n  for (const num of deque[Symbol.iterator]()) {\n    sum += num;\n  }\n  \n  return sum;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `popLast` methods of `Deque` (from @kit.ArkTS) to reverse a given array of strings, then uses the `forEach` method of `Deque` to print each reversed string in uppercase.",
    "input": "",
    "output": "import {stream, Deque} from '@kit.ArkTS';\n\nexport function reverseAndPrintUppercase(arr: string[]): void {\n  const deque = new Deque<string>();\n  \n  // Insert each element from the array to the front of the deque\n  arr.forEach((str) => {\n    deque.insertFront(str);\n  });\n  \n  // Pop each element from the end of the deque and print in uppercase\n  deque.forEach((str) => {\n    console.log(str.toUpperCase());\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirst` and `getLast` methods of `Deque` (from @kit.ArkTS) to check if the first and last elements of a deque are equal, and then uses the `has` method of `Deque` to verify if a specific value exists in the deque, returning a boolean result based on both checks.",
    "input": "",
    "output": "import {stream, Deque} from '@kit.ArkTS';\n\nexport function checkDeque(deque: Deque<number>, value: number): boolean {\n  const firstElement = deque.getFirst();\n  const lastElement = deque.getLast();\n  const hasValue = deque.has(value);\n  return (firstElement === lastElement) && hasValue;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a new Worker with a specified name and shared flag using the `WorkerOptions` API, then sends a message to the Worker containing an object with a `data` property using the `MessageEvents` API. The function should return the Worker instance after sending the message.",
    "input": "",
    "output": "import {MessageEvents, WorkerOptions} from '@kit.ArkTS';\n\nexport function createAndSendMessageToWorker(workerScriptURL: string, workerName: string, isShared: boolean, messageData: object): Worker {\n  const workerOptions: WorkerOptions = {\n    name: workerName,\n    shared: isShared\n  };\n  \n  const worker = new Worker(workerScriptURL, workerOptions);\n  worker.postMessage({ data: messageData });\n  \n  return worker;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that listens for messages from a Worker using the `MessageEvents` API, extracts the `data` property from the received message, and uses it to dynamically set the `name` property of a new `WorkerOptions` object. The function should return the configured `WorkerOptions` object.",
    "input": "",
    "output": "import {MessageEvents, WorkerOptions} from '@kit.ArkTS';\n\nexport function configureWorkerOptionsFromMessage(event: MessageEvents): WorkerOptions {\n  const data = event.data;\n  const options: WorkerOptions = {\n    name: data\n  };\n  return options;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that initializes a Worker with `WorkerOptions` (setting both `name` and `shared` properties), then sends a series of messages to the Worker using the `MessageEvents` API, each containing a different `data` payload. The function should return an array of all the `data` properties sent to the Worker.",
    "input": "",
    "output": "import {MessageEvents, WorkerOptions} from '@kit.ArkTS';\n\nexport function initializeWorkerAndSendMessages(): Array<unknown> {\n  const workerOptions: WorkerOptions = {\n    name: 'exampleWorker',\n    shared: true\n  };\n\n  const worker = new Worker('worker.js', workerOptions);\n  const messages: Array<unknown> = [];\n\n  const message1 = { data: 'First message' };\n  const message2 = { data: 12345 };\n  const message3 = { data: { key: 'value' } };\n\n  worker.postMessage(message1.data);\n  messages.push(message1.data);\n  worker.postMessage(message2.data);\n  messages.push(message2.data);\n  worker.postMessage(message3.data);\n  messages.push(message3.data);\n\n  return messages;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that listens for a `MessageEvent` and extracts the `data` property, then uses the extracted data to construct a URL by passing it to the `url` API. The function should return the constructed URL.",
    "input": "",
    "output": "import {MessageEvent, url} from '@kit.ArkTS';\n\nexport function constructUrlFromMessageEvent(event: MessageEvent<string>): string {\n  const eventData = event.data;\n  return url.URL.parse(eventData).toString();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes a URL string, processes it using the `url` API to extract specific components (e.g., hostname or path), and then sends the extracted components as `data` in a `MessageEvent` to another part of the application.",
    "input": "",
    "output": "import {MessageEvent, url} from '@kit.ArkTS';\n\nexport function processAndSendUrlComponents(urlString: string): void {\n  try {\n    const parsedUrl = new url.URL(urlString);\n    const components = {\n      hostname: parsedUrl.hostname,\n      path: parsedUrl.pathname\n    };\n    const messageEvent = new MessageEvent('urlComponents', {\n      data: components\n    });\n    // In a real application, you would dispatch this event to the target\n    // For example: target.dispatchEvent(messageEvent);\n  } catch (error) {\n    console.error('Error parsing URL:', error);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that receives a `MessageEvent`, checks if the `data` property contains a valid URL (using the `url` API for validation), and then either logs the validated URL or throws an error if the URL is invalid.",
    "input": "",
    "output": "import {MessageEvent, url} from '@kit.ArkTS';\n\nexport function validateAndLogUrl(event: MessageEvent<string>): void {\n  try {\n    new url.URL(event.data);\n    console.log(`Valid URL: ${event.data}`);\n  } catch (error) {\n    throw new Error(`Invalid URL: ${event.data}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `parse` method of `json` to convert a JSON string into an object, then uses the `add` and `get` methods of `LinkedList` to store and retrieve specific values from the parsed object.",
    "input": "",
    "output": "import {json, LinkedList} from '@kit.ArkTS';\n\nexport function parseAndStoreJSON(jsonString: string, keyToStore: string): LinkedList<string> {\n  const parsedObject = json.parse(jsonString);\n  const linkedList = new LinkedList<string>();\n  \n  if (parsedObject && typeof parsedObject === 'object' && !Array.isArray(parsedObject)) {\n    for (const key in parsedObject) {\n      if (key === keyToStore) {\n        linkedList.add(parsedObject[key]);\n      }\n    }\n  }\n  \n  return linkedList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `stringify` method of `json` to convert a `LinkedList` object into a JSON string, then uses the `has` method of `json` to check if a specific key exists in the resulting JSON string before performing further operations.",
    "input": "",
    "output": "import {json, LinkedList} from '@kit.ArkTS';\n\nexport function processLinkedList(list: LinkedList<any>, key: string): boolean {\n  const jsonString = json.stringify(list);\n  const jsonObj = json.parse(jsonString);\n  return json.has(jsonObj, key);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LinkedList` to iterate over its elements, then applies the `remove` method of `json` to delete specific properties from each element if they meet certain conditions, and finally uses the `convertToArray` method of `LinkedList` to return the modified elements as an array.",
    "input": "",
    "output": "import {json, LinkedList} from '@kit.ArkTS';\n\nexport function processLinkedList(linkedList: LinkedList<Record<string, unknown>>, condition: (key: string, value: unknown) => boolean): Array<Record<string, unknown>> {\n  linkedList.forEach((element: Record<string, unknown>) => {\n    for (const key in element) {\n      if (condition(key, element[key])) {\n        json.remove(element, key);\n      }\n    }\n  });\n  return linkedList.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` to collect a sequence of `MessageEvent` objects, then iterates over the deque using `[Symbol.iterator]` to extract and process the `data` property from each `MessageEvent`.",
    "input": "",
    "output": "import {MessageEvent, Deque} from '@kit.ArkTS';\n\nexport function processMessageEvents(events: MessageEvent<string>[]): void {\n  const deque = new Deque<MessageEvent<string>>();\n  \n  // Insert events into the deque\n  for (const event of events) {\n    deque.insertFront(event);\n    deque.insertEnd(event);\n  }\n  \n  // Process each event's data\n  for (const event of deque) {\n    const data = event.data;\n    // Process data here\n    console.log(data);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `popFirst` method of `Deque` to remove and retrieve the first `MessageEvent` object, then accesses its `data` property to perform a validation check, and finally uses the `insertEnd` method to re-insert the object if the validation fails.",
    "input": "",
    "output": "import {MessageEvent, Deque} from '@kit.ArkTS';\n\nexport function validateAndReinsert(deque: Deque<MessageEvent<string>>): void {\n  if (deque.length === 0) {\n    return;\n  }\n  \n  const messageEvent: MessageEvent<string> | undefined = deque.popFirst();\n  \n  if (messageEvent && !messageEvent.data) {\n    deque.insertEnd(messageEvent);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Deque` to process each `MessageEvent` object in the deque, extracting the `data` property and storing it in a new array, then uses the `length` property of `Deque` to verify the number of processed events matches the deque's original size.",
    "input": "",
    "output": "import {MessageEvent, Deque} from '@kit.ArkTS';\n\nexport function processMessageEvents(deque: Deque<MessageEvent<string>>): string[] {\n  const processedData: string[] = [];\n  const originalLength = deque.length;\n  \n  deque.forEach((event: MessageEvent<string>) => {\n    processedData.push(event.data);\n  });\n  \n  if (processedData.length !== originalLength) {\n    throw new Error('Processed events count does not match deque original size');\n  }\n  \n  return processedData;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a `PostMessageOptions` object with the `transfer` property set to an array of resources, then uses this object to send a message via `postMessage`. The receiving end should extract the message content using the `data` property of the `MessageEvent` object and log it.",
    "input": "",
    "output": "import {PostMessageOptions, MessageEvent} from '@kit.ArkTS';\n\nexport function sendMessageWithTransfer(message: string, transfer: ArrayBuffer[]): void {\n  const options: PostMessageOptions = {\n    transfer: transfer\n  };\n  postMessage(message, options);\n}\n\nexport function handleMessage(event: MessageEvent<string>): void {\n  console.log(event.data);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a message handler that processes incoming `MessageEvent` objects, checks the `data` property for a specific command, and if found, creates a new `PostMessageOptions` object with the `transfer` property set to a response message. The response should then be sent back using `postMessage`.",
    "input": "",
    "output": "import {PostMessageOptions, MessageEvent} from '@kit.ArkTS';\n\nexport function handleMessageEvent(event: MessageEvent<string>): void {\n  if (event.data === 'specificCommand') {\n    const response: ArrayBuffer = new ArrayBuffer(8);\n    const options: PostMessageOptions = {\n      transfer: [response]\n    };\n    postMessage('responseMessage', options);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that sends a structured message using `postMessage` with a `PostMessageOptions` object where the `transfer` property specifies certain resources. The receiver should validate the `data` property of the `MessageEvent` to ensure it matches the expected format, and if valid, use the transferred resources to perform a specific action.",
    "input": "",
    "output": "import {PostMessageOptions, MessageEvent} from '@kit.ArkTS';\n\nexport function sendStructuredMessage(target: Worker, data: {type: string, payload: object}, transferList: ArrayBuffer[]): void {\n  const options: PostMessageOptions = {\n    transfer: transferList\n  };\n  target.postMessage(data, options);\n}\n\nexport function validateAndUseMessage(event: MessageEvent<{type: string, payload: object}>): void {\n  const expectedType = 'expectedType';\n  if (event.data && event.data.type === expectedType) {\n    // Perform specific action with the transferred resources\n    console.log('Valid message received:', event.data.payload);\n  } else {\n    console.error('Invalid message format');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then iterates over the stack using the `Symbol.iterator` method to calculate the sum of all elements, and finally uses the `write` method of `stream` (from @kit.ArkTS) to output the result.",
    "input": "",
    "output": "import {stream, Stack} from '@kit.ArkTS';\n\nexport function calculateAndOutputSum(numbers: number[]): void {\n  const stack = new Stack<number>();\n  \n  // Push all numbers into the stack\n  numbers.forEach((num) => {\n    stack.push(num);\n  });\n  \n  // Calculate the sum of all elements in the stack\n  let sum = 0;\n  for (const num of stack) {\n    sum += num;\n  }\n  \n  // Output the result using stream.write\n  stream.write(sum.toString());\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the top element of the stack, and if the element is even, uses the `write` method of `stream` (from @kit.ArkTS) to print 'Even'; otherwise, uses the `pop` method to remove the element and push a modified value back using the `push` method.",
    "input": "",
    "output": "import {stream, Stack} from '@kit.ArkTS';\n\nexport function checkAndModifyStackTop(stack: Stack<number>): void {\n  if (stack.isEmpty()) {\n    return;\n  }\n  \n  const topElement = stack.peek();\n  if (topElement % 2 === 0) {\n    stream.write('Even');\n  } else {\n    stack.pop();\n    stack.push(topElement + 1);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `Stack` (from @kit.ArkTS) to process each element in the stack, applies a transformation (e.g., squaring the number), and then uses the `write` method of `stream` (from @kit.ArkTS) to log each transformed element to a log file.",
    "input": "",
    "output": "import {stream, Stack} from '@kit.ArkTS';\n\nexport function processStackAndLog(stack: Stack<number>, logFilePath: string): void {\n  const writableStream = new stream.Writable();\n  writableStream.open(logFilePath, 'w');\n\n  stack.forEach((item: number) => {\n    const transformedItem = item * item;\n    writableStream.write(transformedItem.toString() + '\\n');\n  });\n\n  writableStream.close();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Queue` to enqueue a sequence of numbers, then uses the `Symbol.iterator` method of `Queue` to iterate over the elements and pass each element to a stream processing function that logs the square of each number.",
    "input": "",
    "output": "import {Queue, stream} from '@kit.ArkTS';\n\nexport function processQueueWithStream(numbers: number[]): void {\n  const queue = new Queue<number>();\n  \n  // Enqueue each number to the queue\n  numbers.forEach(num => queue.add(num));\n  \n  // Iterate over the queue elements using Symbol.iterator\n  for (const num of queue) {\n    // Log the square of each number\n    console.log(num * num);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getFirst` method of `Queue` to retrieve the first element, then checks if the `length` property of `Queue` is greater than 1. If true, use the `pop` method to remove the first element and pass it to a stream processing function that converts the element to a string and logs it.",
    "input": "",
    "output": "import {Queue, stream} from '@kit.ArkTS';\n\nexport function processQueueElement(queue: Queue<unknown>): void {\n  const firstElement = queue.getFirst();\n  if (queue.length > 1) {\n    const poppedElement = queue.pop();\n    const elementAsString = String(poppedElement);\n    console.log(elementAsString);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `Queue` to process each element in the queue, doubling its value, and then passes the modified elements to a stream processing function that filters out even numbers and logs the remaining odd numbers.",
    "input": "",
    "output": "import {Queue, stream} from '@kit.ArkTS';\n\nexport function processQueue(queue: Queue<number>): void {\n  const doubledQueue = new Queue<number>();\n  queue.forEach((value: number) => {\n    doubledQueue.add(value * 2);\n  });\n\n  const readableStream = new stream.Readable<number>({\n    read(size: number): void {\n      while (doubledQueue.length > 0) {\n        const value = doubledQueue.pop();\n        if (value !== undefined) {\n          this.push(value);\n        }\n      }\n      this.push(null);\n    }\n  });\n\n  const transformStream = new stream.Transform<number, number>({\n    transform(chunk: number, encoding: string, callback: Function): void {\n      if (chunk % 2 !== 0) {\n        this.push(chunk);\n      }\n      callback();\n    }\n  });\n\n  readableStream.pipe(transformStream).on('data', (data: number) => {\n    console.log(data);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that parses an XML string using the `xml` API to extract all attribute values, then stores these values in a `LightWeightSet` using its `addAll` method. Finally, use the `LightWeightSet`'s `toArray` method to convert the set into an array and return it. The function must explicitly use `xml.parse` and `LightWeightSet.addAll`.",
    "input": "",
    "output": "import {xml, LightWeightSet} from '@kit.ArkTS';\n\nexport function parseXmlAndExtractAttributes(xmlString: string): string[] {\n  const parsedXml = xml.parse(xmlString);\n  const attributeValues = new LightWeightSet<string>();\n\n  function extractAttributes(node: any): void {\n    if (node.attributes) {\n      for (const attr in node.attributes) {\n        if (node.attributes.hasOwnProperty(attr)) {\n          attributeValues.add(node.attributes[attr]);\n        }\n      }\n    }\n\n    if (node.children) {\n      for (const child of node.children) {\n        extractAttributes(child);\n      }\n    }\n  }\n\n  extractAttributes(parsedXml);\n  return attributeValues.toArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `LightWeightSet` API to collect a set of unique tags from an XML document (parsed using the `xml` API). Then, iterate over these tags using the `LightWeightSet`'s `Symbol.iterator` method and for each tag, use the `xml` API to count how many times it appears in the document. Return an object mapping each tag to its count. The function must explicitly use `xml.querySelectorAll` and `LightWeightSet.Symbol.iterator`.",
    "input": "",
    "output": "import {xml, LightWeightSet} from '@kit.ArkTS';\n\nexport function countXmlTags(xmlString: string): Record<string, number> {\n  const doc = xml.parseXmlText(xmlString);\n  const allElements = doc.querySelectorAll('*');\n  const tagSet = new LightWeightSet<string>();\n\n  for (let i = 0; i < allElements.length; i++) {\n    const element = allElements[i];\n    const tagName = element.tagName;\n    tagSet.add(tagName);\n  }\n\n  const tagCounts: Record<string, number> = {};\n  const iterator = tagSet[Symbol.iterator]();\n  let result = iterator.next();\n\n  while (!result.done) {\n    const tag = result.value;\n    const count = doc.querySelectorAll(tag).length;\n    tagCounts[tag] = count;\n    result = iterator.next();\n  }\n\n  return tagCounts;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that processes an XML string to extract all element names using the `xml` API, then stores these names in a `LightWeightSet` using its `add` method. Next, use the `LightWeightSet`'s `removeAt` method to remove every other element name, and finally return the remaining names as an array using the `toArray` method. The function must explicitly use `xml.getElementsByTagName` and `LightWeightSet.removeAt`.",
    "input": "",
    "output": "import {xml, LightWeightSet} from '@kit.ArkTS';\n\nexport function processXmlAndExtractNames(xmlString: string): string[] {\n  const xmlDoc = xml.parseXML(xmlString);\n  const elements = xmlDoc.getElementsByTagName('*');\n  const nameSet = new LightWeightSet<string>();\n  \n  for (let i = 0; i < elements.length; i++) {\n    nameSet.add(elements[i].tagName);\n  }\n  \n  let index = 0;\n  while (index < nameSet.length) {\n    nameSet.removeAt(index);\n    index++;\n  }\n  \n  return nameSet.toArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of numbers from user input, then passes the resulting `LinkedList` to a worker thread using the `worker` API to compute the sum of all elements in the list. The worker should return the sum to the main thread, which then prints the result. Required API methods: `LinkedList.add`, `worker.postMessage`, and `worker.onmessage`.",
    "input": "",
    "output": "import {LinkedList, worker} from '@kit.ArkTS';\n\nexport function collectAndSumNumbers(): void {\n  const list = new LinkedList<number>();\n  \n  // Collect numbers from user input (simulated here for example)\n  const numbers = [1, 2, 3, 4, 5]; // Replace with actual user input collection\n  numbers.forEach(num => list.add(num));\n  \n  // Create a worker\n  const myWorker = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n  \n  // Send the LinkedList to the worker\n  myWorker.postMessage(list);\n  \n  // Receive the result from the worker\n  myWorker.onmessage = (msg: worker.MessageEvents<number>) => {\n    console.log(`Sum of numbers: ${msg.data}`);\n    myWorker.terminate();\n  };\n}\n\nexport class Worker {\n  static sumNumbers(list: LinkedList<number>): number {\n    let sum = 0;\n    for (const num of list) {\n      sum += num;\n    }\n    return sum;\n  }\n}\n",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `convertToArray` method of `LinkedList` to transform a list of strings into an array, then passes this array to a worker thread using the `worker` API to filter out all strings that contain a specific substring. The worker should return the filtered array to the main thread, which then prints the results. Required API methods: `LinkedList.convertToArray`, `worker.postMessage`, and `worker.onmessage`.",
    "input": "",
    "output": "import {LinkedList, worker} from '@kit.ArkTS';\n\nexport function filterLinkedListWithWorker(list: LinkedList<string>, substring: string): void {\n  const array = list.convertToArray();\n  \n  const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n  \n  workerInstance.postMessage({data: array, substring: substring});\n  \n  workerInstance.onmessage = (message: {data: string[]}) => {\n    console.log('Filtered array:', message.data);\n    workerInstance.terminate();\n  };\n}\n\n// Worker.ts content (should be in a separate file)\n// import {worker} from '@kit.ArkTS';\n// \n// const workerPort = worker.workerPort;\n// \n// workerPort.onmessage = (message: {data: string[], substring: string}) => {\n//   const filteredArray = message.data.filter(item => !item.includes(message.substring));\n//   workerPort.postMessage(filteredArray);\n// };",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LinkedList` to iterate over a list of numbers and double each value, then passes the modified list to a worker thread using the `worker` API to find the maximum value. The worker should return the maximum value to the main thread, which then prints it. Required API methods: `LinkedList.forEach`, `LinkedList.set`, `worker.postMessage`, and `worker.onmessage`.",
    "input": "",
    "output": "import {LinkedList, worker} from '@kit.ArkTS';\n\nexport function doubleAndFindMax(list: LinkedList<number>): void {\n  list.forEach((value: number, index: number) => {\n    list.set(index, value * 2);\n  });\n\n  const myWorker = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n\n  myWorker.postMessage(list.convertToArray());\n\n  myWorker.onmessage = (message: worker.MessageEvents): void => {\n    console.log(`The maximum value is: ${message.data}`);\n    myWorker.terminate();\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `LightWeightMap` to retrieve all keys, then passes these keys to the `data` property of `MessageEvents` to send them as a message payload. The function should return the message object with the keys as data.",
    "input": "",
    "output": "import {LightWeightMap, MessageEvents} from '@kit.ArkTS';\n\nexport function sendKeysAsMessagePayload(map: LightWeightMap<number, unknown>): MessageEvents {\n  const keys = map.keys();\n  const message = new MessageEvents();\n  message.data = keys;\n  return message;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if a `LightWeightMap` is empty using the `isEmpty` method, and if it is not empty, uses the `getValueAt` method to retrieve the first value and sets it as the `data` property of a new `MessageEvents` object. The function should return the message object or null if the map is empty.",
    "input": "",
    "output": "import {LightWeightMap, MessageEvents} from '@kit.ArkTS';\n\nexport function getFirstValueFromMap(map: LightWeightMap<unknown, unknown>): MessageEvents | null {\n  if (!map.isEmpty()) {\n    const firstValue = map.getValueAt(0);\n    const messageEvent = new MessageEvents();\n    messageEvent.data = firstValue;\n    return messageEvent;\n  }\n  return null;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that iterates over a `LightWeightMap` using the `Symbol.iterator` method, collects all values, and then creates a `MessageEvents` object where the `data` property is set to the concatenated string of all values separated by commas. The function should return the message object.",
    "input": "",
    "output": "import {LightWeightMap, MessageEvents} from '@kit.ArkTS';\n\nexport function collectAndCreateMessage(map: LightWeightMap<number, string>): MessageEvents {\n  const values: string[] = [];\n  for (const [_, value] of map) {\n    values.push(value);\n  }\n  const message = new MessageEvents();\n  message.data = values.join(',');\n  return message;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `forEach` method of `LightWeightMap` to iterate over its entries and create an array of `Event` objects, where each `Event`'s `type` is set to the key from the `LightWeightMap` entry and the `timeStamp` is set to the corresponding value. Then, use the `length` property of `LightWeightMap` to determine the number of events created.",
    "input": "",
    "output": "import {Event, LightWeightMap} from '@kit.ArkTS';\n\nexport function createEventsFromMap(lightWeightMap: LightWeightMap<string, number>): Event[] {\n  const events: Event[] = [];\n  lightWeightMap.forEach((value: number, key: string) => {\n    const event = new Event();\n    event.type = key;\n    event.timeStamp = value;\n    events.push(event);\n  });\n  const numberOfEvents = lightWeightMap.length;\n  return events;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getKeyAt` and `getValueAt` methods of `LightWeightMap` to retrieve key-value pairs at specific indices, then creates an `Event` object for each pair where the `type` is the key and the `timeStamp` is the value. Finally, use the `hasKey` method of `LightWeightMap` to check if a specific key exists in the map and log the corresponding `Event` object if it does.",
    "input": "",
    "output": "import {Event, LightWeightMap} from '@kit.ArkTS';\n\nexport function createEventsFromMap(lightWeightMap: LightWeightMap<string, number>): Event[] {\n  const events: Event[] = [];\n  for (let i = 0; i < lightWeightMap.length; i++) {\n    const key = lightWeightMap.getKeyAt(i);\n    const value = lightWeightMap.getValueAt(i);\n    if (key !== undefined && value !== undefined) {\n      const event: Event = {\n        type: key,\n        timeStamp: value\n      };\n      events.push(event);\n    }\n  }\n  return events;\n}\n\nexport function logEventIfKeyExists(lightWeightMap: LightWeightMap<string, number>, key: string): void {\n  if (lightWeightMap.hasKey(key)) {\n    const value = lightWeightMap.get(key);\n    if (value !== undefined) {\n      const event: Event = {\n        type: key,\n        timeStamp: value\n      };\n      console.log(event);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `entries` method of `LightWeightMap` to get an iterator of its key-value pairs, then iterates over them using `[Symbol.iterator]` to create an array of `Event` objects. Each `Event` should have its `type` set to the key and `timeStamp` set to the value. Finally, use the `isEmpty` method of `LightWeightMap` to check if the map was empty before processing and log a message accordingly.",
    "input": "",
    "output": "import {Event, LightWeightMap} from '@kit.ArkTS';\n\nexport function processLightWeightMap(map: LightWeightMap<string, number>): Event[] {\n  const events: Event[] = [];\n  \n  if (map.isEmpty()) {\n    console.log('The LightWeightMap is empty.');\n    return events;\n  }\n  \n  const iterator = map.entries()[Symbol.iterator]();\n  let next = iterator.next();\n  \n  while (!next.done) {\n    const [key, value] = next.value;\n    const event: Event = {\n      type: key,\n      timeStamp: value\n    };\n    events.push(event);\n    next = iterator.next();\n  }\n  \n  return events;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.getEnvironmentVar` to retrieve an environment variable containing JSON data, then parses it using `json.parse` to extract specific key-value pairs, and finally logs the parsed data. The function must handle cases where the environment variable is missing or the JSON is invalid.",
    "input": "",
    "output": "import {process, json} from '@kit.ArkTS';\n\nexport function parseEnvJson(envVarName: string, keys: string[]): void {\n  try {\n    const envVarValue = process.getEnvironmentVar(envVarName);\n    if (envVarValue === undefined) {\n      console.error(`Environment variable ${envVarName} is missing.`);\n      return;\n    }\n\n    const parsedData = json.parse(envVarValue);\n    const result: Record<string, unknown> = {};\n\n    for (const key of keys) {\n      if (json.has(parsedData, key)) {\n        result[key] = parsedData[key];\n      } else {\n        console.error(`Key ${key} not found in JSON data.`);\n      }\n    }\n\n    console.log('Parsed data:', result);\n  } catch (error) {\n    console.error('Error parsing JSON:', error);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if the current process is 64-bit using `process.is64Bit`, then uses `json.stringify` to convert a complex object (containing process details like uptime from `process.uptime` and system config from `process.getSystemConfig`) into a JSON string, and writes it to a file or logs it.",
    "input": "",
    "output": "import {process, json} from '@kit.ArkTS';\n\nexport function processAndLogDetails(): void {\n  const is64Bit: boolean = process.is64Bit();\n  const uptime: number = process.uptime();\n  const systemConfig: object = process.getSystemConfig();\n\n  const processDetails: object = {\n    is64Bit,\n    uptime,\n    systemConfig\n  };\n\n  const jsonString: string = json.stringify(processDetails);\n  console.log(jsonString);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `process.getStartRealtime` to get the process start time, then constructs an object with this time and other process details (like thread priority from `process.getThreadPriority`), and uses `json.has` to check if a specific key exists in the object before performing further operations like logging or data transformation.",
    "input": "",
    "output": "import {process, json} from '@kit.ArkTS';\n\nexport function getProcessDetails(): object {\n  const startTime = process.getStartRealtime();\n  const threadPriority = process.getThreadPriority();\n  \n  const processDetails = {\n    startTime,\n    threadPriority\n  };\n  \n  if (json.has(processDetails, 'startTime')) {\n    console.log('Process start time:', processDetails.startTime);\n  }\n  \n  if (json.has(processDetails, 'threadPriority')) {\n    console.log('Thread priority:', processDetails.threadPriority);\n  }\n  \n  return processDetails;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` to collect a sequence of numbers, then transfers these numbers to a `TreeSet` using its `add` method. Finally, use the `getFirstValue` and `getLastValue` methods of `TreeSet` to determine the smallest and largest values in the sequence.",
    "input": "",
    "output": "import {TreeSet, Stack} from '@kit.ArkTS';\n\nexport function findMinMax(numbers: number[]): {min: number, max: number} {\n  const stack = new Stack<number>();\n  const treeSet = new TreeSet<number>();\n\n  // Push numbers into the stack\n  for (const num of numbers) {\n    stack.push(num);\n  }\n\n  // Transfer numbers from stack to TreeSet\n  while (!stack.isEmpty()) {\n    const num = stack.pop();\n    treeSet.add(num);\n  }\n\n  // Get min and max values\n  const min = treeSet.getFirstValue();\n  const max = treeSet.getLastValue();\n\n  return {min, max};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `popFirst` and `popLast` methods of `TreeSet` to extract the smallest and largest values from a set of numbers, then pushes these values into a `Stack` using its `push` method. Use the `peek` method of `Stack` to verify the order of the values.",
    "input": "",
    "output": "import {TreeSet, Stack} from '@kit.ArkTS';\n\nexport function processTreeSetToStack(treeSet: TreeSet<number>, stack: Stack<number>): void {\n  if (treeSet.isEmpty()) {\n    return;\n  }\n  \n  const smallest = treeSet.popFirst();\n  const largest = treeSet.popLast();\n  \n  if (smallest !== undefined) {\n    stack.push(smallest);\n  }\n  \n  if (largest !== undefined) {\n    stack.push(largest);\n  }\n  \n  // Verify the order of the values using peek\n  if (!stack.isEmpty()) {\n    stack.peek();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that checks if a `Stack` is empty using its `isEmpty` method. If it is not empty, pop all elements using the `pop` method and add them to a `TreeSet` using its `add` method. Then, use the `forEach` method of `TreeSet` to print each element in ascending order.",
    "input": "",
    "output": "import {TreeSet, Stack} from '@kit.ArkTS';\n\nexport function processStack(stack: Stack<number>): void {\n  if (!stack.isEmpty()) {\n    const treeSet = new TreeSet<number>();\n    while (!stack.isEmpty()) {\n      const element = stack.pop();\n      treeSet.add(element);\n    }\n    treeSet.forEach((value: number) => {\n      console.log(value);\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a Worker with a specified name using the `name` property of `WorkerOptions`, then uses the `add` method of `Queue` to enqueue tasks for the worker. The function should return the length of the queue after adding all tasks, using the `length` property of `Queue`.",
    "input": "",
    "output": "import {WorkerOptions, Queue} from '@kit.ArkTS';\n\nexport function createWorkerAndEnqueueTasks(workerName: string, tasks: string[]): number {\n  const workerOptions: WorkerOptions = {\n    name: workerName\n  };\n  const worker = new Worker('', workerOptions);\n  const queue = new Queue<string>();\n  tasks.forEach(task => queue.add(task));\n  return queue.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that initializes a `Queue` using its `constructor`, then iterates over the queue using the `[Symbol.iterator]` method to process each task. For each task, create a new Worker with the `shared` property of `WorkerOptions` set to true, and log the task details.",
    "input": "",
    "output": "import {WorkerOptions, Queue} from '@kit.ArkTS';\n\nexport function processTasksWithWorkers(): void {\n  const queue = new Queue<string>();\n  queue.add('Task1');\n  queue.add('Task2');\n  queue.add('Task3');\n\n  for (const task of queue) {\n    const workerOptions: WorkerOptions = {\n      shared: true\n    };\n    const worker = new Worker('worker.js', workerOptions);\n    console.log(`Processing task: ${task}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirst` method of `Queue` to retrieve the first task, then creates a Worker with the `name` property of `WorkerOptions` set to the task's ID. The function should then use the `forEach` method of `Queue` to process the remaining tasks and log their details.",
    "input": "",
    "output": "import {WorkerOptions, Queue} from '@kit.ArkTS';\n\nexport function processTasks(queue: Queue<string>): void {\n  const firstTask = queue.getFirst();\n  if (firstTask) {\n    const workerOptions: WorkerOptions = {\n      name: firstTask\n    };\n    new Worker('worker.js', workerOptions);\n  }\n\n  queue.forEach((task: string) => {\n    console.log(`Processing task: ${task}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a message containing an array of numbers to a worker thread, and then uses the `transfer` property of `PostMessageOptions` to transfer ownership of a shared array buffer to the worker thread for efficient processing.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport function sendDataToWorker(worker: ThreadWorkerGlobalScope, data: number[], buffer: ArrayBuffer): void {\n  worker.postMessage(data);\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  worker.postMessage(buffer, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that listens for incoming messages using the `onmessage` property of `ThreadWorkerGlobalScope`, processes the received data by calling a global method via `callGlobalCallObjectMethod`, and then sends the result back to the main thread using `postMessageWithSharedSendable` with the `transfer` property of `PostMessageOptions` to optimize performance.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport const workerScript = `\n  const globalScope = typeof self !== 'undefined' ? self : {} as ThreadWorkerGlobalScope;\n\n  globalScope.onmessage = (event: MessageEvent) => {\n    const data = event.data;\n    const result = globalScope.callGlobalCallObjectMethod('processData', data);\n    \n    const options: PostMessageOptions = {\n      transfer: [result.buffer]\n    };\n    \n    globalScope.postMessageWithSharedSendable(result, options);\n  };\n`;",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where the main thread uses the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope` to send a large dataset to a worker thread, specifying the `transfer` property of `PostMessageOptions` to avoid copying data. The worker thread then processes the data and uses the `close` method of `ThreadWorkerGlobalScope` to terminate itself after sending the final result back to the main thread via `postMessage`.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, PostMessageOptions} from '@kit.ArkTS';\n\nexport function setupWorker(worker: ThreadWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent<ArrayBuffer>): void => {\n    const processedData = processData(event.data);\n    worker.postMessage(processedData);\n    worker.close();\n  };\n}\n\nfunction processData(data: ArrayBuffer): ArrayBuffer {\n  // Example processing: just return the same data for demonstration\n  return data;\n}\n\nexport function sendDataToWorker(worker: ThreadWorkerGlobalScope, data: ArrayBuffer): void {\n  const options: PostMessageOptions = {\n    transfer: [data]\n  };\n  worker.postMessageWithSharedSendable(data, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `read` method of `stream` to read data from a file, then uses the `parse` method of `uri` to extract and validate the URL components from the read data. The function should return the extracted domain name if the URI is valid, or an error otherwise.",
    "input": "",
    "output": "import {stream, uri} from '@kit.ArkTS';\n\nexport function extractDomainFromFile(filePath: string): string | Error {\n  try {\n    const readableStream = new stream.Readable();\n    const data = readableStream.read(filePath);\n    const parsedUri = uri.parse(data);\n    \n    if (!parsedUri || !parsedUri.host) {\n      return new Error('Invalid URI: No domain found');\n    }\n    \n    return parsedUri.host;\n  } catch (error) {\n    return new Error(`Error reading or parsing URI: ${error.message}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `write` method of `stream` to write a list of URIs to a file, then uses the `resolve` method of `uri` to normalize each URI in the list before writing. The function should return the number of successfully normalized URIs written to the file.",
    "input": "",
    "output": "import {stream, uri} from '@kit.ArkTS';\n\nexport function writeAndNormalizeUris(filePath: string, uris: string[]): number {\n  let normalizedCount = 0;\n  const normalizedUris: string[] = [];\n\n  for (const uriStr of uris) {\n    try {\n      const normalizedUri = uri.resolve(uriStr);\n      normalizedUris.push(normalizedUri);\n      normalizedCount++;\n    } catch (error) {\n      continue;\n    }\n  }\n\n  if (normalizedUris.length > 0) {\n    const writableStream = stream.createWritableStream(filePath);\n    writableStream.write(normalizedUris.join('\\n'));\n    writableStream.close();\n  }\n\n  return normalizedCount;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `open` method of `stream` to establish a connection to a remote resource specified by a URI (using the `toString` method of `uri` to get the full URL), then uses the `close` method of `stream` to properly terminate the connection after reading the first 100 bytes of data. The function should return the read data or an error if the connection fails.",
    "input": "",
    "output": "import {stream, uri} from '@kit.ArkTS';\n\nexport function fetchFirst100Bytes(resourceUri: uri.URI): string | Error {\n  try {\n    const url = resourceUri.toString();\n    const connection = stream.open(url, 'r');\n    \n    if (!connection) {\n      return new Error('Failed to establish connection');\n    }\n    \n    const buffer = new ArrayBuffer(100);\n    const bytesRead = connection.read(buffer);\n    connection.close();\n    \n    if (bytesRead <= 0) {\n      return new Error('No data read from the resource');\n    }\n    \n    const data = new Uint8Array(buffer).slice(0, bytesRead);\n    return String.fromCharCode.apply(null, Array.from(data));\n  } catch (error) {\n    return error instanceof Error ? error : new Error('Unknown error occurred');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a set of unique IDs, then stores them in a `LightWeightSet` using its `addAll` method. Finally, iterate over the set using the `Symbol.iterator` method of `LightWeightSet` and print each ID using the `printf` method of `util`.",
    "input": "",
    "output": "import {LightWeightSet, util, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function generateAndPrintUUIDs(count: number): void {\n  const uuidSet = new LightWeightSet<string>();\n  const uuids: string[] = [];\n\n  for (let i = 0; i < count; i++) {\n    uuids.push(util.generateRandomUUID());\n  }\n\n  uuidSet.addAll(uuids);\n\n  for (const uuid of uuidSet) {\n    util.printf('%s', uuid);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `ThreadWorkerGlobalScope` and uses its `postMessage` method to send a message containing a `LightWeightSet` (populated using its `add` and `getValueAt` methods) to a worker thread. The worker thread should then use the `onmessage` property of `ThreadWorkerGlobalScope` to receive the set and convert it to an array using the `toArray` method of `LightWeightSet`.",
    "input": "",
    "output": "import {LightWeightSet, util, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function initializeWorkerAndSendMessage() {\n  const worker = new ThreadWorkerGlobalScope('worker.js');\n  \n  const lightWeightSet = new LightWeightSet<number>();\n  lightWeightSet.add(1);\n  lightWeightSet.add(2);\n  lightWeightSet.add(3);\n  \n  const message = {\n    set: lightWeightSet\n  };\n  \n  worker.postMessage(message);\n}\n\nexport function setupWorkerListener(worker: ThreadWorkerGlobalScope) {\n  worker.onmessage = (event) => {\n    const receivedSet = event.data.set as LightWeightSet<number>;\n    const array = receivedSet.toArray();\n    console.log('Received array:', array);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LightWeightSet` to process each element in the set, applying a callback function wrapped with the `callbackWrapper` method of `util`. The callback should log each element using the `printf` method of `util` and then remove the element from the set using the `remove` method of `LightWeightSet` if it meets a certain condition.",
    "input": "",
    "output": "import {LightWeightSet, util, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processLightWeightSet(set: LightWeightSet<number>, condition: (value: number) => boolean): void {\n  const callback = (value: number) => {\n    util.printf(`Processing value: ${value}`);\n    if (condition(value)) {\n      set.remove(value);\n    }\n  };\n\n  const wrappedCallback = util.callbackWrapper(callback);\n  set.forEach(wrappedCallback);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `DedicatedWorkerGlobalScope` to send a `List` of numbers to a worker thread, where the worker thread uses the `sort` method of `List` to sort the numbers in ascending order and then sends the sorted list back to the main thread using `postMessage`. The main thread should handle the sorted list using the `onmessage` property of `DedicatedWorkerGlobalScope`.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, List, ErrorEvent} from '@kit.ArkTS';\n\nexport function sendListToWorker(worker: DedicatedWorkerGlobalScope, numbers: List<number>): void {\n  worker.postMessage(numbers);\n}\n\nexport function setupWorker(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent<List<number>>) => {\n    const receivedList: List<number> = event.data;\n    receivedList.sort((a: number, b: number) => a - b);\n    worker.postMessage(receivedList);\n  };\n\n  worker.onmessageerror = (event: ErrorEvent) => {\n    console.error('Error in worker:', event.message);\n  };\n}\n\nexport function handleSortedList(worker: DedicatedWorkerGlobalScope, callback: (sortedList: List<number>) => void): void {\n  worker.onmessage = (event: MessageEvent<List<number>>) => {\n    callback(event.data);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that constructs a `List` of filenames and uses the `forEach` method of `List` to iterate over each filename. For each filename, simulate an error event by creating an `ErrorEvent` object with the `filename`, `message`, and `error` properties set, and then log these error details to the console. The function should also use the `length` property of `List` to report the total number of files processed.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, List, ErrorEvent} from '@kit.ArkTS';\n\nexport function processFiles(): void {\n  const filenames: List<string> = new List<string>();\n  filenames.add('file1.txt');\n  filenames.add('file2.txt');\n  filenames.add('file3.txt');\n\n  filenames.forEach((filename: string) => {\n    const errorEvent: ErrorEvent = new ErrorEvent('error');\n    errorEvent.filename = filename;\n    errorEvent.message = `Error processing file: ${filename}`;\n    errorEvent.error = new Error(`Failed to process ${filename}`);\n    \n    console.log(`Filename: ${errorEvent.filename}`);\n    console.log(`Message: ${errorEvent.message}`);\n    console.log(`Error: ${errorEvent.error}`);\n  });\n\n  console.log(`Total files processed: ${filenames.length}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `add` and `getSubList` methods of `List` to create and manipulate a list of error messages. Then, pass this list to a worker thread using the `postMessage` method of `DedicatedWorkerGlobalScope`. In the worker thread, use the `onmessageerror` property of `DedicatedWorkerGlobalScope` to handle any message errors and log them using the `message` property of `ErrorEvent`.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, List, ErrorEvent} from '@kit.ArkTS';\n\nexport function createAndManipulateErrorList(): List<string> {\n  const errorList: List<string> = new List();\n  errorList.add('Error 1: Invalid input');\n  errorList.add('Error 2: Network failure');\n  errorList.add('Error 3: Timeout');\n  \n  const subList = errorList.getSubList(1, 2);\n  return subList;\n}\n\nexport function postToWorker(worker: DedicatedWorkerGlobalScope, errorList: List<string>): void {\n  worker.postMessage(errorList);\n}\n\nexport function setupWorkerErrorHandler(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessageerror = (event: ErrorEvent) => {\n    console.error(`Message error: ${event.message}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `ArrayList<string>` (from @kit.ArkTS) to collect a list of XML event names, then uses the `dispatchEvent` method of `EventTarget` (from @kit.ArkTS) to trigger each event in the list sequentially. The function should also use the `length` property of `ArrayList` to log the total number of events dispatched.",
    "input": "",
    "output": "import {ArrayList, xml, EventTarget} from '@kit.ArkTS';\n\nexport function dispatchXmlEvents(): void {\n  const eventList: ArrayList<string> = new ArrayList();\n  eventList.add('start');\n  eventList.add('progress');\n  eventList.add('end');\n\n  const eventTarget: EventTarget = new EventTarget();\n\n  for (let i = 0; i < eventList.length; i++) {\n    const eventName: string = eventList.get(i);\n    eventTarget.dispatchEvent(eventName);\n  }\n\n  console.log(`Total events dispatched: ${eventList.length}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `convertToArray` method of `ArrayList<number>` (from @kit.ArkTS) to transform the list into an array, then uses the `EventType` enum from `xml` (from @kit.ArkTS) to filter the array for specific event types. Finally, use the `replaceAllElements` method of `ArrayList` to update the list with the filtered results.",
    "input": "",
    "output": "import {ArrayList, xml, EventTarget} from '@kit.ArkTS';\n\nexport function filterEventTypes(list: ArrayList<number>, eventTypes: xml.EventType[]): void {\n  const array: number[] = list.convertToArray();\n  const filteredArray: number[] = array.filter((item: number) => {\n    return eventTypes.includes(item as xml.EventType);\n  });\n  list.replaceAllElements((_: number, index: number) => {\n    return filteredArray[index];\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getIndexOf` method of `ArrayList<string>` (from @kit.ArkTS) to find the position of a specific XML event name in the list, then uses the `removeEventListener` method of `EventTarget` (from @kit.ArkTS) to unregister the event at that index. The function should also use the `trimToCurrentLength` method of `ArrayList` to optimize the list storage after removal.",
    "input": "",
    "output": "import {ArrayList, xml, EventTarget} from '@kit.ArkTS';\n\nexport function unregisterEvent(eventList: ArrayList<string>, eventName: string, target: EventTarget): void {\n  const index: number = eventList.getIndexOf(eventName);\n  if (index !== -1) {\n    target.removeEventListener(eventName);\n    eventList.removeByIndex(index);\n    eventList.trimToCurrentLength();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of events (using `Event` objects), then filters these events by their `type` property, and finally uses the `convertToArray` method of `LinkedList` to return an array of filtered events.",
    "input": "",
    "output": "import {Event, GlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function filterEventsByType(events: Event[], filterType: string): Event[] {\n  const linkedList = new LinkedList<Event>();\n  \n  for (const event of events) {\n    linkedList.add(event);\n  }\n  \n  const filteredList = new LinkedList<Event>();\n  \n  for (const event of linkedList) {\n    if (event.type === filterType) {\n      filteredList.add(event);\n    }\n  }\n  \n  return filteredList.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if the `self` property of `GlobalScope` matches a given name, then uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a linked list, and finally logs these elements along with the `timeStamp` property of an `Event` object.",
    "input": "",
    "output": "import {Event, GlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function checkAndLog(scope: GlobalScope, name: string, list: LinkedList<string>, event: Event): void {\n  if (scope.self === name) {\n    const firstElement = list.getFirst();\n    const lastElement = list.getLast();\n    console.log(`First element: ${firstElement}, Last element: ${lastElement}, Timestamp: ${event.timeStamp}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LinkedList` to iterate over a list of events, checks each event's `type` property, and then uses the `onerror` property of `GlobalScope` to handle any events of type 'error', logging their `timeStamp` and details.",
    "input": "",
    "output": "import {Event, GlobalScope, LinkedList} from '@kit.ArkTS';\n\nexport function handleErrorEvents(events: LinkedList<Event>): void {\n  events.forEach((event: Event) => {\n    if (event.type === 'error') {\n      GlobalScope.onerror = (ev: Event) => {\n        console.log(`Error timestamp: ${ev.timeStamp}, details: ${JSON.stringify(ev)}`);\n        return true;\n      };\n      GlobalScope.onerror(event);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addEventListener` method of `EventTarget` to listen for a custom event, and upon triggering the event, uses the `data` property of `MessageEvents` to extract and log the event payload to the console.",
    "input": "",
    "output": "import {EventTarget, MessageEvents, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function listenToCustomEvent(eventTarget: EventTarget, eventName: string): void {\n  eventTarget.addEventListener(eventName, (event: MessageEvents) => {\n    console.log(event.data);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker script that uses the `self` property of `WorkerGlobalScope` to access the worker's global scope, then uses the `dispatchEvent` method of `EventTarget` to emit a custom event with a message payload. The main thread should listen for this event using `addEventListener` and log the received `data` from the `MessageEvents` object.",
    "input": "",
    "output": "import {EventTarget, MessageEvents, WorkerGlobalScope} from '@kit.ArkTS';\n\n// Worker script\nexport const workerScript = `\n  import {EventTarget, MessageEvents, WorkerGlobalScope} from '@kit.ArkTS';\n\n  const globalScope: WorkerGlobalScope = self;\n  const eventTarget: EventTarget = globalScope;\n\n  const messageEvent: MessageEvents = new MessageEvents('customEvent', {\n    data: 'Hello from worker!'\n  });\n\n  eventTarget.dispatchEvent(messageEvent);\n`;\n\n// Main thread\nexport class MainThread {\n  private worker: Worker;\n\n  constructor() {\n    this.worker = new Worker('worker.js', {type: 'classic'});\n    this.worker.addEventListener('customEvent', (event: MessageEvents) => {\n      console.log('Received data:', event.data);\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that sets up an error handler using the `onerror` property of `WorkerGlobalScope` to catch errors in a worker context. When an error occurs, use the `dispatchEvent` method of `EventTarget` to propagate the error to the main thread, where it should be logged using the `data` property of `MessageEvents` to display the error details.",
    "input": "",
    "output": "import {EventTarget, MessageEvents, WorkerGlobalScope} from '@kit.ArkTS';\n\nexport function setupWorkerErrorHandler(workerScope: WorkerGlobalScope): void {\n  workerScope.onerror = (event: ErrorEvent) => {\n    const errorEvent = new MessageEvents('error', {\n      data: {\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        error: event.error\n      }\n    });\n    workerScope.dispatchEvent(errorEvent);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of numbers, then transfers them to an `ArrayList<number>` (from @kit.ArkTS) using the `add` method, and finally sorts the numbers using the `sort` method of `ArrayList`.",
    "input": "",
    "output": "import {ArrayList, Stack, taskpool} from '@kit.ArkTS';\n\nexport function processNumbers(numbers: number[]): ArrayList<number> {\n  const stack = new Stack<number>();\n  const arrayList = new ArrayList<number>();\n\n  // Push numbers into the stack\n  for (const num of numbers) {\n    stack.push(num);\n  }\n\n  // Transfer numbers from stack to ArrayList\n  while (!stack.isEmpty()) {\n    arrayList.add(stack.pop());\n  }\n\n  // Sort the ArrayList\n  arrayList.sort((a, b) => a - b);\n\n  return arrayList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `execute` method of `taskpool` (from @kit.ArkTS) to run a task that generates a list of random numbers, stores them in an `ArrayList<number>` (from @kit.ArkTS) using the `add` method, and then uses the `trimToCurrentLength` method to optimize the storage of the list.",
    "input": "",
    "output": "import {ArrayList, Stack, taskpool} from '@kit.ArkTS';\n\nexport function generateRandomNumbers(count: number): ArrayList<number> {\n  const list = new ArrayList<number>();\n  for (let i = 0; i < count; i++) {\n    list.add(Math.random());\n  }\n  list.trimToCurrentLength();\n  return list;\n}\n\nexport async function executeRandomNumberGeneration(count: number): Promise<ArrayList<number>> {\n  const task = new taskpool.Task(generateRandomNumbers, count);\n  return await taskpool.execute(task);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `peek` method of `Stack` (from @kit.ArkTS) to check the top element of the stack, then uses the `getIndexOf` method of `ArrayList<number>` (from @kit.ArkTS) to find the position of that element in an existing list, and finally uses the `removeByIndex` method to remove it from the list if found.",
    "input": "",
    "output": "import {ArrayList, Stack, taskpool} from '@kit.ArkTS';\n\nexport function checkTopAndRemove(stack: Stack<number>, list: ArrayList<number>): void {\n  if (stack.isEmpty() || list.isEmpty()) {\n    return;\n  }\n  const topElement: number = stack.peek();\n  const index: number = list.getIndexOf(topElement);\n  if (index !== -1) {\n    list.removeByIndex(index);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates a new Worker instance with a specified name using the `name` property of WorkerOptions, then listens for a custom event using the `type` property of Event to determine when the worker has completed its task and logs the `timeStamp` of the event.",
    "input": "",
    "output": "import {worker, Event, WorkerOptions} from '@kit.ArkTS';\n\nexport function createWorkerWithListener(workerName: string): void {\n  const options: WorkerOptions = {\n    name: workerName\n  };\n  const newWorker = new worker.ThreadWorker('', options);\n\n  newWorker.on('customEvent', (event: Event) => {\n    if (event.type === 'taskCompleted') {\n      console.log(`Task completed at timestamp: ${event.timeStamp}`);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a shared Worker using the `shared` property of WorkerOptions, then uses the `type` property of Event to filter and handle only specific types of messages sent between the main thread and the worker, logging the `timeStamp` of each relevant event.",
    "input": "",
    "output": "import {worker, Event, WorkerOptions} from '@kit.ArkTS';\n\nexport function initializeSharedWorker(): void {\n  const options: WorkerOptions = {\n    name: 'sharedWorker',\n    shared: true\n  };\n\n  const myWorker = new worker.ThreadWorker('workers/worker.ts', options);\n\n  myWorker.onmessage = (event: Event): void => {\n    if (event.type === 'specificType') {\n      console.log(`Received message with timestamp: ${event.timeStamp}`);\n    }\n  };\n\n  myWorker.onmessageerror = (event: Event): void => {\n    if (event.type === 'errorType') {\n      console.log(`Error message with timestamp: ${event.timeStamp}`);\n    }\n  };\n\n  myWorker.postMessage({ type: 'specificType', data: 'Hello Worker' });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task where you start a Worker with a unique name using the `name` property of WorkerOptions, then dispatch an event with a custom `type` and capture the `timeStamp` to measure the time taken for the worker to process and respond to the event.",
    "input": "",
    "output": "import {worker, Event, WorkerOptions} from '@kit.ArkTS';\n\nexport function startWorkerWithEvent(): void {\n  const workerOptions: WorkerOptions = {\n    name: 'uniqueWorkerName'\n  };\n\n  const myWorker = new worker.ThreadWorker('workers/worker.ts', workerOptions);\n\n  myWorker.onmessage = (event: Event): void => {\n    const endTime = event.timeStamp;\n    console.log(`Worker response time: ${endTime} ms`);\n    myWorker.terminate();\n  };\n\n  const startTime = Date.now();\n  myWorker.postMessage({ type: 'customEvent', timeStamp: startTime });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `keys` method of `LightWeightMap` to retrieve all keys, then passes them to the `insertEnd` method of `Deque` to store them in a deque. Finally, use the `getFirst` and `popFirst` methods of `Deque` to process and log each key in sequence.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightMap, Deque} from '@kit.ArkTS';\n\nexport function processKeysToDeque(lightWeightMap: LightWeightMap<number, string>, deque: Deque<number>): void {\n  const keys = lightWeightMap.keys();\n  for (const key of keys) {\n    deque.insertEnd(key);\n  }\n\n  while (deque.length > 0) {\n    const firstKey = deque.getFirst();\n    console.log(firstKey);\n    deque.popFirst();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `hasKey` method of `LightWeightMap` to check if a specific key exists, and if it does, use the `get` method to retrieve its value. Then, pass this value to the `insertFront` method of `Deque` to add it to the front of the deque. Use the `length` property of both `LightWeightMap` and `Deque` to verify the operations.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightMap, Deque} from '@kit.ArkTS';\n\nexport function checkKeyAndInsertToDeque(lightWeightMap: LightWeightMap<string, string>, deque: Deque<string>, key: string): void {\n  if (lightWeightMap.hasKey(key)) {\n    const value = lightWeightMap.get(key);\n    if (value !== undefined) {\n      deque.insertFront(value);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `WorkerGlobalScope` to iterate over a list of error messages. For each error message, use the `set` method of `LightWeightMap` to store the message with a unique key, and then use the `popLast` method of `Deque` to remove and process the oldest error message if the `length` property of `Deque` exceeds a certain threshold.",
    "input": "",
    "output": "import {WorkerGlobalScope, LightWeightMap, Deque} from '@kit.ArkTS';\n\nexport function processErrorMessages(errorMessages: string[], threshold: number): void {\n  const errorMap = new LightWeightMap<number, string>();\n  const errorQueue = new Deque<string>();\n  let keyCounter = 0;\n\n  errorMessages.forEach((message: string) => {\n    errorMap.set(keyCounter++, message);\n    errorQueue.insertEnd(message);\n\n    if (errorQueue.length > threshold) {\n      const oldestMessage = errorQueue.popLast();\n      console.log(`Processed oldest message: ${oldestMessage}`);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.getEnvironmentVar` to retrieve an environment variable and then passes the retrieved value to `WorkerEventTarget.addEventListener` to set up an event listener for a custom event in a worker context.",
    "input": "",
    "output": "import {process, WorkerEventTarget, PostMessageOptions} from '@kit.ArkTS';\n\nexport function setupWorkerEventListener(eventName: string, callback: EventListener): void {\n  const envVar = process.getEnvironmentVar('CUSTOM_EVENT_VAR');\n  const workerEventTarget = new WorkerEventTarget();\n  workerEventTarget.addEventListener(eventName, callback);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes `process.getUidForName` to fetch the UID for a given process name and then uses `WorkerEventTarget.dispatchEvent` to send this UID as part of a custom event payload to a worker thread.",
    "input": "",
    "output": "import {process, WorkerEventTarget, PostMessageOptions} from '@kit.ArkTS';\n\nexport function fetchAndDispatchUid(processName: string, workerEventTarget: WorkerEventTarget): void {\n  const uid = process.getUidForName(processName);\n  const event = {\n    type: 'customEvent',\n    data: { uid }\n  };\n  workerEventTarget.dispatchEvent(event);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first calls `process.getStartRealtime` to get the start time of the current process, then uses `PostMessageOptions.transfer` to transfer this timestamp to a worker thread via `WorkerEventTarget.postMessage` for further processing.",
    "input": "",
    "output": "import {process, WorkerEventTarget, PostMessageOptions} from '@kit.ArkTS';\n\nexport function transferStartTimeToWorker(worker: WorkerEventTarget): void {\n  const startTime: number = process.getStartRealtime();\n  const buffer: ArrayBuffer = new ArrayBuffer(8);\n  const view = new DataView(buffer);\n  view.setFloat64(0, startTime, true);\n  const options: PostMessageOptions = {\n    transfer: [buffer]\n  };\n  worker.postMessage(buffer, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a Buffer from a string, then uses `buffer.byteLength` to get its size, and finally uses `List.add` to store the size in a List<number> for tracking multiple buffer sizes.",
    "input": "",
    "output": "import {buffer, xml, List} from '@kit.ArkTS';\n\nexport function trackBufferSizes(strings: string[]): List<number> {\n  const sizeList: List<number> = new List<number>();\n  for (const str of strings) {\n    const buf = buffer.from(str);\n    const size = buffer.byteLength(buf);\n    sizeList.add(size);\n  }\n  return sizeList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that parses an XML string using `xml.EventType` to identify specific elements, extracts their text content into a Buffer using `buffer.concat`, and then stores these Buffers in a List<Buffer> using `List.insert` for further processing.",
    "input": "",
    "output": "import {buffer, xml, List} from '@kit.ArkTS';\n\nexport function parseXmlAndStoreBuffers(xmlString: string): List<buffer.Buffer> {\n  const buffers: List<buffer.Buffer> = new List<buffer.Buffer>();\n  const parser = new xml.XmlPullParser(xmlString);\n  let currentBuffer: buffer.Buffer | null = null;\n  let eventType = parser.getEventType();\n\n  while (eventType !== xml.EventType.END_DOCUMENT) {\n    switch (eventType) {\n      case xml.EventType.START_TAG:\n        currentBuffer = buffer.Buffer.alloc(0);\n        break;\n      case xml.EventType.TEXT:\n        if (currentBuffer !== null) {\n          const text = parser.getText();\n          const textBuffer = buffer.Buffer.from(text, 'utf-8');\n          currentBuffer = buffer.Buffer.concat([currentBuffer, textBuffer]);\n        }\n        break;\n      case xml.EventType.END_TAG:\n        if (currentBuffer !== null && currentBuffer.length > 0) {\n          buffers.insert(buffers.length, currentBuffer);\n          currentBuffer = null;\n        }\n        break;\n    }\n    eventType = parser.next();\n  }\n  return buffers;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that reads a List<string> of encoded data, checks each element's encoding validity with `buffer.isEncoding`, filters out invalid entries, and converts the valid ones to Buffers using `buffer.transcode`, then stores them in a new List<Buffer> using `List.replaceAllElements`.",
    "input": "",
    "output": "import {buffer, xml, List} from '@kit.ArkTS';\n\nexport function filterAndConvertEncodedStrings(encodedList: List<string>): List<Buffer> {\n  const validBuffers: Buffer[] = [];\n  \n  for (let i = 0; i < encodedList.length; i++) {\n    const encodedString = encodedList.get(i);\n    if (buffer.isEncoding(encodedString)) {\n      const buf = buffer.transcode(buffer.from(encodedString), 'utf8', 'utf8');\n      validBuffers.push(buf);\n    }\n  }\n  \n  const resultList = new List<Buffer>();\n  resultList.replaceAllElements(validBuffers);\n  return resultList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a buffer from a given string with UTF-8 encoding, then passes this buffer to a `MessageEvents` object by setting its `data` property. Finally, log the `timeStamp` property of an `Event` object triggered when the message is processed.",
    "input": "",
    "output": "import {buffer, MessageEvents, Event} from '@kit.ArkTS';\n\nexport function processMessageWithBuffer(inputString: string): void {\n  const bufferData: buffer.Buffer = buffer.from(inputString, 'utf-8');\n  const messageEvent: MessageEvents = new MessageEvents('message');\n  messageEvent.data = bufferData;\n  \n  const event: Event = new Event('process');\n  console.log(event.timeStamp);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that compares two buffers using `buffer.compare`, and based on the comparison result, constructs a `MessageEvents` object with the comparison result as its `data` property. Then, trigger an `Event` and log its `type` property to indicate whether the buffers were equal or not.",
    "input": "",
    "output": "import {buffer, MessageEvents, Event} from '@kit.ArkTS';\n\nexport function compareBuffersAndTriggerEvent(buf1: buffer.Buffer, buf2: buffer.Buffer): void {\n  const comparisonResult: number = buffer.compare(buf1, buf2);\n  const eventType: string = comparisonResult === 0 ? 'equal' : 'notEqual';\n  \n  const messageEvent: MessageEvents = new MessageEvents(eventType, {\n    data: comparisonResult\n  });\n  \n  const event: Event = new Event(eventType);\n  console.log(event.type);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that concatenates multiple buffers using `buffer.concat`, then uses the resulting buffer to set the `data` property of a `MessageEvents` object. After processing the message, create an `Event` and print both its `timeStamp` and `type` properties to track when and what type of event occurred.",
    "input": "",
    "output": "import {buffer, MessageEvents, Event} from '@kit.ArkTS';\n\nexport function concatenateAndProcessBuffers(buffers: buffer[]): void {\n  const concatenatedBuffer: buffer = buffer.concat(buffers);\n  const messageEvent: MessageEvents = new MessageEvents('message');\n  messageEvent.data = concatenatedBuffer;\n  \n  const event: Event = new Event('processed');\n  console.log(`Event timeStamp: ${event.timeStamp}`);\n  console.log(`Event type: ${event.type}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getFirst` and `getLast` methods of `Deque` (from @kit.ArkTS) to retrieve the first and last elements of a deque, then passes these elements to the `add` and `insert` methods of `List` (from @kit.ArkTS) to create a new list where the first element of the deque is added to the end and the last element of the deque is inserted at the beginning.",
    "input": "",
    "output": "import {WorkerGlobalScope, List, Deque} from '@kit.ArkTS';\n\nexport function processDequeToNewList(deque: Deque<number>): List<number> {\n  const firstElement = deque.getFirst();\n  const lastElement = deque.getLast();\n  \n  const newList = new List<number>();\n  newList.insert(0, lastElement);\n  newList.add(firstElement);\n  \n  return newList;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `convertToArray` method of `List` (from @kit.ArkTS) to transform a list into an array, then passes this array to the `forEach` method of `WorkerGlobalScope` (from @kit.ArkTS) to log each element of the array to the console in a worker thread.",
    "input": "",
    "output": "import {WorkerGlobalScope, List, Deque} from '@kit.ArkTS';\n\nexport function logListElementsInWorker(list: List<number>): void {\n  const array: number[] = list.convertToArray();\n  const workerScope: WorkerGlobalScope = self as WorkerGlobalScope;\n  workerScope.forEach(array, (element: number) => {\n    console.log(element);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `popFirst` and `popLast` methods of `Deque` (from @kit.ArkTS) to remove and retrieve the first and last elements of a deque, then uses the `set` method of `List` (from @kit.ArkTS) to replace the first and last elements of a list with the retrieved deque elements.",
    "input": "",
    "output": "import {WorkerGlobalScope, List, Deque} from '@kit.ArkTS';\n\nexport function replaceListElementsWithDeque(deque: Deque<number>, list: List<number>): void {\n  if (deque.length === 0 || list.length === 0) {\n    return;\n  }\n  \n  const firstElement = deque.popFirst();\n  const lastElement = deque.popLast();\n  \n  if (firstElement !== undefined) {\n    list.set(0, firstElement);\n  }\n  \n  if (lastElement !== undefined) {\n    list.set(list.length - 1, lastElement);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `set` method of `HashMap` to store event types as keys and their corresponding timestamps as values. Then, use the `dispatchEvent` method of `WorkerEventTarget` to trigger events based on the entries in the `HashMap`, ensuring the event `type` and `timeStamp` properties match the stored values.",
    "input": "",
    "output": "import {WorkerEventTarget, HashMap, Event} from '@kit.ArkTS';\n\nexport function triggerEvents(eventTarget: WorkerEventTarget, eventMap: HashMap<string, number>): void {\n  for (let [eventType, timeStamp] of eventMap.entries()) {\n    const event: Event = {\n      type: eventType,\n      timeStamp: timeStamp\n    };\n    eventTarget.dispatchEvent(event);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `forEach` method of `HashMap` to iterate over a collection of event types and their associated data. For each entry, use the `addEventListener` method of `WorkerEventTarget` to register a listener that logs the event `type` and `timeStamp` properties when the event is dispatched.",
    "input": "",
    "output": "import {WorkerEventTarget, HashMap, Event} from '@kit.ArkTS';\n\nexport function registerEventListeners(eventTarget: WorkerEventTarget, eventMap: HashMap<string, string>): void {\n  eventMap.forEach((value: string, key: string) => {\n    eventTarget.addEventListener(key, (event: Event) => {\n      console.log(`Event type: ${event.type}, timestamp: ${event.timeStamp}`);\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `keys` method of `HashMap` to retrieve all event types stored in the map. Then, use the `removeEventListener` method of `WorkerEventTarget` to unregister all listeners for these event types, ensuring no events are dispatched for them afterward.",
    "input": "",
    "output": "import {WorkerEventTarget, HashMap, Event} from '@kit.ArkTS';\n\nexport function unregisterAllListeners(eventMap: HashMap<string, Event>, target: WorkerEventTarget): void {\n  const eventTypes: string[] = eventMap.keys();\n  for (const eventType of eventTypes) {\n    target.removeEventListener(eventType);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `parse` method of `json` to convert a JSON string into an object, then uses the `add` method of `LightWeightSet` to store the parsed object's values. Finally, use the `values` method of `LightWeightSet` to iterate over the stored values and log them to the console.",
    "input": "",
    "output": "import {json, WorkerGlobalScope, LightWeightSet} from '@kit.ArkTS';\n\nexport function parseAndStoreJson(jsonString: string): void {\n  const parsedObject = json.parse(jsonString);\n  const lightWeightSet = new LightWeightSet<unknown>();\n\n  if (typeof parsedObject === 'object' && parsedObject !== null) {\n    for (const key in parsedObject) {\n      if (parsedObject.hasOwnProperty(key)) {\n        lightWeightSet.add(parsedObject[key]);\n      }\n    }\n  }\n\n  const valuesIterator = lightWeightSet.values();\n  let currentValue = valuesIterator.next();\n  while (!currentValue.done) {\n    console.log(currentValue.value);\n    currentValue = valuesIterator.next();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `stringify` method of `json` to convert an object into a JSON string, then passes this string to a Worker thread using the `postMessage` method of `WorkerGlobalScope`. Inside the Worker, use the `parse` method of `json` to convert the string back into an object and log it.",
    "input": "",
    "output": "import {json, WorkerGlobalScope, LightWeightSet} from '@kit.ArkTS';\n\nexport function sendObjectToWorker(obj: object, worker: WorkerGlobalScope): void {\n  const jsonString = json.stringify(obj);\n  worker.postMessage(jsonString);\n}\n\nexport function handleWorkerMessage(event: MessageEvent): void {\n  const jsonString = event.data;\n  const parsedObj = json.parse(jsonString);\n  console.log(parsedObj);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `has` method of `LightWeightSet` to check if a specific value exists in the set. If the value exists, use the `remove` method of `LightWeightSet` to delete it, then use the `stringify` method of `json` to convert the modified set into a JSON string and return it.",
    "input": "",
    "output": "import {json, WorkerGlobalScope, LightWeightSet} from '@kit.ArkTS';\n\nexport function modifySetAndReturnJson(set: LightWeightSet<unknown>, value: unknown): string {\n  if (set.has(value)) {\n    set.remove(value);\n  }\n  return json.stringify(set);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` to collect a sequence of numbers, then passes the deque to the `convertToArray` method of `LinkedList` to convert it into an array, and finally uses the `forEach` method of `LinkedList` to print each element.",
    "input": "",
    "output": "import {uri, Deque, LinkedList} from '@kit.ArkTS';\n\nexport function processDequeToArrayAndPrint(): void {\n  const deque = new Deque<number>();\n  deque.insertFront(1);\n  deque.insertEnd(2);\n  deque.insertFront(3);\n  deque.insertEnd(4);\n\n  const linkedList = new LinkedList<number>();\n  const array = linkedList.convertToArray(deque);\n\n  linkedList.forEach(array, (value: number) => {\n    console.log(value);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `add` and `addFirst` methods of `LinkedList` to build a list of strings, then transfers the elements to a `Deque` using its `insertFront` and `insertEnd` methods, and finally uses the `getFirst` and `getLast` methods of `Deque` to retrieve and print the first and last elements.",
    "input": "",
    "output": "import {uri, Deque, LinkedList} from '@kit.ArkTS';\n\nexport function transferAndPrintElements(): void {\n  // Create a LinkedList and add elements\n  const linkedList = new LinkedList<string>();\n  linkedList.add('First');\n  linkedList.add('Middle');\n  linkedList.addFirst('VeryFirst');\n  linkedList.add('Last');\n\n  // Create a Deque and transfer elements from LinkedList\n  const deque = new Deque<string>();\n  for (const element of linkedList) {\n    deque.insertEnd(element);\n  }\n\n  // Retrieve and print the first and last elements of the Deque\n  const firstElement = deque.getFirst();\n  const lastElement = deque.getLast();\n  console.log(`First element: ${firstElement}`);\n  console.log(`Last element: ${lastElement}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `removeFirst` and `removeLast` methods of `LinkedList` to trim a list of integers, then transfers the remaining elements to a `Deque` using its `insertFront` method, and finally uses the `popFirst` and `popLast` methods of `Deque` to process and print the elements in reverse order.",
    "input": "",
    "output": "import {uri, Deque, LinkedList} from '@kit.ArkTS';\n\nexport function processLinkedList(list: LinkedList<number>): void {\n  // Trim the list by removing first and last elements\n  if (list.length > 0) {\n    list.removeFirst();\n  }\n  if (list.length > 0) {\n    list.removeLast();\n  }\n\n  // Transfer remaining elements to a Deque using insertFront\n  const deque = new Deque<number>();\n  for (const element of list) {\n    deque.insertFront(element);\n  }\n\n  // Process and print elements in reverse order using popFirst and popLast\n  while (deque.length > 0) {\n    if (deque.length % 2 === 0) {\n      const element = deque.popFirst();\n      console.log(element);\n    } else {\n      const element = deque.popLast();\n      console.log(element);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `PlainArray` to store a sequence of key-value pairs representing task IDs and their priorities, then filters out tasks with priority below a threshold using the `removeRangeFrom` method of `PlainArray`, and finally passes the remaining task IDs to the `execute` method of `taskpool` to schedule their execution.",
    "input": "",
    "output": "import {PlainArray, HashSet, taskpool} from '@kit.ArkTS';\n\nexport function filterAndExecuteTasks(taskPriorities: Map<number, number>, priorityThreshold: number): void {\n  const tasks = new PlainArray<number>();\n  \n  // Add task IDs and their priorities to PlainArray\n  taskPriorities.forEach((priority, taskId) => {\n    tasks.add(taskId, priority);\n  });\n  \n  // Filter out tasks with priority below the threshold\n  const filteredTasks = new PlainArray<number>();\n  tasks.forEach((value, key) => {\n    if (value >= priorityThreshold) {\n      filteredTasks.add(key, value);\n    }\n  });\n  \n  // Collect remaining task IDs\n  const taskIds = new HashSet<number>();\n  filteredTasks.forEach((_, key) => {\n    taskIds.add(key);\n  });\n  \n  // Execute remaining tasks using taskpool\n  taskIds.forEach((taskId) => {\n    taskpool.execute(() => {\n      // Task execution logic goes here\n      console.log(`Executing task with ID: ${taskId}`);\n    }, taskpool.Priority.LOW);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first populates a `HashSet` with unique user IDs using its `add` method, then checks for duplicates in a `PlainArray` of user activities using the `has` method of `HashSet`, and finally logs the duplicate activities by iterating through the `PlainArray` using its `getValueAt` method.",
    "input": "",
    "output": "import {PlainArray, HashSet, taskpool} from '@kit.ArkTS';\n\nexport function findDuplicateActivities(userIds: number[], activities: PlainArray<number, string>): void {\n  const userIdSet = new HashSet<number>();\n  \n  // Populate HashSet with unique user IDs\n  for (const userId of userIds) {\n    userIdSet.add(userId);\n  }\n  \n  const duplicateActivities: string[] = [];\n  \n  // Check for duplicates in PlainArray\n  for (let i = 0; i < activities.length; i++) {\n    const activity = activities.getValueAt(i);\n    const userId = activities.getKeyAt(i);\n    \n    if (userIdSet.has(userId)) {\n      duplicateActivities.push(activity);\n    }\n  }\n  \n  // Log duplicate activities\n  console.log('Duplicate Activities:', duplicateActivities);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a task scheduler that uses the `executePeriodically` method of `taskpool` to run a periodic task, which collects system metrics into a `PlainArray` using its `add` method, and then processes the metrics by iterating through the `PlainArray` with `forEach` and storing the results in a `HashSet` using its `add` method to ensure uniqueness.",
    "input": "",
    "output": "import {PlainArray, HashSet, taskpool} from '@kit.ArkTS';\n\nexport class TaskScheduler {\n  private metricsArray: PlainArray<number, string> = new PlainArray();\n  private processedMetrics: HashSet<string> = new HashSet();\n  private taskId: number | null = null;\n\n  private collectMetrics(): void {\n    // Simulate collecting system metrics\n    const metricKey = Date.now();\n    const metricValue = `metric_${metricKey}`;\n    this.metricsArray.add(metricKey, metricValue);\n  }\n\n  private processMetrics(): void {\n    this.metricsArray.forEach((value: string) => {\n      this.processedMetrics.add(value);\n    });\n    this.metricsArray.clear();\n  }\n\n  public start(interval: number): void {\n    if (this.taskId !== null) {\n      return;\n    }\n\n    this.taskId = taskpool.executePeriodically(() => {\n      this.collectMetrics();\n      this.processMetrics();\n    }, interval, false);\n  }\n\n  public stop(): void {\n    if (this.taskId !== null) {\n      taskpool.cancel(this.taskId);\n      this.taskId = null;\n    }\n  }\n\n  public getProcessedMetrics(): HashSet<string> {\n    return this.processedMetrics;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` to collect a sequence of numbers, then passes the deque to a `DedicatedWorkerGlobalScope` using the `postMessage` method to process the numbers in a worker thread. The worker should use the `onmessage` property to receive the deque and return the sum of all numbers using the `getFirst` and `popFirst` methods of `Deque`.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, Deque, Deque} from '@kit.ArkTS';\n\nexport function processNumbersWithWorker(numbers: number[]): void {\n  const deque = new Deque<number>();\n  \n  // Insert numbers into the deque\n  numbers.forEach(num => {\n    if (num % 2 === 0) {\n      deque.insertFront(num);\n    } else {\n      deque.insertEnd(num);\n    }\n  });\n  \n  // Create a worker\n  const worker = new DedicatedWorkerGlobalScope('worker.js');\n  \n  // Post the deque to the worker\n  worker.postMessage(deque);\n  \n  // Handle the result from the worker\n  worker.onmessage = (event) => {\n    console.log('Sum of numbers:', event.data);\n    worker.close();\n  };\n}\n\n// worker.js content (should be in a separate file)\n// This part is for reference and should be in a separate file named 'worker.js'\n/*\nimport {DedicatedWorkerGlobalScope, Deque, Deque} from '@kit.ArkTS';\n\nconst workerScope = self as unknown as DedicatedWorkerGlobalScope;\n\nworkerScope.onmessage = (event) => {\n  const deque: Deque<number> = event.data;\n  let sum = 0;\n  \n  while (deque.length > 0) {\n    sum += deque.getFirst();\n    deque.popFirst();\n  }\n  \n  workerScope.postMessage(sum);\n};\n*/\n",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes a `Deque` with random strings using the `insertEnd` method, then uses the `forEach` method of `Deque` to filter out strings longer than 5 characters. The filtered strings should be passed to a `DedicatedWorkerGlobalScope` via `postMessage`, where the worker uses the `onmessage` property to receive the data and the `length` property of `Deque` to count the number of remaining strings.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, Deque, Deque} from '@kit.ArkTS';\n\nexport function initializeDequeWithRandomStrings(): Deque<string> {\n  const deque = new Deque<string>();\n  const randomStrings = ['apple', 'banana', 'cherry', 'date', 'elderberry', 'fig', 'grape', 'honeydew'];\n  \n  randomStrings.forEach((str) => {\n    deque.insertEnd(str);\n  });\n  \n  return deque;\n}\n\nexport function filterAndSendToWorker(deque: Deque<string>, worker: DedicatedWorkerGlobalScope): void {\n  const filteredStrings: string[] = [];\n  \n  deque.forEach((str: string) => {\n    if (str.length <= 5) {\n      filteredStrings.push(str);\n    }\n  });\n  \n  worker.postMessage({\n    filteredStrings: filteredStrings,\n    remainingCount: deque.length\n  });\n}\n\nexport function setupWorker(): DedicatedWorkerGlobalScope {\n  const worker = new DedicatedWorkerGlobalScope();\n  \n  worker.onmessage = (event: MessageEvent) => {\n    const data = event.data;\n    console.log(`Filtered strings: ${data.filteredStrings}`);\n    console.log(`Remaining count: ${data.remainingCount}`);\n  };\n  \n  return worker;\n}\n\nexport function main(): void {\n  const deque = initializeDequeWithRandomStrings();\n  const worker = setupWorker();\n  filterAndSendToWorker(deque, worker);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `popLast` method of `Deque` to remove and collect the last 3 elements, then sends these elements to a `DedicatedWorkerGlobalScope` using the `postMessage` method. The worker should use the `onmessage` property to receive the elements and the `insertFront` method of `Deque` to prepend them to a new deque, then return the modified deque.",
    "input": "",
    "output": "import {DedicatedWorkerGlobalScope, Deque} from '@kit.ArkTS';\n\nexport function processDequeWithWorker(originalDeque: Deque<number>, worker: DedicatedWorkerGlobalScope): void {\n  const lastThreeElements: number[] = [];\n  for (let i = 0; i < 3 && originalDeque.length > 0; i++) {\n    const element = originalDeque.popLast();\n    if (element !== undefined) {\n      lastThreeElements.push(element);\n    }\n  }\n  worker.postMessage(lastThreeElements);\n}\n\nexport function setupWorker(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent<number[]>) => {\n    const receivedElements = event.data;\n    const newDeque = new Deque<number>();\n    for (const element of receivedElements) {\n      newDeque.insertFront(element);\n    }\n    worker.postMessage(newDeque);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `ArrayList.add` to collect a list of JSON strings, then parses each string using `json.parse` to extract objects, and finally uses `util.format` to log a formatted summary of each object's properties.",
    "input": "",
    "output": "import {ArrayList, json, util} from '@kit.ArkTS';\n\nexport function processJsonStrings(jsonStrings: ArrayList<string>): void {\n  const parsedObjects: ArrayList<object> = new ArrayList();\n  \n  for (const jsonString of jsonStrings) {\n    try {\n      const parsedObject = json.parse(jsonString);\n      parsedObjects.add(parsedObject);\n    } catch (error) {\n      console.error(`Failed to parse JSON string: ${jsonString}`);\n    }\n  }\n  \n  for (const obj of parsedObjects) {\n    const formattedSummary = util.format('Object properties: %j', obj);\n    console.log(formattedSummary);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that generates random UUIDs using `util.generateRandomUUID`, stores them in an `ArrayList` using `ArrayList.add`, then converts the list to a JSON string using `json.stringify` and logs the result.",
    "input": "",
    "output": "import {ArrayList, json, util} from '@kit.ArkTS';\n\nexport function generateAndLogUUIDs(count: number): void {\n  const uuidList: ArrayList<string> = new ArrayList();\n  \n  for (let i = 0; i < count; i++) {\n    const uuid: string = util.generateRandomUUID();\n    uuidList.add(uuid);\n  }\n  \n  const jsonString: string = json.stringify(uuidList.convertToArray());\n  console.log(jsonString);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `json.parse` to extract an array of numbers from a JSON string, then uses `ArrayList.sort` to sort the numbers in ascending order, and finally uses `util.printf` to print the sorted list in a formatted string.",
    "input": "",
    "output": "import {ArrayList, json, util} from '@kit.ArkTS';\n\nexport function sortAndPrintNumbers(jsonString: string): void {\n  const parsedArray: number[] = json.parse(jsonString) as number[];\n  const arrayList: ArrayList<number> = new ArrayList();\n  \n  for (const num of parsedArray) {\n    arrayList.add(num);\n  }\n  \n  arrayList.sort((a: number, b: number) => a - b);\n  \n  const sortedArray: number[] = [];\n  for (let i = 0; i < arrayList.length; i++) {\n    sortedArray.push(arrayList.get(i));\n  }\n  \n  util.printf('Sorted numbers: %s', sortedArray.join(', '));\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Vector` to collect a sequence of event names, then passes the resulting vector to the `dispatchEvent` method of `EventTarget` to trigger all the events in sequence. The function should also use the `length` property of `Vector` to verify that events were added before dispatching.",
    "input": "",
    "output": "import {worker, Vector, EventTarget} from '@kit.ArkTS';\n\nexport function dispatchEventsSequentially(eventNames: string[], target: EventTarget): void {\n  const eventsVector = new Vector<string>();\n  \n  for (const eventName of eventNames) {\n    eventsVector.add(eventName);\n  }\n  \n  if (eventsVector.length > 0) {\n    for (let i = 0; i < eventsVector.length; i++) {\n      const eventName = eventsVector.get(i);\n      target.dispatchEvent(eventName);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `getFirstElement` method of `Vector` to retrieve the first event name, then passes it to the `addEventListener` method of `EventTarget` to set up a listener for that event. The function should also use the `removeEventListener` method of `EventTarget` to clean up the listener after the event is triggered once.",
    "input": "",
    "output": "import {worker, Vector, EventTarget} from '@kit.ArkTS';\n\nexport function setupAndCleanupEventListener(eventNames: Vector<string>, target: EventTarget, callback: (event: Event) => void): void {\n  if (eventNames.isEmpty()) {\n    return;\n  }\n  \n  const firstEventName: string = eventNames.getFirstElement();\n  \n  const eventListener = (event: Event) => {\n    callback(event);\n    target.removeEventListener(firstEventName, eventListener);\n  };\n  \n  target.addEventListener(firstEventName, eventListener);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `sort` method of `Vector` to organize a list of event names alphabetically, then iterates over the sorted vector using the `Symbol.iterator` method to register each event name with the `addEventListener` method of `EventTarget`. The function should also use the `removeAllListener` method of `EventTarget` to remove all listeners at the end.",
    "input": "",
    "output": "import {worker, Vector, EventTarget} from '@kit.ArkTS';\n\nexport function registerAndCleanupEvents(eventNames: Vector<string>, target: EventTarget): void {\n  // Sort the event names alphabetically\n  eventNames.sort((a: string, b: string) => a.localeCompare(b));\n\n  // Register each event name with the EventTarget\n  for (const eventName of eventNames) {\n    target.addEventListener(eventName, () => {});\n  }\n\n  // Remove all listeners at the end\n  target.removeAllListener();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a URI string to a worker thread, and then uses the `addEventListener` method of `EventTarget` in the main thread to listen for and handle the response message from the worker thread.",
    "input": "",
    "output": "import {uri, EventTarget, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function sendUriToWorker(worker: ThreadWorkerGlobalScope, uriString: string): void {\n  worker.postMessage(uriString);\n}\n\nexport function listenForWorkerResponse(eventTarget: EventTarget, callback: (event: MessageEvent) => void): void {\n  eventTarget.addEventListener('message', callback);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker thread that uses the `onmessage` property of `ThreadWorkerGlobalScope` to receive a URI string from the main thread, processes it (e.g., validates or modifies it), and then uses the `dispatchEvent` method of `EventTarget` to send the processed URI back to the main thread.",
    "input": "",
    "output": "import {uri, EventTarget, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport class UriWorker {\n  private workerScope: ThreadWorkerGlobalScope;\n\n  constructor(workerScope: ThreadWorkerGlobalScope) {\n    this.workerScope = workerScope;\n    this.workerScope.onmessage = this.handleMessage.bind(this);\n  }\n\n  private handleMessage(event: MessageEvent<string>): void {\n    const receivedUri: string = event.data;\n    const processedUri: string = this.processUri(receivedUri);\n    const customEvent: CustomEvent<string> = new CustomEvent('processedUri', { detail: processedUri });\n    (this.workerScope as unknown as EventTarget).dispatchEvent(customEvent);\n  }\n\n  private processUri(uriString: string): string {\n    // Example processing: validate or modify the URI\n    return uriString.startsWith('http://') ? uriString : `http://${uriString}`;\n  }\n}\n\nconst worker = new UriWorker(self as unknown as ThreadWorkerGlobalScope);",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where the main thread uses the `removeEventListener` method of `EventTarget` to stop listening for messages from a worker thread after receiving a specific message (e.g., a 'close' signal), and then uses the `close` method of `ThreadWorkerGlobalScope` to terminate the worker thread.",
    "input": "",
    "output": "import {uri, EventTarget, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function handleWorkerCommunication(worker: ThreadWorkerGlobalScope): void {\n  const eventTarget: EventTarget = new EventTarget();\n  \n  const messageHandler = (event: MessageEvent): void => {\n    if (event.data === 'close') {\n      eventTarget.removeEventListener('message', messageHandler);\n      worker.close();\n    }\n  };\n  \n  eventTarget.addEventListener('message', messageHandler);\n  worker.onmessage = (event: MessageEvent): void => {\n    eventTarget.dispatchEvent(event);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first uses the `getEnvironmentVar` method of `process` to retrieve the value of an environment variable, then encodes the retrieved value using the `from` method of `buffer` with UTF-8 encoding, and finally checks if the encoded buffer is valid using the `isEncoding` method of `buffer`.",
    "input": "",
    "output": "import {process, buffer} from '@kit.ArkTS';\n\nexport function checkEnvironmentVarEncoding(envVarName: string): boolean {\n  const envVarValue = process.getEnvironmentVar(envVarName);\n  if (envVarValue === undefined) {\n    return false;\n  }\n  const encodedBuffer = buffer.from(envVarValue, 'utf-8');\n  return buffer.isEncoding('utf-8');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getPastCpuTime` method of `process` to measure the CPU time consumed by the current process, converts the measured time into a string, and then creates a buffer from this string using the `alloc` method of `buffer` with a specified size. The function should then compare this buffer with another predefined buffer using the `compare` method of `buffer` to determine if the CPU time exceeds a certain threshold.",
    "input": "",
    "output": "import {process, buffer} from '@kit.ArkTS';\n\nexport function checkCpuTimeThreshold(thresholdBuffer: buffer.Buffer): boolean {\n  const cpuTime = process.getPastCpuTime();\n  const cpuTimeStr = cpuTime.toString();\n  const cpuTimeBuffer = buffer.alloc(cpuTimeStr.length, cpuTimeStr);\n  \n  const comparisonResult = buffer.compare(cpuTimeBuffer, thresholdBuffer);\n  \n  return comparisonResult > 0;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first checks if the current process is running in a 64-bit environment using the `is64Bit` method of `process`, then allocates a buffer of a specific size based on the result (larger size if 64-bit, smaller otherwise) using the `allocUninitialized` method of `buffer`, and finally writes the process uptime obtained from the `uptime` method of `process` into the buffer as a string.",
    "input": "",
    "output": "import {process, buffer, process} from '@kit.ArkTS';\n\nexport function processUptimeBuffer(): buffer.Buffer {\n  const is64Bit: boolean = process.is64Bit();\n  const bufferSize: number = is64Bit ? 1024 : 512;\n  const buf: buffer.Buffer = buffer.allocUninitialized(bufferSize);\n  const uptime: number = process.uptime();\n  buf.write(uptime.toString());\n  return buf;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `postMessage` method of `ThreadWorkerGlobalScope` to send a sequence of numbers to a worker thread, where the worker thread uses the `insertFront` and `popLast` methods of `Deque` to reverse the sequence and then sends the reversed sequence back to the main thread using `postMessage`.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, WorkerEventTarget, Deque} from '@kit.ArkTS';\n\nexport function reverseSequenceWithWorker(sequence: number[]): void {\n  const worker = new ThreadWorkerGlobalScope('workers/worker.ts');\n  \n  worker.onmessage = (event: MessageEvent<number[]>) => {\n    console.log('Reversed sequence:', event.data);\n    worker.close();\n  };\n  \n  worker.postMessage(sequence);\n}\n\nexport function workerThreadLogic(): void {\n  const workerScope = self as unknown as ThreadWorkerGlobalScope;\n  \n  workerScope.onmessage = (event: MessageEvent<number[]>) => {\n    const deque = new Deque<number>();\n    \n    for (const num of event.data) {\n      deque.insertFront(num);\n    }\n    \n    const reversedSequence: number[] = [];\n    while (deque.length > 0) {\n      reversedSequence.push(deque.popLast());\n    }\n    \n    workerScope.postMessage(reversedSequence);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a worker event handler that uses the `addEventListener` method of `WorkerEventTarget` to listen for messages from the main thread. Upon receiving a message, the handler should use the `getFirst` and `getLast` methods of `Deque` to check if the first and last elements of the received array are equal, and then use the `postMessage` method of `ThreadWorkerGlobalScope` to send the result back to the main thread.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, WorkerEventTarget, Deque} from '@kit.ArkTS';\n\nexport function setupWorkerListener(workerScope: ThreadWorkerGlobalScope): void {\n  const eventTarget: WorkerEventTarget = workerScope as unknown as WorkerEventTarget;\n  \n  eventTarget.addEventListener('message', (event: MessageEvent<Array<number>>) => {\n    const deque = new Deque<number>();\n    const receivedArray = event.data;\n    \n    for (const item of receivedArray) {\n      deque.insertEnd(item);\n    }\n    \n    const firstElement = deque.getFirst();\n    const lastElement = deque.getLast();\n    const result = firstElement === lastElement;\n    \n    workerScope.postMessage(result);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where the main thread uses the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope` to send a shared array buffer to a worker thread. The worker thread should then use the `forEach` method of `Deque` to process each element of the array buffer and send the processed data back to the main thread using the `dispatchEvent` method of `WorkerEventTarget`.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, WorkerEventTarget, Deque} from '@kit.ArkTS';\n\nexport function setupWorker(workerScope: ThreadWorkerGlobalScope): void {\n  workerScope.onmessage = (event: MessageEvent<ArrayBuffer>): void => {\n    const sharedBuffer = event.data;\n    const deque = new Deque<number>();\n    const view = new Int32Array(sharedBuffer);\n\n    view.forEach((value: number) => {\n      deque.insertEnd(value * 2); // Example processing: doubling each value\n    });\n\n    const processedData: number[] = [];\n    deque.forEach((value: number) => {\n      processedData.push(value);\n    });\n\n    const eventTarget = workerScope as unknown as WorkerEventTarget;\n    const customEvent = new CustomEvent('processedData', { detail: processedData });\n    eventTarget.dispatchEvent(customEvent);\n  };\n}\n\nexport function sendDataToWorker(workerScope: ThreadWorkerGlobalScope, buffer: ArrayBuffer): void {\n  workerScope.postMessageWithSharedSendable(buffer);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `HashSet` to collect unique event names from a list, then passes these names to the `forEach` method of `Vector` to create a new Vector containing the lengths of each event name. Finally, use the `sort` method of `Vector` to arrange the lengths in ascending order.",
    "input": "",
    "output": "import {Vector, HashSet, EventTarget} from '@kit.ArkTS';\n\nexport function processEventNames(events: string[]): Vector<number> {\n  const uniqueNames = new HashSet<string>();\n  events.forEach(event => {\n    uniqueNames.add(event);\n  });\n\n  const lengths = new Vector<number>();\n  uniqueNames.forEach(name => {\n    lengths.add(name.length);\n  });\n\n  lengths.sort((a, b) => a - b);\n  return lengths;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `get` and `length` properties of `Vector` to extract a subset of elements, then pass this subset to the `add` method of `HashSet` to ensure all elements are unique. Use the `dispatchEvent` method of `EventTarget` to trigger an event with the unique elements as part of the event data.",
    "input": "",
    "output": "import {Vector, HashSet, EventTarget} from '@kit.ArkTS';\n\nexport function extractUniqueElementsAndDispatch(vector: Vector<number>, start: number, end: number, eventTarget: EventTarget, eventType: string): void {\n  const subset = new Vector<number>();\n  for (let i = start; i < end && i < vector.length; i++) {\n    const element = vector.get(i);\n    subset.add(element);\n  }\n\n  const hashSet = new HashSet<number>();\n  for (const element of subset) {\n    hashSet.add(element);\n  }\n\n  const uniqueElements = Array.from(hashSet.values());\n  const event = {\n    type: eventType,\n    data: uniqueElements\n  };\n  eventTarget.dispatchEvent(event);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `addEventListener` method of `EventTarget` to listen for custom events. When an event is received, use the `convertToArray` method of `Vector` to transform the event data into an array, then pass this array to the `entries` method of `HashSet` to iterate over and log each key-value pair.",
    "input": "",
    "output": "import {Vector, HashSet, EventTarget} from '@kit.ArkTS';\n\nexport function listenAndProcessCustomEvent(eventTarget: EventTarget, eventName: string): void {\n  eventTarget.addEventListener(eventName, (event: CustomEvent) => {\n    const vector = new Vector<number>();\n    vector.add(1);\n    vector.add(2);\n    vector.add(3);\n    \n    const array = vector.convertToArray();\n    const hashSet = new HashSet<number>();\n    hashSet.add(1);\n    hashSet.add(2);\n    hashSet.add(3);\n    \n    const entries = hashSet.entries();\n    for (const entry of entries) {\n      console.log(`Key: ${entry[0]}, Value: ${entry[1]}`);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` and `pop` methods of `Stack` (from @kit.ArkTS) to manage a stack of task priorities (of type `Priority` from `taskpool`). Then, use the `postMessage` method of `ThreadWorkerGlobalScope` to send the processed stack (as an array) to a worker thread for further execution.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, Stack, taskpool} from '@kit.ArkTS';\n\nexport function manageTaskPriorities(priorities: taskpool.Priority[]): Stack<taskpool.Priority> {\n  const stack = new Stack<taskpool.Priority>();\n  priorities.forEach((priority) => {\n    stack.push(priority);\n  });\n  return stack;\n}\n\nexport function sendStackToWorker(worker: ThreadWorkerGlobalScope, stack: Stack<taskpool.Priority>): void {\n  const stackArray: taskpool.Priority[] = [];\n  while (!stack.isEmpty()) {\n    stackArray.push(stack.pop());\n  }\n  worker.postMessage(stackArray);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a task scheduler that uses the `execute` method of `taskpool` (with `Priority` enum) to run multiple tasks concurrently. Collect the task results in a `Stack` (using `push`), and then use the `postMessageWithSharedSendable` method of `ThreadWorkerGlobalScope` to share the stack with another worker thread for aggregation.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, Stack, taskpool} from '@kit.ArkTS';\n\nexport class TaskScheduler {\n  private stack: Stack<number> = new Stack();\n  private worker: ThreadWorkerGlobalScope = new ThreadWorkerGlobalScope();\n\n  async executeTasks(tasks: (() => number)[]): Promise<void> {\n    const promises = tasks.map(task => {\n      return taskpool.execute(task, taskpool.Priority.LOW);\n    });\n\n    const results = await Promise.all(promises);\n    results.forEach(result => {\n      this.stack.push(result);\n    });\n\n    this.worker.postMessageWithSharedSendable(this.stack);\n  }\n}\n\nexport class AggregatorWorker {\n  private worker: ThreadWorkerGlobalScope = new ThreadWorkerGlobalScope();\n\n  constructor() {\n    this.worker.onmessage = (message: { data: Stack<number> }) => {\n      const stack = message.data;\n      let sum = 0;\n      while (!stack.isEmpty()) {\n        sum += stack.pop();\n      }\n      console.log(`Aggregated result: ${sum}`);\n    };\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a worker thread that receives a shared stack (via `onmessage` of `ThreadWorkerGlobalScope`) containing task IDs, processes them using the `peek` and `locate` methods of `Stack`, and then cancels specific tasks using the `cancel` method of `taskpool` based on the stack's contents.",
    "input": "",
    "output": "import {ThreadWorkerGlobalScope, Stack, taskpool} from '@kit.ArkTS';\n\nexport class TaskProcessorWorker {\n  private workerScope: ThreadWorkerGlobalScope;\n\n  constructor(workerScope: ThreadWorkerGlobalScope) {\n    this.workerScope = workerScope;\n    this.workerScope.onmessage = this.handleMessage.bind(this);\n  }\n\n  private handleMessage(event: MessageEvent<Stack<number>>): void {\n    const taskStack: Stack<number> = event.data;\n    while (!taskStack.isEmpty()) {\n      const taskId: number = taskStack.peek();\n      const position: number = taskStack.locate(taskId);\n      if (position !== -1) {\n        taskpool.cancel(taskId);\n      }\n      taskStack.pop();\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `LinkedList` to collect a sequence of XML event types (from the `EventType` enum of `xml`), then uses the `convertToArray` method of `LinkedList` to convert the list into an array, and finally passes this array to the `transfer` property of `PostMessageOptions` to send the event types to another context.",
    "input": "",
    "output": "import {LinkedList, xml, PostMessageOptions} from '@kit.ArkTS';\n\nexport function collectAndSendEventTypes(): void {\n  const eventList: LinkedList<xml.EventType> = new LinkedList<xml.EventType>();\n  eventList.add(xml.EventType.START_ELEMENT);\n  eventList.add(xml.EventType.END_ELEMENT);\n  eventList.add(xml.EventType.TEXT);\n  \n  const eventArray: Array<xml.EventType> = eventList.convertToArray();\n  const options: PostMessageOptions = {\n    transfer: eventArray\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `getFirst` and `getLast` methods of `LinkedList` to retrieve the first and last elements of a list, then constructs an XML message using these elements (using `xml` API for formatting), and finally uses the `PostMessageOptions` with the `transfer` property to send the constructed XML message to a web worker.",
    "input": "",
    "output": "import {LinkedList, xml, PostMessageOptions} from '@kit.ArkTS';\n\nexport function sendFirstAndLastToWorker(list: LinkedList<string>, worker: Worker): void {\n  const firstElement = list.getFirst();\n  const lastElement = list.getLast();\n\n  const xmlBuilder = new xml.XmlBuilder();\n  xmlBuilder.startElement('elements');\n  xmlBuilder.startElement('first').text(firstElement).endElement();\n  xmlBuilder.startElement('last').text(lastElement).endElement();\n  xmlBuilder.endElement();\n  const xmlMessage = xmlBuilder.toString();\n\n  const options: PostMessageOptions = {\n    transfer: []\n  };\n\n  worker.postMessage(xmlMessage, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `LinkedList` to iterate over a list of data items, generates XML content for each item (using `xml` API), and then uses the `PostMessageOptions` with the `transfer` property to batch-send all generated XML content to a remote server.",
    "input": "",
    "output": "import {LinkedList, xml, PostMessageOptions} from '@kit.ArkTS';\n\nexport function processAndSendData(dataList: LinkedList<string>, serverUrl: string): void {\n  const xmlContents: ArrayBuffer[] = [];\n  \n  dataList.forEach((data: string) => {\n    const xmlBuilder = new xml.XmlBuilder();\n    xmlBuilder.startElement('item');\n    xmlBuilder.setAttributes('value', data);\n    xmlBuilder.endElement();\n    const xmlContent = xmlBuilder.toString();\n    const buffer = new ArrayBuffer(xmlContent.length * 2);\n    const view = new Uint16Array(buffer);\n    for (let i = 0; i < xmlContent.length; i++) {\n      view[i] = xmlContent.charCodeAt(i);\n    }\n    xmlContents.push(buffer);\n  });\n  \n  const options: PostMessageOptions = {\n    transfer: xmlContents\n  };\n  \n  // Assuming there is a postMessage function available to send data to the server\n  postMessage(serverUrl, xmlContents, options);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `Vector` to collect a series of event objects (from the `Event` API), then uses the `sort` method of `Vector` to sort these events based on their `timeStamp` property, and finally converts the sorted events into an array using the `convertToArray` method of `Vector`.",
    "input": "",
    "output": "import {Vector, Event} from '@kit.ArkTS';\n\nexport function sortEventsByTimestamp(events: Event[]): Event[] {\n  const vector = new Vector<Event>();\n  \n  for (const event of events) {\n    vector.add(event);\n  }\n  \n  vector.sort((a: Event, b: Event) => {\n    return a.timeStamp - b.timeStamp;\n  });\n  \n  return vector.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first checks if a `Vector` is empty using the `isEmpty` method, and if not, retrieves the first element using `getFirstElement` and the last element using `getLastElement`. Then, use these elements to create a new `Event` object where the `type` property is a concatenation of the first and last element's types from the `Vector`.",
    "input": "",
    "output": "import {Vector, Event} from '@kit.ArkTS';\n\nexport function createEventFromVector(vector: Vector<unknown>): Event | null {\n  if (vector.isEmpty()) {\n    return null;\n  }\n\n  const firstElement = vector.getFirstElement();\n  const lastElement = vector.getLastElement();\n  const eventType = `${typeof firstElement}_${typeof lastElement}`;\n\n  const event: Event = {\n    type: eventType,\n    timeStamp: new Date().getTime()\n  };\n\n  return event;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `getIndexFrom` method of `Vector` to find all indices of a specific event type (from the `Event` API) in the vector, then uses the `removeByIndex` method of `Vector` to remove all events at those indices, and finally returns the updated vector using the `toString` method of `Vector`.",
    "input": "",
    "output": "import {Vector, Event, Vector} from '@kit.ArkTS';\n\nexport function removeEventsByType(vector: Vector<Event>, eventType: string): string {\n  const indices: number[] = [];\n  let index = 0;\n  \n  while (index < vector.length) {\n    const foundIndex = vector.getIndexFrom(index, (event: Event) => event.type === eventType);\n    if (foundIndex === -1) {\n      break;\n    }\n    indices.push(foundIndex);\n    index = foundIndex + 1;\n  }\n  \n  for (let i = indices.length - 1; i >= 0; i--) {\n    vector.removeByIndex(indices[i]);\n  }\n  \n  return vector.toString();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `TreeSet` to store a collection of unique timestamps, then uses the `getFirstValue` and `getLastValue` methods of `TreeSet` to determine the earliest and latest timestamps. Finally, pass these timestamps to the `set` method of `TreeMap` to map the earliest timestamp to 'start' and the latest timestamp to 'end'.",
    "input": "",
    "output": "import {TreeSet, TreeMap, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function mapTimestamps(timestamps: number[]): TreeMap<number, string> {\n  const timestampSet = new TreeSet<number>();\n  \n  // Add all timestamps to the TreeSet (automatically handles uniqueness)\n  timestamps.forEach((timestamp) => {\n    timestampSet.add(timestamp);\n  });\n  \n  // Get the earliest and latest timestamps\n  const earliest = timestampSet.getFirstValue();\n  const latest = timestampSet.getLastValue();\n  \n  // Create a TreeMap and map the timestamps\n  const timestampMap = new TreeMap<number, string>();\n  timestampMap.set(earliest, 'start');\n  timestampMap.set(latest, 'end');\n  \n  return timestampMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `keys` method of `TreeMap` to retrieve all keys, then uses the `forEach` method of `TreeSet` to iterate over these keys and add them to a `TreeSet`. Finally, use the `length` property of both `TreeMap` and `TreeSet` to verify that all keys were successfully transferred and are unique.",
    "input": "",
    "output": "import {TreeSet, TreeMap, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function transferKeysToTreeSet(treeMap: TreeMap<number, string>): TreeSet<number> {\n  const treeSet = new TreeSet<number>();\n  const keys = treeMap.keys();\n  keys.forEach((key: number) => {\n    treeSet.add(key);\n  });\n  \n  if (treeMap.length === treeSet.length) {\n    console.log('All keys were successfully transferred and are unique.');\n  } else {\n    console.log('Key transfer failed or keys were not unique.');\n  }\n  \n  return treeSet;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `dispatchEvent` method of `WorkerEventTarget` to emit an event containing a data object. Then, use the `addEventListener` method of `WorkerEventTarget` to listen for this event and process the data object by adding its values to a `TreeSet` using the `add` method, and then mapping these values to their squares in a `TreeMap` using the `set` method.",
    "input": "",
    "output": "import {TreeSet, TreeMap, WorkerEventTarget} from '@kit.ArkTS';\n\nexport function emitAndProcessEvent(eventTarget: WorkerEventTarget, data: number[]): void {\n  // Create a custom event with the data\n  const event = {\n    type: 'customEvent',\n    data: data\n  };\n\n  // Dispatch the event\n  eventTarget.dispatchEvent(event);\n}\n\nexport function setupEventListener(eventTarget: WorkerEventTarget): {treeSet: TreeSet<number>, treeMap: TreeMap<number, number>} {\n  const treeSet = new TreeSet<number>();\n  const treeMap = new TreeMap<number, number>();\n\n  eventTarget.addEventListener('customEvent', (event: {data: number[]}) => {\n    // Process data: add to TreeSet\n    event.data.forEach((value: number) => {\n      treeSet.add(value);\n    });\n\n    // Map values to their squares in TreeMap\n    treeSet.forEach((value: number) => {\n      treeMap.set(value, value * value);\n    });\n  });\n\n  return {treeSet, treeMap};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of randomly generated UUIDs (using `generateRandomUUID` from `util`), then iterates over the stack using `[Symbol.iterator]` to filter out invalid UUIDs (using `parseUUID` from `util`). The valid UUIDs should be returned as an array.",
    "input": "",
    "output": "import {PostMessageOptions, Stack, util} from '@kit.ArkTS';\n\nexport function filterValidUUIDs(count: number): string[] {\n  const stack = new Stack<string>();\n  \n  for (let i = 0; i < count; i++) {\n    const uuid = util.generateRandomUUID();\n    stack.push(uuid);\n  }\n  \n  const validUUIDs: string[] = [];\n  \n  for (const uuid of stack) {\n    try {\n      util.parseUUID(uuid);\n      validUUIDs.push(uuid);\n    } catch (e) {\n      continue;\n    }\n  }\n  \n  return validUUIDs;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `peek` method of `Stack` (from @kit.ArkTS) to check the top element of the stack, and if it matches a specific error code, converts the error code to a human-readable string using `errnoToString` from `util`. The function should return the readable error message or `undefined` if the stack is empty (checked via `isEmpty`).",
    "input": "",
    "output": "import {PostMessageOptions, Stack, util} from '@kit.ArkTS';\n\nexport function checkTopError(stack: Stack<number>): string | undefined {\n  if (stack.isEmpty()) {\n    return undefined;\n  }\n  const topElement = stack.peek();\n  if (topElement !== undefined) {\n    return util.errnoToString(topElement);\n  }\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first generates a random binary UUID using `generateRandomBinaryUUID` from `util`, then transfers it to a `PostMessageOptions` object (setting the `transfer` property). The function should then push this object into a `Stack` (using `push` from @kit.ArkTS) and return the stack's `length` property to indicate the number of transferred UUIDs.",
    "input": "",
    "output": "import {PostMessageOptions, Stack, util} from '@kit.ArkTS';\n\nexport function transferRandomUUIDToStack(): number {\n  const binaryUUID: ArrayBuffer = util.generateRandomBinaryUUID();\n  const postMessageOptions: PostMessageOptions = {\n    transfer: [binaryUUID]\n  };\n  const stack = new Stack<PostMessageOptions>();\n  stack.push(postMessageOptions);\n  return stack.length;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `util.generateRandomUUID()` to create a unique identifier, then passes this UUID to `DedicatedWorkerGlobalScope.postMessage()` to send it to a worker thread for further processing. The worker thread should log the received UUID using `console.log`.",
    "input": "",
    "output": "import {util, DedicatedWorkerGlobalScope, xml} from '@kit.ArkTS';\n\nexport function sendUUIDToWorker(worker: DedicatedWorkerGlobalScope): void {\n  const uuid: string = util.generateRandomUUID();\n  worker.postMessage(uuid);\n}\n\nexport function setupWorkerListener(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: MessageEvent<string>): void => {\n    console.log(`Received UUID: ${event.data}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `xml.EventType` to determine the type of an XML event, then formats the event type information into a human-readable string using `util.printf()`. The formatted string should be returned as the result.",
    "input": "",
    "output": "import {util, DedicatedWorkerGlobalScope, xml} from '@kit.ArkTS';\n\nexport function formatXmlEventType(eventType: xml.EventType): string {\n  let eventTypeString: string;\n  switch (eventType) {\n    case xml.EventType.START_DOCUMENT:\n      eventTypeString = 'START_DOCUMENT';\n      break;\n    case xml.EventType.END_DOCUMENT:\n      eventTypeString = 'END_DOCUMENT';\n      break;\n    case xml.EventType.START_ELEMENT:\n      eventTypeString = 'START_ELEMENT';\n      break;\n    case xml.EventType.END_ELEMENT:\n      eventTypeString = 'END_ELEMENT';\n      break;\n    case xml.EventType.TEXT:\n      eventTypeString = 'TEXT';\n      break;\n    case xml.EventType.CDATA:\n      eventTypeString = 'CDATA';\n      break;\n    case xml.EventType.COMMENT:\n      eventTypeString = 'COMMENT';\n      break;\n    case xml.EventType.PROCESSING_INSTRUCTION:\n      eventTypeString = 'PROCESSING_INSTRUCTION';\n      break;\n    case xml.EventType.DTD:\n      eventTypeString = 'DTD';\n      break;\n    case xml.EventType.ENTITY_DECLARATION:\n      eventTypeString = 'ENTITY_DECLARATION';\n      break;\n    case xml.EventType.NAMESPACE_DECLARATION:\n      eventTypeString = 'NAMESPACE_DECLARATION';\n      break;\n    case xml.EventType.NOTATION_DECLARATION:\n      eventTypeString = 'NOTATION_DECLARATION';\n      break;\n    default:\n      eventTypeString = 'UNKNOWN';\n  }\n  return util.printf('Event type: %s', eventTypeString);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `util.getHash()` to compute the hash of a given string, then sends the hash value to a worker thread using `DedicatedWorkerGlobalScope.postMessage()`. The worker thread should verify the hash by comparing it with a precomputed value and return the result via `DedicatedWorkerGlobalScope.onmessage`.",
    "input": "",
    "output": "import {util, DedicatedWorkerGlobalScope, xml} from '@kit.ArkTS';\n\nexport function computeAndSendHash(inputString: string, worker: DedicatedWorkerGlobalScope, precomputedHash: string): void {\n  const hashValue: string = util.getHash(inputString);\n  worker.postMessage({hash: hashValue, precomputedHash: precomputedHash});\n}\n\nexport function setupWorkerVerification(worker: DedicatedWorkerGlobalScope): void {\n  worker.onmessage = (event: {data: {hash: string, precomputedHash: string}}) => {\n    const {hash, precomputedHash} = event.data;\n    const result: boolean = hash === precomputedHash;\n    worker.postMessage({verified: result});\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `push` method of `Stack` (from @kit.ArkTS) to store a sequence of randomly generated UUIDs, then iterates through the stack using the `Symbol.iterator` method to extract each UUID, and finally uses the `parseUUID` method of `util` (from @kit.ArkTS) to validate and log the parsed UUID components.",
    "input": "",
    "output": "import {url, Stack, util} from '@kit.ArkTS';\n\nexport function processUUIDs(): void {\n  const stack = new Stack<string>();\n  \n  // Generate and push 5 random UUIDs into the stack\n  for (let i = 0; i < 5; i++) {\n    const uuid = util.generateRandomUUID();\n    stack.push(uuid);\n  }\n  \n  // Iterate through the stack using Symbol.iterator\n  for (const uuid of stack[Symbol.iterator]()) {\n    try {\n      const parsedUUID = util.parseUUID(uuid);\n      console.log(`Parsed UUID components: ${JSON.stringify(parsedUUID)}`);\n    } catch (error) {\n      console.error(`Invalid UUID: ${uuid}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `generateRandomUUID` method of `util` (from @kit.ArkTS) to produce a UUID, pushes it onto a `Stack` (from @kit.ArkTS) using the `push` method, and then checks if the stack is empty using the `isEmpty` property before performing a `peek` operation to verify the last inserted UUID.",
    "input": "",
    "output": "import {url, Stack, util} from '@kit.ArkTS';\n\nexport function handleUUIDStack(): void {\n  const stack = new Stack<string>();\n  const uuid = util.generateRandomUUID();\n  stack.push(uuid);\n  if (!stack.isEmpty) {\n    const lastUUID = stack.peek();\n    console.log(`Last inserted UUID: ${lastUUID}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that first uses the `getHash` method of `util` (from @kit.ArkTS) to compute the hash of a given string, then stores the hash value in a `Stack` (from @kit.ArkTS) via the `push` method, and finally iterates through the stack using the `forEach` method to apply the `format` method of `util` to each hash value for standardized logging.",
    "input": "",
    "output": "import {url, Stack, util} from '@kit.ArkTS';\n\nexport function processHashAndLog(input: string): void {\n  const hashValue: string = util.getHash(input);\n  const stack: Stack<string> = new Stack<string>();\n  stack.push(hashValue);\n  stack.forEach((value: string) => {\n    const formattedLog: string = util.format('Hash value: %s', value);\n    console.log(formattedLog);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `buffer.from` to create a Buffer from a string, then uses `process.getUidForName` to get the UID of a process name, and finally stores the UID and the Buffer in a `LightWeightMap` using `set` method. The function should return the LightWeightMap containing the UID-Buffer pair.",
    "input": "",
    "output": "import {LightWeightMap, process, buffer} from '@kit.ArkTS';\n\nexport function storeUidAndBuffer(processName: string, inputString: string): LightWeightMap<number, buffer.Buffer> {\n  const uid = process.getUidForName(processName);\n  const buf = buffer.from(inputString);\n  const map = new LightWeightMap<number, buffer.Buffer>();\n  map.set(uid, buf);\n  return map;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `process.getEnvironmentVar` to retrieve an environment variable, checks if the value is a valid encoding using `buffer.isEncoding`, and if valid, creates a Buffer from the value using `buffer.from`. Then, store the encoding type and the Buffer in a `LightWeightMap` using `setValueAt` method. The function should return the LightWeightMap with the encoding-Buffer pair.",
    "input": "",
    "output": "import {LightWeightMap, process, buffer} from '@kit.ArkTS';\n\nexport function storeEncodingBuffer(envVarName: string): LightWeightMap<string, buffer.Buffer> {\n  const envVarValue = process.getEnvironmentVar(envVarName);\n  const map = new LightWeightMap<string, buffer.Buffer>();\n  \n  if (envVarValue !== undefined) {\n    const encodingTypes: buffer.BufferEncoding[] = ['ascii', 'utf8', 'utf-8', 'utf16le', 'ucs2', 'ucs-2', 'base64', 'base64url', 'latin1', 'binary', 'hex'];\n    \n    for (const encoding of encodingTypes) {\n      if (buffer.isEncoding(encoding) && buffer.isEncoding(envVarValue)) {\n        const buf = buffer.from(envVarValue, encoding);\n        map.setValueAt(0, encoding, buf);\n        break;\n      }\n    }\n  }\n  \n  return map;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `LightWeightMap.entries` to iterate over key-value pairs, converts each value to a Buffer using `buffer.from`, and then uses `process.kill` to terminate processes whose UIDs (keys in the LightWeightMap) match a certain condition (e.g., even-numbered UIDs). The function should return the number of processes killed.",
    "input": "",
    "output": "import {LightWeightMap, process, buffer} from '@kit.ArkTS';\n\nexport function killProcessesByCondition(processMap: LightWeightMap<number, string>): number {\n  let killedCount = 0;\n  const entries = processMap.entries();\n  let entry = entries.next();\n  \n  while (!entry.done) {\n    const [uid, value] = entry.value;\n    const valueBuffer = buffer.from(value);\n    \n    if (uid % 2 === 0) {\n      process.kill(uid);\n      killedCount++;\n    }\n    \n    entry = entries.next();\n  }\n  \n  return killedCount;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `set` method of `HashMap` to store key-value pairs of event names and their corresponding event handlers, then uses the `addEventListener` method of `EventTarget` to register these handlers. Finally, use the `dispatchEvent` method of `EventTarget` to trigger a specific event based on a key lookup in the `HashMap`.",
    "input": "",
    "output": "import {PostMessageOptions, EventTarget, HashMap} from '@kit.ArkTS';\n\nexport function registerAndTriggerEvent(eventTarget: EventTarget, eventMap: HashMap<string, () => void>, eventName: string): void {\n  if (eventMap.hasKey(eventName)) {\n    const handler = eventMap.get(eventName);\n    if (handler) {\n      eventTarget.addEventListener(eventName, handler);\n      eventTarget.dispatchEvent(new Event(eventName));\n    }\n  }\n}\n\nexport function createEventMap(): HashMap<string, () => void> {\n  const eventMap = new HashMap<string, () => void>();\n  return eventMap;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first uses the `keys` method of `HashMap` to retrieve all keys, then iterates over them using `[Symbol.iterator]` to remove each key-value pair with the `remove` method. For each removed pair, use the `removeEventListener` method of `EventTarget` to unregister any associated event listeners.",
    "input": "",
    "output": "import {PostMessageOptions, EventTarget, HashMap} from '@kit.ArkTS';\n\nexport function removeAllKeyValuePairsAndListeners(map: HashMap<string, EventTarget>, eventType: string): void {\n  const keys = map.keys();\n  for (const key of keys[Symbol.iterator]()) {\n    const eventTarget = map.get(key);\n    if (eventTarget) {\n      eventTarget.removeEventListener(eventType);\n    }\n    map.remove(key);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `forEach` method of `HashMap` to iterate over all key-value pairs and construct a `PostMessageOptions` object for each pair, setting the `transfer` property based on the value type. Then, use the `dispatchEvent` method of `EventTarget` to send each constructed message as a custom event.",
    "input": "",
    "output": "import {PostMessageOptions, EventTarget, HashMap} from '@kit.ArkTS';\n\nexport function dispatchMessagesFromHashMap(map: HashMap<string, ArrayBuffer | object>, eventTarget: EventTarget): void {\n  map.forEach((value: ArrayBuffer | object, key: string) => {\n    const options: PostMessageOptions = {\n      transfer: value instanceof ArrayBuffer ? [value] : []\n    };\n    const event = { type: key, data: value, options };\n    eventTarget.dispatchEvent(event);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `add` method of `ArrayList<string>` to collect a list of file names, then passes this list to the `concat` method of `buffer` to merge the contents of all files into a single buffer. Finally, use the `toString` method of `Vector<Uint8Array>` to convert the buffer into a readable string.",
    "input": "",
    "output": "import {ArrayList, Vector, buffer} from '@kit.ArkTS';\n\nexport function mergeFilesContents(fileNames: string[]): string {\n  const fileList: ArrayList<string> = new ArrayList();\n  \n  for (const fileName of fileNames) {\n    fileList.add(fileName);\n  }\n  \n  const buffers: Vector<Uint8Array> = new Vector();\n  \n  for (let i = 0; i < fileList.length; i++) {\n    const fileName = fileList.get(i);\n    // Assuming each file's content is read as Uint8Array\n    // Note: Actual file reading mechanism is not specified in the API\n    const fileContent = new Uint8Array(0); // Placeholder for actual file content\n    buffers.add(fileContent);\n  }\n  \n  const mergedBuffer = buffer.concat(buffers);\n  return buffers.toString();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `get` and `set` methods of `Vector<number>` to manipulate a sequence of numerical data, then passes the modified vector to the `sort` method of `ArrayList<number>` to organize the data in ascending order. Ensure the sorted data is then converted to an array using the `convertToArray` method of `ArrayList`.",
    "input": "",
    "output": "import {ArrayList, Vector, buffer} from '@kit.ArkTS';\n\nexport function manipulateAndSortVector(data: number[]): number[] {\n  // Create a Vector instance and populate it with the input data\n  let vec = new Vector<number>();\n  for (let num of data) {\n    vec.add(num);\n  }\n\n  // Manipulate the Vector using get and set methods\n  for (let i = 0; i < vec.length; i++) {\n    let value = vec.get(i);\n    vec.set(i, value * 2); // Example manipulation: double each value\n  }\n\n  // Create an ArrayList and populate it with the Vector's data\n  let arrList = new ArrayList<number>();\n  for (let i = 0; i < vec.length; i++) {\n    arrList.add(vec.get(i));\n  }\n\n  // Sort the ArrayList in ascending order\n  arrList.sort((a: number, b: number) => a - b);\n\n  // Convert the sorted ArrayList to an array and return\n  return arrList.convertToArray();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses the `from` method of `buffer` to create a buffer from a string, then passes this buffer to the `insert` method of `Vector<Uint8Array>` to embed it at a specific position. Finally, use the `subVector` method to extract a portion of the vector and convert it back to a string using the `toString` method of `Vector`.",
    "input": "",
    "output": "import {ArrayList, Vector, buffer} from '@kit.ArkTS';\n\nexport function processBuffer(inputString: string, insertPosition: number, subVectorStart: number, subVectorEnd: number): string {\n  // Create a buffer from the input string\n  const buf = buffer.from(inputString, 'utf-8');\n  \n  // Create a Vector<Uint8Array> and insert the buffer at the specified position\n  const vec = new Vector<Uint8Array>();\n  vec.insert(insertPosition, buf);\n  \n  // Extract a portion of the vector using subVector\n  const subVec = vec.subVector(subVectorStart, subVectorEnd);\n  \n  // Convert the subVector back to a string\n  return subVec.toString();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `insertFront` and `insertEnd` methods of `Deque` to collect a sequence of numbers, then passes the deque to a `ThreadWorkerGlobalScope` worker via `postMessage`. The worker should use the `forEach` method of `Deque` to process each number (e.g., square it) and return the results via `onmessage`.",
    "input": "",
    "output": "import {Deque, taskpool, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function processDequeWithWorker(numbers: number[]): void {\n  const deque = new Deque<number>();\n  \n  // Insert numbers into the deque\n  numbers.forEach(num => {\n    deque.insertFront(num);\n    deque.insertEnd(num * 2); // Example operation to demonstrate both insertFront and insertEnd\n  });\n  \n  // Create a worker\n  const worker = new ThreadWorkerGlobalScope('workers/worker.js');\n  \n  // Post the deque to the worker\n  worker.postMessage(deque);\n  \n  // Handle the result from the worker\n  worker.onmessage = (result: number[]) => {\n    console.log('Processed results:', result);\n    worker.close();\n  };\n}\n\n// worker.js content (simulated here for completeness)\n// Note: In a real scenario, this would be a separate file\n/*\nimport {Deque} from '@kit.ArkTS';\n\nconst workerScope = self as ThreadWorkerGlobalScope;\n\nworkerScope.onmessage = (deque: Deque<number>) => {\n  const results: number[] = [];\n  deque.forEach(num => {\n    results.push(num * num); // Square each number\n  });\n  workerScope.postMessage(results);\n};\n*/\n",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a task that uses the `execute` method of `taskpool` to run a `CallbackFunction` that generates a list of random numbers. The callback should then pass this list to a `Deque` using the `insertEnd` method. Finally, use the `getFirst` and `getLast` methods of `Deque` to display the smallest and largest numbers in the deque.",
    "input": "",
    "output": "import {Deque, taskpool, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function generateRandomNumbers(): number[] {\n  const numbers: number[] = [];\n  for (let i = 0; i < 10; i++) {\n    numbers.push(Math.floor(Math.random() * 100));\n  }\n  return numbers;\n}\n\nexport function processNumbers(numbers: number[]): void {\n  const deque = new Deque<number>();\n  numbers.forEach((num) => {\n    deque.insertEnd(num);\n  });\n  \n  const first = deque.getFirst();\n  const last = deque.getLast();\n  \n  console.log(`Smallest number: ${first}`);\n  console.log(`Largest number: ${last}`);\n}\n\nexport async function runTask(): Promise<void> {\n  const task = new taskpool.Task(generateRandomNumbers);\n  const result = await taskpool.execute(task);\n  processNumbers(result);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function where a `ThreadWorkerGlobalScope` worker uses `callGlobalCallObjectMethod` to fetch data, stores it in a `Deque` using `insertFront`, and then posts the deque back to the main thread. The main thread should use the `popFirst` method of `Deque` to process each item and log it, while also using `taskpool.terminateTask` to clean up the worker after completion.",
    "input": "",
    "output": "import {Deque, taskpool, ThreadWorkerGlobalScope} from '@kit.ArkTS';\n\nexport function workerFunction(workerGlobalScope: ThreadWorkerGlobalScope): void {\n  const data = workerGlobalScope.callGlobalCallObjectMethod('fetchData');\n  const deque = new Deque<unknown>();\n  deque.insertFront(data);\n  workerGlobalScope.postMessage(deque);\n}\n\nexport function mainThreadFunction(): void {\n  const worker = new ThreadWorkerGlobalScope('script/worker.js');\n  worker.onmessage = (message: { data: Deque<unknown> }) => {\n    const deque = message.data;\n    while (deque.length > 0) {\n      const item = deque.popFirst();\n      console.log(item);\n    }\n    taskpool.terminateTask(worker);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `generateRandomUUID` method of `util` to create a unique identifier, then passes this UUID to a worker thread (using the `worker` API) for processing. The worker should log the UUID along with a timestamp using the `message` property of `ErrorEvent` to report back to the main thread.",
    "input": "",
    "output": "import {worker, ErrorEvent, util} from '@kit.ArkTS';\n\nexport function generateAndProcessUUID(): void {\n  const uuid: string = util.generateRandomUUID();\n  \n  const workerInstance: worker.ThreadWorker = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n  \n  workerInstance.onerror = (error: ErrorEvent): void => {\n    console.log(`Worker error: ${error.message}`);\n  };\n  \n  workerInstance.postMessage(uuid);\n  \n  workerInstance.terminate();\n}\n\n// Worker.ts content should be:\n// import {worker, ErrorEvent, util} from '@kit.ArkTS';\n// \n// const workerPort: worker.ThreadWorkerGlobalScope = worker.workerPort;\n// \n// workerPort.onmessage = (event: MessageEvent<string>): void => {\n//   const uuid: string = event.data;\n//   const timestamp: string = new Date().toISOString();\n//   const errorEvent: ErrorEvent = new ErrorEvent('error', {\n//     message: `UUID: ${uuid}, Timestamp: ${timestamp}`\n//   });\n//   workerPort.dispatchEvent(errorEvent);\n// };",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that captures an error event using the `error` and `lineno` properties of `ErrorEvent`, then formats the error details into a human-readable string using the `format` method of `util`. The formatted string should be passed to a worker thread (using the `worker` API) for further logging or processing.",
    "input": "",
    "output": "import {worker, ErrorEvent, util} from '@kit.ArkTS';\n\nexport function captureAndFormatError(errorEvent: ErrorEvent): string {\n  const errorDetails = {\n    message: errorEvent.message,\n    error: errorEvent.error,\n    lineno: errorEvent.lineno,\n    filename: errorEvent.filename,\n    colno: errorEvent.colno\n  };\n  \n  const formattedError = util.format('Error Details: %j', errorDetails);\n  return formattedError;\n}\n\nexport function sendErrorToWorker(errorEvent: ErrorEvent, workerInstance: worker.ThreadWorker): void {\n  const formattedError = captureAndFormatError(errorEvent);\n  workerInstance.postMessage({ type: 'error', data: formattedError });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `promisify` method of `util` to convert a callback-based function into a promise, then handles any errors using the `error` and `message` properties of `ErrorEvent`. The resulting promise should be processed in a worker thread (using the `worker` API) to perform additional asynchronous operations.",
    "input": "",
    "output": "import {worker, ErrorEvent, util} from '@kit.ArkTS';\n\nexport function promisifyAndHandleErrors(callbackBasedFunc: (arg: string, callback: (err: ErrorEvent | null, result: string) => void) => void): Promise<string> {\n  const promisifiedFunc = util.promisify(callbackBasedFunc);\n  \n  return new Promise((resolve, reject) => {\n    const workerInstance = new worker.ThreadWorker('entry/ets/workers/Worker.ts');\n    \n    workerInstance.onmessage = (message: string) => {\n      resolve(message);\n      workerInstance.terminate();\n    };\n    \n    workerInstance.onerror = (error: ErrorEvent) => {\n      reject({ error: error.error, message: error.message });\n      workerInstance.terminate();\n    };\n    \n    promisifiedFunc('input').then((result: string) => {\n      workerInstance.postMessage(result);\n    }).catch((err: ErrorEvent) => {\n      reject({ error: err.error, message: err.message });\n      workerInstance.terminate();\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that listens for XML parsing errors using `xml.EventType.ERROR` and constructs an `ErrorEvent` object with the error details (using `message`, `filename`, `lineno`, and `colno` properties). Then, pass this `ErrorEvent` object to the `onerror` handler of `GlobalScope` to handle the error globally.",
    "input": "",
    "output": "import {ErrorEvent, xml, GlobalScope} from '@kit.ArkTS';\n\nexport function listenForXMLErrors(): void {\n  xml.EventType.ERROR = 'error';\n  const errorHandler = (event: xml.EventType): void => {\n    if (event === xml.EventType.ERROR) {\n      const errorEvent: ErrorEvent = {\n        message: 'XML parsing error',\n        filename: 'unknown.xml',\n        lineno: 0,\n        colno: 0,\n        error: null\n      };\n      if (GlobalScope.onerror) {\n        GlobalScope.onerror(errorEvent);\n      }\n    }\n  };\n  xml.on(event => {\n    errorHandler(event);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `xml.EventType` to monitor XML loading events. If an error occurs, extract the error details and assign them to the `error` property of an `ErrorEvent` object. Then, use the `self` property of `GlobalScope` to log the error event to the console.",
    "input": "",
    "output": "import {ErrorEvent, xml, GlobalScope} from '@kit.ArkTS';\n\nexport function monitorXMLLoadingEvents(): void {\n  const eventType = xml.EventType;\n  \n  const onXMLError = (event: ErrorEvent): void => {\n    const errorEvent = new ErrorEvent('error', {\n      error: event.error,\n      message: event.message,\n      filename: event.filename,\n      lineno: event.lineno,\n      colno: event.colno\n    });\n    \n    GlobalScope.self.console.error(errorEvent);\n  };\n  \n  GlobalScope.onerror = onXMLError;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that captures XML parsing errors via `xml.EventType.ERROR`, constructs an `ErrorEvent` with the error details (using `message`, `filename`, and `lineno`), and then uses the `name` property of `GlobalScope` to customize the error message before passing it to the `onerror` handler for further processing.",
    "input": "",
    "output": "import {ErrorEvent, xml, GlobalScope} from '@kit.ArkTS';\n\nexport function handleXmlParsingError(eventType: xml.EventType, message: string, filename: string, lineno: number): void {\n  if (eventType === xml.EventType.ERROR) {\n    const errorEvent: ErrorEvent = new ErrorEvent('error', {\n      message: message,\n      filename: filename,\n      lineno: lineno\n    });\n\n    const globalScope: GlobalScope = globalThis as unknown as GlobalScope;\n    const customizedMessage: string = `[${globalScope.name}] ${errorEvent.message}`;\n    \n    if (globalScope.onerror) {\n      globalScope.onerror(customizedMessage, errorEvent.filename, errorEvent.lineno, 0, errorEvent.error);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that registers an `AbilityLifecycleCallback` to monitor an ability's lifecycle events. When the `onAbilityForeground` event is triggered, use the `AbilityRunningInfo` properties (`abilityState`, `pid`, and `processName`) to log detailed information about the foregrounded ability.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, AbilityRunningInfo } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(abilityRunningInfo: AbilityRunningInfo): void {\n    console.log(`Ability State: ${abilityRunningInfo.abilityState}`);\n    console.log(`PID: ${abilityRunningInfo.pid}`);\n    console.log(`Process Name: ${abilityRunningInfo.processName}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature where the `onWindowStageCreate` method of `AbilityLifecycleCallback` is used to initialize a window stage. Once initialized, retrieve the `startTime` and `uid` from `AbilityRunningInfo` to track and display the ability's startup performance metrics.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private abilityRunningInfo: AbilityRunningInfo | null = null;\n\n  onWindowStageCreate(windowStage: any): void {\n    this.abilityRunningInfo = windowStage.context.abilityInfo as AbilityRunningInfo;\n    if (this.abilityRunningInfo) {\n      const startTime: number = this.abilityRunningInfo.startTime;\n      const uid: number = this.abilityRunningInfo.uid;\n      console.log(`Ability startup performance metrics - StartTime: ${startTime}, UID: ${uid}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility that uses the `onAbilityDestroy` method of `AbilityLifecycleCallback` to detect when an ability is destroyed. Upon destruction, use the `AbilityRunningInfo` properties (`ability`, `pid`, and `abilityState`) to generate a report of the terminated ability's details for debugging purposes.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class AbilityDestroyReporter extends AbilityLifecycleCallback {\n  onAbilityDestroy(abilityRunningInfo: AbilityRunningInfo): void {\n    const report = {\n      ability: abilityRunningInfo.ability,\n      pid: abilityRunningInfo.pid,\n      abilityState: abilityRunningInfo.abilityState\n    };\n    console.log('Ability Destroyed:', JSON.stringify(report));\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch an ability and then checks its state using `AbilityDelegator.getAbilityState`. Based on the returned state (e.g., `AbilityConstant.StateType.READY` or `AbilityConstant.StateType.BACKGROUND`), print a corresponding message using `AbilityDelegator.printSync`.",
    "input": "",
    "output": "import { AbilityConstant, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function launchAndCheckAbility(delegator: AbilityDelegator, want: Want): void {\n  delegator.startAbility(want, (err) => {\n    if (err) {\n      delegator.printSync(`Failed to start ability: ${err.message}`);\n      return;\n    }\n\n    const abilityState = delegator.getAbilityState(want);\n    switch (abilityState) {\n      case AbilityConstant.StateType.READY:\n        delegator.printSync('Ability is in READY state');\n        break;\n      case AbilityConstant.StateType.BACKGROUND:\n        delegator.printSync('Ability is in BACKGROUND state');\n        break;\n      case AbilityConstant.StateType.INACTIVE:\n        delegator.printSync('Ability is in INACTIVE state');\n        break;\n      case AbilityConstant.StateType.INITIAL:\n        delegator.printSync('Ability is in INITIAL state');\n        break;\n      default:\n        delegator.printSync(`Unknown ability state: ${abilityState}`);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that monitors an ability's lifecycle using `AbilityDelegator.addAbilityMonitorSync` and waits for it to reach a specific state (e.g., `AbilityConstant.StateType.FOREGROUND`) using `AbilityDelegator.waitAbilityMonitor`. Once the state is detected, use `AbilityDelegator.doAbilityBackground` to move the ability to the background and verify the transition using `AbilityDelegator.getAbilityState`.",
    "input": "",
    "output": "import { AbilityConstant, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function monitorAbilityLifecycle(delegator: AbilityDelegator, abilityName: string): void {\n  const monitor = delegator.addAbilityMonitorSync({\n    abilityName: abilityName,\n    onAbilityCreate: (ability) => {\n      console.log(`Ability ${abilityName} created`);\n    },\n    onAbilityForeground: (ability) => {\n      console.log(`Ability ${abilityName} is in foreground`);\n    },\n    onAbilityBackground: (ability) => {\n      console.log(`Ability ${abilityName} is in background`);\n    },\n    onAbilityDestroy: (ability) => {\n      console.log(`Ability ${abilityName} destroyed`);\n    }\n  });\n\n  delegator.waitAbilityMonitor(monitor).then(() => {\n    const state = delegator.getAbilityState(abilityName);\n    if (state === AbilityConstant.StateType.FOREGROUND) {\n      console.log(`Ability ${abilityName} is in foreground, moving to background`);\n      delegator.doAbilityBackground(abilityName);\n      const newState = delegator.getAbilityState(abilityName);\n      console.log(`Ability ${abilityName} state after background: ${newState}`);\n    }\n  }).catch((error) => {\n    console.error(`Error monitoring ability ${abilityName}: ${error}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a test scenario where you use `AbilityDelegator.executeShellCommand` to simulate a low-memory event and then check the ability's `AbilityConstant.MemoryLevel` state. Depending on the memory level (e.g., `AbilityConstant.MemoryLevel.LOW`), use `AbilityDelegator.finishTest` to terminate the test or `AbilityDelegator.setMockList` to mock additional scenarios.",
    "input": "",
    "output": "import { AbilityConstant, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function testLowMemoryScenario(delegator: AbilityDelegator): void {\n  // Simulate a low-memory event using shell command\n  delegator.executeShellCommand('memory_pressure simulate low', (err: Error, result: string) => {\n    if (err) {\n      console.error(`Failed to execute shell command: ${err.message}`);\n      return;\n    }\n\n    // Get the current memory level\n    const memoryLevel: AbilityConstant.MemoryLevel = delegator.getAbilityState().memoryLevel;\n\n    // Check the memory level and take appropriate action\n    if (memoryLevel === AbilityConstant.MemoryLevel.LOW) {\n      console.log('Low memory detected. Finishing test.');\n      delegator.finishTest('Low memory scenario test completed', 0);\n    } else {\n      console.log('Memory level is not low. Mocking additional scenarios.');\n      delegator.setMockList(['memory_pressure simulate critical']);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityMonitor.onAbilityCreate` to monitor the creation of an ability, and then retrieves the `pid` and `processName` from the `AbilityRunningInfo` object associated with the created ability to log the process details.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityRunningInfo, Ability} from '@kit.AbilityKit';\n\nexport function monitorAbilityCreation(): void {\n  const abilityMonitor: AbilityMonitor = {\n    onAbilityCreate: (ability: Ability) => {\n      const abilityRunningInfo: AbilityRunningInfo = {\n        ability: ability,\n        abilityState: 0,\n        pid: 0,\n        processName: '',\n        startTime: 0,\n        uid: 0\n      };\n      console.log(`Ability created with pid: ${abilityRunningInfo.pid}, processName: ${abilityRunningInfo.processName}`);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes `AbilityMonitor.onWindowStageCreate` to detect when a window stage is created for an ability, and then uses the `onConfigurationUpdate` method of the `Ability` class to handle configuration changes specific to that window stage.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityRunningInfo, Ability} from '@kit.AbilityKit';\n\nexport function setupAbilityMonitor(abilityName: string, moduleName: string): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor({\n    abilityName: abilityName,\n    moduleName: moduleName\n  });\n\n  monitor.onWindowStageCreate = (windowStage) => {\n    const ability: Ability = windowStage.context as Ability;\n    ability.onConfigurationUpdate = (newConfig) => {\n      // Handle configuration changes here\n      console.log('Configuration updated:', newConfig);\n    };\n  };\n\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityMonitor.onAbilityDestroy` to monitor the destruction of an ability, and then checks the `abilityState` property of the `AbilityRunningInfo` object to verify if the ability was successfully terminated before performing cleanup operations.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityRunningInfo, Ability} from '@kit.AbilityKit';\n\nexport function monitorAbilityDestruction(abilityName: string, moduleName: string, cleanup: () => void): AbilityMonitor {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityDestroy: (ability: Ability, abilityRunningInfo: AbilityRunningInfo) => {\n      if (abilityRunningInfo.abilityState === 0) {\n        cleanup();\n      }\n    }\n  };\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onConfigurationUpdate` method of `Ability` to detect configuration changes and then logs the current `LaunchReason` from `AbilityConstant` to determine if the ability was launched due to a configuration update or other reasons.",
    "input": "",
    "output": "import {Ability, AbilityDelegatorArgs, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  onConfigurationUpdate(newConfig) {\n    super.onConfigurationUpdate(newConfig);\n    const launchReason: AbilityConstant.LaunchReason = this.launchReason;\n    console.log(`LaunchReason: ${launchReason}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes an `AbilityDelegatorArgs` object with `bundleName` and `testCaseNames` properties, then uses the `onMemoryLevel` method of `Ability` to monitor memory levels, and logs the `MemoryLevel` enum value from `AbilityConstant` when the memory level changes.",
    "input": "",
    "output": "import {Ability, AbilityDelegatorArgs, AbilityConstant} from '@kit.AbilityKit';\n\nexport function initializeAndMonitorMemory() {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    bundleName: 'com.example.myapplication',\n    testCaseNames: ['TestCase1', 'TestCase2']\n  };\n\n  const ability: Ability = new Ability();\n  ability.onMemoryLevel((level: AbilityConstant.MemoryLevel) => {\n    console.log(`Memory level changed to: ${level}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks the `LastExitReason` from `AbilityConstant` and uses the `parameters` property of `AbilityDelegatorArgs` to pass this reason to another ability or test case for further processing or logging.",
    "input": "",
    "output": "import {Ability, AbilityDelegatorArgs, AbilityConstant} from '@kit.AbilityKit';\n\nexport function checkLastExitReason(args: AbilityDelegatorArgs): AbilityConstant.LastExitReason | undefined {\n  if (args.parameters && args.parameters.lastExitReason) {\n    return args.parameters.lastExitReason as AbilityConstant.LastExitReason;\n  }\n  return undefined;\n}\n\nexport function setLastExitReason(args: AbilityDelegatorArgs, reason: AbilityConstant.LastExitReason): void {\n  if (!args.parameters) {\n    args.parameters = {};\n  }\n  args.parameters.lastExitReason = reason;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityMonitor.onAbilityCreate` to monitor the creation of a specific ability, and upon detection, uses `Ability.onConfigurationUpdate` to dynamically update the ability's configuration based on the monitored ability's properties (e.g., `abilityName` or `moduleName`).",
    "input": "",
    "output": "import {Ability, AbilityResult, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function monitorAndUpdateAbility(targetAbilityName: string, targetModuleName: string): void {\n  const monitor: AbilityMonitor = {\n    abilityName: targetAbilityName,\n    moduleName: targetModuleName,\n    onAbilityCreate: (ability: Ability) => {\n      ability.onConfigurationUpdate((newConfig) => {\n        // Update the ability's configuration based on the monitored ability's properties\n        // Example: Update configuration with abilityName and moduleName\n        const updatedConfig = {\n          ...newConfig,\n          abilityName: ability.context.abilityInfo?.name,\n          moduleName: ability.context.abilityInfo?.moduleName\n        };\n        return updatedConfig;\n      });\n    }\n  };\n\n  // Register the monitor (implementation depends on the specific runtime environment)\n  // Example: AbilityContext.registerAbilityMonitor(monitor);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes `Ability.onMemoryLevel` to check the current memory level of the system, and if the memory level is critical, triggers `AbilityMonitor.onAbilityDestroy` to destroy a specified ability (identified by `abilityName`) to free up resources.",
    "input": "",
    "output": "import {Ability, AbilityResult, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function monitorAndDestroyAbility(abilityName: string): void {\n  const abilityMonitor = new AbilityMonitor();\n  abilityMonitor.abilityName = abilityName;\n\n  abilityMonitor.onAbilityDestroy = (ability: Ability) => {\n    console.log(`Ability ${abilityName} has been destroyed to free up resources.`);\n  };\n\n  Ability.onMemoryLevel = (level: string) => {\n    if (level === 'CRITICAL') {\n      const result: AbilityResult = {\n        resultCode: 0,\n        want: {\n          bundleName: '',\n          abilityName: abilityName\n        }\n      };\n      abilityMonitor.onAbilityDestroy?.(new Ability());\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityResult.resultCode` to determine the success or failure of an ability operation, and based on the result, either calls `AbilityMonitor.onAbilityForeground` to bring another ability to the foreground or `AbilityMonitor.onAbilityBackground` to send it to the background.",
    "input": "",
    "output": "import {Ability, AbilityResult, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function handleAbilityResult(result: AbilityResult, monitor: AbilityMonitor): void {\n  if (result.resultCode === 0) {\n    if (monitor.onAbilityForeground) {\n      monitor.onAbilityForeground(new Ability());\n    }\n  } else {\n    if (monitor.onAbilityBackground) {\n      monitor.onAbilityBackground(new Ability());\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that monitors the lifecycle of an ability by implementing `AbilityLifecycleCallback.onAbilityCreate` and `AbilityLifecycleCallback.onAbilityDestroy`. When the ability is created, use `AbilityRunningInfo.abilityState` to log its initial state, and when it is destroyed, use `AbilityRunningInfo.pid` to verify the process termination.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(abilityRunningInfo: AbilityRunningInfo): void {\n    console.log(`Ability created with initial state: ${abilityRunningInfo.abilityState}`);\n  }\n\n  onAbilityDestroy(abilityRunningInfo: AbilityRunningInfo): void {\n    console.log(`Ability destroyed with PID: ${abilityRunningInfo.pid}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility that tracks ability state transitions by combining `AbilityLifecycleCallback.onAbilityForeground` and `AbilityLifecycleCallback.onAbilityBackground` with `AbilityRunningInfo.abilityState`. Store the transition timestamps (using `AbilityRunningInfo.startTime`) and map them to `AbilityConstant.StateType` to analyze the ability's active/inactive patterns.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport class AbilityStateTracker extends AbilityLifecycleCallback {\n  private transitionLogs: Map<string, {state: AbilityConstant.StateType, timestamp: number}[]> = new Map();\n\n  onAbilityForeground(ability: AbilityRunningInfo): void {\n    this.logTransition(ability, AbilityConstant.StateType.FOREGROUND);\n  }\n\n  onAbilityBackground(ability: AbilityRunningInfo): void {\n    this.logTransition(ability, AbilityConstant.StateType.BACKGROUND);\n  }\n\n  private logTransition(ability: AbilityRunningInfo, state: AbilityConstant.StateType): void {\n    const abilityName = ability.ability?.bundleName + '::' + ability.ability?.abilityName;\n    if (!abilityName) {\n      return;\n    }\n\n    const timestamp = ability.startTime;\n    const logEntry = {state, timestamp};\n\n    if (!this.transitionLogs.has(abilityName)) {\n      this.transitionLogs.set(abilityName, []);\n    }\n\n    this.transitionLogs.get(abilityName)?.push(logEntry);\n  }\n\n  getTransitionLogs(): Map<string, {state: AbilityConstant.StateType, timestamp: number}[]> {\n    return this.transitionLogs;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature that handles ability continuation by using `AbilityLifecycleCallback.onAbilityContinue` to trigger a save operation. Validate the continuation request by checking `AbilityConstant.OnContinueResult` and log the outcome along with the ability's details (using `AbilityRunningInfo.uid` and `AbilityRunningInfo.processName`).",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityContinue(abilityRunningInfo: AbilityRunningInfo): AbilityConstant.OnContinueResult {\n    // Perform save operation here\n    const saveSuccessful = this.performSaveOperation();\n    \n    if (saveSuccessful) {\n      console.log(`Continuation successful for ability with uid: ${abilityRunningInfo.uid} and processName: ${abilityRunningInfo.processName}`);\n      return AbilityConstant.OnContinueResult.AGREE;\n    } else {\n      console.log(`Continuation failed for ability with uid: ${abilityRunningInfo.uid} and processName: ${abilityRunningInfo.processName}`);\n      return AbilityConstant.OnContinueResult.REJECT;\n    }\n  }\n\n  private performSaveOperation(): boolean {\n    // Implement actual save logic here\n    return true;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onAbilityForeground` event of `AbilityMonitor` to detect when an ability comes to the foreground, and then retrieves the `abilityState` from `AbilityRunningInfo` to log the current state of the ability. The function should also check if the `abilityState` matches any of the `StateType` enum values from `AbilityConstant` and print the corresponding state name.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityConstant, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function monitorAbilityForeground(): void {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  \n  monitor.onAbilityForeground = (abilityRunningInfo: AbilityRunningInfo) => {\n    const abilityState: AbilityConstant.StateType = abilityRunningInfo.abilityState;\n    \n    switch (abilityState) {\n      case AbilityConstant.StateType.INITIAL:\n        console.log('Ability state: INITIAL');\n        break;\n      case AbilityConstant.StateType.READY:\n        console.log('Ability state: READY');\n        break;\n      case AbilityConstant.StateType.FOREGROUND:\n        console.log('Ability state: FOREGROUND');\n        break;\n      case AbilityConstant.StateType.BACKGROUND:\n        console.log('Ability state: BACKGROUND');\n        break;\n      case AbilityConstant.StateType.TERMINATING:\n        console.log('Ability state: TERMINATING');\n        break;\n      default:\n        console.log('Unknown ability state');\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that monitors ability destruction using the `onAbilityDestroy` event of `AbilityMonitor`. When an ability is destroyed, the function should use `AbilityRunningInfo` to get the `pid` and `processName` of the destroyed ability, and then determine the `LastExitReason` from `AbilityConstant` to log a detailed exit report including the process details and exit reason.",
    "input": "",
    "output": "import { AbilityMonitor, AbilityConstant, AbilityRunningInfo } from '@kit.AbilityKit';\n\nexport function createAbilityDestroyMonitor(): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n\n  monitor.onAbilityDestroy = (abilityRunningInfo: AbilityRunningInfo) => {\n    const pid: number = abilityRunningInfo.pid;\n    const processName: string = abilityRunningInfo.processName;\n    const lastExitReason: AbilityConstant.LastExitReason = abilityRunningInfo.ability?.lastExitReason;\n\n    console.log(`Ability destroyed - PID: ${pid}, Process Name: ${processName}, Exit Reason: ${AbilityConstant.LastExitReason[lastExitReason]}`);\n  };\n\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `onWindowStageCreate` event of `AbilityMonitor` to detect when a window stage is created for an ability. The function should then retrieve the `WindowMode` from `AbilityConstant` and the `abilityName` from `AbilityRunningInfo` to log a message indicating the window mode and the name of the ability that created the window stage.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityConstant, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function createWindowStageMonitor(): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  \n  monitor.onWindowStageCreate = (windowStage) => {\n    const windowMode: AbilityConstant.WindowMode = windowStage.getWindowMode();\n    const abilityRunningInfo: AbilityRunningInfo = windowStage.getAbilityRunningInfo();\n    const abilityName: string = abilityRunningInfo.ability?.name || 'unknown';\n    \n    console.log(`Window stage created by ability: ${abilityName}, WindowMode: ${windowMode}`);\n  };\n  \n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch a specific ability, then uses `AbilityDelegator.waitAbilityMonitor` to wait for the ability to be fully loaded, and finally checks the ability's state using `AbilityDelegator.getAbilityState` to confirm it is in the foreground.",
    "input": "",
    "output": "import { AbilityDelegator, Ability } from '@kit.AbilityKit';\n\nexport function launchAndCheckAbility(delegator: AbilityDelegator, want: Want): boolean {\n  const abilityName = 'AbilityName';\n  const monitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (ability: Ability) => {\n      console.log(`Ability ${abilityName} created`);\n    },\n    onAbilityForeground: (ability: Ability) => {\n      console.log(`Ability ${abilityName} is in foreground`);\n    },\n    onAbilityBackground: (ability: Ability) => {\n      console.log(`Ability ${abilityName} is in background`);\n    },\n    onAbilityDestroy: (ability: Ability) => {\n      console.log(`Ability ${abilityName} destroyed`);\n    }\n  };\n\n  delegator.addAbilityMonitor(monitor);\n  delegator.startAbility(want);\n  delegator.waitAbilityMonitor(monitor);\n  const state = delegator.getAbilityState(monitor);\n  delegator.removeAbilityMonitor(monitor);\n  return state === 2; // 2 represents the foreground state\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.addAbilityMonitor` to set up a monitor for an ability, then uses `AbilityDelegator.doAbilityBackground` to send the ability to the background, and finally verifies the background state using `Ability.onMemoryLevel` to check if the ability received a memory level update.",
    "input": "",
    "output": "import { AbilityDelegator, Ability } from '@kit.AbilityKit';\n\nexport function monitorAndBackgroundAbility(abilityDelegator: AbilityDelegator, ability: Ability): void {\n  const abilityMonitor = {\n    abilityName: ability.context.abilityInfo.name,\n    onMemoryLevel: (level: number) => {\n      console.log(`Ability received memory level update: ${level}`);\n    }\n  };\n\n  abilityDelegator.addAbilityMonitor(abilityMonitor);\n  abilityDelegator.doAbilityBackground(ability);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.executeShellCommand` to run a shell command and capture its output, then uses `AbilityDelegator.printSync` to log the output, and finally passes the output to `Ability.onConfigurationUpdate` to simulate a configuration change based on the command's result.",
    "input": "",
    "output": "import { AbilityDelegator, Ability } from '@kit.AbilityKit';\n\nexport function executeAndLogShellCommand(delegator: AbilityDelegator, ability: Ability, command: string): void {\n  delegator.executeShellCommand(command, (err: Error, output: string) => {\n    if (err) {\n      delegator.printSync(`Error executing command: ${err.message}`);\n      return;\n    }\n    delegator.printSync(`Command output: ${output}`);\n    ability.onConfigurationUpdate({ commandOutput: output });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` to track the lifecycle events of an ability with a specific `abilityName` and `moduleName`. Use the `onAbilityForeground` callback of `AbilityMonitor` to detect when the ability comes to the foreground, and then retrieve its runtime information (e.g., `pid`, `processName`) using the `AbilityRunningInfo` API. Log the ability's `startTime` and `uid` when it becomes active.",
    "input": "",
    "output": "import { AbilityMonitor, AbilityRunningInfo } from '@kit.AbilityKit';\n\nexport function createAbilityMonitor(abilityName: string, moduleName: string): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor({\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityForeground: (abilityRunningInfo: AbilityRunningInfo) => {\n      console.log(`Ability ${abilityName} is in foreground. StartTime: ${abilityRunningInfo.startTime}, UID: ${abilityRunningInfo.uid}`);\n    }\n  });\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature that uses `AbilityMonitor` to listen for the `onAbilityDestroy` event of a specific ability. When the ability is destroyed, use the `AbilityRunningInfo` API to check if the `abilityState` of the destroyed ability matches the expected state (e.g., `TERMINATED`). If not, trigger an alert with the `processName` and `pid` of the ability.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class AbilityMonitorHelper {\n  private monitor: AbilityMonitor;\n  private expectedState: number;\n\n  constructor(abilityName: string, expectedState: number) {\n    this.expectedState = expectedState;\n    this.monitor = new AbilityMonitor({\n      abilityName: abilityName,\n      onAbilityDestroy: (abilityRunningInfo: AbilityRunningInfo) => {\n        this.handleAbilityDestroy(abilityRunningInfo);\n      }\n    });\n  }\n\n  private handleAbilityDestroy(abilityRunningInfo: AbilityRunningInfo): void {\n    if (abilityRunningInfo.abilityState !== this.expectedState) {\n      console.error(`Alert: Ability destroyed with unexpected state. Process: ${abilityRunningInfo.processName}, PID: ${abilityRunningInfo.pid}`);\n    }\n  }\n\n  public getMonitor(): AbilityMonitor {\n    return this.monitor;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility that monitors multiple abilities using `AbilityMonitor` with different `abilityName` and `moduleName` values. For each ability that triggers the `onWindowStageCreate` event, use `AbilityRunningInfo` to collect and aggregate the `uid` and `startTime` of all running abilities. Display the sorted list of abilities based on their `startTime`.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class AbilityMonitorUtility {\n  private monitors: AbilityMonitor[] = [];\n  private runningAbilities: AbilityRunningInfo[] = [];\n\n  public addMonitor(abilityName: string, moduleName: string): void {\n    const monitor: AbilityMonitor = {\n      abilityName: abilityName,\n      moduleName: moduleName,\n      onWindowStageCreate: (info: AbilityRunningInfo) => {\n        this.runningAbilities.push(info);\n        this.sortAbilitiesByStartTime();\n        this.displayRunningAbilities();\n      }\n    };\n    this.monitors.push(monitor);\n  }\n\n  private sortAbilitiesByStartTime(): void {\n    this.runningAbilities.sort((a, b) => a.startTime - b.startTime);\n  }\n\n  private displayRunningAbilities(): void {\n    console.log('Sorted Running Abilities:');\n    this.runningAbilities.forEach((ability) => {\n      console.log(`UID: ${ability.uid}, StartTime: ${ability.startTime}`);\n    });\n  }\n\n  public getMonitors(): AbilityMonitor[] {\n    return this.monitors;\n  }\n\n  public getRunningAbilities(): AbilityRunningInfo[] {\n    return this.runningAbilities;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create an `AbilityMonitor` instance to monitor an ability with a specific `abilityName` and `moduleName`. Implement an `AbilityLifecycleCallback` that logs the lifecycle events (`onAbilityCreate`, `onAbilityDestroy`, `onWindowStageCreate`, `onWindowStageDestroy`) of the monitored ability. Pass the callback to the `AbilityMonitor` instance using its corresponding properties (`onAbilityCreate`, `onAbilityDestroy`, `onWindowStageCreate`, `onWindowStageDestroy`).",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityMonitor} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(ability) {\n    console.log(`onAbilityCreate: ${ability}`);\n  }\n\n  onAbilityDestroy(ability) {\n    console.log(`onAbilityDestroy: ${ability}`);\n  }\n\n  onWindowStageCreate(ability, windowStage) {\n    console.log(`onWindowStageCreate: ${ability}, ${windowStage}`);\n  }\n\n  onWindowStageDestroy(ability, windowStage) {\n    console.log(`onWindowStageDestroy: ${ability}, ${windowStage}`);\n  }\n}\n\nexport function createAbilityMonitor(abilityName: string, moduleName: string): AbilityMonitor {\n  const callback = new MyAbilityLifecycleCallback();\n  const monitor = new AbilityMonitor({\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityCreate: callback.onAbilityCreate.bind(callback),\n    onAbilityDestroy: callback.onAbilityDestroy.bind(callback),\n    onWindowStageCreate: callback.onWindowStageCreate.bind(callback),\n    onWindowStageDestroy: callback.onWindowStageDestroy.bind(callback)\n  });\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses `AbilityMonitor` to detect when an ability enters the background (`onAbilityBackground` property) and then triggers a custom `AbilityLifecycleCallback` method (`onAbilityContinue`) to handle the ability's continuation logic. Ensure the callback is registered with the monitor and invoked when the background event occurs.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityMonitor} from '@kit.AbilityKit';\n\nexport class CustomAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityContinue(ability: any): void {\n    // Custom continuation logic here\n  }\n}\n\nexport function setupAbilityMonitor(): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  const callback: CustomAbilityLifecycleCallback = new CustomAbilityLifecycleCallback();\n\n  monitor.onAbilityBackground = (ability: any): void => {\n    callback.onAbilityContinue(ability);\n  };\n\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a system where an `AbilityMonitor` with `onWindowStageRestore` property set to a custom `AbilityLifecycleCallback` method (`onWindowStageActive`) is used to restore and activate a window stage. The callback should be passed to the monitor and executed when the window stage is restored, ensuring the stage becomes active.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityMonitor} from '@kit.AbilityKit';\n\nexport class CustomAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onWindowStageActive(): void {\n    // Custom implementation for window stage activation\n  }\n}\n\nexport function setupAbilityMonitor(): AbilityMonitor {\n  const callback: AbilityLifecycleCallback = new CustomAbilityLifecycleCallback();\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.onWindowStageRestore = callback.onWindowStageActive.bind(callback);\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `name` and `bundleName` properties of `AbilityInfo` to filter abilities from a given list, then registers an `AbilityMonitor` with the filtered ability names using the `abilityName` property and sets up an `onAbilityCreate` callback to log when these abilities are created.",
    "input": "",
    "output": "import {AbilityInfo, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function filterAndMonitorAbilities(abilityInfos: AbilityInfo[], filterName: string, filterBundleName: string): AbilityMonitor[] {\n  const filteredAbilities = abilityInfos.filter(\n    (info: AbilityInfo) => info.name === filterName && info.bundleName === filterBundleName\n  );\n\n  const monitors: AbilityMonitor[] = [];\n\n  filteredAbilities.forEach((ability: AbilityInfo) => {\n    const monitor = new AbilityMonitor(ability.name);\n    monitor.onAbilityCreate = (data) => {\n      console.log(`Ability created: ${ability.name}`);\n    };\n    monitors.push(monitor);\n  });\n\n  return monitors;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `applicationInfo` property from `AbilityInfo` for a specific ability, checks if the `enabled` property is true, and if so, uses the `moduleName` property to register an `AbilityMonitor` with a callback (`onAbilityForeground`) to track when the ability comes to the foreground.",
    "input": "",
    "output": "import {AbilityInfo, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function registerAbilityMonitor(abilityInfo: AbilityInfo): void {\n  if (abilityInfo.applicationInfo.enabled) {\n    const monitor: AbilityMonitor = {\n      moduleName: abilityInfo.moduleName,\n      onAbilityForeground: (data) => {\n        console.log('Ability came to foreground:', data);\n      }\n    };\n    console.log('AbilityMonitor registered for module:', abilityInfo.moduleName);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that extracts the `deviceTypes` and `permissions` properties from `AbilityInfo` to validate if an ability can run on the current device, then dynamically registers an `AbilityMonitor` using the `abilityName` and `moduleName` properties to monitor the ability's lifecycle events (`onAbilityDestroy` and `onWindowStageCreate`) only if the validation passes.",
    "input": "",
    "output": "import {AbilityInfo, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function validateAndMonitorAbility(abilityInfo: AbilityInfo): AbilityMonitor | null {\n  const { deviceTypes, permissions, abilityName, moduleName } = abilityInfo;\n  \n  // Validate if the ability can run on the current device\n  const canRunOnDevice = validateDeviceTypes(deviceTypes) && validatePermissions(permissions);\n  \n  if (!canRunOnDevice) {\n    return null;\n  }\n  \n  // Create and return an AbilityMonitor if validation passes\n  const monitor = new AbilityMonitor({\n    abilityName,\n    moduleName,\n    onAbilityDestroy: () => {\n      console.log(`Ability ${abilityName} destroyed`);\n    },\n    onWindowStageCreate: () => {\n      console.log(`Window stage created for ability ${abilityName}`);\n    }\n  });\n  \n  return monitor;\n}\n\nfunction validateDeviceTypes(deviceTypes: string[]): boolean {\n  // Implement device type validation logic here\n  return true;\n}\n\nfunction validatePermissions(permissions: string[]): boolean {\n  // Implement permission validation logic here\n  return true;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `bundleName` property of `AbilityDelegatorArgs` to identify the target bundle, then checks the current `StateType` from `AbilityConstant` to determine if the ability is in the foreground (`StateType.READY`) before executing a test case from `testCaseNames`.",
    "input": "",
    "output": "import {AbilityConstant, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function executeTestCaseIfReady(args: AbilityDelegatorArgs, currentState: AbilityConstant.StateType): void {\n  if (args.bundleName && currentState === AbilityConstant.StateType.READY) {\n    if (args.testCaseNames && args.testCaseNames.length > 0) {\n      // Execute the first test case as an example\n      const testCase = args.testCaseNames[0];\n      console.log(`Executing test case: ${testCase}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `LaunchReason` from `AbilityConstant` to determine why an ability was launched, then uses this information along with the `parameters` property of `AbilityDelegatorArgs` to dynamically adjust the test execution strategy (e.g., skip certain tests if the launch reason is `LaunchReason.CONTINUATION`).",
    "input": "",
    "output": "import {AbilityConstant, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function adjustTestStrategy(args: AbilityDelegatorArgs): void {\n  const launchReason: AbilityConstant.LaunchReason = args.parameters?.launchReason as AbilityConstant.LaunchReason;\n  \n  if (launchReason === AbilityConstant.LaunchReason.CONTINUATION) {\n    console.log('Skipping certain tests due to CONTINUATION launch reason');\n    // Add logic to skip tests here\n  } else {\n    console.log('Proceeding with normal test execution');\n    // Add logic for normal test execution here\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that monitors the `MemoryLevel` from `AbilityConstant` during test execution (using `AbilityDelegatorArgs.testRunnerClassName`). If the memory level reaches `MemoryLevel.CRITICAL`, the function should pause the test execution and log the current test case name from `testCaseNames` for debugging purposes.",
    "input": "",
    "output": "import {AbilityConstant, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function monitorMemoryLevel(delegatorArgs: AbilityDelegatorArgs): void {\n  const memoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel.CRITICAL;\n  \n  // Assuming there's a way to get current memory level (not directly provided in the API)\n  // This is a placeholder for the actual memory level monitoring logic\n  const currentMemoryLevel: AbilityConstant.MemoryLevel = getCurrentMemoryLevel();\n  \n  if (currentMemoryLevel === memoryLevel) {\n    // Pause test execution (implementation depends on test runner)\n    pauseTestExecution();\n    \n    // Log current test case name\n    if (delegatorArgs.testCaseNames && delegatorArgs.testCaseNames.length > 0) {\n      console.log(`Memory critical during test case: ${delegatorArgs.testCaseNames[0]}`);\n    }\n  }\n}\n\n// Placeholder functions (actual implementation would depend on test runner)\nfunction getCurrentMemoryLevel(): AbilityConstant.MemoryLevel {\n  // Implementation to get current memory level\n  return AbilityConstant.MemoryLevel.NORMAL;\n}\n\nfunction pauseTestExecution(): void {\n  // Implementation to pause test execution\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `bundleName` property of `AbilityDelegatorArgs` to initialize a test configuration, then passes this configuration to a method that returns an `AbilityResult` object, and finally checks the `resultCode` property of `AbilityResult` to determine if the test was successful.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function initializeTestAndCheckResult(bundleName: string): boolean {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    bundleName: bundleName\n  };\n  \n  const abilityResult: AbilityResult = executeTest(delegatorArgs);\n  \n  return abilityResult.resultCode === 0;\n}\n\nexport function executeTest(args: AbilityDelegatorArgs): AbilityResult {\n  // Mock implementation for the method that returns AbilityResult\n  return {\n    resultCode: 0,\n    want: {}\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that constructs an `AbilityDelegatorArgs` object with `testCaseNames` and `parameters` properties, then uses this object to run a test suite, and verifies the outcome by examining the `want` property of the returned `AbilityResult` object to ensure the expected intent was executed.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function runTestSuite(testCaseNames: string[], parameters: {[key: string]: string}): AbilityResult {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    testCaseNames: testCaseNames,\n    parameters: parameters\n  };\n\n  // Assume there's a method to run the test suite with AbilityDelegatorArgs\n  // This is a placeholder for the actual implementation\n  const result: AbilityResult = {\n    resultCode: 0,\n    want: {}\n  };\n\n  return result;\n}\n\nexport function verifyTestOutcome(result: AbilityResult, expectedIntent: object): boolean {\n  return JSON.stringify(result.want) === JSON.stringify(expectedIntent);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes an `AbilityDelegatorArgs` object with `testRunnerClassName` and `bundleName` properties, executes a test runner, and then uses the `resultCode` and `want` properties of the resulting `AbilityResult` object to generate a detailed test report.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function executeTestRunnerAndGenerateReport(args: AbilityDelegatorArgs): string {\n  // Simulate executing the test runner and getting the result\n  const abilityResult: AbilityResult = {\n    resultCode: 0,\n    want: {}\n  };\n\n  // Generate detailed test report based on AbilityResult\n  const report = `Test Report:\n` +\n    `- Test Runner Class: ${args.testRunnerClassName}\n` +\n    `- Bundle Name: ${args.bundleName}\n` +\n    `- Result Code: ${abilityResult.resultCode}\n` +\n    `- Want: ${JSON.stringify(abilityResult.want)}\n`;\n\n  return report;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityLifecycleCallback.onAbilityCreate` to initialize an ability and then checks the current `StateType` from `AbilityConstant` to determine if the ability should proceed with foreground operations or terminate immediately based on the state.",
    "input": "",
    "output": "import {AbilityConstant, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(ability): void {\n    const state: AbilityConstant.StateType = ability.getState();\n    if (state === AbilityConstant.StateType.READY) {\n      // Proceed with foreground operations\n      ability.context.emit('READY', {});\n    } else {\n      // Terminate immediately\n      ability.terminateSelf();\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a callback handler that uses `AbilityLifecycleCallback.onAbilityContinue` to resume an ability and then evaluates the `OnContinueResult` from `AbilityConstant` to decide whether to restore the ability's state or show an error message to the user.",
    "input": "",
    "output": "import {AbilityConstant, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityContinue(want): AbilityConstant.OnContinueResult {\n    // Implement logic to decide whether to continue the ability\n    const shouldContinue = this.checkIfShouldContinue();\n    \n    if (shouldContinue) {\n      return AbilityConstant.OnContinueResult.AGREE;\n    } else {\n      return AbilityConstant.OnContinueResult.REJECT;\n    }\n  }\n\n  private checkIfShouldContinue(): boolean {\n    // Add your custom logic here to determine if the ability should continue\n    return true;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that monitors memory levels using `AbilityConstant.MemoryLevel` and triggers `AbilityLifecycleCallback.onAbilityBackground` to gracefully pause the ability when the memory level reaches a critical threshold, ensuring resources are freed up.",
    "input": "",
    "output": "import {AbilityConstant, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MemoryMonitorCallback extends AbilityLifecycleCallback {\n  private criticalMemoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel.MEMORY_LEVEL_CRITICAL;\n\n  onAbilityBackground(): void {\n    // Implement logic to gracefully pause the ability and free up resources\n    console.log('Ability is being paused due to critical memory level');\n  }\n}\n\nexport function monitorMemoryLevel(callback: MemoryMonitorCallback): void {\n  const memoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel.MEMORY_LEVEL_CRITICAL;\n  \n  if (memoryLevel === callback.criticalMemoryLevel) {\n    callback.onAbilityBackground();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` instance to monitor an ability with a specific `abilityName` and `moduleName`, then uses the `bundleName` property of `AbilityDelegatorArgs` to verify if the monitored ability belongs to the specified bundle. The function should trigger `onAbilityCreate` and `onAbilityDestroy` events of `AbilityMonitor` to log the lifecycle events of the ability.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function createAndMonitorAbility(abilityName: string, moduleName: string, delegatorArgs: AbilityDelegatorArgs): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor({\n    abilityName: abilityName,\n    moduleName: moduleName\n  });\n\n  monitor.onAbilityCreate = (ability) => {\n    if (ability.context.bundleName === delegatorArgs.bundleName) {\n      console.log(`Ability ${abilityName} created in bundle ${delegatorArgs.bundleName}`);\n    }\n  };\n\n  monitor.onAbilityDestroy = (ability) => {\n    if (ability.context.bundleName === delegatorArgs.bundleName) {\n      console.log(`Ability ${abilityName} destroyed in bundle ${delegatorArgs.bundleName}`);\n    }\n  };\n\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a test scenario where an `AbilityDelegatorArgs` object is configured with `testCaseNames` and `testRunnerClassName`, and then an `AbilityMonitor` is set up to listen for `onWindowStageCreate` and `onWindowStageDestroy` events. The function should validate that the window stage events correspond to the test cases specified in `AbilityDelegatorArgs`.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function setupTestScenario(): void {\n  // Configure AbilityDelegatorArgs with test case names and test runner class name\n  const delegatorArgs: AbilityDelegatorArgs = {\n    testCaseNames: ['TestCase1', 'TestCase2'],\n    testRunnerClassName: 'TestRunner'\n  };\n\n  // Create an AbilityMonitor to listen for window stage events\n  const abilityMonitor: AbilityMonitor = new AbilityMonitor();\n\n  // Set up event listeners for window stage create and destroy\n  abilityMonitor.onWindowStageCreate = (windowStage) => {\n    console.log('WindowStage created for test case');\n    // Validate that the window stage event corresponds to the test cases\n    if (delegatorArgs.testCaseNames && delegatorArgs.testCaseNames.length > 0) {\n      console.log('Validating test cases:', delegatorArgs.testCaseNames);\n    }\n  };\n\n  abilityMonitor.onWindowStageDestroy = (windowStage) => {\n    console.log('WindowStage destroyed for test case');\n    // Validate that the window stage event corresponds to the test cases\n    if (delegatorArgs.testCaseNames && delegatorArgs.testCaseNames.length > 0) {\n      console.log('Validating test cases:', delegatorArgs.testCaseNames);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityMonitor` to track an ability's foreground and background transitions (`onAbilityForeground` and `onAbilityBackground`) and then checks if these transitions align with the `parameters` specified in an `AbilityDelegatorArgs` object. The function should log discrepancies between the expected and actual transitions.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function monitorAbilityTransitions(args: AbilityDelegatorArgs): AbilityMonitor {\n  const monitor = new AbilityMonitor();\n  \n  monitor.onAbilityForeground = (ability) => {\n    const expectedForeground = args.parameters?.expectedForeground;\n    if (expectedForeground && ability.abilityName !== expectedForeground) {\n      console.error(`Expected foreground ability: ${expectedForeground}, Actual: ${ability.abilityName}`);\n    }\n  };\n  \n  monitor.onAbilityBackground = (ability) => {\n    const expectedBackground = args.parameters?.expectedBackground;\n    if (expectedBackground && ability.abilityName !== expectedBackground) {\n      console.error(`Expected background ability: ${expectedBackground}, Actual: ${ability.abilityName}`);\n    }\n  };\n  \n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onAbilityCreate` and `onAbilityDestroy` methods of `AbilityMonitor` to track the lifecycle of an `Ability`, and then triggers the `onMemoryLevel` method of the `Ability` when the monitored ability is destroyed to log memory usage changes.",
    "input": "",
    "output": "import {AbilityMonitor, Ability} from '@kit.AbilityKit';\n\nexport function trackAbilityLifecycle(abilityName: string, moduleName: string): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.abilityName = abilityName;\n  monitor.moduleName = moduleName;\n\n  monitor.onAbilityCreate = (ability: Ability) => {\n    console.log(`Ability created: ${abilityName}`);\n  };\n\n  monitor.onAbilityDestroy = (ability: Ability) => {\n    console.log(`Ability destroyed: ${abilityName}`);\n    ability.onMemoryLevel(0);\n  };\n\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a program that utilizes the `abilityName` property of `AbilityMonitor` to identify a specific `Ability`, and then invokes the `onConfigurationUpdate` method of that `Ability` when the `onWindowStageCreate` event is detected by the `AbilityMonitor` to handle configuration changes during window stage creation.",
    "input": "",
    "output": "import {AbilityMonitor, Ability} from '@kit.AbilityKit';\n\nexport class MyAbilityMonitor {\n  private abilityMonitor: AbilityMonitor;\n\n  constructor(abilityName: string) {\n    this.abilityMonitor = new AbilityMonitor(abilityName);\n    this.setupMonitor();\n  }\n\n  private setupMonitor(): void {\n    this.abilityMonitor.onWindowStageCreate = (ability: Ability) => {\n      ability.onConfigurationUpdate();\n    };\n  }\n\n  public getMonitor(): AbilityMonitor {\n    return this.abilityMonitor;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a system where the `onAbilityForeground` method of `AbilityMonitor` is used to detect when an `Ability` comes to the foreground, and then the `onMemoryLevel` method of the `Ability` is called to check and adjust memory resources based on the foreground state.",
    "input": "",
    "output": "import {AbilityMonitor, Ability} from '@kit.AbilityKit';\n\nexport class MemoryMonitor extends AbilityMonitor {\n  constructor() {\n    super();\n  }\n\n  onAbilityForeground(ability: Ability): void {\n    if (ability) {\n      ability.onMemoryLevel(0); // Adjust memory level as needed\n    }\n  }\n}\n\nexport class MyAbility extends Ability {\n  onMemoryLevel(level: number): void {\n    // Implement memory adjustment logic based on the level\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `bundleName` property of `AbilityDelegatorArgs` to retrieve the bundle name of the test application, then uses this bundle name to query the `AbilityInfo` object using its `bundleName` property. Finally, check if the ability is enabled by accessing the `enabled` property of `AbilityInfo` and return the result.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function checkAbilityEnabled(args: AbilityDelegatorArgs, abilityInfo: AbilityInfo): boolean {\n  const bundleName = args.bundleName;\n  if (abilityInfo.bundleName === bundleName) {\n    return abilityInfo.enabled;\n  }\n  return false;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes an `AbilityDelegatorArgs` object and uses its `testCaseNames` property to get the list of test cases. For each test case, use the `moduleName` property of `AbilityInfo` to filter abilities belonging to a specific module, then collect and return the `label` properties of these filtered abilities.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function filterAbilitiesByModule(args: AbilityDelegatorArgs, moduleName: string): string[] {\n  const labels: string[] = [];\n  if (args.testCaseNames) {\n    for (const testCase of args.testCaseNames) {\n      const abilityInfo: AbilityInfo = testCase as unknown as AbilityInfo;\n      if (abilityInfo.moduleName === moduleName) {\n        labels.push(abilityInfo.label);\n      }\n    }\n  }\n  return labels;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `parameters` property of `AbilityDelegatorArgs` to get a target ability name. Then, use the `name` property of `AbilityInfo` to find the matching ability, and verify if it supports window modes by checking the `supportWindowModes` property. Return true if the ability supports the specified window mode, otherwise false.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function verifyAbilityWindowMode(args: AbilityDelegatorArgs, abilityInfos: AbilityInfo[], windowMode: number): boolean {\n  const targetAbilityName = args.parameters?.targetAbilityName;\n  if (!targetAbilityName) {\n    return false;\n  }\n\n  const abilityInfo = abilityInfos.find(info => info.name === targetAbilityName);\n  if (!abilityInfo) {\n    return false;\n  }\n\n  return (abilityInfo.supportWindowModes & windowMode) !== 0;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityResult` object, sets its `resultCode` property to a specific value, and then passes this object to another function that extracts the `resultCode` and `want` properties to perform a conditional operation based on these values.",
    "input": "",
    "output": "import { AbilityResult } from '@kit.AbilityKit';\n\nexport function createAbilityResult(resultCode: number, want?: object): AbilityResult {\n  const abilityResult: AbilityResult = {\n    resultCode: resultCode,\n    want: want\n  };\n  return abilityResult;\n}\n\nexport function processAbilityResult(result: AbilityResult): void {\n  const { resultCode, want } = result;\n  if (resultCode === 0 && want) {\n    console.log('Operation succeeded with want data');\n  } else if (resultCode === 0) {\n    console.log('Operation succeeded without want data');\n  } else {\n    console.log('Operation failed');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes two `AbilityResult` objects, compares their `resultCode` properties, and merges their `want` properties into a new `AbilityResult` object with the higher `resultCode` value, then returns the merged object.",
    "input": "",
    "output": "import { AbilityResult } from '@kit.AbilityKit';\n\nexport function mergeAbilityResults(result1: AbilityResult, result2: AbilityResult): AbilityResult {\n  const mergedResult: AbilityResult = new AbilityResult();\n  mergedResult.resultCode = Math.max(result1.resultCode, result2.resultCode);\n  \n  if (result1.want && result2.want) {\n    mergedResult.want = result1.want;\n    mergedResult.want.mergeParameters(result2.want);\n  } else if (result1.want) {\n    mergedResult.want = result1.want;\n  } else if (result2.want) {\n    mergedResult.want = result2.want;\n  }\n  \n  return mergedResult;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that processes an array of `AbilityResult` objects, filters out those with a `resultCode` less than a specified threshold, and then aggregates the remaining `want` properties into a single `AbilityResult` object with the highest `resultCode` from the filtered list.",
    "input": "",
    "output": "import { AbilityResult } from '@kit.AbilityKit';\n\nexport function processAbilityResults(results: AbilityResult[], threshold: number): AbilityResult | null {\n  const filteredResults = results.filter(result => result.resultCode >= threshold);\n  \n  if (filteredResults.length === 0) {\n    return null;\n  }\n  \n  const highestResultCode = Math.max(...filteredResults.map(result => result.resultCode));\n  const highestResult = filteredResults.find(result => result.resultCode === highestResultCode);\n  \n  if (!highestResult) {\n    return null;\n  }\n  \n  const aggregatedWant = filteredResults.reduce((acc, result) => {\n    return {\n      ...acc,\n      ...result.want\n    };\n  }, highestResult.want);\n  \n  return {\n    resultCode: highestResult.resultCode,\n    want: aggregatedWant\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityMonitor` to monitor an ability with a specific `abilityName` and `moduleName`. When the ability is created (triggering `onAbilityCreate`), retrieve its runtime information using `AbilityRunningInfo` properties (`pid`, `processName`, `uid`) and log these details.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function monitorAbility(abilityName: string, moduleName: string): void {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityCreate: (abilityRunningInfo: AbilityRunningInfo) => {\n      console.log(`Ability created with pid: ${abilityRunningInfo.pid}`);\n      console.log(`Process name: ${abilityRunningInfo.processName}`);\n      console.log(`UID: ${abilityRunningInfo.uid}`);\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that sets up an `AbilityMonitor` to track an ability's lifecycle events (`onAbilityForeground`, `onAbilityBackground`). When the ability enters the foreground, use `AbilityRunningInfo` to capture its `startTime` and `abilityState`, then calculate the duration since the ability was started and log the result.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function setupAbilityMonitor(abilityName: string, moduleName: string): AbilityMonitor {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityForeground: (abilityRunningInfo: AbilityRunningInfo) => {\n      const currentTime = new Date().getTime();\n      const startTime = abilityRunningInfo.startTime;\n      const duration = currentTime - startTime;\n      console.log(`Ability ${abilityName} entered foreground. Duration since start: ${duration}ms. State: ${abilityRunningInfo.abilityState}`);\n    },\n    onAbilityBackground: (abilityRunningInfo: AbilityRunningInfo) => {\n      console.log(`Ability ${abilityName} entered background. State: ${abilityRunningInfo.abilityState}`);\n    }\n  };\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityMonitor` to detect when an ability is destroyed (`onAbilityDestroy`). Upon destruction, use `AbilityRunningInfo` to access the destroyed ability's `pid` and `processName`, then verify if the process is still running (simulated check) and log the verification result.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function setupAbilityMonitor(): AbilityMonitor {\n  const monitor: AbilityMonitor = {\n    onAbilityDestroy: (abilityInfo: AbilityRunningInfo) => {\n      const pid = abilityInfo.pid;\n      const processName = abilityInfo.processName;\n      \n      // Simulate process check\n      const isProcessRunning = simulateProcessCheck(pid, processName);\n      \n      console.log(`Ability destroyed - PID: ${pid}, ProcessName: ${processName}, IsRunning: ${isProcessRunning}`);\n    }\n  };\n  \n  return monitor;\n}\n\nfunction simulateProcessCheck(pid: number, processName: string): boolean {\n  // Simulate process check logic\n  return Math.random() > 0.5;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create an ability lifecycle manager that uses `onAbilityCreate` and `onAbilityDestroy` methods of `AbilityLifecycleCallback` to track the creation and destruction of abilities, and then uses `onWindowStageCreate` and `onWindowStageDestroy` methods of `AbilityLifecycleCallback` to manage the corresponding window stages. The manager should ensure that window stages are only created for abilities that are currently active and destroyed when the ability is destroyed.",
    "input": "",
    "output": "import { AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class AbilityLifecycleManager extends AbilityLifecycleCallback {\n  private activeAbilities: Set<string> = new Set();\n\n  onAbilityCreate(ability): void {\n    this.activeAbilities.add(ability.context.abilityInfo.name);\n  }\n\n  onAbilityDestroy(ability): void {\n    this.activeAbilities.delete(ability.context.abilityInfo.name);\n  }\n\n  onWindowStageCreate(ability, windowStage): void {\n    if (this.activeAbilities.has(ability.context.abilityInfo.name)) {\n      // Handle window stage creation logic\n    }\n  }\n\n  onWindowStageDestroy(ability, windowStage): void {\n    if (!this.activeAbilities.has(ability.context.abilityInfo.name)) {\n      // Handle window stage destruction logic\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a state synchronization system that uses `onAbilityForeground` and `onAbilityBackground` methods of `AbilityLifecycleCallback` to detect when an ability moves to the foreground or background, and then uses `onWindowStageActive` and `onWindowStageInactive` methods of `AbilityLifecycleCallback` to synchronize the window stage state with the ability state. The system should ensure that window stages are only active when their corresponding abilities are in the foreground.",
    "input": "",
    "output": "import { AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class StateSynchronizationCallback extends AbilityLifecycleCallback {\n  private isAbilityForeground: boolean = false;\n\n  onAbilityForeground(): void {\n    this.isAbilityForeground = true;\n  }\n\n  onAbilityBackground(): void {\n    this.isAbilityForeground = false;\n  }\n\n  onWindowStageActive(): void {\n    if (!this.isAbilityForeground) {\n      // Handle inactive state\n    }\n  }\n\n  onWindowStageInactive(): void {\n    if (this.isAbilityForeground) {\n      // Handle active state\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a recovery mechanism that uses `onAbilityContinue` method of `AbilityLifecycleCallback` to handle ability continuation requests, and then uses `onWindowStageCreate` and `onWindowStageActive` methods of `AbilityLifecycleCallback` to recreate and activate the window stage for the continued ability. The mechanism should ensure that the window stage is fully restored to its previous state before the ability was destroyed.",
    "input": "",
    "output": "import { AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class RecoveryMechanism extends AbilityLifecycleCallback {\n  private continuationData: Record<string, Object> = {};\n\n  onAbilityContinue(ability: any): boolean {\n    // Handle ability continuation request\n    // Store necessary data for recovery\n    this.continuationData = ability.getContinuationData();\n    return true;\n  }\n\n  onWindowStageCreate(ability: any, windowStage: any): void {\n    // Recreate window stage for continued ability\n    if (Object.keys(this.continuationData).length > 0) {\n      // Restore window stage state from continuation data\n      windowStage.restoreWindowStage(this.continuationData);\n    }\n  }\n\n  onWindowStageActive(ability: any, windowStage: any): void {\n    // Activate the window stage for continued ability\n    windowStage.activate();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onAbilityCreate` method of `AbilityLifecycleCallback` to initialize an ability, and then uses the `resultCode` property of `AbilityResult` to verify if the initialization was successful. If the `resultCode` indicates success, trigger the `onAbilityForeground` method to bring the ability to the foreground.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityResult} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate() {\n    let abilityResult: AbilityResult = {\n      resultCode: 0,\n      want: {}\n    };\n\n    if (abilityResult.resultCode === 0) {\n      this.onAbilityForeground();\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onWindowStageCreate` method of `AbilityLifecycleCallback` to set up a window stage for an ability, and then passes the `want` property of `AbilityResult` to the `onAbilityContinue` method to handle the continuation of the ability with the specified intent.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityResult} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onWindowStageCreate(windowStage) {\n    // Setup window stage for the ability\n  }\n\n  onAbilityContinue(abilityResult: AbilityResult) {\n    const want = abilityResult.want;\n    // Handle the continuation of the ability with the specified intent\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `onAbilityDestroy` method of `AbilityLifecycleCallback` to clean up resources when an ability is destroyed, and then checks the `resultCode` property of `AbilityResult` to log the destruction status. If the `resultCode` indicates an error, trigger the `onWindowStageDestroy` method to ensure all associated window stages are also cleaned up.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityResult} from '@kit.AbilityKit';\n\nexport class CustomAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityDestroy(ability: any, result: AbilityResult): void {\n    // Clean up resources when ability is destroyed\n    if (result.resultCode !== 0) {\n      console.error(`Ability destruction failed with resultCode: ${result.resultCode}`);\n      this.onWindowStageDestroy(ability);\n    } else {\n      console.log(`Ability destroyed successfully with resultCode: ${result.resultCode}`);\n    }\n  }\n\n  onWindowStageDestroy(ability: any): void {\n    // Clean up window stage resources\n    console.log('Window stage destroyed due to ability destruction error');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegatorArgs.bundleName` to specify the target bundle, then uses `AbilityDelegator.startAbility` to launch the specified ability, and finally uses `AbilityDelegator.waitAbilityMonitor` to verify that the ability has been successfully launched and is in the foreground state.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function launchAndVerifyAbility(delegator: AbilityDelegator, args: AbilityDelegatorArgs, abilityName: string): void {\n  const monitor = delegator.addAbilityMonitor({\n    abilityName: abilityName,\n    onAbilityCreate: (data) => {\n      console.log(`Ability ${abilityName} created`);\n    },\n    onAbilityForeground: (data) => {\n      console.log(`Ability ${abilityName} is in foreground`);\n    },\n    onAbilityBackground: (data) => {\n      console.log(`Ability ${abilityName} is in background`);\n    },\n    onAbilityDestroy: (data) => {\n      console.log(`Ability ${abilityName} destroyed`);\n    }\n  });\n\n  delegator.startAbility({\n    bundleName: args.bundleName,\n    abilityName: abilityName\n  }).then(() => {\n    console.log(`Started ability ${abilityName}`);\n  }).catch((err) => {\n    console.error(`Failed to start ability ${abilityName}: ${err}`);\n  });\n\n  delegator.waitAbilityMonitor(monitor, (err, data) => {\n    if (err) {\n      console.error(`Failed to monitor ability ${abilityName}: ${err}`);\n      return;\n    }\n    console.log(`Ability ${abilityName} state verified`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test scenario where `AbilityDelegatorArgs.testCaseNames` is used to define the test cases, then `AbilityDelegator.executeShellCommand` is called to set up the test environment, and `AbilityDelegator.finishTest` is used to clean up and finalize the test execution after verifying the results with `AbilityDelegator.getAbilityState`.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function createTestScenario() {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    testCaseNames: ['testCase1', 'testCase2'],\n    bundleName: 'com.example.myapplication',\n    testRunnerClassName: 'TestRunner',\n    parameters: {}\n  };\n\n  const abilityDelegator = new AbilityDelegator(delegatorArgs);\n\n  async function runTestScenario() {\n    try {\n      // Setup test environment\n      const setupResult = await abilityDelegator.executeShellCommand('setup_command');\n      console.log(`Setup command result: ${setupResult}`);\n\n      // Verify ability state\n      const abilityState = abilityDelegator.getAbilityState();\n      console.log(`Ability state: ${abilityState}`);\n\n      // Clean up and finalize test\n      abilityDelegator.finishTest('Test completed successfully', 0);\n    } catch (error) {\n      console.error(`Test failed: ${error}`);\n      abilityDelegator.finishTest(`Test failed: ${error}`, 1);\n    }\n  }\n\n  runTestScenario();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegatorArgs.parameters` to pass configuration data, then `AbilityDelegator.addAbilityMonitor` to set up a monitor for an ability, and `AbilityDelegator.doAbilityBackground` and `AbilityDelegator.doAbilityForeground` to test the ability's behavior when transitioning between background and foreground states, finally using `AbilityDelegator.removeAbilityMonitor` to clean up the monitor.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function testAbilityLifecycleTransition(delegator: AbilityDelegator, args: AbilityDelegatorArgs): void {\n  const parameters = args.parameters;\n  const abilityName = parameters?.abilityName;\n  \n  if (!abilityName) {\n    return;\n  }\n  \n  const monitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (ability) => {\n      console.log(`Ability ${abilityName} created`);\n    },\n    onAbilityForeground: (ability) => {\n      console.log(`Ability ${abilityName} moved to foreground`);\n    },\n    onAbilityBackground: (ability) => {\n      console.log(`Ability ${abilityName} moved to background`);\n    },\n    onAbilityDestroy: (ability) => {\n      console.log(`Ability ${abilityName} destroyed`);\n    }\n  };\n  \n  delegator.addAbilityMonitor(monitor);\n  \n  delegator.doAbilityForeground(abilityName).then(() => {\n    console.log(`Foreground transition completed for ${abilityName}`);\n    \n    delegator.doAbilityBackground(abilityName).then(() => {\n      console.log(`Background transition completed for ${abilityName}`);\n      \n      delegator.removeAbilityMonitor(monitor);\n      console.log(`Monitor for ${abilityName} removed`);\n    }).catch((err) => {\n      console.error(`Failed to transition to background: ${err}`);\n    });\n  }).catch((err) => {\n    console.error(`Failed to transition to foreground: ${err}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` instance to monitor an ability with a specific `abilityName` and `moduleName`, then uses the `addAbilityMonitor` method of `AbilityDelegator` to register the monitor. Finally, use the `waitAbilityMonitor` method of `AbilityDelegator` to wait for the ability to reach the foreground state, and print the ability state using `getAbilityState`.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function monitorAndWaitForAbility(abilityDelegator: AbilityDelegator, abilityName: string, moduleName: string): void {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityForeground: (ability) => {\n      const state = abilityDelegator.getAbilityState(ability);\n      console.log(`Ability state: ${state}`);\n    }\n  };\n\n  abilityDelegator.addAbilityMonitor(monitor);\n  abilityDelegator.waitAbilityMonitor(monitor);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `startAbility` method of `AbilityDelegator` to launch an ability, then creates an `AbilityMonitor` instance to track the ability's lifecycle events (e.g., `onAbilityCreate`, `onAbilityDestroy`). Register the monitor using `addAbilityMonitorSync` of `AbilityDelegator`, and use `removeAbilityMonitorSync` to unregister it after the ability is destroyed.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function monitorAbilityLifecycle(delegator: AbilityDelegator, abilityName: string, moduleName: string): void {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityCreate: (ability) => {\n      console.log(`Ability created: ${ability}`);\n    },\n    onAbilityDestroy: (ability) => {\n      console.log(`Ability destroyed: ${ability}`);\n      delegator.removeAbilityMonitorSync(monitor);\n    }\n  };\n\n  delegator.addAbilityMonitorSync(monitor);\n  delegator.startAbility({\n    abilityName: abilityName,\n    moduleName: moduleName\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` instance with `onWindowStageCreate` and `onWindowStageDestroy` callbacks, then registers it using `addAbilityStageMonitor` of `AbilityDelegator`. Use `executeShellCommand` of `AbilityDelegator` to simulate a scenario that triggers window stage changes, and verify the callbacks are invoked by checking the monitor's state.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function createAndRegisterAbilityMonitor(abilityDelegator: AbilityDelegator): void {\n  const abilityMonitor: AbilityMonitor = new AbilityMonitor();\n  \n  abilityMonitor.onWindowStageCreate = () => {\n    console.log('onWindowStageCreate callback invoked');\n  };\n  \n  abilityMonitor.onWindowStageDestroy = () => {\n    console.log('onWindowStageDestroy callback invoked');\n  };\n  \n  abilityDelegator.addAbilityStageMonitor(abilityMonitor);\n  \n  abilityDelegator.executeShellCommand('window stage change command').then(() => {\n    console.log('Shell command executed to trigger window stage changes');\n  }).catch((err) => {\n    console.error(`Failed to execute shell command: ${err}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch an ability and then uses `AbilityDelegator.waitAbilityMonitor` to wait for the ability to reach a specific state. Once the ability is in the desired state, retrieve its result using `AbilityResult.resultCode` and `AbilityResult.want` to verify the success of the operation.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function startAndWaitForAbility(delegator: AbilityDelegator, want: Want, state: number): Promise<AbilityResult> {\n  return new Promise((resolve, reject) => {\n    try {\n      delegator.startAbility(want, (err) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        delegator.waitAbilityMonitor({\n          abilityName: want.bundleName,\n          onAbilityCreate: (ability) => {\n            if (ability.getState() === state) {\n              resolve({\n                resultCode: 0,\n                want: want\n              });\n            }\n          }\n        }, (err) => {\n          if (err) {\n            reject(err);\n          }\n        });\n      });\n    } catch (err) {\n      reject(err);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test scenario where you use `AbilityDelegator.addAbilityMonitorSync` to set up a monitor for an ability, then use `AbilityDelegator.doAbilityForeground` to bring the ability to the foreground. After the ability is in the foreground, use `AbilityDelegator.getAbilityState` to confirm its state and then pass the state information to `AbilityDelegator.printSync` to log the result.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function testAbilityLifecycle(delegator: AbilityDelegator, want: Want): void {\n  const abilityName = 'testAbility';\n  const monitor = delegator.addAbilityMonitorSync(abilityName);\n  \n  delegator.startAbility(want);\n  delegator.doAbilityForeground(abilityName);\n  \n  const abilityState = delegator.getAbilityState(abilityName);\n  delegator.printSync(`Ability state: ${abilityState}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.executeShellCommand` to run a shell command and then checks the output of the command. Based on the output, use `AbilityDelegator.setMockList` to mock certain behaviors for subsequent tests. Finally, use `AbilityDelegator.startAbility` to launch an ability and verify the mocked behavior by inspecting `AbilityResult.want`.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function executeShellAndMockBehavior(delegator: AbilityDelegator, command: string, mockList: Array<string>, abilityWant: any): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    delegator.executeShellCommand(command, (err: Error, output: string) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      if (output.includes('success')) {\n        delegator.setMockList(mockList);\n        delegator.startAbility(abilityWant, (err: Error, result: AbilityResult) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n\n          if (result.want !== undefined) {\n            resolve();\n          } else {\n            reject(new Error('Mock behavior verification failed'));\n          }\n        });\n      } else {\n        reject(new Error('Shell command output does not indicate success'));\n      }\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that registers an `AbilityLifecycleCallback` to monitor the lifecycle events of an ability. When the `onAbilityCreate` method is triggered, use the `AbilityRunningInfo` properties (`ability`, `pid`, and `startTime`) to log the details of the newly created ability and store them in a global map for tracking.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nlet abilityInfoMap: Map<string, AbilityRunningInfo> = new Map();\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(abilityRunningInfo: AbilityRunningInfo): void {\n    console.log(`Ability created: ${abilityRunningInfo.ability}`);\n    console.log(`PID: ${abilityRunningInfo.pid}`);\n    console.log(`Start Time: ${abilityRunningInfo.startTime}`);\n    abilityInfoMap.set(abilityRunningInfo.ability, abilityRunningInfo);\n  }\n}\n\nexport function registerAbilityLifecycleCallback(): AbilityLifecycleCallback {\n  return new MyAbilityLifecycleCallback();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature where the `onAbilityForeground` method of `AbilityLifecycleCallback` is used to detect when an ability comes to the foreground. Then, query the `AbilityRunningInfo` properties (`abilityState`, `processName`, and `uid`) to verify if the ability is running in the expected process and has the correct permissions, logging any discrepancies.",
    "input": "",
    "output": "import { AbilityRunningInfo, AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private expectedProcessName: string;\n  private expectedUid: number;\n\n  constructor(expectedProcessName: string, expectedUid: number) {\n    super();\n    this.expectedProcessName = expectedProcessName;\n    this.expectedUid = expectedUid;\n  }\n\n  onAbilityForeground(abilityRunningInfo: AbilityRunningInfo): void {\n    if (abilityRunningInfo.abilityState !== 2) { // 2 represents FOREGROUND state\n      console.error(`Ability is not in foreground state. Current state: ${abilityRunningInfo.abilityState}`);\n      return;\n    }\n\n    if (abilityRunningInfo.processName !== this.expectedProcessName) {\n      console.error(`Process name mismatch. Expected: ${this.expectedProcessName}, Actual: ${abilityRunningInfo.processName}`);\n    }\n\n    if (abilityRunningInfo.uid !== this.expectedUid) {\n      console.error(`UID mismatch. Expected: ${this.expectedUid}, Actual: ${abilityRunningInfo.uid}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility that uses the `onWindowStageDestroy` method of `AbilityLifecycleCallback` to detect when a window stage is destroyed. Then, use the `AbilityRunningInfo` properties (`pid`, `ability`, and `startTime`) to identify and clean up any residual resources associated with the destroyed window stage, ensuring no memory leaks occur.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class WindowStageCleanup extends AbilityLifecycleCallback {\n  private runningAbilities: Map<number, AbilityRunningInfo> = new Map();\n\n  onWindowStageDestroy(abilityRunningInfo: AbilityRunningInfo): void {\n    const pid = abilityRunningInfo.pid;\n    const ability = abilityRunningInfo.ability;\n    const startTime = abilityRunningInfo.startTime;\n\n    if (this.runningAbilities.has(pid)) {\n      const cachedInfo = this.runningAbilities.get(pid);\n      if (cachedInfo && cachedInfo.ability === ability && cachedInfo.startTime === startTime) {\n        this.cleanupResources(pid, ability, startTime);\n        this.runningAbilities.delete(pid);\n      }\n    }\n  }\n\n  private cleanupResources(pid: number, ability: string, startTime: number): void {\n    // Implement resource cleanup logic here\n    console.log(`Cleaning up resources for PID: ${pid}, Ability: ${ability}, StartTime: ${startTime}`);\n  }\n\n  trackAbility(abilityRunningInfo: AbilityRunningInfo): void {\n    this.runningAbilities.set(abilityRunningInfo.pid, abilityRunningInfo);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.getCurrentTopAbility()` to retrieve the current top ability, then checks if its `bundleName` (from `AbilityInfo`) matches a target bundle name. If it matches, use `AbilityDelegator.startAbility()` to launch a new ability with the same `bundleName` but a different `moduleName` (from `AbilityInfo`).",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function checkAndStartNewAbility(abilityDelegator: AbilityDelegator, targetBundleName: string, newModuleName: string): void {\n  const currentTopAbility: AbilityInfo | null = abilityDelegator.getCurrentTopAbility();\n  if (currentTopAbility && currentTopAbility.bundleName === targetBundleName) {\n    const want = {\n      bundleName: targetBundleName,\n      moduleName: newModuleName\n    };\n    abilityDelegator.startAbility(want);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `AbilityDelegator.addAbilityMonitor()` to monitor for a specific ability (identified by its `name` from `AbilityInfo`). Once the ability is detected, use `AbilityInfo.permissions` to verify if it has a required permission, and then use `AbilityDelegator.doAbilityForeground()` to bring it to the foreground if the permission check passes.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function monitorAndForegroundAbility(\n  delegator: AbilityDelegator,\n  abilityName: string,\n  requiredPermission: string\n): void {\n  const monitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (abilityInfo: AbilityInfo) => {\n      if (abilityInfo.permissions && abilityInfo.permissions.includes(requiredPermission)) {\n        delegator.doAbilityForeground(abilityInfo);\n      }\n    }\n  };\n  \n  delegator.addAbilityMonitor(monitor);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that retrieves the `applicationInfo` (from `AbilityInfo`) of the current ability using `AbilityDelegator.getCurrentTopAbility()`, then checks its `enabled` status (from `AbilityInfo`). If the ability is disabled, use `AbilityDelegator.executeShellCommand()` to enable it and then verify the status again.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegator} from '@kit.AbilityKit';\n\nexport async function checkAndEnableAbility(abilityDelegator: AbilityDelegator): Promise<boolean> {\n  try {\n    const abilityInfo: AbilityInfo | null = abilityDelegator.getCurrentTopAbility();\n    if (!abilityInfo) {\n      return false;\n    }\n\n    if (!abilityInfo.enabled) {\n      const bundleName = abilityInfo.bundleName;\n      const abilityName = abilityInfo.name;\n      const command = `bm enable -n ${bundleName}/${abilityName}`;\n      const result = await abilityDelegator.executeShellCommand(command);\n      if (result.exitCode !== 0) {\n        return false;\n      }\n\n      const updatedAbilityInfo: AbilityInfo | null = abilityDelegator.getCurrentTopAbility();\n      if (!updatedAbilityInfo) {\n        return false;\n      }\n      return updatedAbilityInfo.enabled;\n    }\n    return true;\n  } catch (error) {\n    return false;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegatorArgs.bundleName` to specify the target bundle, then uses `AbilityDelegator.startAbility` to launch the specified ability, and finally uses `AbilityDelegator.waitAbilityMonitor` to wait for the ability to reach the foreground state.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function launchAndWaitForAbility(bundleName: string, abilityName: string, abilityDelegator: AbilityDelegator): void {\n  const abilityDelegatorArgs: AbilityDelegatorArgs = {\n    bundleName: bundleName\n  };\n\n  const want = {\n    bundleName: bundleName,\n    abilityName: abilityName\n  };\n\n  const monitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (data) => {\n      console.log(`Ability ${abilityName} created`);\n    },\n    onAbilityForeground: (data) => {\n      console.log(`Ability ${abilityName} foreground`);\n    },\n    onAbilityBackground: (data) => {\n      console.log(`Ability ${abilityName} background`);\n    },\n    onAbilityDestroy: (data) => {\n      console.log(`Ability ${abilityName} destroyed`);\n    }\n  };\n\n  abilityDelegator.addAbilityMonitor(monitor);\n  abilityDelegator.startAbility(want);\n  abilityDelegator.waitAbilityMonitor(monitor, (err, data) => {\n    if (err) {\n      console.error(`Error waiting for ability: ${err.code}, ${err.message}`);\n    } else {\n      console.log(`Ability ${abilityName} reached foreground state`);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test scenario where you use `AbilityDelegatorArgs.testCaseNames` to define test cases, then use `AbilityDelegator.executeShellCommand` to set up the test environment, and finally use `AbilityDelegator.finishTest` to conclude the test execution and report results.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function createAbilityDelegatorArgs(): AbilityDelegatorArgs {\n  const args: AbilityDelegatorArgs = {\n    bundleName: 'com.example.myapplication',\n    parameters: {},\n    testCaseNames: ['TestCase1', 'TestCase2'],\n    testRunnerClassName: 'TestRunner'\n  };\n  return args;\n}\n\nexport async function runTestScenario(delegator: AbilityDelegator): Promise<void> {\n  try {\n    const setupCommand = 'echo \"Setting up test environment\"';\n    const setupResult = await delegator.executeShellCommand(setupCommand);\n    console.log(`Setup command result: ${setupResult}`);\n\n    const testCommand = 'echo \"Running test cases\"';\n    const testResult = await delegator.executeShellCommand(testCommand);\n    console.log(`Test command result: ${testResult}`);\n\n    delegator.finishTest('Test execution completed successfully', 0);\n  } catch (error) {\n    delegator.finishTest(`Test execution failed: ${error}`, 1);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegatorArgs.parameters` to pass configuration data, then uses `AbilityDelegator.addAbilityMonitorSync` to monitor ability lifecycle events, and finally uses `AbilityDelegator.getAbilityState` to verify the ability's current state matches the expected configuration.",
    "input": "",
    "output": "import { AbilityDelegatorArgs, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function monitorAndVerifyAbility(\n  delegatorArgs: AbilityDelegatorArgs,\n  delegator: AbilityDelegator,\n  expectedState: number\n): boolean {\n  const { parameters } = delegatorArgs;\n  \n  if (!parameters) {\n    return false;\n  }\n  \n  const abilityMonitor = {\n    abilityName: parameters['abilityName'],\n    onAbilityCreate: (ability) => {\n      console.log(`Ability created: ${ability}`);\n    },\n    onAbilityForeground: (ability) => {\n      console.log(`Ability foreground: ${ability}`);\n    },\n    onAbilityBackground: (ability) => {\n      console.log(`Ability background: ${ability}`);\n    },\n    onAbilityDestroy: (ability) => {\n      console.log(`Ability destroyed: ${ability}`);\n    }\n  };\n  \n  delegator.addAbilityMonitorSync(abilityMonitor);\n  \n  const currentState = delegator.getAbilityState(parameters['abilityName']);\n  \n  return currentState === expectedState;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that implements `AbilityLifecycleCallback` to monitor the lifecycle of an ability, specifically using `onAbilityCreate` to initialize resources and `onAbilityDestroy` to release them. Then, use `AbilityResult` to return a result code and a `want` object containing the lifecycle state changes when the ability is destroyed.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, AbilityResult } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private resources: string[] = [];\n\n  onAbilityCreate() {\n    // Initialize resources\n    this.resources.push('Resource1');\n    this.resources.push('Resource2');\n  }\n\n  onAbilityDestroy() {\n    // Release resources\n    this.resources = [];\n\n    // Return AbilityResult with resultCode and want\n    const abilityResult: AbilityResult = {\n      resultCode: 0,\n      want: {\n        bundleName: 'com.example.myability',\n        abilityName: 'MyAbility',\n        parameters: {\n          lifecycleState: 'destroyed'\n        }\n      }\n    };\n    return abilityResult;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `AbilityLifecycleCallback` to track window stage events, specifically `onWindowStageCreate` to set up a window and `onWindowStageDestroy` to clean up resources. Pass the window stage status (active/inactive) to `AbilityResult` and return it along with a custom result code when the window stage is destroyed.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, AbilityResult } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private windowStageStatus: string = 'inactive';\n\n  onWindowStageCreate(windowStage: any): void {\n    this.windowStageStatus = 'active';\n    // Setup window here\n  }\n\n  onWindowStageDestroy(windowStage: any): void {\n    this.windowStageStatus = 'inactive';\n    // Clean up resources here\n  }\n\n  onWindowStageActive(windowStage: any): void {\n    this.windowStageStatus = 'active';\n  }\n\n  onWindowStageInactive(windowStage: any): void {\n    this.windowStageStatus = 'inactive';\n  }\n\n  getAbilityResult(): AbilityResult {\n    const abilityResult: AbilityResult = {\n      resultCode: 0,\n      want: undefined\n    };\n\n    if (this.windowStageStatus === 'inactive') {\n      abilityResult.resultCode = 1;\n    }\n\n    return abilityResult;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that leverages `AbilityLifecycleCallback` to handle ability foreground and background events, using `onAbilityForeground` to log when the ability comes to the foreground and `onAbilityBackground` to log when it goes to the background. Use `AbilityResult` to return a result code and a `want` object containing the timestamp of these events.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, AbilityResult } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(ability): AbilityResult {\n    console.log('Ability has come to the foreground');\n    const want = {\n      parameters: {\n        timestamp: new Date().toISOString()\n      }\n    };\n    return {\n      resultCode: 0,\n      want\n    };\n  }\n\n  onAbilityBackground(ability): AbilityResult {\n    console.log('Ability has gone to the background');\n    const want = {\n      parameters: {\n        timestamp: new Date().toISOString()\n      }\n    };\n    return {\n      resultCode: 0,\n      want\n    };\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `bundleName` property of `AbilityDelegatorArgs` to fetch the current bundle name, then passes it to the `onConfigurationUpdate` method of `Ability` to trigger a configuration update for the specified bundle.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityConstant, Ability} from '@kit.AbilityKit';\n\nexport function triggerConfigurationUpdate(args: AbilityDelegatorArgs, ability: Ability): void {\n  const bundleName: string = args.bundleName;\n  ability.onConfigurationUpdate({\n    bundleName: bundleName\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `LaunchReason` enum from `AbilityConstant` and uses it as a parameter in the `onMemoryLevel` method of `Ability` to handle memory level changes based on the launch reason of the ability.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityConstant, Ability} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  onMemoryLevel(level: AbilityConstant.MemoryLevel, launchReason: AbilityConstant.LaunchReason): void {\n    switch (launchReason) {\n      case AbilityConstant.LaunchReason.START_ABILITY:\n        // Handle memory level change when ability is started\n        break;\n      case AbilityConstant.LaunchReason.CALL:\n        // Handle memory level change when ability is called\n        break;\n      default:\n        // Handle other launch reasons\n        break;\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes the `testCaseNames` property from `AbilityDelegatorArgs` and the `StateType` enum from `AbilityConstant`, then uses them in the `onConfigurationUpdate` method of `Ability` to update the configuration only for specific test cases and state types.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityConstant, Ability} from '@kit.AbilityKit';\n\nexport class TestAbility extends Ability {\n  private testCaseNames: string[] = [];\n  private stateTypes: AbilityConstant.StateType[] = [];\n\n  public setTestConfig(testCaseNames: string[], stateTypes: AbilityConstant.StateType[]): void {\n    this.testCaseNames = testCaseNames;\n    this.stateTypes = stateTypes;\n  }\n\n  onConfigurationUpdate(config: Record<string, any>): void {\n    const delegatorArgs: AbilityDelegatorArgs | undefined = this.context?.abilityDelegatorArgs;\n    if (!delegatorArgs?.testCaseNames || !this.stateTypes.length) {\n      return;\n    }\n\n    const shouldUpdate = delegatorArgs.testCaseNames.some(testCase => \n      this.testCaseNames.includes(testCase)\n    ) && this.stateTypes.includes(this.launchReason as AbilityConstant.StateType);\n\n    if (shouldUpdate) {\n      super.onConfigurationUpdate(config);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch a new ability, then monitors its lifecycle state changes using `AbilityLifecycleCallback.onAbilityCreate` and `AbilityLifecycleCallback.onAbilityForeground`. The function should return the ability's state once it reaches the foreground.",
    "input": "",
    "output": "import { Ability, AbilityDelegator, AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport function startAbilityAndMonitorLifecycle(delegator: AbilityDelegator, want: Want): Promise<string> {\n  return new Promise((resolve) => {\n    const abilityMonitor = {\n      abilityName: want.abilityName,\n      onAbilityCreate: (ability: Ability) => {\n        console.log(`Ability created: ${ability.bundleName}`);\n      },\n      onAbilityForeground: (ability: Ability) => {\n        console.log(`Ability in foreground: ${ability.bundleName}`);\n        resolve('foreground');\n      }\n    };\n\n    delegator.addAbilityMonitor(abilityMonitor);\n    delegator.startAbility(want).then(() => {\n      console.log('Ability started successfully');\n    }).catch((err: Error) => {\n      console.error(`Failed to start ability: ${err.message}`);\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test scenario where `AbilityDelegator.addAbilityMonitor` is used to set up a monitor for an ability, and then `AbilityDelegator.waitAbilityMonitor` is called to wait for the ability to be created. Once the ability is detected, use `AbilityDelegator.getAbilityState` to verify its state and `Ability.onConfigurationUpdate` to simulate a configuration change, ensuring the ability handles it correctly.",
    "input": "",
    "output": "import {Ability, AbilityDelegator, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport function testAbilityMonitorScenario(delegator: AbilityDelegator, abilityName: string) {\n  const abilityMonitor = delegator.addAbilityMonitor({\n    abilityName: abilityName,\n    onAbilityCreate: (ability: Ability) => {\n      console.log(`Ability ${abilityName} created`);\n    }\n  });\n\n  delegator.waitAbilityMonitor(abilityMonitor).then((ability: Ability) => {\n    if (ability) {\n      const state = delegator.getAbilityState(ability);\n      console.log(`Ability state: ${state}`);\n\n      const newConfig = {\n        language: 'en',\n        colorMode: 'dark'\n      };\n      ability.onConfigurationUpdate(newConfig);\n      console.log('Configuration updated');\n    } else {\n      console.log('Ability not detected');\n    }\n  }).catch((error) => {\n    console.error(`Error waiting for ability: ${error}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.doAbilityBackground` to move an ability to the background, then checks if the ability properly handles the transition by verifying `AbilityLifecycleCallback.onAbilityBackground` is triggered. The function should also use `Ability.onMemoryLevel` to simulate a low memory event and ensure the ability responds appropriately.",
    "input": "",
    "output": "import {Ability, AbilityDelegator, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class TestAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private backgroundTriggered: boolean = false;\n  private memoryLevelTriggered: boolean = false;\n\n  onAbilityBackground(ability: Ability): void {\n    this.backgroundTriggered = true;\n  }\n\n  onMemoryLevel(level: number): void {\n    this.memoryLevelTriggered = true;\n  }\n\n  isBackgroundTriggered(): boolean {\n    return this.backgroundTriggered;\n  }\n\n  isMemoryLevelTriggered(): boolean {\n    return this.memoryLevelTriggered;\n  }\n}\n\nexport async function testAbilityBackgroundTransition(delegator: AbilityDelegator, ability: Ability): Promise<boolean> {\n  const callback = new TestAbilityLifecycleCallback();\n  ability.on('abilityLifecycle', callback);\n\n  await delegator.doAbilityBackground(ability);\n\n  const backgroundHandled = callback.isBackgroundTriggered();\n\n  ability.onMemoryLevel(10);\n  const memoryHandled = callback.isMemoryLevelTriggered();\n\n  ability.off('abilityLifecycle', callback);\n\n  return backgroundHandled && memoryHandled;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `abilityName` property of `AbilityMonitor` to monitor a specific ability, and then retrieves the corresponding `abilityState` and `pid` from `AbilityRunningInfo` to log the current state and process ID of the monitored ability.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityMonitor, Ability} from '@kit.AbilityKit';\n\nexport function monitorAbility(abilityName: string): void {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (ability: Ability) => {\n      console.log(`Ability ${abilityName} created`);\n    },\n    onAbilityForeground: (ability: Ability) => {\n      console.log(`Ability ${abilityName} is in foreground`);\n    },\n    onAbilityBackground: (ability: Ability) => {\n      console.log(`Ability ${abilityName} is in background`);\n    },\n    onAbilityDestroy: (ability: Ability) => {\n      console.log(`Ability ${abilityName} destroyed`);\n    },\n    onWindowStageCreate: (ability: Ability) => {\n      console.log(`Window stage created for ability ${abilityName}`);\n    },\n    onWindowStageDestroy: (ability: Ability) => {\n      console.log(`Window stage destroyed for ability ${abilityName}`);\n    },\n    onWindowStageRestore: (ability: Ability) => {\n      console.log(`Window stage restored for ability ${abilityName}`);\n    }\n  };\n\n  // Assuming there is a method to add the monitor to the ability manager\n  // This part is hypothetical as the actual implementation depends on the framework\n  // abilityManager.addAbilityMonitor(monitor);\n\n  // Log the ability state and pid when the ability is created\n  monitor.onAbilityCreate = (ability: Ability) => {\n    const runningInfo: AbilityRunningInfo = {\n      ability: ability,\n      abilityState: 0, // Assuming 0 represents a valid state\n      pid: 1234, // Example pid\n      processName: 'exampleProcess',\n      startTime: new Date().getTime(),\n      uid: 1000 // Example uid\n    };\n    console.log(`Ability state: ${runningInfo.abilityState}, PID: ${runningInfo.pid}`);\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onAbilityForeground` callback of `AbilityMonitor` to detect when an ability comes to the foreground, and then uses the `onConfigurationUpdate` method of `Ability` to update the ability's configuration based on the foreground event.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityMonitor, Ability} from '@kit.AbilityKit';\n\nexport function setupAbilityMonitor(abilityName: string, moduleName: string, configUpdateCallback: (config: object) => void): AbilityMonitor {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityForeground: (abilityRunningInfo: AbilityRunningInfo) => {\n      const ability: Ability = abilityRunningInfo.ability;\n      if (ability) {\n        ability.onConfigurationUpdate(configUpdateCallback);\n      }\n    }\n  };\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `startTime` property of `AbilityRunningInfo` to calculate the uptime of an ability, and then triggers the `onMemoryLevel` method of `Ability` if the uptime exceeds a certain threshold to handle potential memory management issues.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityMonitor, Ability} from '@kit.AbilityKit';\n\nexport function checkAbilityUptimeAndTriggerMemoryLevel(abilityInfo: AbilityRunningInfo, threshold: number, ability: Ability): void {\n  const currentTime = new Date().getTime();\n  const uptime = currentTime - abilityInfo.startTime;\n  if (uptime > threshold) {\n    ability.onMemoryLevel(0); // Assuming default memory level is 0\n  }\n}\n\nexport class UptimeAbilityMonitor extends AbilityMonitor {\n  private threshold: number;\n  private monitoredAbility: Ability | null = null;\n\n  constructor(threshold: number) {\n    super();\n    this.threshold = threshold;\n  }\n\n  onAbilityCreate(abilityInfo: AbilityRunningInfo): void {\n    if (this.monitoredAbility) {\n      checkAbilityUptimeAndTriggerMemoryLevel(abilityInfo, this.threshold, this.monitoredAbility);\n    }\n  }\n\n  setMonitoredAbility(ability: Ability): void {\n    this.monitoredAbility = ability;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onMemoryLevel` method of `Ability` to monitor memory level changes and then logs the current `abilityState` and `pid` from `AbilityRunningInfo` when the memory level reaches `MemoryLevel.CRITICAL` (from `AbilityConstant`).",
    "input": "",
    "output": "import {Ability, AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MemoryMonitorAbility extends Ability {\n  onMemoryLevel(level: AbilityConstant.MemoryLevel): void {\n    if (level === AbilityConstant.MemoryLevel.CRITICAL) {\n      const runningInfo: AbilityRunningInfo = this.context.getRunningInfo();\n      console.log(`Current abilityState: ${runningInfo.abilityState}`);\n      console.log(`Current pid: ${runningInfo.pid}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `AbilityRunningInfo` of the current ability, checks its `startTime`, and uses the `onConfigurationUpdate` method of `Ability` to handle configuration changes if the ability has been running for more than 5 minutes.",
    "input": "",
    "output": "import {Ability, AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function checkAbilityRunningTimeAndHandleConfigChange(ability: Ability): void {\n  const runningInfo: AbilityRunningInfo | undefined = ability.context.getRunningInfo();\n  if (runningInfo && runningInfo.startTime) {\n    const currentTime: number = new Date().getTime();\n    const runningDuration: number = currentTime - runningInfo.startTime;\n    const fiveMinutesInMillis: number = 5 * 60 * 1000;\n    if (runningDuration > fiveMinutesInMillis) {\n      ability.onConfigurationUpdate = (newConfig) => {\n        // Handle configuration changes here\n        console.log('Configuration updated after running for more than 5 minutes');\n      };\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `abilityState` property from `AbilityRunningInfo` to determine if the ability is in the foreground, and if so, uses the `WindowMode` enum from `AbilityConstant` to adjust the window mode settings via the `onConfigurationUpdate` method of `Ability`.",
    "input": "",
    "output": "import {Ability, AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  onConfigurationUpdate(newConfig) {\n    const abilityInfo: AbilityRunningInfo = this.context.getRunningInfo();\n    if (abilityInfo.abilityState === AbilityConstant.StateType.FOREGROUND) {\n      this.context.setWindowMode(AbilityConstant.WindowMode.FULLSCREEN);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegatorArgs.bundleName` to get the bundle name of a test case, then passes it to `AbilityRunningInfo.processName` to verify if the process name matches the bundle name. If they match, log the `AbilityRunningInfo.abilityState` and `AbilityRunningInfo.startTime`.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityLifecycleCallback, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class AbilityProcessVerifier extends AbilityLifecycleCallback {\n  private bundleName: string;\n\n  constructor(args: AbilityDelegatorArgs) {\n    super();\n    this.bundleName = args.bundleName;\n  }\n\n  onAbilityCreate(abilityRunningInfo: AbilityRunningInfo): void {\n    if (abilityRunningInfo.processName === this.bundleName) {\n      console.log(`AbilityState: ${abilityRunningInfo.abilityState}`);\n      console.log(`StartTime: ${abilityRunningInfo.startTime}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that registers an `AbilityLifecycleCallback` to monitor an ability's lifecycle events. Use `onAbilityCreate` to log the ability's creation time and `onAbilityForeground` to track when it comes to the foreground. Then, use `AbilityRunningInfo.ability` and `AbilityRunningInfo.pid` to cross-check the ability's details with the lifecycle events.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityLifecycleCallback, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(abilityRunningInfo: AbilityRunningInfo): void {\n    console.log(`Ability created at: ${abilityRunningInfo.startTime}`);\n    console.log(`Ability details - Name: ${abilityRunningInfo.ability}, PID: ${abilityRunningInfo.pid}`);\n  }\n\n  onAbilityForeground(abilityRunningInfo: AbilityRunningInfo): void {\n    console.log(`Ability came to foreground at: ${abilityRunningInfo.startTime}`);\n    console.log(`Ability details - Name: ${abilityRunningInfo.ability}, PID: ${abilityRunningInfo.pid}`);\n  }\n}\n\nexport function registerAbilityLifecycleCallback(): void {\n  const abilityLifecycleCallback = new MyAbilityLifecycleCallback();\n  const abilityDelegatorArgs: AbilityDelegatorArgs = {\n    bundleName: '',\n    parameters: {},\n    testCaseNames: [],\n    testRunnerClassName: ''\n  };\n  \n  // Assuming there's a method to register the callback, though not explicitly provided in the API\n  // This is a placeholder for the actual registration logic\n  // abilityDelegator.registerAbilityLifecycleCallback(abilityLifecycleCallback);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a test scenario where `AbilityDelegatorArgs.testCaseNames` is used to fetch test case names, and then `AbilityLifecycleCallback.onWindowStageCreate` is triggered for each test case. For each window stage created, use `AbilityRunningInfo.uid` and `AbilityRunningInfo.abilityState` to validate the ability's state and user ID.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityLifecycleCallback, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class TestScenario {\n  private abilityDelegatorArgs: AbilityDelegatorArgs;\n  private abilityLifecycleCallback: AbilityLifecycleCallback;\n\n  constructor(args: AbilityDelegatorArgs) {\n    this.abilityDelegatorArgs = args;\n    this.abilityLifecycleCallback = new AbilityLifecycleCallback();\n    this.setupLifecycleCallback();\n  }\n\n  private setupLifecycleCallback(): void {\n    this.abilityLifecycleCallback.onWindowStageCreate = (windowStage) => {\n      const testCaseNames = this.abilityDelegatorArgs.testCaseNames;\n      if (testCaseNames && testCaseNames.length > 0) {\n        testCaseNames.forEach((testCaseName) => {\n          const abilityRunningInfo: AbilityRunningInfo = windowStage.abilityContext.getAbilityRunningInfo();\n          this.validateAbilityState(abilityRunningInfo, testCaseName);\n        });\n      }\n    };\n  }\n\n  private validateAbilityState(abilityRunningInfo: AbilityRunningInfo, testCaseName: string): void {\n    const uid = abilityRunningInfo.uid;\n    const abilityState = abilityRunningInfo.abilityState;\n    \n    // Add validation logic here based on uid and abilityState\n    console.log(`Test Case: ${testCaseName}, UID: ${uid}, AbilityState: ${abilityState}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `bundleName` property of `AbilityDelegatorArgs` to identify a specific ability, then triggers the `onConfigurationUpdate` method of the `Ability` class to dynamically update the ability's configuration based on the provided parameters from `AbilityDelegatorArgs`.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegatorArgs, Ability} from '@kit.AbilityKit';\n\nexport function updateAbilityConfiguration(args: AbilityDelegatorArgs, ability: Ability): AbilityResult {\n  if (args.bundleName) {\n    ability.onConfigurationUpdate(args.parameters);\n    return {\n      resultCode: 0,\n      want: undefined\n    };\n  }\n  return {\n    resultCode: -1,\n    want: undefined\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes an `AbilityDelegatorArgs` object with `testCaseNames` and `parameters`, then uses these parameters to simulate a test scenario where the `onMemoryLevel` method of the `Ability` class is called to handle memory pressure, and finally returns an `AbilityResult` object with the `resultCode` and `want` properties set based on the outcome of the memory test.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegatorArgs, Ability} from '@kit.AbilityKit';\n\nexport function simulateMemoryTest(testCaseNames: string[], parameters: {[key: string]: string}): AbilityResult {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    testCaseNames: testCaseNames,\n    parameters: parameters\n  };\n\n  const ability = new Ability();\n  const memoryLevel = 1; // Simulating memory pressure level\n  ability.onMemoryLevel(memoryLevel);\n\n  const result: AbilityResult = {\n    resultCode: 0,\n    want: {\n      bundleName: delegatorArgs.bundleName,\n      parameters: delegatorArgs.parameters\n    }\n  };\n\n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes an `AbilityResult` object with a `resultCode` and `want` property, checks if the `resultCode` indicates a successful operation, and if so, uses the `want` property to construct a new `AbilityDelegatorArgs` object with `bundleName` and `parameters` derived from the `want` property, then passes this object to the `onConfigurationUpdate` method of the `Ability` class to reconfigure the ability.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegatorArgs, Ability} from '@kit.AbilityKit';\n\nexport function handleAbilityResult(abilityResult: AbilityResult, ability: Ability): void {\n  if (abilityResult.resultCode === 0) {\n    const want = abilityResult.want;\n    const abilityDelegatorArgs: AbilityDelegatorArgs = {\n      bundleName: want.bundleName,\n      parameters: want.parameters,\n      testCaseNames: [],\n      testRunnerClassName: ''\n    };\n    ability.onConfigurationUpdate(abilityDelegatorArgs);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `bundleName` property of `AbilityDelegatorArgs` to retrieve the bundle name of a test case, then uses this bundle name to query the `AbilityInfo` object using its `bundleName` property. Finally, check if the ability is enabled by accessing the `enabled` property of `AbilityInfo` and return the result.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function checkAbilityEnabled(args: AbilityDelegatorArgs, abilityInfo: AbilityInfo): boolean {\n  const bundleName = args.bundleName;\n  if (abilityInfo.bundleName === bundleName) {\n    return abilityInfo.enabled;\n  }\n  return false;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes an `AbilityInfo` object and uses its `launchType` property to determine the launch type of the ability. Then, based on the launch type, use the `LaunchReason` enum from `AbilityConstant` to log the appropriate launch reason (e.g., NORMAL, START_ABILITIES, or CONTINUATION).",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function logLaunchReason(abilityInfo: AbilityInfo): void {\n  const launchType = abilityInfo.launchType;\n  let launchReason: AbilityConstant.LaunchReason;\n\n  switch (launchType) {\n    case 0: // STANDARD\n    case 1: // SINGLETON\n      launchReason = AbilityConstant.LaunchReason.NORMAL;\n      break;\n    case 2: // SPECIFIED\n      launchReason = AbilityConstant.LaunchReason.START_ABILITIES;\n      break;\n    case 3: // CONTINUATION\n      launchReason = AbilityConstant.LaunchReason.CONTINUATION;\n      break;\n    default:\n      launchReason = AbilityConstant.LaunchReason.NORMAL;\n      break;\n  }\n\n  console.log(`Launch reason: ${launchReason}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `testCaseNames` property of `AbilityDelegatorArgs` to get the list of test cases, then for each test case, retrieves the corresponding `AbilityInfo` object using the `bundleName` property. Check the `supportWindowModes` property of `AbilityInfo` to ensure the ability supports the desired window mode (e.g., FULLSCREEN or FLOATING) using the `WindowMode` enum from `AbilityConstant`.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function checkWindowModeSupport(abilityDelegatorArgs: AbilityDelegatorArgs, desiredWindowMode: AbilityConstant.WindowMode): boolean {\n  if (!abilityDelegatorArgs.testCaseNames || abilityDelegatorArgs.testCaseNames.length === 0) {\n    return false;\n  }\n\n  for (const testCaseName of abilityDelegatorArgs.testCaseNames) {\n    const abilityInfo: AbilityInfo | undefined = getAbilityInfo(abilityDelegatorArgs.bundleName, testCaseName);\n    if (!abilityInfo || !abilityInfo.supportWindowModes) {\n      return false;\n    }\n\n    if (!abilityInfo.supportWindowModes.includes(desiredWindowMode)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getAbilityInfo(bundleName: string, abilityName: string): AbilityInfo | undefined {\n  // Implementation to retrieve AbilityInfo based on bundleName and abilityName\n  // This is a placeholder as the actual implementation depends on the specific API usage\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onAbilityCreate` method of `AbilityLifecycleCallback` to initialize an `Ability` instance, and then accesses the `bundleName` property of `AbilityInfo` to log the bundle name of the newly created ability.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, Ability, AbilityInfo} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(ability: Ability): void {\n    const abilityInfo: AbilityInfo = ability.context.abilityInfo;\n    console.log(`Bundle name of the newly created ability: ${abilityInfo.bundleName}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onWindowStageCreate` method of `AbilityLifecycleCallback` to set up a window stage for an `Ability`, and then uses the `onConfigurationUpdate` method of `Ability` to handle configuration changes (e.g., screen rotation) for that window stage.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, Ability, AbilityInfo} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onWindowStageCreate(ability: Ability, windowStage: window.WindowStage): void {\n    // Setup window stage for the ability\n    console.log('onWindowStageCreate');\n  }\n}\n\nexport class MyAbility extends Ability {\n  onConfigurationUpdate(config: Configuration): void {\n    // Handle configuration changes (e.g., screen rotation)\n    console.log('onConfigurationUpdate');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature that uses the `onAbilityForeground` method of `AbilityLifecycleCallback` to detect when an `Ability` comes to the foreground, and then checks the `isVisible` property of `AbilityInfo` to determine if the ability should be displayed or hidden based on its visibility status.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, Ability, AbilityInfo} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(ability: Ability): void {\n    const abilityInfo: AbilityInfo = ability.context.abilityInfo;\n    if (abilityInfo.isVisible) {\n      // Ability should be displayed\n      console.log('Ability is visible and should be displayed');\n    } else {\n      // Ability should be hidden\n      console.log('Ability is not visible and should be hidden');\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onAbilityCreate` method of `AbilityLifecycleCallback` to initialize a new ability and then uses the `onWindowStageCreate` method of the same API to set up the window stage, ensuring the ability is ready for user interaction.",
    "input": "",
    "output": "import { AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(ability): void {\n    // Initialize the ability here\n  }\n\n  onWindowStageCreate(ability, windowStage): void {\n    // Set up the window stage here\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onAbilityForeground` method of `AbilityLifecycleCallback` to bring an ability to the foreground and then immediately calls the `onWindowStageActive` method to ensure the window stage is fully interactive and visible to the user.",
    "input": "",
    "output": "import { AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(): void {\n    // Bring the ability to the foreground\n    super.onAbilityForeground();\n    // Ensure the window stage is fully interactive and visible\n    this.onWindowStageActive();\n  }\n\n  onWindowStageActive(): void {\n    // Implementation to ensure window stage is active\n    super.onWindowStageActive();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that first uses the `onAbilityDestroy` method of `AbilityLifecycleCallback` to clean up resources when an ability is destroyed, followed by the `onWindowStageDestroy` method to ensure the window stage is properly terminated and all associated resources are released.",
    "input": "",
    "output": "import { AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityDestroy(ability) {\n    // Clean up resources when ability is destroyed\n    super.onAbilityDestroy(ability);\n  }\n\n  onWindowStageDestroy(ability) {\n    // Ensure window stage is properly terminated and resources are released\n    super.onWindowStageDestroy(ability);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` to track the lifecycle of a specific ability (using `abilityName` and `moduleName` properties), then uses `addAbilityMonitor` method of `AbilityDelegator` to register the monitor, and finally checks the ability's state using `getAbilityState` method of `AbilityDelegator` to verify if the ability is in the expected state.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function monitorAbilityLifecycle(\n  abilityDelegator: AbilityDelegator,\n  abilityName: string,\n  moduleName: string,\n  expectedState: number\n): boolean {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityCreate: () => {\n      console.log(`Ability ${abilityName} created`);\n    },\n    onAbilityDestroy: () => {\n      console.log(`Ability ${abilityName} destroyed`);\n    },\n    onAbilityForeground: () => {\n      console.log(`Ability ${abilityName} foreground`);\n    },\n    onAbilityBackground: () => {\n      console.log(`Ability ${abilityName} background`);\n    },\n    onWindowStageCreate: () => {\n      console.log(`Ability ${abilityName} window stage created`);\n    },\n    onWindowStageDestroy: () => {\n      console.log(`Ability ${abilityName} window stage destroyed`);\n    },\n    onWindowStageRestore: () => {\n      console.log(`Ability ${abilityName} window stage restored`);\n    }\n  };\n\n  abilityDelegator.addAbilityMonitor(monitor);\n  const currentState = abilityDelegator.getAbilityState(abilityName, moduleName);\n  return currentState === expectedState;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `startAbility` method of `AbilityDelegator` to launch a specific ability, then creates an `AbilityMonitor` with `onAbilityForeground` callback to detect when the ability comes to the foreground, and uses `waitAbilityMonitor` method of `AbilityDelegator` to wait for the monitor to trigger, confirming the ability's foreground state.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function launchAndMonitorAbility(delegator: AbilityDelegator, abilityName: string, moduleName: string): void {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.abilityName = abilityName;\n  monitor.moduleName = moduleName;\n  \n  monitor.onAbilityForeground = (ability) => {\n    console.log(`Ability ${abilityName} is in foreground`);\n  };\n  \n  delegator.addAbilityMonitor(monitor);\n  delegator.startAbility({\n    bundleName: moduleName,\n    abilityName: abilityName\n  });\n  \n  delegator.waitAbilityMonitor(monitor);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` with `onAbilityDestroy` callback to detect when an ability is destroyed, then uses `removeAbilityMonitor` method of `AbilityDelegator` to unregister the monitor after a specific event, and finally uses `printSync` method of `AbilityDelegator` to log the monitor's removal status for debugging purposes.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function createAndRemoveAbilityMonitor(abilityDelegator: AbilityDelegator, abilityName: string, eventCallback: () => void): void {\n  const abilityMonitor: AbilityMonitor = {\n    abilityName: abilityName,\n    onAbilityDestroy: () => {\n      eventCallback();\n      const isRemoved = abilityDelegator.removeAbilityMonitor(abilityMonitor);\n      abilityDelegator.printSync(`AbilityMonitor removal status: ${isRemoved}`);\n    }\n  };\n\n  abilityDelegator.addAbilityMonitor(abilityMonitor);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onAbilityCreate` and `onAbilityDestroy` methods of `AbilityMonitor` to track the lifecycle events of an `Ability`, and then triggers the `onMemoryLevel` method of the `Ability` when the monitored ability is destroyed to handle memory cleanup.",
    "input": "",
    "output": "import {AbilityMonitor, Ability} from '@kit.AbilityKit';\n\nexport class MyAbilityMonitor extends AbilityMonitor {\n  private monitoredAbility: Ability | null = null;\n\n  onAbilityCreate(ability: Ability): void {\n    this.monitoredAbility = ability;\n  }\n\n  onAbilityDestroy(ability: Ability): void {\n    if (this.monitoredAbility === ability) {\n      ability.onMemoryLevel(0); // Assuming 0 is the memory level for cleanup\n      this.monitoredAbility = null;\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `abilityName` property of `AbilityMonitor` to identify a specific ability, and then calls the `onConfigurationUpdate` method of the `Ability` to apply configuration changes when the ability is brought to the foreground using the `onAbilityForeground` method of `AbilityMonitor`.",
    "input": "",
    "output": "import {AbilityMonitor, Ability} from '@kit.AbilityKit';\n\nexport function setupAbilityMonitor(abilityName: string, config: object): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.abilityName = abilityName;\n\n  monitor.onAbilityForeground = (ability: Ability) => {\n    ability.onConfigurationUpdate(config);\n  };\n\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that monitors an ability's window stage events using the `onWindowStageCreate` and `onWindowStageDestroy` methods of `AbilityMonitor`, and then invokes the `onMemoryLevel` method of the `Ability` to adjust memory usage based on the window stage lifecycle events.",
    "input": "",
    "output": "import {AbilityMonitor, Ability} from '@kit.AbilityKit';\n\nexport class MyAbilityMonitor extends AbilityMonitor {\n  private monitoredAbility: Ability | null = null;\n\n  constructor() {\n    super();\n    this.onWindowStageCreate = (windowStage) => {\n      if (this.monitoredAbility) {\n        this.monitoredAbility.onMemoryLevel(0);\n      }\n    };\n    this.onWindowStageDestroy = () => {\n      if (this.monitoredAbility) {\n        this.monitoredAbility.onMemoryLevel(1);\n      }\n    };\n  }\n\n  setMonitoredAbility(ability: Ability): void {\n    this.monitoredAbility = ability;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityLifecycleCallback.onAbilityCreate` to initialize an ability and then checks its initial state using `AbilityConstant.StateType` to ensure it transitions to the correct state (e.g., `StateType.READY`). The function must log an error if the state is not as expected.",
    "input": "",
    "output": "import {AbilityConstant, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private expectedState: AbilityConstant.StateType = AbilityConstant.StateType.READY;\n\n  onAbilityCreate(ability): void {\n    console.log('Ability created');\n    this.checkAbilityState(ability);\n  }\n\n  private checkAbilityState(ability): void {\n    const currentState = ability.getState();\n    if (currentState !== this.expectedState) {\n      console.error(`Error: Ability state is ${currentState}, expected ${this.expectedState}`);\n    } else {\n      console.log(`Ability state is ${currentState} as expected`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that monitors memory levels using `AbilityConstant.MemoryLevel` during the ability's lifecycle. When the memory level reaches `MemoryLevel.CRITICAL`, trigger `AbilityLifecycleCallback.onAbilityBackground` to gracefully release resources and log the event. The function must also handle the transition back to normal memory levels.",
    "input": "",
    "output": "import {AbilityConstant, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MemoryMonitorCallback extends AbilityLifecycleCallback {\n  private currentMemoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel.NORMAL;\n\n  onMemoryLevelChange(newLevel: AbilityConstant.MemoryLevel): void {\n    if (newLevel === AbilityConstant.MemoryLevel.CRITICAL && this.currentMemoryLevel !== AbilityConstant.MemoryLevel.CRITICAL) {\n      this.onAbilityBackground();\n      console.log('Memory level reached CRITICAL, resources released.');\n    } else if (newLevel !== AbilityConstant.MemoryLevel.CRITICAL && this.currentMemoryLevel === AbilityConstant.MemoryLevel.CRITICAL) {\n      console.log('Memory level returned to normal.');\n    }\n    this.currentMemoryLevel = newLevel;\n  }\n\n  onAbilityBackground(): void {\n    // Gracefully release resources here\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityLifecycleCallback.onWindowStageCreate` to set up a window stage and then checks the window mode using `AbilityConstant.WindowMode`. If the window mode is `WindowMode.FULLSCREEN`, adjust the UI layout accordingly. The function must also handle window stage destruction via `AbilityLifecycleCallback.onWindowStageDestroy` to clean up resources.",
    "input": "",
    "output": "import { AbilityConstant, AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private windowStage: any;\n\n  onWindowStageCreate(windowStage: any): void {\n    this.windowStage = windowStage;\n    const windowMode = windowStage.getWindowMode();\n    if (windowMode === AbilityConstant.WindowMode.FULLSCREEN) {\n      this.adjustUILayoutForFullscreen();\n    }\n  }\n\n  onWindowStageDestroy(): void {\n    this.cleanupResources();\n  }\n\n  private adjustUILayoutForFullscreen(): void {\n    // Adjust UI layout for fullscreen mode\n  }\n\n  private cleanupResources(): void {\n    // Clean up resources\n    this.windowStage = undefined;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `pid` and `processName` from an `AbilityRunningInfo` object, then uses these values to filter and display all running abilities with the same `processName` and a `pid` greater than a specified threshold.",
    "input": "",
    "output": "import { AbilityRunningInfo } from '@kit.AbilityKit';\n\nexport function filterRunningAbilities(abilities: AbilityRunningInfo[], threshold: number): AbilityRunningInfo[] {\n  if (abilities.length === 0) {\n    return [];\n  }\n\n  const { pid, processName } = abilities[0];\n  return abilities.filter((ability: AbilityRunningInfo) => {\n    return ability.processName === processName && ability.pid > threshold;\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that compares the `startTime` of two `AbilityRunningInfo` objects to determine which ability started earlier, and then uses the `uid` property of the earlier ability to perform a specific action (e.g., logging or notification).",
    "input": "",
    "output": "import {AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function compareAndLogEarlierAbility(ability1: AbilityRunningInfo, ability2: AbilityRunningInfo): void {\n  if (ability1.startTime < ability2.startTime) {\n    console.log(`Ability with uid ${ability1.uid} started earlier.`);\n  } else if (ability1.startTime > ability2.startTime) {\n    console.log(`Ability with uid ${ability2.uid} started earlier.`);\n  } else {\n    console.log('Both abilities started at the same time.');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that collects the `abilityState` and `uid` from multiple `AbilityRunningInfo` objects, groups them by `abilityState`, and then processes each group (e.g., counting or sorting) based on the `uid` values.",
    "input": "",
    "output": "import {AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function processAbilityRunningInfo(infos: AbilityRunningInfo[]): Map<string, number[]> {\n  const groupedByState = new Map<string, number[]>();\n\n  for (const info of infos) {\n    const state = info.abilityState;\n    const uid = info.uid;\n\n    if (!groupedByState.has(state)) {\n      groupedByState.set(state, []);\n    }\n\n    groupedByState.get(state)?.push(uid);\n  }\n\n  // Process each group (e.g., count or sort)\n  for (const [state, uids] of groupedByState) {\n    uids.sort((a, b) => a - b);\n  }\n\n  return groupedByState;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `pid` and `processName` from an `AbilityRunningInfo` object, then uses these values to construct a `want` property in an `AbilityResult` object, and finally returns the `AbilityResult` object with the constructed `want` and a predefined `resultCode`.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityResult} from '@kit.AbilityKit';\n\nexport function constructAbilityResult(abilityInfo: AbilityRunningInfo, resultCode: number): AbilityResult {\n  const want = {\n    pid: abilityInfo.pid,\n    processName: abilityInfo.processName\n  };\n  \n  const abilityResult: AbilityResult = {\n    resultCode: resultCode,\n    want: want\n  };\n  \n  return abilityResult;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes an array of `AbilityRunningInfo` objects, filters them based on their `abilityState`, collects the `uid` of each filtered object, and then constructs an `AbilityResult` object where the `want` property contains the collected UIDs and the `resultCode` indicates the count of filtered abilities.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityResult} from '@kit.AbilityKit';\n\nexport function filterAndCollectAbilityInfo(infos: AbilityRunningInfo[], state: number): AbilityResult {\n  const filteredInfos = infos.filter((info) => info.abilityState === state);\n  const uids = filteredInfos.map((info) => info.uid);\n  const result: AbilityResult = {\n    resultCode: filteredInfos.length,\n    want: {\n      uids: uids\n    }\n  };\n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that compares the `startTime` of two `AbilityRunningInfo` objects, determines which ability started earlier, and returns an `AbilityResult` object where the `want` property contains the `ability` name of the earlier-started ability and the `resultCode` indicates the time difference in milliseconds.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityResult} from '@kit.AbilityKit';\n\nexport function compareStartTime(abilityInfo1: AbilityRunningInfo, abilityInfo2: AbilityRunningInfo): AbilityResult {\n  const timeDiff = abilityInfo1.startTime - abilityInfo2.startTime;\n  const result = new AbilityResult();\n  \n  if (timeDiff < 0) {\n    result.want = { ability: abilityInfo1.ability };\n    result.resultCode = -timeDiff;\n  } else {\n    result.want = { ability: abilityInfo2.ability };\n    result.resultCode = timeDiff;\n  }\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "",
    "input": "",
    "output": "",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `resultCode` property of `AbilityResult` to check if an ability execution was successful (resultCode === 0). If successful, extract the `want` property from `AbilityResult` and use it to determine the `LaunchReason` enum value from `AbilityConstant` to log the reason the ability was launched.",
    "input": "",
    "output": "import {AbilityResult, AbilityConstant} from '@kit.AbilityKit';\n\nexport function checkAbilityResult(result: AbilityResult): void {\n  if (result.resultCode === 0) {\n    const want = result.want;\n    const launchReason: AbilityConstant.LaunchReason = want?.parameters?.launchReason;\n    console.log(`Ability launched with reason: ${launchReason}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `MemoryLevel` enum from `AbilityConstant` to assess the current memory state of the device. Based on the memory level, use the `resultCode` property of `AbilityResult` to return a custom status code indicating whether the ability can proceed (e.g., 0 for normal, 1 for low memory warning).",
    "input": "",
    "output": "import {AbilityResult, AbilityConstant} from '@kit.AbilityKit';\n\nexport function checkMemoryState(): AbilityResult {\n  const memoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel;\n  let result: AbilityResult = { resultCode: 0 };\n  \n  switch (memoryLevel) {\n    case AbilityConstant.MemoryLevel.MEMORY_LEVEL_LOW:\n      result.resultCode = 1;\n      break;\n    case AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE:\n    case AbilityConstant.MemoryLevel.MEMORY_LEVEL_NORMAL:\n    default:\n      result.resultCode = 0;\n      break;\n  }\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `StateType` enum from `AbilityConstant` to determine the current state of an ability. Depending on the state, construct a new `AbilityResult` object where the `resultCode` is set based on the `OnContinueResult` or `OnSaveResult` enum values from `AbilityConstant` to handle ability continuation or termination scenarios.",
    "input": "",
    "output": "import {AbilityResult, AbilityConstant} from '@kit.AbilityKit';\n\nexport function determineAbilityResult(state: AbilityConstant.StateType): AbilityResult {\n  const abilityResult: AbilityResult = new AbilityResult();\n  \n  switch (state) {\n    case AbilityConstant.StateType.INITIAL:\n      abilityResult.resultCode = AbilityConstant.OnContinueResult.AGREE;\n      break;\n    case AbilityConstant.StateType.READY:\n      abilityResult.resultCode = AbilityConstant.OnContinueResult.REJECT;\n      break;\n    case AbilityConstant.StateType.FOREGROUND:\n      abilityResult.resultCode = AbilityConstant.OnSaveResult.SAVE_OK;\n      break;\n    case AbilityConstant.StateType.BACKGROUND:\n      abilityResult.resultCode = AbilityConstant.OnSaveResult.SAVE_FAILED;\n      break;\n    case AbilityConstant.StateType.TERMINATING:\n      abilityResult.resultCode = AbilityConstant.PrepareTermination.YES;\n      break;\n    default:\n      abilityResult.resultCode = AbilityConstant.OnContinueResult.AGREE;\n      break;\n  }\n  \n  return abilityResult;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` instance to track the lifecycle of a specific ability (using `abilityName` and `moduleName` properties) and registers it with an `AbilityLifecycleCallback`. The function should use `onAbilityCreate` from `AbilityMonitor` to detect when the ability is created and then trigger `onWindowStageActive` from `AbilityLifecycleCallback` to perform an action when the ability's window stage becomes active.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport function createAndRegisterAbilityMonitor(abilityName: string, moduleName: string): void {\n  const abilityMonitor: AbilityMonitor = new AbilityMonitor();\n  abilityMonitor.abilityName = abilityName;\n  abilityMonitor.moduleName = moduleName;\n\n  const abilityLifecycleCallback: AbilityLifecycleCallback = {\n    onWindowStageActive: () => {\n      // Perform action when window stage becomes active\n    }\n  };\n\n  abilityMonitor.onAbilityCreate = (ability) => {\n    ability.registerAbilityLifecycleCallback(abilityLifecycleCallback);\n  };\n\n  // Register the AbilityMonitor\n  // Note: The actual registration method depends on the context (e.g., application context)\n  // This is a placeholder as the registration API is not fully specified in the question\n  // For example: applicationContext.registerAbilityMonitor(abilityMonitor);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature where an `AbilityMonitor` instance uses `onAbilityForeground` to detect when an ability comes to the foreground and then invokes `onAbilityContinue` from `AbilityLifecycleCallback` to handle the continuation logic. The function should also use `onAbilityBackground` from both APIs to ensure proper cleanup when the ability moves to the background.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MyAbilityMonitor extends AbilityMonitor {\n  private lifecycleCallback: AbilityLifecycleCallback = {\n    onAbilityContinue: (ability) => {\n      // Handle continuation logic here\n    },\n    onAbilityBackground: (ability) => {\n      // Handle cleanup when ability moves to background\n    },\n    onAbilityForeground: (ability) => {\n      // Handle logic when ability comes to foreground\n    },\n    onAbilityCreate: (ability) => {\n      // Handle ability creation\n    },\n    onAbilityDestroy: (ability) => {\n      // Handle ability destruction\n    },\n    onWindowStageCreate: (ability) => {\n      // Handle window stage creation\n    },\n    onWindowStageDestroy: (ability) => {\n      // Handle window stage destruction\n    },\n    onWindowStageRestore: (ability) => {\n      // Handle window stage restoration\n    },\n    onWindowStageActive: (ability) => {\n      // Handle window stage active\n    },\n    onWindowStageInactive: (ability) => {\n      // Handle window stage inactive\n    }\n  };\n\n  constructor() {\n    super();\n    this.onAbilityForeground = (ability) => {\n      this.lifecycleCallback.onAbilityForeground(ability);\n      this.lifecycleCallback.onAbilityContinue(ability);\n    };\n    this.onAbilityBackground = (ability) => {\n      this.lifecycleCallback.onAbilityBackground(ability);\n    };\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that sets up an `AbilityMonitor` to monitor an ability's window stage events (using `onWindowStageCreate`, `onWindowStageDestroy`, and `onWindowStageRestore`) and passes these events to an `AbilityLifecycleCallback` instance. The callback should use `onWindowStageInactive` and `onWindowStageActive` to manage resources based on the window stage's active state.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onWindowStageActive(): void {\n    // Manage resources when window stage becomes active\n  }\n\n  onWindowStageInactive(): void {\n    // Manage resources when window stage becomes inactive\n  }\n\n  onWindowStageCreate(): void {\n    // Handle window stage creation\n  }\n\n  onWindowStageDestroy(): void {\n    // Handle window stage destruction\n  }\n\n  onWindowStageRestore(): void {\n    // Handle window stage restoration\n  }\n}\n\nexport function setupAbilityMonitor(callback: MyAbilityLifecycleCallback): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  \n  monitor.onWindowStageCreate = (): void => {\n    callback.onWindowStageCreate();\n  };\n\n  monitor.onWindowStageDestroy = (): void => {\n    callback.onWindowStageDestroy();\n  };\n\n  monitor.onWindowStageRestore = (): void => {\n    callback.onWindowStageRestore();\n  };\n\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch an ability, then uses `AbilityInfo.bundleName` and `AbilityInfo.name` to verify the launched ability's identity, and finally checks its state using `AbilityDelegator.getAbilityState`.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityInfo, Ability} from '@kit.AbilityKit';\n\nexport async function verifyLaunchedAbility(delegator: AbilityDelegator, want: Want, expectedBundleName: string, expectedAbilityName: string): Promise<boolean> {\n  try {\n    await delegator.startAbility(want);\n    const ability = delegator.getCurrentTopAbility();\n    if (!ability) {\n      return false;\n    }\n    const abilityInfo: AbilityInfo = ability.context.abilityInfo;\n    if (abilityInfo.bundleName !== expectedBundleName || abilityInfo.name !== expectedAbilityName) {\n      return false;\n    }\n    const state = delegator.getAbilityState(ability);\n    return state === AbilityState.ACTIVE || state === AbilityState.INACTIVE;\n  } catch (error) {\n    return false;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the current top ability using `AbilityDelegator.getCurrentTopAbility`, extracts its `AbilityInfo.moduleName` and `AbilityInfo.launchType`, and then uses these values to monitor the ability's lifecycle events with `AbilityDelegator.addAbilityMonitor`.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityInfo, Ability} from '@kit.AbilityKit';\n\nexport function monitorTopAbilityLifecycle(delegator: AbilityDelegator): void {\n  const topAbility: Ability | null = delegator.getCurrentTopAbility();\n  if (topAbility === null) {\n    return;\n  }\n  const abilityInfo: AbilityInfo = topAbility.context.abilityInfo;\n  const moduleName: string = abilityInfo.moduleName;\n  const launchType: number = abilityInfo.launchType;\n  \n  const monitor = {\n    moduleName: moduleName,\n    launchType: launchType,\n    onAbilityCreate: (ability: Ability) => {\n      console.log(`Ability created: ${ability.context.abilityInfo.name}`);\n    },\n    onAbilityForeground: (ability: Ability) => {\n      console.log(`Ability foreground: ${ability.context.abilityInfo.name}`);\n    },\n    onAbilityBackground: (ability: Ability) => {\n      console.log(`Ability background: ${ability.context.abilityInfo.name}`);\n    },\n    onAbilityDestroy: (ability: Ability) => {\n      console.log(`Ability destroyed: ${ability.context.abilityInfo.name}`);\n    }\n  };\n  \n  delegator.addAbilityMonitor(monitor);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.executeShellCommand` to fetch a list of running abilities, parses the output to extract ability names, and then uses `AbilityInfo.type` and `AbilityInfo.supportWindowModes` to filter and display only those abilities that support specific window modes.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityInfo, Ability} from '@kit.AbilityKit';\n\nexport function filterAbilitiesByWindowMode(delegator: AbilityDelegator, windowModes: number[]): Promise<string[]> {\n  return new Promise((resolve, reject) => {\n    delegator.executeShellCommand('aa dump', (err: Error, data: string) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      const abilityLines = data.split('\\n').filter(line => line.includes('abilityName'));\n      const abilityNames: string[] = [];\n\n      abilityLines.forEach(line => {\n        const match = line.match(/abilityName=([^\\s]+)/);\n        if (match && match[1]) {\n          abilityNames.push(match[1]);\n        }\n      });\n\n      const filteredAbilities: string[] = [];\n\n      abilityNames.forEach(name => {\n        try {\n          const abilityInfo: AbilityInfo = delegator.getAbilityInfo(name);\n          if (abilityInfo && abilityInfo.supportWindowModes) {\n            const supportedModes = abilityInfo.supportWindowModes;\n            const hasMatchingMode = windowModes.some(mode => supportedModes.includes(mode));\n            if (hasMatchingMode) {\n              filteredAbilities.push(name);\n            }\n          }\n        } catch (e) {\n          console.error(`Error getting ability info for ${name}: ${e}`);\n        }\n      });\n\n      resolve(filteredAbilities);\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch a new ability, then monitors its lifecycle state changes by registering an `AbilityLifecycleCallback` with `AbilityDelegator.addAbilityMonitor`. The callback should implement `onAbilityCreate` and `onAbilityForeground` to log when the ability is created and brought to the foreground.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegator, Ability} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(ability: Ability): void {\n    console.log(`Ability created: ${ability.context.abilityInfo?.name}`);\n  }\n\n  onAbilityForeground(ability: Ability): void {\n    console.log(`Ability brought to foreground: ${ability.context.abilityInfo?.name}`);\n  }\n}\n\nexport function startAbilityAndMonitorLifecycle(delegator: AbilityDelegator, want: Want): void {\n  const callback = new MyAbilityLifecycleCallback();\n  const monitor = {\n    abilityLifecycleCallback: callback\n  };\n\n  delegator.addAbilityMonitor(monitor);\n  delegator.startAbility(want);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test scenario where `AbilityDelegator.doAbilityForeground` is called to simulate bringing an ability to the foreground, and then use `AbilityDelegator.getAbilityState` to verify the current state of the ability. Additionally, implement `Ability.onConfigurationUpdate` in the ability to handle configuration changes and log them.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegator, Ability} from '@kit.AbilityKit';\n\nexport class TestAbility extends Ability {\n  onConfigurationUpdate(newConfig: any) {\n    console.log('Configuration updated:', newConfig);\n  }\n}\n\nexport class TestAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(ability: Ability): void {\n    console.log('Ability brought to foreground:', ability);\n  }\n}\n\nexport async function testAbilityForeground(delegator: AbilityDelegator, ability: TestAbility): Promise<void> {\n  await delegator.doAbilityForeground(ability);\n  const state = delegator.getAbilityState(ability);\n  console.log('Current ability state:', state);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses `AbilityDelegator.waitAbilityMonitor` to wait for an ability to reach the `DESTROYED` state, then triggers `AbilityLifecycleCallback.onAbilityDestroy` to clean up resources. The function should also use `AbilityDelegator.executeShellCommand` to fetch system logs related to the ability's destruction.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegator, Ability} from '@kit.AbilityKit';\n\nexport class AbilityDestroyMonitor {\n  private abilityDelegator: AbilityDelegator;\n  private abilityMonitor: AbilityMonitor;\n  private lifecycleCallback: AbilityLifecycleCallback;\n\n  constructor(abilityDelegator: AbilityDelegator) {\n    this.abilityDelegator = abilityDelegator;\n    this.lifecycleCallback = {\n      onAbilityDestroy: (ability: Ability) => {\n        this.cleanupResources(ability);\n      }\n    };\n    this.abilityMonitor = {\n      abilityName: '',\n      lifecycleCallback: this.lifecycleCallback\n    };\n  }\n\n  public async waitForAbilityDestroy(abilityName: string): Promise<void> {\n    this.abilityMonitor.abilityName = abilityName;\n    await this.abilityDelegator.waitAbilityMonitor(this.abilityMonitor);\n  }\n\n  private cleanupResources(ability: Ability): void {\n    // Cleanup resources logic here\n  }\n\n  public async fetchDestructionLogs(abilityName: string): Promise<string> {\n    const command = `logcat -d | grep ${abilityName} | grep DESTROYED`;\n    const result = await this.abilityDelegator.executeShellCommand(command);\n    return result;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` instance to monitor an ability with a specific `abilityName` and `moduleName`. Use the `onAbilityCreate` callback of `AbilityMonitor` to check if the ability's launch reason (from `AbilityConstant.LaunchReason`) is `COLD_START`. If true, pass the ability's bundle name to an `AbilityDelegatorArgs` instance's `bundleName` property for testing.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityConstant, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function createAbilityMonitorForTesting(abilityName: string, moduleName: string): AbilityMonitor {\n  const abilityMonitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityCreate: (ability) => {\n      if (ability.launchReason === AbilityConstant.LaunchReason.COLD_START) {\n        const abilityDelegatorArgs: AbilityDelegatorArgs = {\n          bundleName: ability.bundleName\n        };\n      }\n    }\n  };\n  return abilityMonitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes an `AbilityMonitor` to track an ability's lifecycle events. Use the `onAbilityForeground` callback to detect when the ability enters the foreground, then check its `WindowMode` (from `AbilityConstant.WindowMode`). If the mode is `FULLSCREEN`, update the `parameters` property of an `AbilityDelegatorArgs` instance with a custom flag indicating fullscreen mode for test verification.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityConstant, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function initializeAbilityMonitor(abilityDelegatorArgs: AbilityDelegatorArgs): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  \n  monitor.onAbilityForeground = (data) => {\n    if (data.windowMode === AbilityConstant.WindowMode.FULLSCREEN) {\n      abilityDelegatorArgs.parameters = {\n        ...abilityDelegatorArgs.parameters,\n        isFullscreen: true\n      };\n    }\n  };\n  \n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that sets up an `AbilityMonitor` to observe an ability's state changes. Use the `onWindowStageDestroy` callback to capture the ability's `LastExitReason` (from `AbilityConstant.LastExitReason`). If the reason is `ABILITY_NOT_RESPONDING`, dynamically add the ability's name to the `testCaseNames` array in an `AbilityDelegatorArgs` instance for further debugging.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityConstant, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function setupAbilityMonitor(abilityName: string, delegatorArgs: AbilityDelegatorArgs): AbilityMonitor {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    onWindowStageDestroy: (ability) => {\n      const lastExitReason = ability.context.lastExitReason;\n      if (lastExitReason === AbilityConstant.LastExitReason.ABILITY_NOT_RESPONDING) {\n        if (!delegatorArgs.testCaseNames) {\n          delegatorArgs.testCaseNames = [];\n        }\n        delegatorArgs.testCaseNames.push(abilityName);\n      }\n    }\n  };\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `startAbility` method of `AbilityDelegator` to launch an ability, then uses the `getAbilityState` method of `AbilityDelegator` to check the state of the launched ability, and finally uses the `resultCode` property of `AbilityResult` to verify if the ability was successfully started.",
    "input": "",
    "output": "import { AbilityResult, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function startAndCheckAbility(abilityDelegator: AbilityDelegator, want: Want): boolean {\n  const result: AbilityResult = abilityDelegator.startAbility(want);\n  if (result.resultCode !== 0) {\n    return false;\n  }\n\n  const state = abilityDelegator.getAbilityState(want);\n  return state === 2; // 2 represents the active state\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `addAbilityMonitor` method of `AbilityDelegator` to set up a monitor for an ability, then uses the `waitAbilityMonitor` method of `AbilityDelegator` to wait for the ability to be launched, and finally uses the `want` property of `AbilityResult` to extract and return the intent data passed to the ability.",
    "input": "",
    "output": "import { AbilityResult, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function monitorAndExtractIntent(abilityDelegator: AbilityDelegator, abilityName: string): Promise<object> {\n  return new Promise((resolve, reject) => {\n    const monitor = {\n      abilityName: abilityName,\n      onAbilityCreate: (ability) => {\n        console.log(`Ability ${abilityName} created`);\n      }\n    };\n\n    abilityDelegator.addAbilityMonitor(monitor, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      abilityDelegator.waitAbilityMonitor(monitor, (err, abilityResult: AbilityResult) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        if (abilityResult && abilityResult.want) {\n          resolve(abilityResult.want);\n        } else {\n          reject(new Error('No intent data found'));\n        }\n      });\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `executeShellCommand` method of `AbilityDelegator` to run a shell command, then uses the `printSync` method of `AbilityDelegator` to log the command output, and finally uses the `resultCode` property of `AbilityResult` to determine if the command execution was successful.",
    "input": "",
    "output": "import { AbilityResult, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function executeAndLogShellCommand(delegator: AbilityDelegator, command: string): AbilityResult {\n  const result: AbilityResult = delegator.executeShellCommand(command);\n  delegator.printSync(result.resultCode.toString());\n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onMemoryLevel` method of `Ability` to monitor memory level changes and then uses the `MemoryLevel` enum from `AbilityConstant` to determine if the current memory level is critical. If it is, trigger the `onAbilityBackground` callback of `AbilityMonitor` to move the ability to the background.",
    "input": "",
    "output": "import {Ability, AbilityConstant, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function monitorMemoryLevel(ability: Ability, monitor: AbilityMonitor): void {\n  ability.onMemoryLevel((level: AbilityConstant.MemoryLevel) => {\n    if (level === AbilityConstant.MemoryLevel.MEMORY_LEVEL_CRITICAL) {\n      if (monitor.onAbilityBackground) {\n        monitor.onAbilityBackground(ability);\n      }\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onConfigurationUpdate` method of `Ability` to detect configuration changes (e.g., screen rotation) and then uses the `StateType` enum from `AbilityConstant` to check the current state of the ability. Based on the state, use the `onWindowStageDestroy` or `onWindowStageCreate` callbacks of `AbilityMonitor` to manage the window stage lifecycle accordingly.",
    "input": "",
    "output": "import {Ability, AbilityConstant, AbilityMonitor} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  private abilityMonitor: AbilityMonitor | null = null;\n\n  onConfigurationUpdate(newConfig: AbilityConstant.Configuration): void {\n    const currentState: AbilityConstant.StateType = this.getState();\n    \n    if (currentState === AbilityConstant.StateType.FOREGROUND) {\n      if (this.abilityMonitor) {\n        this.abilityMonitor.onWindowStageCreate = (windowStage) => {\n          console.log('Window stage created');\n        };\n      }\n    } else if (currentState === AbilityConstant.StateType.BACKGROUND) {\n      if (this.abilityMonitor) {\n        this.abilityMonitor.onWindowStageDestroy = () => {\n          console.log('Window stage destroyed');\n        };\n      }\n    }\n  }\n\n  onCreate(): void {\n    this.abilityMonitor = new AbilityMonitor();\n    this.abilityMonitor.abilityName = 'MyAbility';\n  }\n\n  onDestroy(): void {\n    this.abilityMonitor = null;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `LaunchReason` enum from `AbilityConstant` to determine the reason for the ability's launch (e.g., cold start or hot start). Depending on the launch reason, use the `onAbilityCreate` or `onAbilityForeground` callbacks of `AbilityMonitor` to initialize or resume the ability's UI components.",
    "input": "",
    "output": "import {Ability, AbilityConstant, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function setupAbilityMonitor(ability: Ability): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n\n  monitor.onAbilityCreate = (ability: Ability) => {\n    const launchReason: AbilityConstant.LaunchReason = ability.launchReason;\n    if (launchReason === AbilityConstant.LaunchReason.COLD_START) {\n      initializeUIComponents();\n    }\n  };\n\n  monitor.onAbilityForeground = (ability: Ability) => {\n    const launchReason: AbilityConstant.LaunchReason = ability.launchReason;\n    if (launchReason === AbilityConstant.LaunchReason.HOT_START) {\n      resumeUIComponents();\n    }\n  };\n\n  return monitor;\n}\n\nfunction initializeUIComponents(): void {\n  // Initialize UI components for cold start\n}\n\nfunction resumeUIComponents(): void {\n  // Resume UI components for hot start\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `LaunchReason` enum from `AbilityConstant` to determine the reason for launching an ability, and then sets the `resultCode` property of `AbilityResult` based on whether the launch reason was `COLD_START` or `WARM_START`.",
    "input": "",
    "output": "import { AbilityConstant, AbilityResult } from '@kit.AbilityKit';\n\nexport function setResultCodeBasedOnLaunchReason(launchReason: AbilityConstant.LaunchReason): AbilityResult {\n  const abilityResult: AbilityResult = {\n    resultCode: 0,\n    want: undefined\n  };\n\n  if (launchReason === AbilityConstant.LaunchReason.COLD_START) {\n    abilityResult.resultCode = 1;\n  } else if (launchReason === AbilityConstant.LaunchReason.WARM_START) {\n    abilityResult.resultCode = 2;\n  }\n\n  return abilityResult;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks the `MemoryLevel` enum from `AbilityConstant` to determine the current memory state of the device, and then constructs a `want` object in `AbilityResult` to trigger a low-memory cleanup process if the memory level is `CRITICAL` or `LOW`.",
    "input": "",
    "output": "import { AbilityConstant, AbilityResult } from '@kit.AbilityKit';\n\nexport function checkMemoryAndTriggerCleanup(): AbilityResult {\n  const memoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel;\n  const currentMemoryLevel = memoryLevel.CRITICAL || memoryLevel.LOW;\n  \n  let want = {};\n  if (currentMemoryLevel === memoryLevel.CRITICAL || currentMemoryLevel === memoryLevel.LOW) {\n    want = {\n      bundleName: 'com.example.cleanup',\n      abilityName: 'CleanupAbility',\n      action: 'action.cleanup.lowMemory'\n    };\n  }\n  \n  const result: AbilityResult = {\n    resultCode: 0,\n    want: want\n  };\n  \n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `StateType` enum from `AbilityConstant` to verify if the ability is in the `FOREGROUND` state, and then uses the `OnContinueResult` enum to return a success or failure status based on whether the ability can continue its current operation.",
    "input": "",
    "output": "import { AbilityConstant } from '@kit.AbilityKit';\n\nexport function verifyAbilityStateAndContinue(state: AbilityConstant.StateType): AbilityConstant.OnContinueResult {\n  if (state === AbilityConstant.StateType.FOREGROUND) {\n    return AbilityConstant.OnContinueResult.AGREE;\n  } else {\n    return AbilityConstant.OnContinueResult.REJECT;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create an application that uses `AbilityMonitor` to monitor the lifecycle of a specific ability (specified by `abilityName` and `moduleName`). When the ability enters the background (detected via `onAbilityBackground`), trigger a custom `AbilityLifecycleCallback` to log the event and then use `onWindowStageDestroy` to clean up any associated window stages.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, AbilityMonitor } from '@kit.AbilityKit';\n\nexport class CustomAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityBackground(ability) {\n    console.log(`Ability ${ability.abilityName} entered background`);\n  }\n\n  onWindowStageDestroy(ability) {\n    console.log(`Cleaning up window stages for ability ${ability.abilityName}`);\n  }\n}\n\nexport function setupAbilityMonitor(abilityName: string, moduleName: string) {\n  const callback = new CustomAbilityLifecycleCallback();\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityBackground: (ability) => {\n      callback.onAbilityBackground(ability);\n    },\n    onWindowStageDestroy: (ability) => {\n      callback.onWindowStageDestroy(ability);\n    }\n  };\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a system where `AbilityMonitor` detects when an ability is created (using `onAbilityCreate`) and immediately registers a custom `AbilityLifecycleCallback` to track its subsequent lifecycle events. The callback should use `onWindowStageCreate` to initialize resources and `onWindowStageDestroy` to release them, ensuring proper resource management.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, AbilityMonitor } from '@kit.AbilityKit';\n\nexport class CustomAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onWindowStageCreate(abilityWindow) {\n    // Initialize resources when window stage is created\n    console.log('Window stage created, initializing resources');\n  }\n\n  onWindowStageDestroy(abilityWindow) {\n    // Release resources when window stage is destroyed\n    console.log('Window stage destroyed, releasing resources');\n  }\n}\n\nexport function setupAbilityMonitoring() {\n  const abilityMonitor: AbilityMonitor = new AbilityMonitor();\n  \n  abilityMonitor.onAbilityCreate = (ability) => {\n    console.log(`Ability created: ${ability.abilityName}`);\n    const lifecycleCallback = new CustomAbilityLifecycleCallback();\n    ability.registerAbilityLifecycleCallback(lifecycleCallback);\n  };\n\n  return abilityMonitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a feature where `AbilityMonitor` monitors an ability's foreground and background transitions (using `onAbilityForeground` and `onAbilityBackground`). When the ability comes to the foreground, use `AbilityLifecycleCallback`'s `onWindowStageActive` to restore UI state, and when it goes to the background, use `onWindowStageInactive` to pause non-essential operations.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, AbilityMonitor } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onWindowStageActive() {\n    // Restore UI state when ability comes to foreground\n  }\n\n  onWindowStageInactive() {\n    // Pause non-essential operations when ability goes to background\n  }\n}\n\nexport function setupAbilityMonitor() {\n  const monitor: AbilityMonitor = {\n    abilityName: 'your_ability_name',\n    onAbilityForeground: (ability) => {\n      const callback = new MyAbilityLifecycleCallback();\n      ability.registerAbilityLifecycleCallback(callback);\n    },\n    onAbilityBackground: (ability) => {\n      const callback = new MyAbilityLifecycleCallback();\n      ability.registerAbilityLifecycleCallback(callback);\n    }\n  };\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` to track the lifecycle of a specific ability (using `abilityName` and `moduleName` properties). When the ability enters the foreground (detected via `onAbilityForeground` callback), use `AbilityRunningInfo` to log the `abilityState`, `pid`, and `processName` of the running ability.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityRunningInfo, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function createAbilityMonitor(abilityName: string, moduleName: string): AbilityMonitor {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityForeground: (abilityRunningInfo: AbilityRunningInfo) => {\n      console.log(`AbilityState: ${abilityRunningInfo.abilityState}`);\n      console.log(`PID: ${abilityRunningInfo.pid}`);\n      console.log(`ProcessName: ${abilityRunningInfo.processName}`);\n    }\n  };\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityLifecycleCallback` to monitor an ability's window stage events (via `onWindowStageCreate` and `onWindowStageDestroy`). When a window stage is created, extract the `startTime` from `AbilityRunningInfo` and combine it with the `abilityState` to generate a unique session ID for the ability instance.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityRunningInfo, AbilityMonitor} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private generateSessionId(abilityInfo: AbilityRunningInfo): string {\n    return `${abilityInfo.startTime}_${abilityInfo.abilityState}`;\n  }\n\n  onWindowStageCreate(abilityInfo: AbilityRunningInfo): void {\n    const sessionId = this.generateSessionId(abilityInfo);\n    console.log(`WindowStage created with sessionId: ${sessionId}`);\n  }\n\n  onWindowStageDestroy(abilityInfo: AbilityRunningInfo): void {\n    const sessionId = this.generateSessionId(abilityInfo);\n    console.log(`WindowStage destroyed with sessionId: ${sessionId}`);\n  }\n}\n\nexport function setupAbilityMonitor(): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.onWindowStageCreate = (abilityInfo: AbilityRunningInfo) => {\n    const sessionId = `${abilityInfo.startTime}_${abilityInfo.abilityState}`;\n    console.log(`Monitor: WindowStage created with sessionId: ${sessionId}`);\n  };\n  monitor.onWindowStageDestroy = (abilityInfo: AbilityRunningInfo) => {\n    const sessionId = `${abilityInfo.startTime}_${abilityInfo.abilityState}`;\n    console.log(`Monitor: WindowStage destroyed with sessionId: ${sessionId}`);\n  };\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility that registers an `AbilityMonitor` to detect when an ability is destroyed (using `onAbilityDestroy` callback). Upon destruction, use `AbilityRunningInfo` to collect the `uid` and `pid` of the terminated ability, then pass this data to `AbilityLifecycleCallback`'s `onAbilityDestroy` method to log a detailed termination report.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityRunningInfo, AbilityMonitor} from '@kit.AbilityKit';\n\nexport class AbilityTerminationMonitor extends AbilityLifecycleCallback {\n  private abilityMonitor: AbilityMonitor;\n\n  constructor() {\n    super();\n    this.abilityMonitor = new AbilityMonitor();\n    this.abilityMonitor.onAbilityDestroy = (abilityRunningInfo: AbilityRunningInfo) => {\n      this.onAbilityDestroy(abilityRunningInfo);\n    };\n  }\n\n  public registerMonitor(): void {\n    // Register the monitor with the system\n    // Implementation depends on the specific system API for registration\n    // This is a placeholder for the actual registration call\n  }\n\n  public onAbilityDestroy(abilityRunningInfo: AbilityRunningInfo): void {\n    const uid = abilityRunningInfo.uid;\n    const pid = abilityRunningInfo.pid;\n    console.log(`Ability terminated - UID: ${uid}, PID: ${pid}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch an ability and then uses `AbilityDelegator.waitAbilityMonitor` to wait for the ability to be ready. Once the ability is ready, use `AbilityDelegator.getAbilityState` to verify the ability's state and pass the result to `AbilityResult.resultCode` to check if the ability was successfully launched.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegator, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function launchAndVerifyAbility(delegator: AbilityDelegator, want: Want): AbilityResult {\n  const abilityMonitor = delegator.addAbilityMonitor(want);\n  delegator.startAbility(want);\n  const matchedAbility = delegator.waitAbilityMonitor(abilityMonitor);\n  \n  if (!matchedAbility) {\n    return { resultCode: -1, want };\n  }\n  \n  const abilityState = delegator.getAbilityState(matchedAbility);\n  \n  if (abilityState === 2) { // Assuming 2 represents the active state\n    return { resultCode: 0, want };\n  } else {\n    return { resultCode: -1, want };\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.executeShellCommand` to run a shell command and then passes the output to `AbilityDelegator.printSync` to log the result. After logging, use `AbilityDelegator.getCurrentTopAbility` to get the top ability and pass its information to `AbilityResult.want` to verify the current ability context.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function executeAndLogShellCommand(delegator: AbilityDelegator, command: string): void {\n  delegator.executeShellCommand(command, (err, output) => {\n    if (err) {\n      delegator.printSync(`Error executing shell command: ${err.message}`);\n      return;\n    }\n    delegator.printSync(`Shell command output: ${output}`);\n    \n    const topAbility = delegator.getCurrentTopAbility();\n    if (topAbility) {\n      const abilityResult: AbilityResult = {\n        resultCode: 0,\n        want: topAbility.want\n      };\n      delegator.printSync(`Top ability info: ${JSON.stringify(abilityResult.want)}`);\n    } else {\n      delegator.printSync('No top ability found');\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.addAbilityMonitor` to set up a monitor for an ability, then uses `AbilityDelegator.doAbilityForeground` to bring the ability to the foreground. After the ability is in the foreground, use `AbilityDelegator.removeAbilityMonitor` to clean up the monitor and pass the result to `AbilityResult.resultCode` to confirm the operation was successful.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegator, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function monitorAndForegroundAbility(delegator: AbilityDelegator, abilityName: string): AbilityResult {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (data) => {\n      console.log(`Ability ${abilityName} created`);\n    }\n  };\n\n  delegator.addAbilityMonitor(monitor);\n  delegator.doAbilityForeground(abilityName);\n  delegator.removeAbilityMonitor(monitor);\n\n  const result: AbilityResult = {\n    resultCode: 0,\n    want: {\n      bundleName: '',\n      abilityName: abilityName\n    }\n  };\n\n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `abilityState` from an `AbilityRunningInfo` object and uses it to determine the appropriate `StateType` from `AbilityConstant`. The function should then return a string describing the current state of the ability (e.g., 'Ability is in FOREGROUND state'). Use the `abilityState` property of `AbilityRunningInfo` and the `StateType` enum from `AbilityConstant`.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function getAbilityStateDescription(info: AbilityRunningInfo): string {\n  const stateType = info.abilityState;\n  let stateDescription: string = '';\n\n  switch (stateType) {\n    case AbilityConstant.StateType.INITIAL:\n      stateDescription = 'Ability is in INITIAL state';\n      break;\n    case AbilityConstant.StateType.FOREGROUND:\n      stateDescription = 'Ability is in FOREGROUND state';\n      break;\n    case AbilityConstant.StateType.BACKGROUND:\n      stateDescription = 'Ability is in BACKGROUND state';\n      break;\n    case AbilityConstant.StateType.FOREGROUND_FAILED:\n      stateDescription = 'Ability is in FOREGROUND_FAILED state';\n      break;\n    case AbilityConstant.StateType.TERMINATION:\n      stateDescription = 'Ability is in TERMINATION state';\n      break;\n    default:\n      stateDescription = 'Ability is in unknown state';\n      break;\n  }\n\n  return stateDescription;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes a `pid` from an `AbilityRunningInfo` object and checks if the corresponding process is in a critical memory state. The function should use the `pid` property of `AbilityRunningInfo` to identify the process and then compare the current memory level against the `MemoryLevel` enum from `AbilityConstant` to return a boolean indicating if the process is in a critical state (e.g., `MemoryLevel.CRITICAL`).",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function isProcessInCriticalMemoryState(abilityRunningInfo: AbilityRunningInfo): boolean {\n  const memoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel.CRITICAL;\n  return abilityRunningInfo.memoryLevel === memoryLevel;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that monitors the `startTime` of an ability from `AbilityRunningInfo` and determines the `LaunchReason` from `AbilityConstant` based on the elapsed time since the ability started. If the elapsed time is less than 5 seconds, return `LaunchReason.COLD_START`; otherwise, return `LaunchReason.WARM_START`. Use the `startTime` property of `AbilityRunningInfo` and the `LaunchReason` enum from `AbilityConstant`.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function determineLaunchReason(abilityInfo: AbilityRunningInfo): AbilityConstant.LaunchReason {\n  const currentTime = new Date().getTime();\n  const elapsedTime = (currentTime - abilityInfo.startTime) / 1000; // Convert to seconds\n  return elapsedTime < 5 ? AbilityConstant.LaunchReason.COLD_START : AbilityConstant.LaunchReason.WARM_START;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onAbilityCreate` method of `AbilityLifecycleCallback` to initialize a new ability, and then passes the initialized ability's `bundleName` (from `AbilityDelegatorArgs`) to a test runner to verify the ability's creation.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class TestAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private delegatorArgs: AbilityDelegatorArgs;\n\n  constructor(delegatorArgs: AbilityDelegatorArgs) {\n    super();\n    this.delegatorArgs = delegatorArgs;\n  }\n\n  onAbilityCreate(ability: ability.Ability): void {\n    const bundleName = this.delegatorArgs.bundleName;\n    // Pass bundleName to test runner for verification\n    console.log(`Ability created with bundleName: ${bundleName}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test scenario where the `onWindowStageCreate` method of `AbilityLifecycleCallback` is used to set up a window stage, and then the `testCaseNames` property of `AbilityDelegatorArgs` is used to dynamically load and execute test cases specific to the window stage configuration.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class TestAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private delegatorArgs: AbilityDelegatorArgs;\n\n  constructor(delegatorArgs: AbilityDelegatorArgs) {\n    super();\n    this.delegatorArgs = delegatorArgs;\n  }\n\n  onWindowStageCreate(windowStage: any): void {\n    if (this.delegatorArgs.testCaseNames) {\n      this.delegatorArgs.testCaseNames.forEach((testCase: string) => {\n        console.log(`Executing test case: ${testCase}`);\n      });\n    }\n  }\n}\n\nexport function setupTestScenario(): void {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    testCaseNames: ['testWindowStageConfiguration', 'testWindowStageLifecycle'],\n    testRunnerClassName: 'TestRunner',\n    bundleName: 'com.example.test',\n    parameters: {}\n  };\n\n  const testCallback = new TestAbilityLifecycleCallback(delegatorArgs);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that utilizes the `onAbilityForeground` method of `AbilityLifecycleCallback` to bring an ability to the foreground, and then uses the `parameters` property of `AbilityDelegatorArgs` to pass custom configuration data to the foregrounded ability for further processing.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class CustomAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private delegatorArgs: AbilityDelegatorArgs;\n\n  constructor(args: AbilityDelegatorArgs) {\n    super();\n    this.delegatorArgs = args;\n  }\n\n  onAbilityForeground(ability): void {\n    if (this.delegatorArgs.parameters) {\n      // Process the custom configuration data passed via AbilityDelegatorArgs\n      const customData = this.delegatorArgs.parameters;\n      // Further processing with the custom data\n      console.log(`Custom data received: ${JSON.stringify(customData)}`);\n    }\n  }\n}\n\nexport function setupAbilityLifecycleCallback(args: AbilityDelegatorArgs): CustomAbilityLifecycleCallback {\n  return new CustomAbilityLifecycleCallback(args);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that first retrieves the `bundleName` and `moduleName` properties from an `AbilityInfo` object, then uses these values to construct a URI string by combining them with a predefined path segment, and finally passes this URI to the `uri` property of another `AbilityInfo` object to simulate a deep link configuration.",
    "input": "",
    "output": "import {AbilityInfo, AbilityInfo} from '@kit.AbilityKit';\n\nexport function configureDeepLink(sourceAbility: AbilityInfo, targetAbility: AbilityInfo): void {\n  const bundleName = sourceAbility.bundleName;\n  const moduleName = sourceAbility.moduleName;\n  const pathSegment = 'deepLinkPath';\n  const uri = `${bundleName}/${moduleName}/${pathSegment}`;\n  targetAbility.uri = uri;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks if an ability is visible and enabled by using the `isVisible` and `enabled` properties of an `AbilityInfo` object. If both conditions are true, use the `skills` property of the same `AbilityInfo` object to extract the supported actions and then pass these actions to the `permissions` property of another `AbilityInfo` object to verify if the required permissions are granted.",
    "input": "",
    "output": "import {AbilityInfo, AbilityInfo} from '@kit.AbilityKit';\n\nexport function checkAbilityVisibilityAndPermissions(abilityInfo: AbilityInfo, targetAbilityInfo: AbilityInfo): boolean {\n  if (abilityInfo.isVisible && abilityInfo.enabled) {\n    const supportedActions = abilityInfo.skills?.map(skill => skill.actions).flat() || [];\n    const requiredPermissions = targetAbilityInfo.permissions || [];\n    \n    return supportedActions.every(action => requiredPermissions.includes(action));\n  }\n  return false;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first retrieves the `windowSize` and `orientation` properties from an `AbilityInfo` object to determine the display configuration, then uses these values to set the `supportWindowModes` and `orientationId` properties of another `AbilityInfo` object to ensure compatibility between two different abilities' display settings.",
    "input": "",
    "output": "import {AbilityInfo, AbilityInfo} from '@kit.AbilityKit';\n\nexport function setDisplayCompatibility(sourceAbilityInfo: AbilityInfo, targetAbilityInfo: AbilityInfo): void {\n  const windowSize = sourceAbilityInfo.windowSize;\n  const orientation = sourceAbilityInfo.orientation;\n\n  targetAbilityInfo.supportWindowModes = windowSize;\n  targetAbilityInfo.orientationId = orientation;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch an ability and then uses `AbilityInfo.bundleName` and `AbilityInfo.name` to verify that the launched ability matches the expected target ability. The function should return true if the verification passes, false otherwise.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityInfo} from '@kit.AbilityKit';\n\nexport function verifyLaunchedAbility(abilityDelegator: AbilityDelegator, targetBundleName: string, targetAbilityName: string): boolean {\n  try {\n    const ability = abilityDelegator.getCurrentTopAbility();\n    if (!ability) {\n      return false;\n    }\n    const abilityInfo: AbilityInfo = ability.abilityInfo;\n    return abilityInfo.bundleName === targetBundleName && abilityInfo.name === targetAbilityName;\n  } catch (error) {\n    return false;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test case that uses `AbilityDelegator.addAbilityMonitor` to monitor an ability's lifecycle state changes and then uses `AbilityInfo.type` and `AbilityInfo.launchMode` to validate that the ability behaves according to its declared launch mode (e.g., singleTop, standard). The test should pass if the observed behavior matches the expected behavior based on the `AbilityInfo` properties.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityInfo} from '@kit.AbilityKit';\nimport {describe, it, expect} from '@ohos/hypium';\n\nexport function testAbilityLaunchMode() {\n  describe('AbilityLaunchModeTest', () => {\n    it('testAbilityLaunchModeBehavior', 0, async (done: Function) => {\n      const delegator = AbilityDelegator.getAbilityDelegator();\n      const abilityInfo: AbilityInfo = await delegator.getCurrentTopAbility();\n      const abilityName = abilityInfo.name;\n      const expectedLaunchMode = abilityInfo.launchMode;\n\n      const monitor = {\n        abilityName: abilityName,\n        onAbilityCreate: (ability) => {\n          console.log(`Ability created: ${abilityName}`);\n        },\n        onAbilityForeground: (ability) => {\n          console.log(`Ability foreground: ${abilityName}`);\n        },\n        onAbilityBackground: (ability) => {\n          console.log(`Ability background: ${abilityName}`);\n        },\n        onAbilityDestroy: (ability) => {\n          console.log(`Ability destroyed: ${abilityName}`);\n        }\n      };\n\n      delegator.addAbilityMonitor(monitor);\n\n      // Start the ability and wait for it to be created\n      await delegator.startAbility({\n        bundleName: abilityInfo.bundleName,\n        abilityName: abilityName\n      });\n\n      // Validate the launch mode behavior\n      if (expectedLaunchMode === 'standard') {\n        // For standard mode, a new instance should be created each time\n        const newAbilityInfo = await delegator.getCurrentTopAbility();\n        expect(newAbilityInfo.name).assertEqual(abilityName);\n      } else if (expectedLaunchMode === 'singleTop') {\n        // For singleTop mode, the same instance should be reused if it's on top\n        const sameAbilityInfo = await delegator.getCurrentTopAbility();\n        expect(sameAbilityInfo.name).assertEqual(abilityName);\n      }\n\n      delegator.removeAbilityMonitor(monitor);\n      done();\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that first retrieves the current top ability using `AbilityDelegator.getCurrentTopAbility`, then checks its properties using `AbilityInfo.exported` and `AbilityInfo.permissions` to determine if the ability is accessible to other applications. The function should return a boolean indicating whether the ability is securely exported (i.e., exported but protected by permissions).",
    "input": "",
    "output": "import {AbilityDelegator, AbilityInfo} from '@kit.AbilityKit';\n\nexport function isAbilitySecurelyExported(abilityDelegator: AbilityDelegator): boolean {\n  const abilityInfo: AbilityInfo | null = abilityDelegator.getCurrentTopAbility();\n  if (!abilityInfo) {\n    return false;\n  }\n  return abilityInfo.exported && abilityInfo.permissions.length > 0;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `onAbilityCreate` of `AbilityLifecycleCallback` to initialize an ability, then passes the initialized ability's context to `onWindowStageCreate` to set up a window stage, and finally uses `resultCode` of `AbilityResult` to verify the successful creation of both the ability and the window stage.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityResult} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private abilityContext: any;\n  private windowStageContext: any;\n  private abilityResult: AbilityResult = { resultCode: -1, want: undefined };\n\n  onAbilityCreate(ability) {\n    this.abilityContext = ability.context;\n    this.abilityResult.resultCode = 0;\n  }\n\n  onWindowStageCreate(ability, windowStage) {\n    if (this.abilityResult.resultCode === 0) {\n      this.windowStageContext = windowStage;\n      this.abilityResult.resultCode = 1;\n    }\n  }\n\n  getResult(): AbilityResult {\n    return this.abilityResult;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `onAbilityForeground` of `AbilityLifecycleCallback` to bring an ability to the foreground, then checks the `want` property of `AbilityResult` to determine if the ability was foregrounded due to a specific intent, and logs the result using `resultCode`.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityResult} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(abilityResult: AbilityResult): void {\n    if (abilityResult.want) {\n      console.log(`Ability foregrounded with resultCode: ${abilityResult.resultCode}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `onWindowStageDestroy` of `AbilityLifecycleCallback` to clean up a window stage, then uses `onAbilityDestroy` to terminate the ability, and finally checks the `resultCode` of `AbilityResult` to confirm the successful destruction of both the window stage and the ability.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityResult} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private windowStageDestroyed: boolean = false;\n  private abilityDestroyed: boolean = false;\n\n  onWindowStageDestroy(): void {\n    this.windowStageDestroyed = true;\n  }\n\n  onAbilityDestroy(): void {\n    this.abilityDestroyed = true;\n  }\n\n  checkDestructionResult(): AbilityResult {\n    const result: AbilityResult = {\n      resultCode: this.windowStageDestroyed && this.abilityDestroyed ? 0 : -1,\n      want: undefined\n    };\n    return result;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `resultCode` property of `AbilityResult` to check if an ability was successfully started, and if successful, retrieves the `pid` and `processName` from `AbilityRunningInfo` to log the running process details.",
    "input": "",
    "output": "import {AbilityResult, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function checkAbilityStartResult(result: AbilityResult, runningInfo: AbilityRunningInfo): void {\n  if (result.resultCode === 0) {\n    console.log(`Ability started successfully. PID: ${runningInfo.pid}, Process Name: ${runningInfo.processName}`);\n  } else {\n    console.log('Ability failed to start.');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes an `AbilityResult` object and uses its `want` property to extract the target ability name, then queries `AbilityRunningInfo` to check if the ability is currently running by examining its `abilityState` property.",
    "input": "",
    "output": "import {AbilityResult, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function isAbilityRunning(abilityResult: AbilityResult, runningInfos: AbilityRunningInfo[]): boolean {\n  const targetAbilityName = abilityResult.want?.abilityName;\n  if (!targetAbilityName) {\n    return false;\n  }\n\n  for (const info of runningInfos) {\n    if (info.ability?.name === targetAbilityName && info.abilityState === 2) {\n      return true;\n    }\n  }\n\n  return false;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that collects the `uid` and `startTime` from `AbilityRunningInfo` for all running abilities, then uses the `resultCode` from `AbilityResult` to filter and return only the information for abilities that were successfully started (resultCode === 0).",
    "input": "",
    "output": "import {AbilityResult, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function filterSuccessfulAbilities(abilityResults: AbilityResult[], runningInfos: AbilityRunningInfo[]): {uid: number, startTime: number}[] {\n  const successfulAbilityWants = abilityResults\n    .filter((result: AbilityResult) => result.resultCode === 0)\n    .map((result: AbilityResult) => result.want);\n\n  return runningInfos\n    .filter((info: AbilityRunningInfo) => {\n      return successfulAbilityWants.some((want) => {\n        return info.ability.bundleName === want.bundleName && \n               info.ability.abilityName === want.abilityName;\n      });\n    })\n    .map((info: AbilityRunningInfo) => ({\n      uid: info.uid,\n      startTime: info.startTime\n    }));\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `onAbilityCreate` from `AbilityLifecycleCallback` to initialize an ability and then checks the `LaunchReason` from `AbilityConstant` to determine the reason for the ability's launch, logging different messages based on whether the launch reason is `COLD_START` or `HOT_START`.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(ability) {\n    const launchReason = ability.launchReason;\n    if (launchReason === AbilityConstant.LaunchReason.COLD_START) {\n      console.log('Ability launched due to COLD_START');\n    } else if (launchReason === AbilityConstant.LaunchReason.HOT_START) {\n      console.log('Ability launched due to HOT_START');\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that monitors the ability's state changes by implementing `onAbilityForeground` and `onAbilityBackground` from `AbilityLifecycleCallback`, and uses `MemoryLevel` from `AbilityConstant` to log the current memory level whenever the ability transitions between foreground and background states.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(ability: any): void {\n    const memoryLevel: AbilityConstant.MemoryLevel = ability.context.getMemoryLevel();\n    console.log(`Ability entered foreground. Current memory level: ${memoryLevel}`);\n  }\n\n  onAbilityBackground(ability: any): void {\n    const memoryLevel: AbilityConstant.MemoryLevel = ability.context.getMemoryLevel();\n    console.log(`Ability entered background. Current memory level: ${memoryLevel}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that handles ability continuation by using `onAbilityContinue` from `AbilityLifecycleCallback` and checks the `ContinueState` from `AbilityConstant` to determine if the continuation was successful, then logs a success or failure message based on the result.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityContinue(wantParam: Record<string, Object>): AbilityConstant.OnContinueResult {\n    const continueState: AbilityConstant.ContinueState = AbilityConstant.ContinueState.OK;\n    \n    if (continueState === AbilityConstant.ContinueState.OK) {\n      console.log('Ability continuation successful');\n      return AbilityConstant.OnContinueResult.AGREE;\n    } else {\n      console.log('Ability continuation failed');\n      return AbilityConstant.OnContinueResult.REJECT;\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onMemoryLevel` method of `Ability` to monitor the current memory level, and then uses the `MemoryLevel` enum from `AbilityConstant` to determine if the memory level is critical (e.g., `MemoryLevel.CRITICAL`). If it is critical, trigger a cleanup process.",
    "input": "",
    "output": "import {Ability, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MemoryMonitorAbility extends Ability {\n  private cleanupProcess(): void {\n    // Implement cleanup process here\n  }\n\n  onMemoryLevel(level: AbilityConstant.MemoryLevel): void {\n    if (level === AbilityConstant.MemoryLevel.CRITICAL) {\n      this.cleanupProcess();\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onConfigurationUpdate` method of `Ability` to detect configuration changes (e.g., screen rotation) and then uses the `StateType` enum from `AbilityConstant` to log the type of state change that occurred (e.g., `StateType.CHANGED`).",
    "input": "",
    "output": "import {Ability, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  onConfigurationUpdate(newConfig: Ability.Configuration) {\n    super.onConfigurationUpdate(newConfig);\n    const stateType: AbilityConstant.StateType = AbilityConstant.StateType.CHANGED;\n    console.log(`Configuration updated. StateType: ${stateType}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `LaunchReason` enum from `AbilityConstant` to check the reason for the app launch (e.g., `LaunchReason.NORMAL`), and then based on the reason, call the `onMemoryLevel` method of `Ability` to adjust the app's memory usage accordingly.",
    "input": "",
    "output": "import {Ability, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  onMemoryLevel(level: AbilityConstant.MemoryLevel): void {\n    // Adjust memory usage based on the memory level\n    switch (level) {\n      case AbilityConstant.MemoryLevel.MEMORY_LEVEL_LOW:\n        // Handle low memory scenario\n        break;\n      case AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE:\n        // Handle moderate memory scenario\n        break;\n      case AbilityConstant.MemoryLevel.MEMORY_LEVEL_CRITICAL:\n        // Handle critical memory scenario\n        break;\n      default:\n        // Handle other cases\n        break;\n    }\n  }\n\n  onCreate(want, launchParam: AbilityConstant.LaunchParam): void {\n    const launchReason = launchParam.launchReason;\n    \n    switch (launchReason) {\n      case AbilityConstant.LaunchReason.NORMAL:\n        // Handle normal launch\n        this.onMemoryLevel(AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE);\n        break;\n      case AbilityConstant.LaunchReason.START_ABNORMAL:\n        // Handle abnormal launch\n        this.onMemoryLevel(AbilityConstant.MemoryLevel.MEMORY_LEVEL_LOW);\n        break;\n      case AbilityConstant.LaunchReason.CALL:\n        // Handle call launch\n        this.onMemoryLevel(AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE);\n        break;\n      case AbilityConstant.LaunchReason.CONTINUATION:\n        // Handle continuation launch\n        this.onMemoryLevel(AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE);\n        break;\n      default:\n        // Handle other launch reasons\n        this.onMemoryLevel(AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE);\n        break;\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onConfigurationUpdate` method of `Ability` to detect changes in system configuration (e.g., language or theme), and then passes the updated configuration data to the `onMemoryLevel` method of another `Ability` to adjust memory usage based on the new configuration.",
    "input": "",
    "output": "import { Ability } from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  onConfigurationUpdate(newConfig: object): void {\n    // Handle configuration changes\n    const memoryLevel = this.calculateMemoryLevel(newConfig);\n    this.onMemoryLevel(memoryLevel);\n  }\n\n  private calculateMemoryLevel(config: object): number {\n    // Logic to determine memory level based on configuration\n    return 0;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a program that utilizes the `onMemoryLevel` method of the first `Ability` to monitor memory levels, and when a critical level is detected, triggers the `onConfigurationUpdate` method of the second `Ability` to reduce resource-intensive configurations (e.g., lowering graphics quality).",
    "input": "",
    "output": "import { Ability } from '@kit.AbilityKit';\n\nexport class FirstAbility extends Ability {\n  onMemoryLevel(level: string): void {\n    if (level === 'CRITICAL') {\n      // Trigger configuration update in SecondAbility\n      const secondAbility = new SecondAbility();\n      secondAbility.onConfigurationUpdate({ graphicsQuality: 'LOW' });\n    }\n  }\n}\n\nexport class SecondAbility extends Ability {\n  onConfigurationUpdate(newConfig: { graphicsQuality: string }): void {\n    // Reduce resource-intensive configurations\n    console.log(`Graphics quality updated to: ${newConfig.graphicsQuality}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a solution where the `onConfigurationUpdate` method of one `Ability` is used to respond to system theme changes, and the resulting theme data is passed to the `onMemoryLevel` method of another `Ability` to optimize memory allocation for dark/light mode transitions.",
    "input": "",
    "output": "import { Ability } from '@kit.AbilityKit';\n\nexport class ThemeResponderAbility extends Ability {\n  private currentTheme: string = 'light';\n\n  onConfigurationUpdate(newConfig) {\n    if (newConfig.theme === 'dark' || newConfig.theme === 'light') {\n      this.currentTheme = newConfig.theme;\n      // Notify the other ability about theme change\n      this.context.eventHub.emit('themeChanged', this.currentTheme);\n    }\n  }\n}\n\nexport class MemoryOptimizerAbility extends Ability {\n  onMemoryLevel(level) {\n    this.context.eventHub.on('themeChanged', (theme: string) => {\n      this.optimizeMemoryForTheme(theme, level);\n    });\n  }\n\n  private optimizeMemoryForTheme(theme: string, level: number) {\n    // Implementation for memory optimization based on theme and memory level\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `AbilityRunningInfo` of all running abilities, filters them based on the `abilityState` property, and then uses the `bundleName` and `moduleName` properties from `AbilityInfo` to generate a report of active abilities grouped by their originating application and module.",
    "input": "",
    "output": "import {AbilityInfo, AbilityConstant, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function generateActiveAbilitiesReport(runningInfos: AbilityRunningInfo[], stateFilter: AbilityConstant.AbilityState): Record<string, Record<string, string[]>> {\n  const report: Record<string, Record<string, string[]>> = {};\n\n  for (const runningInfo of runningInfos) {\n    if (runningInfo.abilityState === stateFilter) {\n      const abilityInfo: AbilityInfo = runningInfo.ability;\n      const bundleName: string = abilityInfo.bundleName;\n      const moduleName: string = abilityInfo.moduleName;\n      const abilityName: string = abilityInfo.name;\n\n      if (!report[bundleName]) {\n        report[bundleName] = {};\n      }\n\n      if (!report[bundleName][moduleName]) {\n        report[bundleName][moduleName] = [];\n      }\n\n      report[bundleName][moduleName].push(abilityName);\n    }\n  }\n\n  return report;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks the `launchType` and `launchMode` properties of a given `AbilityInfo` object, and based on these values, determines the appropriate `WindowMode` from `AbilityConstant` to apply when starting the ability, ensuring compatibility between the ability's configuration and the window display mode.",
    "input": "",
    "output": "import {AbilityInfo, AbilityConstant, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function determineWindowMode(abilityInfo: AbilityInfo): AbilityConstant.WindowMode {\n  let windowMode: AbilityConstant.WindowMode = AbilityConstant.WindowMode.WINDOW_MODE_UNDEFINED;\n\n  if (abilityInfo.launchType === 'standard' && abilityInfo.launchMode === 'standard') {\n    windowMode = AbilityConstant.WindowMode.WINDOW_MODE_FULLSCREEN;\n  } else if (abilityInfo.launchType === 'singleton' && abilityInfo.launchMode === 'singleton') {\n    windowMode = AbilityConstant.WindowMode.WINDOW_MODE_FLOATING;\n  } else if (abilityInfo.launchType === 'specified' && abilityInfo.launchMode === 'specified') {\n    windowMode = AbilityConstant.WindowMode.WINDOW_MODE_SPLIT_PRIMARY;\n  }\n\n  return windowMode;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `skills` property of `AbilityInfo` to identify abilities capable of handling a specific intent, then cross-references these with the `pid` and `processName` properties from `AbilityRunningInfo` to prioritize and select the most suitable running ability instance to handle the intent, considering both capability and current activity state.",
    "input": "",
    "output": "import {AbilityInfo, AbilityConstant, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function selectAbilityForIntent(\n  abilityInfos: AbilityInfo[],\n  runningInfos: AbilityRunningInfo[],\n  intentAction: string\n): AbilityInfo | null {\n  const capableAbilities: AbilityInfo[] = [];\n\n  // Filter abilities that can handle the intent\n  for (const abilityInfo of abilityInfos) {\n    if (abilityInfo.skills) {\n      for (const skill of abilityInfo.skills) {\n        if (skill.actions && skill.actions.includes(intentAction)) {\n          capableAbilities.push(abilityInfo);\n          break;\n        }\n      }\n    }\n  }\n\n  if (capableAbilities.length === 0) {\n    return null;\n  }\n\n  // Prioritize running abilities\n  const runningAbilityMap = new Map<string, AbilityRunningInfo>();\n  for (const runningInfo of runningInfos) {\n    runningAbilityMap.set(runningInfo.ability?.bundleName + ':' + runningInfo.ability?.name, runningInfo);\n  }\n\n  let selectedAbility: AbilityInfo | null = null;\n  let highestPriority = -1;\n\n  for (const ability of capableAbilities) {\n    const key = ability.bundleName + ':' + ability.name;\n    const runningInfo = runningAbilityMap.get(key);\n    \n    let currentPriority = 0;\n    \n    if (runningInfo) {\n      // Running abilities get higher priority\n      currentPriority += 100;\n      \n      // Foreground abilities get even higher priority\n      if (runningInfo.abilityState === AbilityConstant.StateType.FOREGROUND) {\n        currentPriority += 50;\n      }\n      \n      // Longer running time gets slightly higher priority\n      currentPriority += Math.min(10, Math.floor((Date.now() - runningInfo.startTime) / 1000));\n    }\n    \n    if (currentPriority > highestPriority) {\n      highestPriority = currentPriority;\n      selectedAbility = ability;\n    }\n  }\n\n  return selectedAbility;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `abilityState` and `pid` from an `AbilityRunningInfo` object, then uses these values to call the `onMemoryLevel` method of the `Ability` class to adjust memory usage for the specified process.",
    "input": "",
    "output": "import {AbilityRunningInfo, Ability, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function adjustMemoryUsage(abilityRunningInfo: AbilityRunningInfo, ability: Ability): void {\n  const { abilityState, pid } = abilityRunningInfo;\n  ability.onMemoryLevel(abilityState, pid);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes an `AbilityDelegatorArgs` object, extracts the `bundleName` and `testCaseNames`, and uses them to filter `AbilityRunningInfo` objects by checking if their `ability` property matches the bundle name and if their `processName` is listed in the test case names.",
    "input": "",
    "output": "import {AbilityRunningInfo, Ability, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function filterAbilityRunningInfo(args: AbilityDelegatorArgs, runningInfos: AbilityRunningInfo[]): AbilityRunningInfo[] {\n  const { bundleName, testCaseNames } = args;\n  if (!bundleName || !testCaseNames || testCaseNames.length === 0) {\n    return [];\n  }\n\n  return runningInfos.filter((info) => {\n    return info.ability && \n           info.ability.bundleName === bundleName && \n           testCaseNames.includes(info.processName);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that collects the `startTime` and `uid` from multiple `AbilityRunningInfo` objects, then passes these values to the `onConfigurationUpdate` method of the `Ability` class to log or update configuration settings based on the earliest start time and highest UID.",
    "input": "",
    "output": "import {AbilityRunningInfo, Ability, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function collectAndUpdateConfig(abilityRunningInfos: AbilityRunningInfo[], ability: Ability): void {\n  if (abilityRunningInfos.length === 0) {\n    return;\n  }\n\n  let earliestStartTime: number = abilityRunningInfos[0].startTime;\n  let highestUid: number = abilityRunningInfos[0].uid;\n\n  for (const info of abilityRunningInfos) {\n    if (info.startTime < earliestStartTime) {\n      earliestStartTime = info.startTime;\n    }\n    if (info.uid > highestUid) {\n      highestUid = info.uid;\n    }\n  }\n\n  ability.onConfigurationUpdate({\n    startTime: earliestStartTime,\n    uid: highestUid\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch an ability and then checks its state using `AbilityDelegator.getAbilityState`. The state should be compared with `AbilityConstant.StateType` to verify if the ability is in the expected state (e.g., FOREGROUND or BACKGROUND).",
    "input": "",
    "output": "import {AbilityDelegator, AbilityConstant, AbilityInfo} from '@kit.AbilityKit';\n\nexport function startAbilityAndCheckState(\n  delegator: AbilityDelegator,\n  want: Want,\n  expectedState: AbilityConstant.StateType\n): Promise<boolean> {\n  return new Promise((resolve, reject) => {\n    delegator.startAbility(want, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      setTimeout(() => {\n        const abilityState = delegator.getAbilityState(want);\n        resolve(abilityState === expectedState);\n      }, 1000);\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `AbilityInfo` of the current top ability using `AbilityDelegator.getCurrentTopAbility` and then checks if the ability supports specific window modes by accessing the `supportWindowModes` property of `AbilityInfo`. The supported modes should be validated against `AbilityConstant.WindowMode`.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityConstant, AbilityInfo} from '@kit.AbilityKit';\n\nexport function checkTopAbilityWindowModes(abilityDelegator: AbilityDelegator, expectedModes: AbilityConstant.WindowMode[]): boolean {\n  const topAbility: AbilityInfo | null = abilityDelegator.getCurrentTopAbility();\n  if (!topAbility) {\n    return false;\n  }\n  \n  const supportedModes: AbilityConstant.WindowMode[] = topAbility.supportWindowModes;\n  if (!supportedModes) {\n    return false;\n  }\n  \n  return expectedModes.every(mode => supportedModes.includes(mode));\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.addAbilityMonitor` to monitor an ability's lifecycle events and then uses `AbilityInfo.launchType` to determine if the ability is launched as a singleton or standard type. Based on the launch type, the function should either wait for the ability to be foregrounded using `AbilityDelegator.waitAbilityMonitor` or terminate it using `AbilityDelegator.doAbilityBackground`.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityConstant, AbilityInfo} from '@kit.AbilityKit';\n\nexport function monitorAndControlAbility(delegator: AbilityDelegator, abilityInfo: AbilityInfo): void {\n  const abilityName = abilityInfo.name;\n  const monitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (ability) => {\n      console.log(`Ability ${abilityName} created`);\n    },\n    onAbilityForeground: (ability) => {\n      console.log(`Ability ${abilityName} foregrounded`);\n    },\n    onAbilityBackground: (ability) => {\n      console.log(`Ability ${abilityName} backgrounded`);\n    },\n    onAbilityDestroy: (ability) => {\n      console.log(`Ability ${abilityName} destroyed`);\n    }\n  };\n\n  delegator.addAbilityMonitor(monitor);\n\n  if (abilityInfo.launchType === AbilityConstant.LaunchType.SINGLETON) {\n    delegator.waitAbilityMonitor(monitor, (err, data) => {\n      if (err) {\n        console.error(`Failed to wait for ability ${abilityName}: ${err}`);\n        return;\n      }\n      console.log(`Ability ${abilityName} is now in foreground`);\n    });\n  } else {\n    delegator.doAbilityBackground(abilityName, (err) => {\n      if (err) {\n        console.error(`Failed to background ability ${abilityName}: ${err}`);\n        return;\n      }\n      console.log(`Ability ${abilityName} has been backgrounded`);\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onMemoryLevel` method of `Ability` to monitor memory levels and, when a critical level is detected, retrieves the `pid` and `processName` from `AbilityRunningInfo` to log or terminate the process with the highest memory usage.",
    "input": "",
    "output": "import {Ability, AbilityRunningInfo, AbilityResult} from '@kit.AbilityKit';\n\nexport class MemoryMonitorAbility extends Ability {\n  private highestMemoryProcess: {pid: number, processName: string} | null = null;\n\n  onMemoryLevel(level: string): void {\n    if (level === 'CRITICAL') {\n      this.handleCriticalMemoryLevel();\n    }\n  }\n\n  private handleCriticalMemoryLevel(): void {\n    const runningInfo: AbilityRunningInfo[] = this.context.getRunningProcessInformation();\n    if (!runningInfo || runningInfo.length === 0) {\n      return;\n    }\n\n    this.highestMemoryProcess = {\n      pid: runningInfo[0].pid,\n      processName: runningInfo[0].processName\n    };\n\n    // Log the process with highest memory usage\n    console.log(`Critical memory level detected. Highest memory process: PID=${this.highestMemoryProcess.pid}, Name=${this.highestMemoryProcess.processName}`);\n\n    // Optionally terminate the process\n    // this.terminateHighestMemoryProcess();\n  }\n\n  private terminateHighestMemoryProcess(): void {\n    if (!this.highestMemoryProcess) {\n      return;\n    }\n\n    const result: AbilityResult = this.context.terminateSelf();\n    if (result.resultCode === 0) {\n      console.log(`Successfully terminated process: ${this.highestMemoryProcess.processName}`);\n    } else {\n      console.error(`Failed to terminate process: ${this.highestMemoryProcess.processName}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onConfigurationUpdate` method of `Ability` to detect configuration changes (e.g., screen rotation) and then uses the `abilityState` property of `AbilityRunningInfo` to check if the ability is still active before applying the new configuration settings.",
    "input": "",
    "output": "import {Ability, AbilityRunningInfo, AbilityResult} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  onConfigurationUpdate(newConfig) {\n    const abilityRunningInfo: AbilityRunningInfo = this.context.getRunningInfo();\n    if (abilityRunningInfo.abilityState === 0) { // 0 indicates the ability is active\n      // Apply new configuration settings here\n      console.log('Applying new configuration settings:', newConfig);\n    } else {\n      console.log('Ability is not active, skipping configuration update');\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that captures the `resultCode` and `want` properties from an `AbilityResult` object after an ability finishes, then uses the `startTime` property of `AbilityRunningInfo` to calculate the duration the ability was running and logs the result along with the duration.",
    "input": "",
    "output": "import {Ability, AbilityRunningInfo, AbilityResult} from '@kit.AbilityKit';\n\nexport function captureAbilityResultAndLogDuration(abilityResult: AbilityResult, abilityRunningInfo: AbilityRunningInfo): void {\n  const {resultCode, want} = abilityResult;\n  const {startTime} = abilityRunningInfo;\n  \n  const currentTime = new Date().getTime();\n  const duration = currentTime - startTime;\n  \n  console.log(`Ability resultCode: ${resultCode}, want: ${JSON.stringify(want)}, duration: ${duration}ms`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityInfo.exported` to check if an ability is exported, and then uses `AbilityLifecycleCallback.onAbilityCreate` to initialize the ability if it is exported. The function should return the initialization status.",
    "input": "",
    "output": "import {AbilityConstant, AbilityInfo, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport function checkAndInitializeAbility(abilityInfo: AbilityInfo, callback: AbilityLifecycleCallback): boolean {\n  if (abilityInfo.exported) {\n    callback.onAbilityCreate();\n    return true;\n  }\n  return false;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `AbilityInfo.launchType` of an ability and then uses `AbilityConstant.LaunchReason` to determine if the ability was launched by the user or the system. The function should return the launch reason along with the ability's launch type.",
    "input": "",
    "output": "import {AbilityConstant, AbilityInfo, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport function getAbilityLaunchInfo(abilityInfo: AbilityInfo): {launchType: AbilityInfo.LaunchType, launchReason: AbilityConstant.LaunchReason} {\n  const launchType = abilityInfo.launchType;\n  const launchReason = AbilityConstant.LaunchReason;\n  return {launchType, launchReason};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks the `AbilityInfo.supportWindowModes` property to determine the supported window modes of an ability, and then uses `AbilityConstant.WindowMode` to verify if a specific window mode is supported. The function should return true if the window mode is supported, otherwise false.",
    "input": "",
    "output": "import {AbilityConstant, AbilityInfo, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport function isWindowModeSupported(abilityInfo: AbilityInfo, windowMode: AbilityConstant.WindowMode): boolean {\n  if (!abilityInfo.supportWindowModes) {\n    return false;\n  }\n  return abilityInfo.supportWindowModes.includes(windowMode);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create an ability that implements `AbilityLifecycleCallback` to monitor lifecycle events. Use `onAbilityCreate` to initialize resources and `onWindowStageCreate` to set up the UI. Then, in the `Ability` class, override `onConfigurationUpdate` to handle configuration changes and update the UI accordingly, ensuring the `AbilityLifecycleCallback` methods are triggered appropriately during these updates.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, Ability } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback implements AbilityLifecycleCallback {\n  onAbilityCreate(ability: Ability): void {\n    // Initialize resources here\n  }\n\n  onWindowStageCreate(ability: Ability): void {\n    // Set up UI here\n  }\n\n  onAbilityBackground(ability: Ability): void {\n    // Handle ability background event\n  }\n\n  onAbilityContinue(ability: Ability): void {\n    // Handle ability continue event\n  }\n\n  onAbilityDestroy(ability: Ability): void {\n    // Handle ability destroy event\n  }\n\n  onAbilityForeground(ability: Ability): void {\n    // Handle ability foreground event\n  }\n\n  onWindowStageActive(ability: Ability): void {\n    // Handle window stage active event\n  }\n\n  onWindowStageDestroy(ability: Ability): void {\n    // Handle window stage destroy event\n  }\n\n  onWindowStageInactive(ability: Ability): void {\n    // Handle window stage inactive event\n  }\n}\n\nexport class MyAbility extends Ability {\n  private lifecycleCallback: MyAbilityLifecycleCallback;\n\n  onCreate() {\n    this.lifecycleCallback = new MyAbilityLifecycleCallback();\n    this.lifecycleCallback.onAbilityCreate(this);\n  }\n\n  onWindowStageCreate(windowStage: any): void {\n    this.lifecycleCallback.onWindowStageCreate(this);\n  }\n\n  onConfigurationUpdate(newConfig: any): void {\n    // Handle configuration changes and update UI accordingly\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Develop a feature where `AbilityLifecycleCallback`'s `onAbilityForeground` is used to resume a paused task when the ability comes to the foreground. Then, in the `Ability` class, use `onMemoryLevel` to check the current memory level and pause or resume background tasks based on the memory level, ensuring coordination between the two APIs for optimal performance.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, Ability } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private pausedTask: () => void = () => {};\n  private resumedTask: () => void = () => {};\n\n  onAbilityForeground(ability: Ability): void {\n    this.resumedTask();\n  }\n\n  setPausedTask(task: () => void): void {\n    this.pausedTask = task;\n  }\n\n  setResumedTask(task: () => void): void {\n    this.resumedTask = task;\n  }\n}\n\nexport class MyAbility extends Ability {\n  private myLifecycleCallback: MyAbilityLifecycleCallback = new MyAbilityLifecycleCallback();\n  private backgroundTaskActive: boolean = true;\n\n  onMemoryLevel(level: number): void {\n    if (level < 30) {\n      this.myLifecycleCallback.setPausedTask(() => {\n        this.backgroundTaskActive = false;\n      });\n    } else {\n      this.myLifecycleCallback.setResumedTask(() => {\n        this.backgroundTaskActive = true;\n      });\n    }\n  }\n\n  onCreate(): void {\n    this.context.registerAbilityLifecycleCallback(this.myLifecycleCallback);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a scenario where `AbilityLifecycleCallback`'s `onWindowStageDestroy` is used to clean up resources when the window stage is destroyed. Then, in the `Ability` class, use `onMemoryLevel` to detect low memory conditions and trigger `onWindowStageDestroy` manually if necessary, ensuring resource cleanup happens even before the system calls it.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, Ability } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onWindowStageDestroy(): void {\n    // Clean up resources here\n    console.log('Cleaning up resources in onWindowStageDestroy');\n  }\n}\n\nexport class MyAbility extends Ability {\n  private lifecycleCallback: MyAbilityLifecycleCallback = new MyAbilityLifecycleCallback();\n\n  onMemoryLevel(level: number): void {\n    if (level < 0) {\n      // Trigger cleanup manually if low memory condition is detected\n      this.lifecycleCallback.onWindowStageDestroy();\n    }\n  }\n\n  onCreate(): void {\n    this.context.registerAbilityLifecycleCallback(this.lifecycleCallback);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onAbilityCreate` method of `AbilityLifecycleCallback` to monitor when an ability is created, and then retrieves the `bundleName` and `moduleName` properties from the `AbilityInfo` object associated with that ability to log its identity.",
    "input": "",
    "output": "import {AbilityInfo, AbilityLifecycleCallback, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(abilityRunningInfo: AbilityRunningInfo): void {\n    const abilityInfo: AbilityInfo = abilityRunningInfo.ability;\n    const bundleName: string = abilityInfo.bundleName;\n    const moduleName: string = abilityInfo.moduleName;\n    console.log(`Ability created with bundleName: ${bundleName}, moduleName: ${moduleName}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onAbilityForeground` method of `AbilityLifecycleCallback` to detect when an ability comes to the foreground, and then accesses the `abilityState` property of the `AbilityRunningInfo` object to check if the ability is in the correct state before performing a specific action.",
    "input": "",
    "output": "import {AbilityInfo, AbilityLifecycleCallback, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(abilityRunningInfo: AbilityRunningInfo): void {\n    if (abilityRunningInfo.abilityState === 0) { // Assuming 0 is the correct state\n      // Perform specific action here\n    }\n  }\n}\n\nexport function registerAbilityLifecycleCallback(callback: MyAbilityLifecycleCallback): void {\n  // Register the callback implementation here\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `onWindowStageCreate` method of `AbilityLifecycleCallback` to track window stage creation, and then retrieves the `windowSize` property from the `AbilityInfo` object to adjust the window dimensions dynamically based on the ability's configuration.",
    "input": "",
    "output": "import { AbilityInfo, AbilityLifecycleCallback, AbilityRunningInfo } from '@kit.AbilityKit';\n\nexport class CustomAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onWindowStageCreate(abilityRunningInfo: AbilityRunningInfo): void {\n    const abilityInfo: AbilityInfo = abilityRunningInfo.ability;\n    if (abilityInfo && abilityInfo.windowSize) {\n      const { windowSize } = abilityInfo;\n      console.log(`Window dimensions: width=${windowSize.width}, height=${windowSize.height}`);\n      // Adjust window dimensions dynamically based on the ability's configuration\n      // Implementation for adjusting window dimensions would go here\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `onAbilityCreate` and `onWindowStageCreate` methods of `AbilityLifecycleCallback` to initialize an Ability, and then uses the `onConfigurationUpdate` method of `Ability` to handle configuration changes during the Ability's lifecycle.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, Ability } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(ability: Ability): void {\n    // Initialize the Ability here\n  }\n\n  onWindowStageCreate(ability: Ability): void {\n    // Initialize the window stage here\n  }\n}\n\nexport class MyAbility extends Ability {\n  onConfigurationUpdate(config: any): void {\n    // Handle configuration changes here\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a scenario where the `onAbilityForeground` method of `AbilityLifecycleCallback` is used to bring an Ability to the foreground, and then the `onMemoryLevel` method of `Ability` is called to check and handle memory levels while the Ability is active.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, Ability } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(ability: Ability): void {\n    console.log('Ability is brought to the foreground');\n  }\n}\n\nexport class MyAbility extends Ability {\n  onMemoryLevel(level: number): void {\n    console.log(`Current memory level: ${level}`);\n    // Handle memory level changes here\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onWindowStageDestroy` method of `AbilityLifecycleCallback` to clean up resources when a window stage is destroyed, and then invokes the `onAbilityDestroy` method of `AbilityLifecycleCallback` to finalize the Ability's termination process.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, Ability } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onWindowStageDestroy(ability: Ability): void {\n    // Clean up resources when window stage is destroyed\n  }\n\n  onAbilityDestroy(ability: Ability): void {\n    // Finalize the Ability's termination process\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `bundleName` property of `AbilityDelegatorArgs` to retrieve the bundle name, then uses this bundle name to filter and find the corresponding `AbilityInfo` object from a list of abilities by checking its `bundleName` property. Finally, return the `moduleName` and `launchType` properties of the matched `AbilityInfo`.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegatorArgs, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function getAbilityInfoProperties(args: AbilityDelegatorArgs, abilities: AbilityInfo[]): {moduleName: string, launchType: number} | undefined {\n  const bundleName = args.bundleName;\n  const matchedAbility = abilities.find((ability: AbilityInfo) => ability.bundleName === bundleName);\n  \n  if (matchedAbility) {\n    return {\n      moduleName: matchedAbility.moduleName,\n      launchType: matchedAbility.launchType\n    };\n  }\n  \n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes a list of `AbilityInfo` objects and uses their `type` and `subType` properties to categorize them. Then, use the `testCaseNames` property of `AbilityDelegatorArgs` to filter and return only those abilities whose names match any of the test case names provided in the `AbilityDelegatorArgs` object.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegatorArgs, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function categorizeAndFilterAbilities(abilityInfos: AbilityInfo[], delegatorArgs: AbilityDelegatorArgs): AbilityInfo[] {\n  // Categorize abilities by type and subType\n  const categorizedAbilities: Record<string, Record<string, AbilityInfo[]>> = {};\n  \n  for (const abilityInfo of abilityInfos) {\n    const type = abilityInfo.type;\n    const subType = abilityInfo.subType;\n    \n    if (!categorizedAbilities[type]) {\n      categorizedAbilities[type] = {};\n    }\n    \n    if (!categorizedAbilities[type][subType]) {\n      categorizedAbilities[type][subType] = [];\n    }\n    \n    categorizedAbilities[type][subType].push(abilityInfo);\n  }\n  \n  // Filter abilities based on testCaseNames\n  const testCaseNames = delegatorArgs.testCaseNames || [];\n  const filteredAbilities: AbilityInfo[] = [];\n  \n  for (const abilityInfo of abilityInfos) {\n    if (testCaseNames.includes(abilityInfo.name)) {\n      filteredAbilities.push(abilityInfo);\n    }\n  }\n  \n  return filteredAbilities;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `parameters` property of `AbilityDelegatorArgs` to get a list of parameters, then checks each parameter against the `permissions` property of `AbilityInfo` to determine if the ability has the required permissions. Return a list of abilities that meet all the permission requirements specified in the parameters.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegatorArgs, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function filterAbilitiesByPermissions(abilityDelegatorArgs: AbilityDelegatorArgs, abilities: AbilityInfo[]): AbilityInfo[] {\n  const parameters: string[] = abilityDelegatorArgs.parameters || [];\n  const result: AbilityInfo[] = [];\n\n  for (const ability of abilities) {\n    const abilityPermissions: string[] = ability.permissions || [];\n    let hasAllPermissions = true;\n\n    for (const param of parameters) {\n      if (!abilityPermissions.includes(param)) {\n        hasAllPermissions = false;\n        break;\n      }\n    }\n\n    if (hasAllPermissions) {\n      result.push(ability);\n    }\n  }\n\n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `startAbility` method of `AbilityDelegator` to launch an ability, then uses the `getCurrentTopAbility` method of `AbilityDelegator` to retrieve the `AbilityRunningInfo` object of the top ability, and finally prints the `abilityState` and `processName` properties of the `AbilityRunningInfo` object using the `printSync` method of `AbilityDelegator`.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityDelegatorArgs, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function launchAndPrintAbilityInfo(delegator: AbilityDelegator, args: AbilityDelegatorArgs): void {\n  delegator.startAbility(args);\n  const topAbility: AbilityRunningInfo | null = delegator.getCurrentTopAbility();\n  if (topAbility) {\n    delegator.printSync(`AbilityState: ${topAbility.abilityState}`);\n    delegator.printSync(`ProcessName: ${topAbility.processName}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes an `AbilityDelegatorArgs` object with `bundleName` and `testCaseNames` properties, then passes this object to the `executeShellCommand` method of `AbilityDelegator` to run a test case, and finally uses the `getAbilityState` method of `AbilityDelegator` to check the state of the ability and prints the result using the `print` method of `AbilityDelegator`.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityDelegatorArgs, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function runTestCaseAndCheckState(bundleName: string, testCaseNames: string[], abilityDelegator: AbilityDelegator): void {\n  const args: AbilityDelegatorArgs = {\n    bundleName: bundleName,\n    testCaseNames: testCaseNames\n  };\n\n  abilityDelegator.executeShellCommand(args);\n  const abilityState: AbilityRunningInfo = abilityDelegator.getAbilityState();\n  abilityDelegator.print(`Ability state: ${abilityState.abilityState}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `addAbilityMonitor` method of `AbilityDelegator` to set up a monitor for an ability, then uses the `waitAbilityMonitor` method of `AbilityDelegator` to wait for the ability to reach a specific state, and finally retrieves the `pid` and `startTime` properties from the `AbilityRunningInfo` object returned by the monitor and prints them using the `printSync` method of `AbilityDelegator`.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityDelegatorArgs, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function monitorAndPrintAbilityInfo(delegator: AbilityDelegator, abilityName: string, state: number): void {\n  const monitor = delegator.addAbilityMonitor({\n    abilityName: abilityName,\n    onAbilityCreate: (ability: AbilityRunningInfo) => {\n      delegator.printSync(`Ability created: ${ability.ability}`);\n    }\n  });\n\n  const abilityInfo: AbilityRunningInfo | null = delegator.waitAbilityMonitor(monitor, state);\n  \n  if (abilityInfo) {\n    delegator.printSync(`pid: ${abilityInfo.pid}`);\n    delegator.printSync(`startTime: ${abilityInfo.startTime}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves all running abilities using `AbilityRunningInfo.ability` and then filters them based on their `AbilityInfo.type` to only include abilities of type 'page'. The function should return an array of the filtered abilities' `AbilityInfo.name` and `AbilityRunningInfo.pid`.",
    "input": "",
    "output": "import {AbilityInfo, AbilityRunningInfo, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function getFilteredPageAbilities(runningInfos: AbilityRunningInfo[]): {name: string, pid: number}[] {\n  const filteredAbilities: {name: string, pid: number}[] = [];\n  \n  for (const runningInfo of runningInfos) {\n    const abilityInfo: AbilityInfo = runningInfo.ability;\n    if (abilityInfo.type === 'page') {\n      filteredAbilities.push({\n        name: abilityInfo.name,\n        pid: runningInfo.pid\n      });\n    }\n  }\n  \n  return filteredAbilities;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes a `bundleName` as input, uses `AbilityInfo.bundleName` to find all abilities belonging to that bundle, and then checks if any of these abilities are currently running by comparing their `AbilityInfo.name` with `AbilityRunningInfo.ability`. The function should return a boolean indicating if at least one ability from the bundle is running.",
    "input": "",
    "output": "import {AbilityInfo, AbilityRunningInfo, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function isBundleAbilityRunning(bundleName: string): boolean {\n  try {\n    const abilityInfos: Array<AbilityInfo> = []; // Assume this is populated with AbilityInfo objects from the bundle\n    const runningInfos: Array<AbilityRunningInfo> = []; // Assume this is populated with AbilityRunningInfo objects\n\n    for (const abilityInfo of abilityInfos) {\n      if (abilityInfo.bundleName === bundleName) {\n        for (const runningInfo of runningInfos) {\n          if (runningInfo.ability === abilityInfo.name) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  } catch (error) {\n    console.error(`Error checking if bundle abilities are running: ${error}`);\n    return false;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that retrieves all abilities with `AbilityInfo.formEnabled` set to true, then checks if any of these abilities are currently running by matching their `AbilityInfo.name` with `AbilityRunningInfo.ability`. For each running form ability, the function should return an object containing `AbilityInfo.label` and `AbilityRunningInfo.startTime`.",
    "input": "",
    "output": "import {AbilityInfo, AbilityRunningInfo, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function getRunningFormAbilitiesInfo(): Array<{label: string, startTime: number}> {\n  const formAbilities: AbilityInfo[] = [];\n  const runningFormAbilitiesInfo: Array<{label: string, startTime: number}> = [];\n  \n  try {\n    // Retrieve all abilities with formEnabled set to true\n    const abilityInfos: AbilityInfo[] = []; // This should be populated with actual AbilityInfo objects\n    for (const abilityInfo of abilityInfos) {\n      if (abilityInfo.formEnabled) {\n        formAbilities.push(abilityInfo);\n      }\n    }\n    \n    // Get all running abilities\n    const runningAbilities: AbilityRunningInfo[] = []; // This should be populated with actual AbilityRunningInfo objects\n    \n    // Check if any form abilities are running\n    for (const formAbility of formAbilities) {\n      for (const runningAbility of runningAbilities) {\n        if (formAbility.name === runningAbility.ability) {\n          runningFormAbilitiesInfo.push({\n            label: formAbility.label,\n            startTime: runningAbility.startTime\n          });\n          break;\n        }\n      }\n    }\n  } catch (error) {\n    console.error(`Failed to get running form abilities info: ${error}`);\n  }\n  \n  return runningFormAbilitiesInfo;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that monitors the lifecycle of an ability by implementing `AbilityLifecycleCallback` methods (`onAbilityCreate`, `onAbilityForeground`, `onAbilityBackground`, `onAbilityDestroy`) and logs the current `StateType` (from `AbilityConstant`) whenever the ability's state changes. Use the `type` property of `AbilityInfo` to filter and log only for abilities of type 'page'.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityConstant, AbilityInfo} from '@kit.AbilityKit';\n\nexport class AbilityLifecycleMonitor implements AbilityLifecycleCallback {\n  onAbilityCreate(ability: AbilityInfo): void {\n    if (ability.type === 'page') {\n      console.log(`Ability created: ${ability.name}, State: ${AbilityConstant.StateType.CREATE}`);\n    }\n  }\n\n  onAbilityForeground(ability: AbilityInfo): void {\n    if (ability.type === 'page') {\n      console.log(`Ability foreground: ${ability.name}, State: ${AbilityConstant.StateType.FOREGROUND}`);\n    }\n  }\n\n  onAbilityBackground(ability: AbilityInfo): void {\n    if (ability.type === 'page') {\n      console.log(`Ability background: ${ability.name}, State: ${AbilityConstant.StateType.BACKGROUND}`);\n    }\n  }\n\n  onAbilityDestroy(ability: AbilityInfo): void {\n    if (ability.type === 'page') {\n      console.log(`Ability destroyed: ${ability.name}, State: ${AbilityConstant.StateType.DESTROY}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility function that checks if an ability can continue after being backgrounded. Use `AbilityLifecycleCallback.onAbilityContinue` to trigger the check and return the `ContinueState` (from `AbilityConstant`) based on the ability's `launchMode` (from `AbilityInfo`). The function should return 'CONTINUE' if the launch mode is 'standard' and 'REJECT' otherwise.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityConstant, AbilityInfo} from '@kit.AbilityKit';\n\nexport class ContinueCheckCallback extends AbilityLifecycleCallback {\n  onAbilityContinue(abilityInfo: AbilityInfo): AbilityConstant.ContinueState {\n    if (abilityInfo.launchMode === AbilityInfo.LaunchMode.STANDARD) {\n      return AbilityConstant.ContinueState.CONTINUE;\n    } else {\n      return AbilityConstant.ContinueState.REJECT;\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that tracks the memory level of an ability during its lifecycle. Use `AbilityLifecycleCallback.onWindowStageCreate` and `onWindowStageDestroy` to monitor window stage events, and log the `MemoryLevel` (from `AbilityConstant`) alongside the `name` and `bundleName` properties of `AbilityInfo` for debugging purposes.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityConstant, AbilityInfo} from '@kit.AbilityKit';\n\nexport class MemoryLevelTracker extends AbilityLifecycleCallback {\n  onWindowStageCreate(abilityInfo: AbilityInfo): void {\n    const memoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE;\n    console.log(`WindowStageCreate - Name: ${abilityInfo.name}, BundleName: ${abilityInfo.bundleName}, MemoryLevel: ${memoryLevel}`);\n  }\n\n  onWindowStageDestroy(abilityInfo: AbilityInfo): void {\n    const memoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE;\n    console.log(`WindowStageDestroy - Name: ${abilityInfo.name}, BundleName: ${abilityInfo.bundleName}, MemoryLevel: ${memoryLevel}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that monitors the memory level of an ability using the `onMemoryLevel` method of `Ability` and logs the current memory level by comparing it with the `MemoryLevel` enum values from `AbilityConstant`. The function should also use the `abilityState` property of `AbilityRunningInfo` to check if the ability is still running before logging the memory level.",
    "input": "",
    "output": "import {Ability, AbilityConstant, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class MemoryMonitor {\n  private ability: Ability;\n  private runningInfo: AbilityRunningInfo;\n\n  constructor(ability: Ability, runningInfo: AbilityRunningInfo) {\n    this.ability = ability;\n    this.runningInfo = runningInfo;\n  }\n\n  public monitorMemoryLevel(): void {\n    this.ability.onMemoryLevel((level: AbilityConstant.MemoryLevel) => {\n      if (this.runningInfo.abilityState === AbilityConstant.StateType.RUNNING) {\n        switch (level) {\n          case AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE:\n            console.log('Current memory level: MODERATE');\n            break;\n          case AbilityConstant.MemoryLevel.MEMORY_LEVEL_LOW:\n            console.log('Current memory level: LOW');\n            break;\n          case AbilityConstant.MemoryLevel.MEMORY_LEVEL_CRITICAL:\n            console.log('Current memory level: CRITICAL');\n            break;\n          default:\n            console.log('Current memory level: UNKNOWN');\n            break;\n        }\n      }\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `AbilityRunningInfo` of an ability, checks its `abilityState` property, and based on the state, uses the `onConfigurationUpdate` method of `Ability` to handle configuration changes. The function should also use the `StateType` enum from `AbilityConstant` to validate the ability state before proceeding with the configuration update.",
    "input": "",
    "output": "import {Ability, AbilityConstant, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function handleAbilityConfigurationUpdate(ability: Ability): void {\n  const runningInfo: AbilityRunningInfo = ability.getAbilityRunningInfo();\n  const abilityState: AbilityConstant.StateType = runningInfo.abilityState;\n\n  if (abilityState === AbilityConstant.StateType.INITIAL || \n      abilityState === AbilityConstant.StateType.ACTIVE || \n      abilityState === AbilityConstant.StateType.INACTIVE) {\n    ability.onConfigurationUpdate();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `LastExitReason` enum from `AbilityConstant` to determine the reason for an ability's last exit and then uses the `startTime` property of `AbilityRunningInfo` to calculate how long the ability has been running since its last start. The function should pass this calculated duration to the `onMemoryLevel` method of `Ability` to adjust memory usage based on the runtime duration.",
    "input": "",
    "output": "import {Ability, AbilityConstant, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function handleAbilityExitAndMemory(ability: Ability, runningInfo: AbilityRunningInfo, lastExitReason: AbilityConstant.LastExitReason): void {\n  const currentTime: number = new Date().getTime();\n  const startTime: number = runningInfo.startTime;\n  const duration: number = currentTime - startTime;\n  \n  ability.onMemoryLevel(lastExitReason, duration);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `AbilityInfo` property `bundleName` to filter abilities from a given list, then creates an `AbilityMonitor` for each filtered ability using its `abilityName` and `moduleName` properties. The function should set up the `onAbilityCreate` callback in each monitor to log the creation of monitored abilities.",
    "input": "",
    "output": "import { AbilityInfo, AbilityMonitor } from '@kit.AbilityKit';\n\nexport function filterAndMonitorAbilities(abilityInfos: AbilityInfo[], targetBundleName: string): AbilityMonitor[] {\n  const filteredAbilities = abilityInfos.filter((abilityInfo: AbilityInfo) => {\n    return abilityInfo.bundleName === targetBundleName;\n  });\n\n  const monitors: AbilityMonitor[] = [];\n\n  filteredAbilities.forEach((abilityInfo: AbilityInfo) => {\n    const monitor = new AbilityMonitor({\n      abilityName: abilityInfo.name,\n      moduleName: abilityInfo.moduleName\n    });\n\n    monitor.onAbilityCreate = (ability) => {\n      console.log(`Ability created: ${abilityInfo.name}`);\n    };\n\n    monitors.push(monitor);\n  });\n\n  return monitors;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves all abilities with `type` set to 'page' from `AbilityInfo`, then dynamically registers an `AbilityMonitor` for each of these abilities. The monitors should use the `onWindowStageCreate` callback to track when the abilities enter the foreground, and the `onAbilityDestroy` callback to log their destruction. The function should return the list of registered monitors.",
    "input": "",
    "output": "import { AbilityInfo, AbilityMonitor } from '@kit.AbilityKit';\n\nexport function registerAbilityMonitors(abilityInfos: AbilityInfo[]): AbilityMonitor[] {\n  const monitors: AbilityMonitor[] = [];\n  \n  for (const abilityInfo of abilityInfos) {\n    if (abilityInfo.type === 'page') {\n      const monitor = new AbilityMonitor({\n        abilityName: abilityInfo.name,\n        moduleName: abilityInfo.moduleName,\n        onWindowStageCreate: () => {\n          console.log(`Ability ${abilityInfo.name} entered foreground`);\n        },\n        onAbilityDestroy: () => {\n          console.log(`Ability ${abilityInfo.name} was destroyed`);\n        }\n      });\n      monitors.push(monitor);\n    }\n  }\n  \n  return monitors;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that checks if an ability with a specific `bundleName` and `abilityName` (from `AbilityInfo`) is currently running by using an `AbilityMonitor` with the corresponding `abilityName` and `moduleName`. The function should use the `onAbilityForeground` and `onAbilityBackground` callbacks to monitor the ability's state and return a boolean indicating whether it is in the foreground.",
    "input": "",
    "output": "import { AbilityInfo, AbilityMonitor } from '@kit.AbilityKit';\n\nexport function isAbilityRunning(bundleName: string, abilityName: string, moduleName: string): boolean {\n  let isForeground = false;\n  \n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityForeground: (abilityInfo: AbilityInfo) => {\n      if (abilityInfo.bundleName === bundleName && abilityInfo.name === abilityName) {\n        isForeground = true;\n      }\n    },\n    onAbilityBackground: (abilityInfo: AbilityInfo) => {\n      if (abilityInfo.bundleName === bundleName && abilityInfo.name === abilityName) {\n        isForeground = false;\n      }\n    }\n  };\n  \n  return isForeground;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `bundleName` property of `AbilityDelegatorArgs` to identify the current ability's bundle, then checks if the ability's configuration has been updated by implementing the `onConfigurationUpdate` method of `Ability`. The function should return a boolean indicating whether the configuration was updated for the specified bundle.",
    "input": "",
    "output": "import {Ability, AbilityDelegatorArgs, AbilityConstant} from '@kit.AbilityKit';\n\nexport class ConfigurationChecker extends Ability {\n  private bundleName: string;\n  private configUpdated: boolean = false;\n\n  constructor(args: AbilityDelegatorArgs) {\n    super();\n    this.bundleName = args.bundleName;\n  }\n\n  onConfigurationUpdate(newConfig: AbilityConstant.Configuration): void {\n    this.configUpdated = true;\n    super.onConfigurationUpdate(newConfig);\n  }\n\n  public isConfigurationUpdated(): boolean {\n    return this.configUpdated;\n  }\n\n  public getBundleName(): string {\n    return this.bundleName;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that monitors the memory level of an ability by implementing the `onMemoryLevel` method of `Ability`. Based on the received `MemoryLevel` enum value from `AbilityConstant`, the function should log different warning messages if the memory level is critical (e.g., `MemoryLevel.LOW` or `MemoryLevel.CRITICAL`).",
    "input": "",
    "output": "import {Ability, AbilityDelegatorArgs, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  onMemoryLevel(level: AbilityConstant.MemoryLevel): void {\n    switch (level) {\n      case AbilityConstant.MemoryLevel.LOW:\n        console.warn('Warning: Memory level is LOW');\n        break;\n      case AbilityConstant.MemoryLevel.CRITICAL:\n        console.warn('Warning: Memory level is CRITICAL');\n        break;\n      default:\n        console.log('Memory level is normal');\n        break;\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `parameters` property of `AbilityDelegatorArgs` to retrieve test parameters, then determines the ability's launch reason by accessing the `LaunchReason` enum from `AbilityConstant`. The function should return a custom message based on whether the launch reason was `LaunchReason.START_ABILITY` or `LaunchReason.CALL`.",
    "input": "",
    "output": "import {Ability, AbilityDelegatorArgs, AbilityConstant} from '@kit.AbilityKit';\n\nexport function getLaunchReasonMessage(args: AbilityDelegatorArgs): string {\n  const parameters = args.parameters;\n  if (parameters && parameters.launchReason) {\n    const launchReason: AbilityConstant.LaunchReason = parameters.launchReason;\n    if (launchReason === AbilityConstant.LaunchReason.START_ABILITY) {\n      return 'Ability was launched via START_ABILITY';\n    } else if (launchReason === AbilityConstant.LaunchReason.CALL) {\n      return 'Ability was launched via CALL';\n    }\n  }\n  return 'Unknown launch reason';\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `bundleName` and `moduleName` from an `AbilityInfo` object, then uses these values to determine the `LaunchReason` from `AbilityConstant` (e.g., whether the ability was launched by the user or system). The function should return a formatted string combining the ability details and launch reason.",
    "input": "",
    "output": "import {AbilityInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function getAbilityLaunchDetails(abilityInfo: AbilityInfo, launchReason: AbilityConstant.LaunchReason): string {\n  const { bundleName, moduleName } = abilityInfo;\n  let reason: string;\n\n  switch (launchReason) {\n    case AbilityConstant.LaunchReason.LAUNCHER:\n      reason = 'Launched by user';\n      break;\n    case AbilityConstant.LaunchReason.START_ABILITY:\n      reason = 'Launched by system';\n      break;\n    default:\n      reason = 'Unknown launch reason';\n  }\n\n  return `Bundle: ${bundleName}, Module: ${moduleName}, Reason: ${reason}`;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks if an ability (using its `AbilityInfo` properties `type`, `supportWindowModes`, and `windowSize`) is compatible with a specific `WindowMode` from `AbilityConstant`. The function should return a boolean indicating whether the ability can be launched in the given window mode (e.g., fullscreen, split-screen).",
    "input": "",
    "output": "import { AbilityInfo, AbilityConstant } from '@kit.AbilityKit';\n\nexport function isWindowModeCompatible(abilityInfo: AbilityInfo, windowMode: AbilityConstant.WindowMode): boolean {\n  if (!abilityInfo.supportWindowModes || abilityInfo.supportWindowModes.length === 0) {\n    return false;\n  }\n  \n  return abilityInfo.supportWindowModes.includes(windowMode);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `enabled` and `exported` properties of `AbilityInfo` to filter abilities, then maps the filtered list to their corresponding `StateType` (from `AbilityConstant`) based on their current state (e.g., `INITIAL`, `ACTIVE`). The function should return an array of objects containing the ability name and its inferred state.",
    "input": "",
    "output": "import {AbilityInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function filterAndMapAbilities(abilities: AbilityInfo[]): {name: string, state: AbilityConstant.StateType}[] {\n  const filteredAbilities = abilities.filter(ability => ability.enabled && ability.exported);\n  \n  return filteredAbilities.map(ability => {\n    let state: AbilityConstant.StateType;\n    \n    // Infer state based on some condition (this is a simplified example)\n    // In a real implementation, you would use actual state detection logic\n    state = AbilityConstant.StateType.INITIAL;\n    \n    return {\n      name: ability.name,\n      state: state\n    };\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create an AbilityLifecycleCallback implementation that tracks the lifecycle state of an Ability by using `onAbilityCreate`, `onAbilityForeground`, and `onAbilityBackground` methods. Then, use the `onConfigurationUpdate` method of the Ability class to log configuration changes only when the Ability is in the foreground (as tracked by the callback).",
    "input": "",
    "output": "import { Ability, AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback implements AbilityLifecycleCallback {\n  private isForeground: boolean = false;\n\n  onAbilityCreate(ability: Ability): void {\n    console.log('Ability created:', ability.context.abilityInfo?.name);\n  }\n\n  onAbilityForeground(ability: Ability): void {\n    this.isForeground = true;\n    console.log('Ability in foreground:', ability.context.abilityInfo?.name);\n  }\n\n  onAbilityBackground(ability: Ability): void {\n    this.isForeground = false;\n    console.log('Ability in background:', ability.context.abilityInfo?.name);\n  }\n\n  getIsForeground(): boolean {\n    return this.isForeground;\n  }\n}\n\nexport class MyAbility extends Ability {\n  private lifecycleCallback: MyAbilityLifecycleCallback = new MyAbilityLifecycleCallback();\n\n  onCreate(): void {\n    this.context.registerAbilityLifecycleCallback(this.lifecycleCallback);\n  }\n\n  onConfigurationUpdate(newConfig: Record<string, any>): void {\n    if (this.lifecycleCallback.getIsForeground()) {\n      console.log('Configuration updated:', newConfig);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature where an Ability uses `onMemoryLevel` to detect low memory conditions and triggers the `onAbilityBackground` method of a registered AbilityLifecycleCallback to gracefully release resources before the system reclaims them.",
    "input": "",
    "output": "import { Ability, AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityBackground(ability: Ability): void {\n    // Release resources gracefully when the ability goes to background\n    console.log('Releasing resources due to low memory condition');\n  }\n}\n\nexport class MyAbility extends Ability {\n  private lifecycleCallback: MyAbilityLifecycleCallback = new MyAbilityLifecycleCallback();\n\n  onCreate(): void {\n    this.context.registerAbilityLifecycleCallback(this.lifecycleCallback);\n  }\n\n  onMemoryLevel(level: number): void {\n    if (level < 0) { // Assuming negative values indicate low memory conditions\n      this.onBackground();\n    }\n  }\n\n  private onBackground(): void {\n    this.lifecycleCallback.onAbilityBackground(this);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a system where an AbilityLifecycleCallback uses `onWindowStageCreate` and `onWindowStageDestroy` to manage window stage resources, and the Ability class uses `onConfigurationUpdate` to adjust the window layout dynamically based on configuration changes (e.g., screen rotation). The callback must ensure the window stage is recreated if destroyed during the configuration update.",
    "input": "",
    "output": "import { Ability, AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class CustomAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private windowStageDestroyed: boolean = false;\n\n  onWindowStageCreate(ability: Ability): void {\n    console.log('onWindowStageCreate');\n    this.windowStageDestroyed = false;\n    // Initialize window stage resources here\n  }\n\n  onWindowStageDestroy(ability: Ability): void {\n    console.log('onWindowStageDestroy');\n    this.windowStageDestroyed = true;\n    // Clean up window stage resources here\n  }\n\n  isWindowStageDestroyed(): boolean {\n    return this.windowStageDestroyed;\n  }\n}\n\nexport class CustomAbility extends Ability {\n  private lifecycleCallback: CustomAbilityLifecycleCallback = new CustomAbilityLifecycleCallback();\n\n  onCreate(): void {\n    console.log('CustomAbility onCreate');\n    this.registerAbilityLifecycleCallback(this.lifecycleCallback);\n  }\n\n  onConfigurationUpdate(newConfig: Configuration): void {\n    console.log('onConfigurationUpdate');\n    if (this.lifecycleCallback.isWindowStageDestroyed()) {\n      console.log('Recreating window stage');\n      // Recreate window stage if destroyed during configuration update\n      this.restoreWindowStage();\n    }\n    // Adjust window layout based on new configuration\n    this.adjustWindowLayout(newConfig);\n  }\n\n  private restoreWindowStage(): void {\n    // Logic to restore window stage\n  }\n\n  private adjustWindowLayout(config: Configuration): void {\n    // Logic to adjust window layout based on configuration changes\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `bundleName` property of `AbilityDelegatorArgs` to initialize a test configuration, then passes the configuration to a method that sets up an ability test scenario. The function should then use the `resultCode` property of `AbilityResult` to verify the test outcome and log the result.",
    "input": "",
    "output": "import { AbilityResult, AbilityDelegatorArgs } from '@kit.AbilityKit';\n\nexport function setupAndVerifyTest(bundleName: string): void {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    bundleName: bundleName,\n    parameters: {},\n    testCaseNames: [],\n    testRunnerClassName: ''\n  };\n\n  const testConfig = initializeTestConfig(delegatorArgs);\n  const abilityResult = setupAbilityTestScenario(testConfig);\n  \n  if (abilityResult.resultCode === 0) {\n    console.log('Test passed');\n  } else {\n    console.log('Test failed');\n  }\n}\n\nfunction initializeTestConfig(args: AbilityDelegatorArgs): AbilityDelegatorArgs {\n  return args;\n}\n\nfunction setupAbilityTestScenario(config: AbilityDelegatorArgs): AbilityResult {\n  return {\n    resultCode: 0,\n    want: {}\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that constructs an `AbilityDelegatorArgs` object with `testCaseNames` and `parameters` properties, then uses this object to run a series of ability tests. The function should collect the `AbilityResult` objects from each test, extract their `want` properties, and aggregate the results into a summary report.",
    "input": "",
    "output": "import { AbilityResult, AbilityDelegatorArgs } from '@kit.AbilityKit';\n\nexport function runAbilityTests(testCaseNames: string[], parameters: {[key: string]: string}): { [key: string]: string } {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    testCaseNames: testCaseNames,\n    parameters: parameters\n  };\n\n  const abilityResults: AbilityResult[] = [];\n  \n  // Simulate running tests and collecting results\n  // In a real implementation, this would involve calling the appropriate test runner\n  \n  const summaryReport: { [key: string]: string } = {};\n  \n  for (const result of abilityResults) {\n    if (result.want) {\n      summaryReport[result.resultCode.toString()] = JSON.stringify(result.want);\n    }\n  }\n  \n  return summaryReport;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that initializes an `AbilityDelegatorArgs` object with `testRunnerClassName` and `bundleName`, then executes a test suite. The function should check each test's outcome using the `resultCode` property of `AbilityResult` and, if any test fails, use the `want` property to generate a detailed error message.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function executeTestSuite(testRunnerClassName: string, bundleName: string, testCaseNames: string[]): void {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    testRunnerClassName: testRunnerClassName,\n    bundleName: bundleName,\n    testCaseNames: testCaseNames,\n    parameters: {}\n  };\n\n  const testResults: AbilityResult[] = []; // Assume this is populated by test execution\n\n  for (const result of testResults) {\n    if (result.resultCode !== 0) {\n      const errorMessage = `Test failed with result code ${result.resultCode}. Details: ${JSON.stringify(result.want)}`;\n      throw new Error(errorMessage);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `onAbilityContinue` method of `AbilityLifecycleCallback` to handle ability continuation requests. The function should then check the `ContinueState` enum from `AbilityConstant` to determine the continuation state and return an appropriate result (e.g., `OnContinueResult.ACCEPT` if the state is `READY`, or `OnContinueResult.REJECT` if the state is `FAILED`).",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityContinue(wantParam: Record<string, Object>): AbilityConstant.OnContinueResult {\n    const continueState: AbilityConstant.ContinueState = wantParam['continueState'] as AbilityConstant.ContinueState;\n    if (continueState === AbilityConstant.ContinueState.READY) {\n      return AbilityConstant.OnContinueResult.ACCEPT;\n    } else if (continueState === AbilityConstant.ContinueState.FAILED) {\n      return AbilityConstant.OnContinueResult.REJECT;\n    }\n    return AbilityConstant.OnContinueResult.REJECT;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test scenario where `startAbility` from `AbilityDelegator` is used to launch an ability, and then `getAbilityState` from `AbilityDelegator` is used to verify the ability's state, followed by `onAbilityForeground` from `AbilityLifecycleCallback` to confirm the ability has successfully entered the foreground.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegator} from '@kit.AbilityKit';\n\nexport class TestAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private abilityState: string = '';\n\n  onAbilityForeground(ability): void {\n    this.abilityState = 'foreground';\n  }\n\n  getAbilityState(): string {\n    return this.abilityState;\n  }\n}\n\nexport async function testAbilityLifecycle(delegator: AbilityDelegator, want: Want): Promise<void> {\n  const callback = new TestAbilityLifecycleCallback();\n  delegator.addAbilityLifecycleCallback(callback);\n\n  await delegator.startAbility(want);\n  const state = delegator.getAbilityState(want);\n  console.log(`Ability state after start: ${state}`);\n\n  delegator.removeAbilityLifecycleCallback(callback);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegatorArgs.bundleName` to identify the target ability, then registers a callback with `AbilityLifecycleCallback.onAbilityCreate` and `AbilityLifecycleCallback.onAbilityDestroy` to monitor the ability's lifecycle events, logging when the ability is created and destroyed.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private targetBundleName: string;\n\n  constructor(args: AbilityDelegatorArgs) {\n    super();\n    this.targetBundleName = args.bundleName;\n  }\n\n  onAbilityCreate(ability): void {\n    if (ability.context.bundleName === this.targetBundleName) {\n      console.log(`Ability created: ${ability.context.bundleName}`);\n    }\n  }\n\n  onAbilityDestroy(ability): void {\n    if (ability.context.bundleName === this.targetBundleName) {\n      console.log(`Ability destroyed: ${ability.context.bundleName}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityMonitor` to monitor the lifecycle events of a specific ability (using `abilityName` and `onAbilityCreate` properties), then uses `AbilityDelegator.addAbilityMonitor` to register the monitor, and finally checks the ability's state using `AbilityDelegator.getAbilityState` to verify it reached the foreground state.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function monitorAbilityLifecycle(abilityDelegator: AbilityDelegator, abilityName: string): void {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (ability) => {\n      console.log(`Ability ${abilityName} created`);\n    }\n  };\n\n  abilityDelegator.addAbilityMonitor(monitor, (err) => {\n    if (err) {\n      console.error(`Failed to add ability monitor: ${err}`);\n      return;\n    }\n    console.log(`Successfully added monitor for ability ${abilityName}`);\n  });\n\n  const abilityState = abilityDelegator.getAbilityState(monitor);\n  if (abilityState === 2) { // 2 represents the foreground state\n    console.log(`Ability ${abilityName} is in the foreground state`);\n  } else {\n    console.log(`Ability ${abilityName} is not in the foreground state`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `pid` and `processName` from an `AbilityRunningInfo` object, then uses these values to filter and log all running abilities with the same `processName` and a `pid` greater than a specified threshold.",
    "input": "",
    "output": "import {AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function filterAndLogRunningAbilities(abilityInfo: AbilityRunningInfo, thresholdPid: number, runningInfos: AbilityRunningInfo[]): void {\n  const { pid, processName } = abilityInfo;\n  \n  const filteredAbilities = runningInfos.filter(info => {\n    return info.processName === processName && info.pid > thresholdPid;\n  });\n  \n  filteredAbilities.forEach(info => {\n    console.log(`Process Name: ${info.processName}, PID: ${info.pid}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that sets up an `AbilityMonitor` to track the background and foreground events of an ability (using `onAbilityBackground` and `onAbilityForeground`). The function should then use `AbilityDelegator` to manually trigger the ability to go to the background (using `doAbilityBackground`) and then to the foreground (using `doAbilityForeground`), while the monitor logs these transitions. Finally, the function should remove the monitor (using `removeAbilityMonitorSync`) and print the final state of the ability (using `printSync`).",
    "input": "",
    "output": "import { AbilityMonitor, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function monitorAbilityTransitions(abilityDelegator: AbilityDelegator, abilityName: string, moduleName: string): void {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.abilityName = abilityName;\n  monitor.moduleName = moduleName;\n\n  monitor.onAbilityBackground = (ability) => {\n    console.log(`Ability ${abilityName} has entered the background`);\n  };\n\n  monitor.onAbilityForeground = (ability) => {\n    console.log(`Ability ${abilityName} has entered the foreground`);\n  };\n\n  abilityDelegator.addAbilityMonitorSync(monitor);\n\n  abilityDelegator.doAbilityBackground();\n  abilityDelegator.doAbilityForeground();\n\n  abilityDelegator.removeAbilityMonitorSync(monitor);\n  abilityDelegator.printSync();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that adds an ability monitor using `AbilityDelegator.addAbilityMonitorSync` and waits for the ability to be created using `AbilityDelegator.waitAbilityMonitor`. Once the ability is detected, use `AbilityInfo.launchType` to determine its launch type and `AbilityLifecycleCallback.onWindowStageCreate` to log the window stage creation.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityInfo, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport function monitorAbilityAndLogWindowStage(delegator: AbilityDelegator, abilityName: string): void {\n  const abilityMonitor = delegator.addAbilityMonitorSync({\n    abilityName: abilityName\n  });\n\n  delegator.waitAbilityMonitor(abilityMonitor).then((abilityInfo: AbilityInfo) => {\n    const launchType = abilityInfo.launchType;\n    console.log(`Ability launch type: ${launchType}`);\n\n    const lifecycleCallback: AbilityLifecycleCallback = {\n      onWindowStageCreate: () => {\n        console.log('Window stage created');\n      },\n      onAbilityCreate: () => {},\n      onAbilityDestroy: () => {},\n      onAbilityForeground: () => {},\n      onAbilityBackground: () => {},\n      onAbilityContinue: () => {},\n      onWindowStageActive: () => {},\n      onWindowStageDestroy: () => {},\n      onWindowStageInactive: () => {}\n    };\n\n    delegator.registerAbilityLifecycleCallback(lifecycleCallback);\n  }).catch((error: Error) => {\n    console.error(`Error waiting for ability monitor: ${error.message}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.executeShellCommand` to trigger an ability to enter the background, then monitors the background event using `AbilityMonitor` (with `onAbilityBackground` property), and finally uses `AbilityDelegator.doAbilityForeground` to bring the ability back to the foreground and verify its state with `AbilityDelegator.getAbilityState`.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function testAbilityBackgroundToForeground(delegator: AbilityDelegator, abilityName: string, moduleName: string): void {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityBackground: (ability) => {\n      console.log(`Ability ${abilityName} entered background`);\n      delegator.doAbilityForeground(ability);\n      const state = delegator.getAbilityState(ability);\n      console.log(`Ability state after foreground: ${state}`);\n    }\n  };\n\n  delegator.addAbilityMonitor(monitor);\n  delegator.executeShellCommand('background');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first retrieves the `orientation` property from an `AbilityInfo` object to determine the current screen orientation, then uses the `onConfigurationUpdate` method of the `Ability` class to dynamically adjust the UI layout based on the retrieved orientation.",
    "input": "",
    "output": "import {Ability, AbilityDelegatorArgs, AbilityInfo} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  private currentOrientation: string = '';\n\n  onConfigurationUpdate(config: AbilityInfo): void {\n    if (config.orientation) {\n      this.currentOrientation = config.orientation;\n      this.adjustUILayout();\n    }\n  }\n\n  private adjustUILayout(): void {\n    // Implement UI layout adjustment based on this.currentOrientation\n    console.log(`Adjusting UI layout for orientation: ${this.currentOrientation}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onConfigurationUpdate` method of `Ability` to detect configuration changes, and then passes the updated configuration data to the `onAbilityContinue` method of `AbilityLifecycleCallback` to handle the ability's state transition during configuration updates.",
    "input": "",
    "output": "import {Ability, AbilityResult, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  private lifecycleCallback: MyAbilityLifecycleCallback = new MyAbilityLifecycleCallback();\n\n  onConfigurationUpdate(newConfig: object): void {\n    super.onConfigurationUpdate(newConfig);\n    this.lifecycleCallback.onAbilityContinue(this);\n  }\n}\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityContinue(ability: Ability): AbilityResult {\n    const result: AbilityResult = {\n      resultCode: 0,\n      want: ability.context.startAbility ? ability.context.startAbility.bind(ability.context) : undefined\n    };\n    return result;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test scenario where `AbilityDelegatorArgs.testCaseNames` is used to specify test cases, and then implement `AbilityLifecycleCallback.onWindowStageCreate` and `AbilityLifecycleCallback.onWindowStageDestroy` to verify that the window stages are correctly initialized and cleaned up for each test case.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class TestAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private testCaseNames: string[] = [];\n\n  constructor(args: AbilityDelegatorArgs) {\n    super();\n    if (args.testCaseNames) {\n      this.testCaseNames = args.testCaseNames;\n    }\n  }\n\n  onWindowStageCreate(): void {\n    console.log(`onWindowStageCreate called for test cases: ${this.testCaseNames.join(', ')}`);\n  }\n\n  onWindowStageDestroy(): void {\n    console.log(`onWindowStageDestroy called for test cases: ${this.testCaseNames.join(', ')}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks the `backgroundModes` property of `AbilityInfo` to determine if an ability supports background tasks, and then uses the `onMemoryLevel` method of `Ability` to handle memory level changes specifically for abilities running in the background.",
    "input": "",
    "output": "import {Ability, AbilityInfo} from '@kit.AbilityKit';\n\nexport function checkBackgroundModesAndHandleMemory(abilityInfo: AbilityInfo, ability: Ability): void {\n  if (abilityInfo.backgroundModes && abilityInfo.backgroundModes.length > 0) {\n    ability.onMemoryLevel = (level: number) => {\n      // Handle memory level changes for background abilities\n      console.log(`Memory level changed to: ${level}`);\n    };\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Develop a utility that leverages `AbilityDelegatorArgs.parameters` to pass configuration data to an ability, and then uses `AbilityLifecycleCallback.onAbilityForeground` and `AbilityLifecycleCallback.onAbilityBackground` to track and report the ability's transitions between foreground and background states based on the provided parameters.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class AbilityLifecycleTracker extends AbilityLifecycleCallback {\n  private foregroundCount: number = 0;\n  private backgroundCount: number = 0;\n  private parameters: Record<string, string> = {};\n\n  constructor(args: AbilityDelegatorArgs) {\n    super();\n    if (args.parameters) {\n      this.parameters = args.parameters;\n    }\n  }\n\n  onAbilityForeground(): void {\n    this.foregroundCount++;\n    console.log(`Ability moved to foreground. Count: ${this.foregroundCount}. Parameters: ${JSON.stringify(this.parameters)}`);\n  }\n\n  onAbilityBackground(): void {\n    this.backgroundCount++;\n    console.log(`Ability moved to background. Count: ${this.backgroundCount}. Parameters: ${JSON.stringify(this.parameters)}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegatorArgs.bundleName` to retrieve the bundle name of the current test case, then passes it to `AbilityLifecycleCallback.onAbilityCreate` to simulate the creation of an ability with the specified bundle name, and finally verifies the ability's state using `AbilityLifecycleCallback.onAbilityForeground`.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class TestAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private bundleName: string;\n\n  constructor(args: AbilityDelegatorArgs) {\n    super();\n    this.bundleName = args.bundleName;\n  }\n\n  onAbilityCreate(): void {\n    console.log(`Ability with bundle name ${this.bundleName} created`);\n  }\n\n  onAbilityForeground(): void {\n    console.log(`Ability with bundle name ${this.bundleName} is in foreground`);\n  }\n}\n\nexport function testAbilityLifecycle(args: AbilityDelegatorArgs): void {\n  const callback = new TestAbilityLifecycleCallback(args);\n  callback.onAbilityCreate();\n  callback.onAbilityForeground();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `abilityState` and `pid` from an `AbilityRunningInfo` object, then uses these values to call the `onMemoryLevel` method of the `Ability` class to monitor and adjust memory usage for the specified process.",
    "input": "",
    "output": "import {AbilityRunningInfo, Ability} from '@kit.AbilityKit';\n\nexport function monitorAndAdjustMemory(abilityInfo: AbilityRunningInfo, ability: Ability): void {\n  const { abilityState, pid } = abilityInfo;\n  ability.onMemoryLevel(abilityState, pid);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch an ability and then checks its state using `AbilityInfo.name` and `AbilityDelegator.getAbilityState`. The function should return the ability state if the launched ability matches the target ability name.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegator, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function launchAndCheckAbilityState(\n  delegator: AbilityDelegator,\n  targetAbilityName: string,\n  abilityDelegatorArgs: AbilityDelegatorArgs\n): string | undefined {\n  delegator.startAbility(abilityDelegatorArgs);\n  const abilityState = delegator.getAbilityState(targetAbilityName);\n  return abilityState;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch an ability and then checks its state using `AbilityDelegator.getAbilityState`. The function should return the ability's state (e.g., `AbilityConstant.StateType.READY`) and verify if the ability's `bundleName` (from `AbilityInfo`) matches the expected value.",
    "input": "",
    "output": "import {AbilityConstant, AbilityDelegator, AbilityInfo} from '@kit.AbilityKit';\n\nexport async function checkAbilityStateAndBundleName(\n  delegator: AbilityDelegator,\n  want: Want,\n  expectedBundleName: string\n): Promise<{state: AbilityConstant.StateType, isBundleNameMatch: boolean}> {\n  await delegator.startAbility(want);\n  const abilityState = delegator.getAbilityState(want);\n  const abilityInfo: AbilityInfo = await delegator.getCurrentTopAbility();\n  const isBundleNameMatch = abilityInfo.bundleName === expectedBundleName;\n  return {state: abilityState, isBundleNameMatch};\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` instance to track the lifecycle events of a specific ability (using `abilityName` and `moduleName` properties) and then passes this monitor to an `AbilityDelegatorArgs` instance (via its `parameters` property) to configure a test case that verifies the ability's background/foreground transitions (using `onAbilityBackground` and `onAbilityForeground` callbacks).",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function createAbilityMonitorAndConfigureTest(abilityName: string, moduleName: string): AbilityDelegatorArgs {\n  const abilityMonitor = new AbilityMonitor();\n  abilityMonitor.abilityName = abilityName;\n  abilityMonitor.moduleName = moduleName;\n\n  abilityMonitor.onAbilityBackground = (data) => {\n    console.log(`Ability ${abilityName} entered background`);\n  };\n\n  abilityMonitor.onAbilityForeground = (data) => {\n    console.log(`Ability ${abilityName} entered foreground`);\n  };\n\n  const abilityDelegatorArgs = new AbilityDelegatorArgs();\n  abilityDelegatorArgs.parameters = {\n    abilityMonitor: abilityMonitor\n  };\n\n  return abilityDelegatorArgs;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses the `startTime` property from `AbilityRunningInfo` to calculate the duration an ability has been running, and then triggers the `onConfigurationUpdate` method of the `Ability` class if the duration exceeds a certain threshold to reconfigure the ability dynamically.",
    "input": "",
    "output": "import {AbilityRunningInfo, Ability} from '@kit.AbilityKit';\n\nexport function checkAndReconfigureAbility(abilityInfo: AbilityRunningInfo, ability: Ability, threshold: number): void {\n  const currentTime: number = new Date().getTime();\n  const startTime: number = abilityInfo.startTime;\n  const duration: number = currentTime - startTime;\n\n  if (duration > threshold) {\n    ability.onConfigurationUpdate(ability.context.config);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that collects the `processName` and `uid` from an `AbilityRunningInfo` object, then passes these values to the `onMemoryLevel` method of the `Ability` class to optimize memory allocation based on the process's unique identifier and name.",
    "input": "",
    "output": "import {AbilityRunningInfo, Ability, Ability} from '@kit.AbilityKit';\n\nexport function collectAndOptimizeMemory(abilityRunningInfo: AbilityRunningInfo, ability: Ability): void {\n  const processName: string = abilityRunningInfo.processName;\n  const uid: number = abilityRunningInfo.uid;\n  ability.onMemoryLevel(processName, uid);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `AbilityRunningInfo` of a running ability using its `uid` and `processName`, then passes this information to an `AbilityResult` object to construct a result payload containing the `resultCode` and the original `want` data from the ability's startup intent.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityResult, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function getAbilityRunningInfo(uid: number, processName: string): AbilityRunningInfo | undefined {\n  const abilityMonitor = new AbilityMonitor();\n  let matchedAbilityInfo: AbilityRunningInfo | undefined;\n\n  abilityMonitor.onAbilityCreate = (ability) => {\n    if (ability.uid === uid && ability.processName === processName) {\n      matchedAbilityInfo = ability;\n    }\n  };\n\n  // In a real scenario, you would need to register this monitor with the Ability context\n  // This is a simplified version focusing on the matching logic\n  \n  return matchedAbilityInfo;\n}\n\nexport function createAbilityResult(abilityInfo: AbilityRunningInfo, resultCode: number): AbilityResult {\n  const abilityResult = new AbilityResult();\n  abilityResult.resultCode = resultCode;\n  abilityResult.want = abilityInfo.ability?.want;\n  \n  return abilityResult;\n}\n\nexport function retrieveAndCreateResult(uid: number, processName: string, resultCode: number): AbilityResult | undefined {\n  const abilityInfo = getAbilityRunningInfo(uid, processName);\n  \n  if (abilityInfo) {\n    return createAbilityResult(abilityInfo, resultCode);\n  }\n  \n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that leverages `AbilityMonitor.abilityName` to filter abilities by a specific name, and then uses `AbilityLifecycleCallback.onAbilityForeground` to monitor when those filtered abilities come to the foreground. The function should aggregate and return the count of foreground events for the specified ability name.",
    "input": "",
    "output": "import { AbilityMonitor, AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport function monitorAbilityForegroundCount(abilityName: string): number {\n  let foregroundCount = 0;\n\n  const abilityMonitor: AbilityMonitor = {\n    abilityName: abilityName,\n    onAbilityForeground: (ability) => {\n      foregroundCount++;\n    }\n  };\n\n  const lifecycleCallback: AbilityLifecycleCallback = {\n    onAbilityForeground: (ability) => {\n      if (ability.abilityInfo?.name === abilityName) {\n        foregroundCount++;\n      }\n    }\n  };\n\n  return foregroundCount;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a system that uses `AbilityMonitor.onWindowStageCreate` to monitor when a window stage is created for an ability, and then uses `AbilityLifecycleCallback.onWindowStageActive` to perform specific actions (e.g., logging or resource allocation) when the window stage becomes active.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onWindowStageActive() {\n    console.log('Window stage is active. Performing specific actions...');\n    // Perform specific actions like logging or resource allocation\n  }\n}\n\nexport function setupAbilityMonitor() {\n  const abilityMonitor: AbilityMonitor = {\n    abilityName: 'your_ability_name',\n    moduleName: 'your_module_name',\n    onWindowStageCreate: (ability) => {\n      console.log('Window stage created for ability:', ability);\n      const callback = new MyAbilityLifecycleCallback();\n      ability.on('windowStageActive', callback.onWindowStageActive.bind(callback));\n    }\n  };\n  return abilityMonitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityResult` object, sets its `resultCode` property to a specific value, and then passes this object to another function that extracts the `resultCode` and uses it to determine the next action (e.g., logging or further processing). The function must explicitly use the `resultCode` property of `AbilityResult` and interact with another API to handle the result.",
    "input": "",
    "output": "import { AbilityResult } from '@kit.AbilityKit';\n\nexport function createAbilityResult(resultCode: number): AbilityResult {\n  const abilityResult: AbilityResult = new AbilityResult();\n  abilityResult.resultCode = resultCode;\n  return abilityResult;\n}\n\nexport function handleAbilityResult(abilityResult: AbilityResult): void {\n  const resultCode: number = abilityResult.resultCode;\n  if (resultCode === 0) {\n    console.log('Operation succeeded');\n  } else {\n    console.log('Operation failed with code: ' + resultCode);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility that monitors memory levels using the `onMemoryLevel` method of `Ability` and dynamically updates the UI configuration by calling the `onConfigurationUpdate` method of another `Ability` instance to optimize performance under low-memory conditions.",
    "input": "",
    "output": "import { Ability } from '@kit.AbilityKit';\n\nexport class MemoryMonitorAbility extends Ability {\n  private targetAbility: Ability | null = null;\n\n  onMemoryLevel(level: string): void {\n    if (level === 'low') {\n      if (this.targetAbility) {\n        this.targetAbility.onConfigurationUpdate({\n          memoryLevel: level\n        });\n      }\n    }\n  }\n\n  setTargetAbility(ability: Ability): void {\n    this.targetAbility = ability;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegatorArgs.parameters` to pass configuration data, then uses `AbilityDelegator.setMockList` to mock dependencies based on the parameters, and finally uses `AbilityDelegator.doAbilityForeground` and `AbilityDelegator.doAbilityBackground` to test the ability's behavior during state transitions.",
    "input": "",
    "output": "import { AbilityDelegator, AbilityDelegatorArgs } from '@kit.AbilityKit';\n\nexport function testAbilityStateTransitions(delegatorArgs: AbilityDelegatorArgs, delegator: AbilityDelegator): void {\n  const mockList = delegatorArgs.parameters?.mockList;\n  if (mockList) {\n    delegator.setMockList(mockList);\n  }\n\n  delegator.doAbilityForeground();\n  delegator.doAbilityBackground();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `onAbilityCreate` from `AbilityLifecycleCallback` to initialize a new Ability instance, and then uses `onConfigurationUpdate` from `Ability` to handle configuration changes (e.g., screen rotation) by updating the Ability's UI layout dynamically.",
    "input": "",
    "output": "import {Ability, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback implements AbilityLifecycleCallback {\n  onAbilityCreate(ability: Ability): void {\n    console.log('Ability created:', ability);\n  }\n\n  onAbilityDestroy(ability: Ability): void {\n    console.log('Ability destroyed:', ability);\n  }\n\n  onAbilityForeground(ability: Ability): void {\n    console.log('Ability foreground:', ability);\n  }\n\n  onAbilityBackground(ability: Ability): void {\n    console.log('Ability background:', ability);\n  }\n\n  onAbilityContinue(ability: Ability): void {\n    console.log('Ability continue:', ability);\n  }\n\n  onWindowStageCreate(ability: Ability): void {\n    console.log('Window stage created:', ability);\n  }\n\n  onWindowStageDestroy(ability: Ability): void {\n    console.log('Window stage destroyed:', ability);\n  }\n\n  onWindowStageActive(ability: Ability): void {\n    console.log('Window stage active:', ability);\n  }\n\n  onWindowStageInactive(ability: Ability): void {\n    console.log('Window stage inactive:', ability);\n  }\n}\n\nexport class MyAbility extends Ability {\n  onConfigurationUpdate(newConfig: Configuration): void {\n    console.log('Configuration updated:', newConfig);\n    // Update UI layout based on new configuration\n  }\n\n  onMemoryLevel(level: MemoryLevel): void {\n    console.log('Memory level changed:', level);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityMonitor.onAbilityCreate` to detect when a specific ability (identified by `abilityName` and `moduleName`) is created, then retrieves the ability's details (such as `bundleName`, `launchMode`, and `type`) using `AbilityInfo` and prints them synchronously using `AbilityDelegator.printSync`.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityInfo, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function monitorAbilityCreation(abilityName: string, moduleName: string, delegator: AbilityDelegator): void {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityCreate: (abilityInfo: AbilityInfo) => {\n      const details = {\n        bundleName: abilityInfo.bundleName,\n        launchMode: abilityInfo.launchMode,\n        type: abilityInfo.type\n      };\n      delegator.printSync(`Ability created: ${JSON.stringify(details)}`);\n    }\n  };\n  delegator.addAbilityMonitor(monitor);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a scenario where an `AbilityMonitor` is used to detect when an ability enters the background via the `onAbilityBackground` callback. Upon detection, invoke the `onMemoryLevel` method of the `Ability` class to handle memory pressure events, passing the current memory level as a parameter.",
    "input": "",
    "output": "import {Ability, AbilityMonitor} from '@kit.AbilityKit';\n\nexport class MyAbilityMonitor extends AbilityMonitor {\n  constructor() {\n    super();\n  }\n\n  onAbilityBackground(ability: Ability): void {\n    const memoryLevel: number = 0; // Replace with actual memory level\n    ability.onMemoryLevel(memoryLevel);\n  }\n}\n\nexport function setupAbilityMonitor(): AbilityMonitor {\n  const monitor: MyAbilityMonitor = new MyAbilityMonitor();\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityMonitor` to monitor an ability's lifecycle events (e.g., `onAbilityCreate`, `onAbilityDestroy`), and then uses the `pid` and `abilityState` properties of `AbilityRunningInfo` to log the process ID and state changes of the monitored ability.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityResult, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function monitorAbilityLifecycle(abilityName: string, moduleName: string): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.abilityName = abilityName;\n  monitor.moduleName = moduleName;\n\n  monitor.onAbilityCreate = (abilityRunningInfo: AbilityRunningInfo) => {\n    console.log(`Ability created - PID: ${abilityRunningInfo.pid}, State: ${abilityRunningInfo.abilityState}`);\n  };\n\n  monitor.onAbilityDestroy = (abilityRunningInfo: AbilityRunningInfo) => {\n    console.log(`Ability destroyed - PID: ${abilityRunningInfo.pid}, State: ${abilityRunningInfo.abilityState}`);\n  };\n\n  monitor.onAbilityForeground = (abilityRunningInfo: AbilityRunningInfo) => {\n    console.log(`Ability foreground - PID: ${abilityRunningInfo.pid}, State: ${abilityRunningInfo.abilityState}`);\n  };\n\n  monitor.onAbilityBackground = (abilityRunningInfo: AbilityRunningInfo) => {\n    console.log(`Ability background - PID: ${abilityRunningInfo.pid}, State: ${abilityRunningInfo.abilityState}`);\n  };\n\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes an `AbilityDelegatorArgs` object and uses its `bundleName` property to query the `AbilityInfo` of the specified bundle. Then, check if the `AbilityInfo`'s `launchType` is set to 'standard' and its `enabled` property is true. If both conditions are met, use the `AbilityRunningInfo` to verify if the ability is currently running by checking its `abilityState` property.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityInfo, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function checkAbilityInfoAndState(args: AbilityDelegatorArgs): boolean {\n  const bundleName = args.bundleName;\n  if (!bundleName) {\n    return false;\n  }\n\n  // Assume getAbilityInfo is a method to retrieve AbilityInfo by bundleName\n  const abilityInfo: AbilityInfo = getAbilityInfo(bundleName);\n  if (!abilityInfo) {\n    return false;\n  }\n\n  const isStandardAndEnabled = abilityInfo.launchType === 'standard' && abilityInfo.enabled;\n  if (!isStandardAndEnabled) {\n    return false;\n  }\n\n  // Assume getAbilityRunningInfo is a method to retrieve AbilityRunningInfo by bundleName\n  const abilityRunningInfo: AbilityRunningInfo = getAbilityRunningInfo(bundleName);\n  if (!abilityRunningInfo) {\n    return false;\n  }\n\n  return abilityRunningInfo.abilityState === 2; // Assuming 2 represents running state\n}\n\n// Placeholder functions (to be implemented based on actual API usage)\nfunction getAbilityInfo(bundleName: string): AbilityInfo {\n  // Implementation to get AbilityInfo by bundleName\n  return {} as AbilityInfo;\n}\n\nfunction getAbilityRunningInfo(bundleName: string): AbilityRunningInfo {\n  // Implementation to get AbilityRunningInfo by bundleName\n  return {} as AbilityRunningInfo;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature where an `AbilityMonitor` is configured to listen for window stage events (`onWindowStageCreate` and `onWindowStageDestroy`). When a window stage is created, extract the `abilityName` from the monitor and pass it to `AbilityResult`'s `want` property, then set the `resultCode` to reflect the successful initialization of the window stage.",
    "input": "",
    "output": "import {AbilityResult, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function setupAbilityMonitor(): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n\n  monitor.onWindowStageCreate = (data) => {\n    const abilityResult: AbilityResult = new AbilityResult();\n    abilityResult.want = {\n      abilityName: monitor.abilityName\n    };\n    abilityResult.resultCode = 0; // Reflect successful initialization\n    return abilityResult;\n  };\n\n  monitor.onWindowStageDestroy = () => {\n    // Handle window stage destroy if needed\n  };\n\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that registers an `AbilityLifecycleCallback` to monitor an ability's lifecycle events. When the `onAbilityCreate` method is triggered, collect the ability's details (such as `pid`, `uid`, and `abilityState`) using `AbilityRunningInfo` and log them to the console.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(abilityRunningInfo: AbilityRunningInfo): void {\n    const { pid, uid, abilityState } = abilityRunningInfo;\n    console.log(`Ability created with pid: ${pid}, uid: ${uid}, state: ${abilityState}`);\n  }\n}\n\nexport function registerAbilityLifecycleCallback(): void {\n  const callback = new MyAbilityLifecycleCallback();\n  AbilityLifecycleCallback.register(callback);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `LaunchReason` enum from `AbilityConstant` to determine the reason for an ability launch, and then based on the launch reason, uses the `MemoryLevel` enum from `AbilityConstant` to set the appropriate memory level for the ability.",
    "input": "",
    "output": "import { AbilityConstant } from '@kit.AbilityKit';\n\nexport function setMemoryLevelBasedOnLaunchReason(launchReason: AbilityConstant.LaunchReason): AbilityConstant.MemoryLevel {\n  let memoryLevel: AbilityConstant.MemoryLevel;\n\n  switch (launchReason) {\n    case AbilityConstant.LaunchReason.START_ABILITY:\n      memoryLevel = AbilityConstant.MemoryLevel.MODERATE;\n      break;\n    case AbilityConstant.LaunchReason.CALL:\n      memoryLevel = AbilityConstant.MemoryLevel.LOW;\n      break;\n    case AbilityConstant.LaunchReason.CONTINUATION:\n      memoryLevel = AbilityConstant.MemoryLevel.HIGH;\n      break;\n    default:\n      memoryLevel = AbilityConstant.MemoryLevel.MODERATE;\n  }\n\n  return memoryLevel;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityMonitor` to monitor an ability's lifecycle events (e.g., `onAbilityCreate`, `onAbilityForeground`), and then uses the `abilityState` and `processName` properties of `AbilityRunningInfo` to log the ability's current state and process details when these events occur.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function setupAbilityMonitor(): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n\n  monitor.onAbilityCreate = (ability: AbilityRunningInfo) => {\n    console.log(`Ability created - State: ${ability.abilityState}, Process: ${ability.processName}`);\n  };\n\n  monitor.onAbilityForeground = (ability: AbilityRunningInfo) => {\n    console.log(`Ability foreground - State: ${ability.abilityState}, Process: ${ability.processName}`);\n  };\n\n  monitor.onAbilityBackground = (ability: AbilityRunningInfo) => {\n    console.log(`Ability background - State: ${ability.abilityState}, Process: ${ability.processName}`);\n  };\n\n  monitor.onAbilityDestroy = (ability: AbilityRunningInfo) => {\n    console.log(`Ability destroyed - State: ${ability.abilityState}, Process: ${ability.processName}`);\n  };\n\n  return monitor;\n}\n\nexport function createAbilityDelegatorArgs(): AbilityDelegatorArgs {\n  const args: AbilityDelegatorArgs = new AbilityDelegatorArgs();\n  args.bundleName = 'com.example.myapplication';\n  args.testCaseNames = ['TestCase1', 'TestCase2'];\n  args.testRunnerClassName = 'TestRunner';\n  return args;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `launchMode` and `skills` properties from an `AbilityInfo` object to configure the launch behavior of an `Ability`, then dynamically updates the `Ability`'s window size and orientation by calling its `onConfigurationUpdate` method to match the specified launch mode and skills requirements.",
    "input": "",
    "output": "import {Ability, AbilityInfo} from '@kit.AbilityKit';\n\nexport function configureAbilityLaunch(abilityInfo: AbilityInfo, ability: Ability): void {\n  const { launchMode, skills, orientation, windowSize } = abilityInfo;\n  \n  if (launchMode) {\n    ability.context.setLaunchMode(launchMode);\n  }\n  \n  if (skills) {\n    ability.context.setSkills(skills);\n  }\n  \n  const config = {\n    orientation,\n    windowSize\n  };\n  \n  ability.onConfigurationUpdate(config);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that evaluates the `LastExitReason` from `AbilityConstant` (e.g., `EXIT_REASON_CRASH`), and based on the result, uses the `OnContinueResult` from `AbilityConstant` to decide whether to restore the previous state (`CONTINUE_SUCCESS`) or start fresh (`CONTINUE_FAILURE`).",
    "input": "",
    "output": "import { AbilityConstant } from '@kit.AbilityKit';\n\nexport function evaluateLastExitReason(lastExitReason: AbilityConstant.LastExitReason): AbilityConstant.OnContinueResult {\n  if (lastExitReason === AbilityConstant.LastExitReason.EXIT_REASON_CRASH) {\n    return AbilityConstant.OnContinueResult.CONTINUE_FAILURE;\n  } else {\n    return AbilityConstant.OnContinueResult.CONTINUE_SUCCESS;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a test case that uses `AbilityDelegator.executeShellCommand` to simulate a background state change, then calls `AbilityDelegator.doAbilityBackground` to force the ability into the background, and finally uses `AbilityDelegator.getAbilityState` to confirm the ability's state matches the `abilityState` property of the `AbilityRunningInfo` object obtained from `AbilityDelegator.getCurrentTopAbility`.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityDelegator} from '@kit.AbilityKit';\n\nexport async function testAbilityBackgroundState(delegator: AbilityDelegator): Promise<void> {\n  // Execute shell command to simulate background state change\n  await delegator.executeShellCommand('command_to_simulate_background');\n\n  // Force the ability into the background\n  await delegator.doAbilityBackground();\n\n  // Get the current top ability's running info\n  const topAbilityInfo: AbilityRunningInfo = delegator.getCurrentTopAbility();\n\n  // Get the ability's state directly\n  const abilityState = delegator.getAbilityState();\n\n  // Verify the states match\n  if (abilityState !== topAbilityInfo.abilityState) {\n    throw new Error(`Ability state mismatch: expected ${topAbilityInfo.abilityState}, got ${abilityState}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a scenario where an `AbilityMonitor` is set up to track `onAbilityDestroy` and `onAbilityBackground` events for a specific ability. The results of these events should be passed to an `AbilityDelegatorArgs` object via its `parameters` property, and the test runner class name (`testRunnerClassName`) should be used to execute the validation logic.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class AbilityMonitorHandler {\n  private abilityMonitor: AbilityMonitor;\n  private abilityDelegatorArgs: AbilityDelegatorArgs;\n\n  constructor(abilityName: string, moduleName: string, testRunnerClassName: string) {\n    this.abilityMonitor = new AbilityMonitor({\n      abilityName: abilityName,\n      moduleName: moduleName\n    });\n\n    this.abilityDelegatorArgs = new AbilityDelegatorArgs({\n      testRunnerClassName: testRunnerClassName\n    });\n\n    this.setupAbilityMonitor();\n  }\n\n  private setupAbilityMonitor(): void {\n    this.abilityMonitor.onAbilityDestroy = (ability) => {\n      this.abilityDelegatorArgs.parameters = {\n        event: 'onAbilityDestroy',\n        abilityName: ability.abilityInfo.name\n      };\n    };\n\n    this.abilityMonitor.onAbilityBackground = (ability) => {\n      this.abilityDelegatorArgs.parameters = {\n        event: 'onAbilityBackground',\n        abilityName: ability.abilityInfo.name\n      };\n    };\n  }\n\n  public getAbilityMonitor(): AbilityMonitor {\n    return this.abilityMonitor;\n  }\n\n  public getAbilityDelegatorArgs(): AbilityDelegatorArgs {\n    return this.abilityDelegatorArgs;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.addAbilityMonitor` to register an `AbilityMonitor` instance with `abilityName` set to 'MainAbility'. Then, use `AbilityDelegator.startAbility` to launch the ability and `AbilityDelegator.waitAbilityMonitor` to wait for the ability to be created. Finally, verify the ability's state using `AbilityDelegator.getAbilityState` and the `onAbilityCreate` callback of `AbilityMonitor`.",
    "input": "",
    "output": "import { AbilityMonitor, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function monitorAndVerifyAbility(delegator: AbilityDelegator): void {\n  const abilityName = 'MainAbility';\n  let abilityCreated = false;\n\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (ability) => {\n      console.log(`Ability ${abilityName} created`);\n      abilityCreated = true;\n    }\n  };\n\n  delegator.addAbilityMonitor(monitor);\n  delegator.startAbility({\n    bundleName: 'com.example.myapplication',\n    abilityName: abilityName\n  });\n\n  delegator.waitAbilityMonitor(monitor, 5000).then(() => {\n    if (abilityCreated) {\n      const state = delegator.getAbilityState(monitor);\n      console.log(`Ability state: ${state}`);\n    } else {\n      console.log('Ability creation timed out');\n    }\n  }).catch((err) => {\n    console.error(`Error waiting for ability: ${err}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that utilizes `AbilityDelegatorArgs.parameters` to pass custom configuration parameters to an ability, then use `AbilityLifecycleCallback.onAbilityBackground` and `AbilityLifecycleCallback.onAbilityForeground` to simulate the ability being moved to the background and brought back to the foreground, verifying the parameters persist across these state changes.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class CustomAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private customParams: Record<string, string> = {};\n\n  onAbilityCreate() {\n    const delegatorArgs = new AbilityDelegatorArgs();\n    delegatorArgs.parameters = {\n      'param1': 'value1',\n      'param2': 'value2'\n    };\n    this.customParams = delegatorArgs.parameters;\n  }\n\n  onAbilityBackground() {\n    console.log('Ability moved to background. Current params:', this.customParams);\n  }\n\n  onAbilityForeground() {\n    console.log('Ability brought to foreground. Current params:', this.customParams);\n  }\n}\n\nexport function setupAbilityLifecycleCallback(): AbilityLifecycleCallback {\n  return new CustomAbilityLifecycleCallback();\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Develop a utility that leverages the `parameters` property of `AbilityDelegatorArgs` to pass configuration data to an ability, and then uses the `onWindowStageCreate` and `onWindowStageDestroy` methods of `AbilityLifecycleCallback` to track and report the window stage lifecycle events triggered by the provided parameters.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private configData: Record<string, string> = {};\n\n  constructor(args: AbilityDelegatorArgs) {\n    super();\n    if (args.parameters) {\n      this.configData = args.parameters;\n    }\n  }\n\n  onWindowStageCreate(): void {\n    console.log(`WindowStage created with config: ${JSON.stringify(this.configData)}`);\n  }\n\n  onWindowStageDestroy(): void {\n    console.log(`WindowStage destroyed with config: ${JSON.stringify(this.configData)}`);\n  }\n}\n\nexport function setupAbilityLifecycleCallback(args: AbilityDelegatorArgs): MyAbilityLifecycleCallback {\n  return new MyAbilityLifecycleCallback(args);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `abilityState` from `AbilityRunningInfo` and uses it to determine the appropriate `StateType` from `AbilityConstant`. The function should return a string indicating whether the ability is in a foreground, background, or terminated state based on the combined information from both APIs.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function getAbilityStateDescription(info: AbilityRunningInfo): string {\n  const state = info.abilityState;\n  \n  switch (state) {\n    case AbilityConstant.StateType.FOREGROUND:\n      return 'foreground';\n    case AbilityConstant.StateType.BACKGROUND:\n      return 'background';\n    case AbilityConstant.StateType.TERMINATED:\n      return 'terminated';\n    default:\n      return 'unknown';\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `pid` and `processName` from an `AbilityRunningInfo` object, then uses these values to monitor memory levels by calling the `onMemoryLevel` method of the `Ability` class, logging the memory level whenever the process name matches a specific target.",
    "input": "",
    "output": "import { AbilityRunningInfo, Ability } from '@kit.AbilityKit';\n\nexport function monitorMemoryLevel(abilityInfo: AbilityRunningInfo, targetProcessName: string): void {\n  const { pid, processName } = abilityInfo;\n  \n  if (processName === targetProcessName) {\n    const ability = new Ability();\n    ability.onMemoryLevel((level: number) => {\n      console.log(`Memory level for process ${processName} (PID: ${pid}): ${level}`);\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `pid` and `processName` from an `AbilityRunningInfo` object, then uses these values to construct a `want` property in an `AbilityResult` object, and finally sets the `resultCode` based on whether the process is still active (e.g., `pid > 0`).",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityResult} from '@kit.AbilityKit';\n\nexport function constructAbilityResult(abilityInfo: AbilityRunningInfo): AbilityResult {\n  const abilityResult: AbilityResult = new AbilityResult();\n  \n  if (abilityInfo.pid && abilityInfo.pid > 0) {\n    abilityResult.resultCode = 1;\n  } else {\n    abilityResult.resultCode = 0;\n  }\n  \n  abilityResult.want = {\n    parameters: {\n      pid: abilityInfo.pid,\n      processName: abilityInfo.processName\n    }\n  };\n  \n  return abilityResult;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature where the `onMemoryLevel` method of `Ability` is used to detect low memory conditions. When such a condition occurs, use the `AbilityRunningInfo` properties (`uid`, `startTime`) to identify and log the oldest running ability, then invoke the `onAbilityDestroy` method of `AbilityLifecycleCallback` to terminate it.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityLifecycleCallback, Ability} from '@kit.AbilityKit';\n\nexport class MemoryMonitorAbility extends Ability {\n  private abilityLifecycleCallback: AbilityLifecycleCallback = {\n    onAbilityDestroy: (ability) => {\n      console.log(`Ability destroyed: ${ability}`);\n    },\n    onAbilityBackground: (ability) => {},\n    onAbilityContinue: (ability) => {},\n    onAbilityCreate: (ability) => {},\n    onAbilityForeground: (ability) => {},\n    onWindowStageActive: (ability) => {},\n    onWindowStageCreate: (ability) => {},\n    onWindowStageDestroy: (ability) => {},\n    onWindowStageInactive: (ability) => {}\n  };\n\n  onMemoryLevel(level: number): void {\n    if (level === Ability.MemoryLevel.LOW) {\n      const runningInfos: Array<AbilityRunningInfo> = this.context.getRunningAbilities();\n      if (runningInfos.length > 0) {\n        let oldestAbility: AbilityRunningInfo = runningInfos[0];\n        for (const info of runningInfos) {\n          if (info.startTime < oldestAbility.startTime) {\n            oldestAbility = info;\n          }\n        }\n        console.log(`Oldest running ability: uid=${oldestAbility.uid}, startTime=${oldestAbility.startTime}`);\n        this.abilityLifecycleCallback.onAbilityDestroy(oldestAbility.ability);\n      }\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onMemoryLevel` method of `Ability` to monitor the current memory level, and then based on the detected `MemoryLevel` enum value from `AbilityConstant`, trigger a specific action (e.g., logging or cleanup) when the memory level reaches `MemoryLevel.CRITICAL`.",
    "input": "",
    "output": "import {AbilityConstant, Ability} from '@kit.AbilityKit';\n\nexport class MemoryMonitorAbility extends Ability {\n  onMemoryLevel(level: AbilityConstant.MemoryLevel): void {\n    if (level === AbilityConstant.MemoryLevel.CRITICAL) {\n      // Trigger specific action when memory level is CRITICAL\n      console.log('Memory level is CRITICAL. Performing cleanup...');\n      // Add cleanup logic here\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes an `AbilityDelegatorArgs` object with `testCaseNames` and `parameters`, executes the test cases, and then uses the `want` property of `AbilityResult` to retrieve and log the detailed output of the test execution.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function executeTests(testCaseNames: string[], parameters: {[key: string]: string}): void {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    testCaseNames: testCaseNames,\n    parameters: parameters\n  };\n\n  // Assume there is a function to execute the tests and return AbilityResult\n  const result: AbilityResult = executeTestCases(delegatorArgs);\n\n  if (result.want) {\n    console.log('Test execution output:', JSON.stringify(result.want));\n  }\n}\n\n// This is a placeholder function for the actual test execution\n// In a real implementation, this would be provided by the framework\nfunction executeTestCases(args: AbilityDelegatorArgs): AbilityResult {\n  // Mock implementation\n  return {\n    resultCode: 0,\n    want: {\n      testResults: 'Detailed test output here'\n    }\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch an ability and then checks its state using `AbilityDelegator.getAbilityState`. Based on the state (using `AbilityConstant.StateType`), print a message indicating whether the ability is in the foreground or background using `AbilityDelegator.printSync`.",
    "input": "",
    "output": "import {AbilityConstant, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function checkAbilityState(delegator: AbilityDelegator, want: Want): void {\n  delegator.startAbility(want).then(() => {\n    const state = delegator.getAbilityState(want);\n    if (state === AbilityConstant.StateType.INACTIVE) {\n      delegator.printSync('Ability is in the background');\n    } else if (state === AbilityConstant.StateType.ACTIVE) {\n      delegator.printSync('Ability is in the foreground');\n    } else {\n      delegator.printSync('Ability state is unknown');\n    }\n  }).catch((err) => {\n    delegator.printSync(`Failed to start ability: ${err}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `bundleName` property of `AbilityDelegatorArgs` to set up a test configuration, then launches the test and captures the result using the `resultCode` property of `AbilityResult` to verify if the test execution was successful.",
    "input": "",
    "output": "import {AbilityResult, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function setupAndRunTest(bundleName: string, testCaseNames: string[], testRunnerClassName: string): AbilityResult {\n  const args: AbilityDelegatorArgs = {\n    bundleName: bundleName,\n    testCaseNames: testCaseNames,\n    testRunnerClassName: testRunnerClassName\n  };\n\n  // Simulate launching the test and getting the result\n  const result: AbilityResult = {\n    resultCode: 0, // Assuming 0 means success\n    want: {}\n  };\n\n  return result;\n}\n\nexport function verifyTestResult(result: AbilityResult): boolean {\n  return result.resultCode === 0;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `startAbility` method of `AbilityDelegator` to launch a new ability, then verifies its launch mode by accessing the `launchMode` property of `AbilityInfo`, and logs the launch mode using the `print` method of `AbilityDelegator`.",
    "input": "",
    "output": "import { AbilityInfo, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function startAndVerifyAbility(abilityDelegator: AbilityDelegator, want: Want): void {\n  abilityDelegator.startAbility(want, (err, data) => {\n    if (err) {\n      abilityDelegator.print(`Failed to start ability: ${err.message}`);\n      return;\n    }\n    const abilityInfo: AbilityInfo = data as AbilityInfo;\n    const launchMode: number = abilityInfo.launchMode;\n    abilityDelegator.print(`Ability launch mode: ${launchMode}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `Ability.onConfigurationUpdate` to detect changes in the device's configuration (e.g., screen orientation) and then checks the current window mode using `AbilityConstant.WindowMode`. Based on the window mode, adjust the UI layout dynamically to optimize for fullscreen or split-screen mode.",
    "input": "",
    "output": "import {AbilityConstant, Ability} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  onConfigurationUpdate(newConfig: Ability.Configuration) {\n    super.onConfigurationUpdate(newConfig);\n    const windowMode: AbilityConstant.WindowMode = this.context.windowMode;\n    this.adjustUILayout(windowMode);\n  }\n\n  private adjustUILayout(windowMode: AbilityConstant.WindowMode): void {\n    switch (windowMode) {\n      case AbilityConstant.WindowMode.WINDOW_MODE_FULLSCREEN:\n        // Adjust UI for fullscreen mode\n        break;\n      case AbilityConstant.WindowMode.WINDOW_MODE_SPLIT_PRIMARY:\n      case AbilityConstant.WindowMode.WINDOW_MODE_SPLIT_SECONDARY:\n        // Adjust UI for split-screen mode\n        break;\n      default:\n        // Handle other window modes if necessary\n        break;\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` to monitor the lifecycle events of a specific ability (using `abilityName` and `moduleName` properties) and then registers this monitor with an `AbilityDelegator` using the `addAbilityMonitorSync` method. The function should wait for the ability to reach the foreground state (using `waitAbilityMonitor`) and then print the current state of the ability (using `getAbilityState`).",
    "input": "",
    "output": "import { AbilityMonitor, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function monitorAndPrintAbilityState(delegator: AbilityDelegator, abilityName: string, moduleName: string): void {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.abilityName = abilityName;\n  monitor.moduleName = moduleName;\n\n  delegator.addAbilityMonitorSync(monitor);\n  delegator.waitAbilityMonitor(monitor);\n\n  const abilityState = delegator.getAbilityState(monitor);\n  console.log(`Current ability state: ${abilityState}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that handles the ability's state changes by listening to `Ability.onConfigurationUpdate`. Based on the new configuration, check if the window mode is `AbilityConstant.WindowMode.FULLSCREEN` and adjust the UI layout accordingly, then log the transition reason using `AbilityConstant.LaunchReason.CONFIGURATION_CHANGE`.",
    "input": "",
    "output": "import {AbilityConstant, Ability} from '@kit.AbilityKit';\n\nexport function handleConfigurationUpdate(abilityContext: Ability): void {\n  abilityContext.onConfigurationUpdate((newConfig) => {\n    if (newConfig.windowMode === AbilityConstant.WindowMode.FULLSCREEN) {\n      // Adjust UI layout for fullscreen mode\n      console.log('UI layout adjusted for FULLSCREEN mode');\n    }\n    console.log(`Transition reason: ${AbilityConstant.LaunchReason.CONFIGURATION_CHANGE}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that collects the `startTime` and `uid` from an `AbilityRunningInfo` object, then uses the `onConfigurationUpdate` method of the `Ability` class to check if the configuration has changed since the ability started, and logs a warning if the elapsed time exceeds a threshold.",
    "input": "",
    "output": "import { AbilityRunningInfo, Ability } from '@kit.AbilityKit';\n\nexport function checkConfigurationUpdate(abilityInfo: AbilityRunningInfo, ability: Ability, threshold: number): void {\n  const startTime = abilityInfo.startTime;\n  const uid = abilityInfo.uid;\n  \n  ability.onConfigurationUpdate(() => {\n    const currentTime = new Date().getTime();\n    const elapsedTime = currentTime - startTime;\n    \n    if (elapsedTime > threshold) {\n      console.warn(`Configuration update detected for UID ${uid} after ${elapsedTime}ms, exceeding threshold of ${threshold}ms`);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses the `WindowMode` enum from `AbilityConstant` to determine the current window mode of an ability, and then based on the window mode, uses the `StateType` enum from `AbilityConstant` to set the appropriate state type for the ability.",
    "input": "",
    "output": "import { AbilityConstant } from '@kit.AbilityKit';\n\nexport function setAbilityStateByWindowMode(windowMode: AbilityConstant.WindowMode): AbilityConstant.StateType {\n  let stateType: AbilityConstant.StateType;\n  \n  switch (windowMode) {\n    case AbilityConstant.WindowMode.WINDOW_MODE_FULLSCREEN:\n      stateType = AbilityConstant.StateType.FOREGROUND;\n      break;\n    case AbilityConstant.WindowMode.WINDOW_MODE_SPLIT_PRIMARY:\n    case AbilityConstant.WindowMode.WINDOW_MODE_SPLIT_SECONDARY:\n      stateType = AbilityConstant.StateType.SPLIT;\n      break;\n    case AbilityConstant.WindowMode.WINDOW_MODE_FLOATING:\n      stateType = AbilityConstant.StateType.FLOATING;\n      break;\n    default:\n      stateType = AbilityConstant.StateType.BACKGROUND;\n      break;\n  }\n  \n  return stateType;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onMemoryLevel` method of `Ability` to detect the current memory level of the device, and then uses the `MemoryLevel` enum from `AbilityConstant` to determine if the memory level is critical (e.g., `MemoryLevel.CRITICAL`). If it is critical, log a warning message and trigger a cleanup process.",
    "input": "",
    "output": "import {Ability, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MemoryMonitorAbility extends Ability {\n  onMemoryLevel(level: AbilityConstant.MemoryLevel): void {\n    if (level === AbilityConstant.MemoryLevel.CRITICAL) {\n      console.warn('Memory level is critical! Triggering cleanup process.');\n      this.triggerCleanup();\n    }\n  }\n\n  private triggerCleanup(): void {\n    // Implement cleanup logic here\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` instance to monitor an ability with a specific `abilityName` and `moduleName`. Use the `onAbilityCreate` callback of the `AbilityMonitor` to trigger the `onConfigurationUpdate` method of the `Ability` class when the ability is created, ensuring the ability responds to configuration changes immediately.",
    "input": "",
    "output": "import {Ability, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function createAbilityMonitor(abilityName: string, moduleName: string): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.abilityName = abilityName;\n  monitor.moduleName = moduleName;\n  monitor.onAbilityCreate = (ability: Ability) => {\n    ability.onConfigurationUpdate();\n  };\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that filters a list of `AbilityInfo` objects based on their `supportWindowModes` and `deviceTypes` properties. For each matching ability, use the `want` property from `AbilityResult` to start the ability and collect the `resultCode` from each `AbilityResult` object. Return an array of all collected `resultCode` values.",
    "input": "",
    "output": "import {AbilityInfo, AbilityResult} from '@kit.AbilityKit';\n\nexport function filterAndStartAbilities(\n  abilities: AbilityInfo[],\n  windowModes: number[],\n  deviceTypes: string[],\n  startAbility: (want: object) => Promise<AbilityResult>\n): Promise<number[]> {\n  const filteredAbilities = abilities.filter(ability => {\n    const supportsWindowMode = windowModes.some(mode => ability.supportWindowModes.includes(mode));\n    const supportsDeviceType = deviceTypes.some(type => ability.deviceTypes.includes(type));\n    return supportsWindowMode && supportsDeviceType;\n  });\n\n  return Promise.all(\n    filteredAbilities.map(async ability => {\n      const result = await startAbility(ability.want);\n      return result.resultCode;\n    })\n  );\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a test scenario where you use `AbilityDelegator.addAbilityMonitor` to register an `AbilityMonitor` configured with `onWindowStageCreate` and `onWindowStageDestroy` callbacks for a specific ability. Then, use `AbilityDelegator.waitAbilityMonitor` to wait for the ability's window stage events, and verify the ability's `supportWindowModes` and `windowSize` properties from `AbilityInfo` to ensure compatibility with the expected window behavior.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityInfo, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function testAbilityWindowStageEvents(abilityDelegator: AbilityDelegator, abilityName: string, moduleName: string, expectedSupportWindowModes: number[], expectedWindowSize: {width: number, height: number}): void {\n  const abilityMonitor = new AbilityMonitor({\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onWindowStageCreate: (ability) => {\n      const abilityInfo: AbilityInfo = ability.context.abilityInfo;\n      if (!abilityInfo) {\n        throw new Error('AbilityInfo is undefined');\n      }\n\n      const actualSupportWindowModes = abilityInfo.supportWindowModes;\n      const actualWindowSize = abilityInfo.windowSize;\n\n      if (!arraysEqual(actualSupportWindowModes, expectedSupportWindowModes)) {\n        throw new Error(`Expected supportWindowModes ${expectedSupportWindowModes}, but got ${actualSupportWindowModes}`);\n      }\n\n      if (!windowSizeEqual(actualWindowSize, expectedWindowSize)) {\n        throw new Error(`Expected windowSize ${JSON.stringify(expectedWindowSize)}, but got ${JSON.stringify(actualWindowSize)}`);\n      }\n    },\n    onWindowStageDestroy: (ability) => {\n      console.log(`Window stage destroyed for ability: ${abilityName}`);\n    }\n  });\n\n  abilityDelegator.addAbilityMonitor(abilityMonitor);\n  abilityDelegator.waitAbilityMonitor(abilityMonitor, (err) => {\n    if (err) {\n      throw err;\n    }\n  });\n}\n\nfunction arraysEqual(a: number[], b: number[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nfunction windowSizeEqual(a: {width: number, height: number}, b: {width: number, height: number}): boolean {\n  return a.width === b.width && a.height === b.height;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that combines the `onMemoryLevel` method of `Ability` with the `ability` property of `AbilityRunningInfo` to compare the memory levels of two different abilities (identified by their `AbilityRunningInfo` objects) and determine which one is consuming more memory.",
    "input": "",
    "output": "import {Ability, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function compareMemoryLevel(ability1: AbilityRunningInfo, ability2: AbilityRunningInfo): number {\n  const memoryLevel1 = ability1.ability.onMemoryLevel();\n  const memoryLevel2 = ability2.ability.onMemoryLevel();\n\n  if (memoryLevel1 > memoryLevel2) {\n    return 1;\n  } else if (memoryLevel1 < memoryLevel2) {\n    return -1;\n  } else {\n    return 0;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a system that uses `AbilityMonitor.onWindowStageCreate` to track when a window stage is created for an ability, and then uses `AbilityLifecycleCallback.onWindowStageActive` to monitor when that window stage becomes active. The system should trigger a custom action (e.g., logging or updating a UI element) only when both events occur for the same ability.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class AbilityMonitorSystem {\n  private abilityMonitor: AbilityMonitor;\n  private lifecycleCallback: AbilityLifecycleCallback;\n  private monitoredAbility: string = '';\n\n  constructor(abilityName: string) {\n    this.monitoredAbility = abilityName;\n    this.abilityMonitor = new AbilityMonitor({\n      abilityName: this.monitoredAbility,\n      onWindowStageCreate: (ability) => {\n        this.handleWindowStageCreate(ability);\n      }\n    });\n\n    this.lifecycleCallback = {\n      onWindowStageActive: (ability) => {\n        this.handleWindowStageActive(ability);\n      }\n    };\n  }\n\n  private handleWindowStageCreate(ability: any): void {\n    console.log(`Window stage created for ability: ${this.monitoredAbility}`);\n    ability.registerAbilityLifecycleCallback(this.lifecycleCallback);\n  }\n\n  private handleWindowStageActive(ability: any): void {\n    console.log(`Window stage active for ability: ${this.monitoredAbility}`);\n    this.triggerCustomAction();\n  }\n\n  private triggerCustomAction(): void {\n    console.log('Custom action triggered');\n  }\n\n  public getMonitor(): AbilityMonitor {\n    return this.abilityMonitor;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `abilityState` from an `AbilityRunningInfo` object and uses it to determine if the ability should handle a configuration update by calling the `onConfigurationUpdate` method of the `Ability` class. The function should return `true` if the ability state is `FOREGROUND` (from `AbilityConstant.StateType`), otherwise return `false`.",
    "input": "",
    "output": "import {AbilityRunningInfo, Ability, AbilityConstant} from '@kit.AbilityKit';\n\nexport function shouldHandleConfigurationUpdate(abilityRunningInfo: AbilityRunningInfo): boolean {\n  return abilityRunningInfo.abilityState === AbilityConstant.StateType.FOREGROUND;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that monitors an ability's lifecycle using `AbilityDelegator.addAbilityMonitor` and waits for it to reach a specific state (e.g., `AbilityConstant.StateType.INITIAL`). Once the state is detected, use `AbilityDelegator.doAbilityBackground` to move the ability to the background and verify the transition using `AbilityDelegator.getAbilityState`.",
    "input": "",
    "output": "import { AbilityConstant, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function monitorAbilityLifecycle(\n  delegator: AbilityDelegator,\n  abilityName: string,\n  targetState: AbilityConstant.StateType\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    const monitor = {\n      abilityName: abilityName,\n      onAbilityCreate: (ability) => {\n        console.log(`Ability ${abilityName} created`);\n      },\n      onAbilityStateChange: (ability, state) => {\n        console.log(`Ability ${abilityName} state changed to ${state}`);\n        if (state === targetState) {\n          delegator.removeAbilityMonitor(monitor);\n          resolve();\n        }\n      },\n    };\n\n    delegator.addAbilityMonitor(monitor, (err) => {\n      if (err) {\n        reject(err);\n      }\n    });\n  });\n}\n\nexport async function moveAbilityToBackgroundAndVerify(\n  delegator: AbilityDelegator,\n  abilityName: string\n): Promise<void> {\n  try {\n    await monitorAbilityLifecycle(delegator, abilityName, AbilityConstant.StateType.INITIAL);\n    await delegator.doAbilityBackground(abilityName);\n    const state = delegator.getAbilityState(abilityName);\n    console.log(`Ability ${abilityName} state after background: ${state}`);\n  } catch (err) {\n    console.error(`Error moving ability to background: ${err}`);\n    throw err;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegatorArgs` to set up test parameters (bundleName, testCaseNames) and then passes these parameters to `AbilityDelegator` to start a specific ability using `startAbility`. Monitor the ability's lifecycle events (onAbilityCreate, onAbilityForeground) using `AbilityMonitor` and print the ability's state using `getAbilityState`.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function setupAndStartAbility(bundleName: string, testCaseNames: string[], abilityName: string): void {\n  const abilityDelegatorArgs: AbilityDelegatorArgs = {\n    bundleName: bundleName,\n    testCaseNames: testCaseNames\n  };\n\n  const abilityDelegator = AbilityDelegator.getAbilityDelegator();\n  const abilityMonitor: AbilityMonitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (ability) => {\n      console.log(`Ability created: ${ability.abilityName}`);\n      const state = abilityDelegator.getAbilityState(ability);\n      console.log(`Ability state: ${state}`);\n    },\n    onAbilityForeground: (ability) => {\n      console.log(`Ability foreground: ${ability.abilityName}`);\n      const state = abilityDelegator.getAbilityState(ability);\n      console.log(`Ability state: ${state}`);\n    }\n  };\n\n  abilityDelegator.addAbilityMonitor(abilityMonitor);\n  abilityDelegator.startAbility(abilityDelegatorArgs);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `StateType` enum from `AbilityConstant` to track the current state of an ability, and then based on the state, uses the `OnContinueResult` enum from `AbilityConstant` to handle the result of a continuation request (e.g., accepting or rejecting the continuation).",
    "input": "",
    "output": "import { AbilityConstant } from '@kit.AbilityKit';\n\nexport class AbilityStateHandler {\n  private currentState: AbilityConstant.StateType = AbilityConstant.StateType.INITIAL;\n\n  public setState(newState: AbilityConstant.StateType): void {\n    this.currentState = newState;\n  }\n\n  public getState(): AbilityConstant.StateType {\n    return this.currentState;\n  }\n\n  public handleContinueRequest(): AbilityConstant.OnContinueResult {\n    switch (this.currentState) {\n      case AbilityConstant.StateType.ACTIVE:\n        return AbilityConstant.OnContinueResult.AGREE;\n      case AbilityConstant.StateType.INACTIVE:\n        return AbilityConstant.OnContinueResult.REJECT;\n      case AbilityConstant.StateType.INITIAL:\n      case AbilityConstant.StateType.BACKGROUND:\n      default:\n        return AbilityConstant.OnContinueResult.REJECT;\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that registers an `AbilityLifecycleCallback` to monitor the lifecycle events of an `Ability`. When the `onAbilityCreate` event is triggered, use the `AbilityRunningInfo` properties (`abilityState`, `pid`, and `processName`) to log detailed information about the newly created ability.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityLifecycleCallback, Ability} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(ability: Ability): void {\n    const runningInfo: AbilityRunningInfo = {\n      ability: ability,\n      abilityState: ability.abilityState,\n      pid: ability.pid,\n      processName: ability.processName,\n      startTime: ability.startTime,\n      uid: ability.uid\n    };\n\n    console.log(`Ability created with state: ${runningInfo.abilityState}`);\n    console.log(`PID: ${runningInfo.pid}`);\n    console.log(`Process Name: ${runningInfo.processName}`);\n  }\n}\n\nexport function registerAbilityLifecycleCallback(): void {\n  const callback = new MyAbilityLifecycleCallback();\n  Ability.registerAbilityLifecycleCallback(callback);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that collects the `startTime` and `processName` from an `AbilityRunningInfo` object, then passes these values to the `onConfigurationUpdate` method of the `Ability` class to log configuration changes along with the process details.",
    "input": "",
    "output": "import {AbilityRunningInfo, Ability} from '@kit.AbilityKit';\n\nexport function logConfigurationChanges(abilityInfo: AbilityRunningInfo, ability: Ability): void {\n  const { startTime, processName } = abilityInfo;\n  ability.onConfigurationUpdate({\n    startTime,\n    processName\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `abilityState` and `pid` from an `AbilityRunningInfo` object, then uses these values to call the `onMemoryLevel` method of the `Ability` class to monitor memory usage for the specified process.",
    "input": "",
    "output": "import {AbilityRunningInfo, Ability} from '@kit.AbilityKit';\n\nexport function monitorMemoryUsage(abilityInfo: AbilityRunningInfo, ability: Ability): void {\n  const { abilityState, pid } = abilityInfo;\n  ability.onMemoryLevel(abilityState, pid);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the `abilityState` and `startTime` from `AbilityRunningInfo` for a running ability, and if the ability is in a 'running' state, uses the `want` property from `AbilityResult` to send a new intent to that ability. Ensure the function logs the `processName` from `AbilityRunningInfo` for debugging purposes.",
    "input": "",
    "output": "import {AbilityResult, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function handleRunningAbility(abilityInfo: AbilityRunningInfo, abilityResult: AbilityResult): void {\n  const { abilityState, startTime, processName } = abilityInfo;\n  console.log(`Process Name: ${processName}`);\n  \n  if (abilityState === 'running') {\n    const { want } = abilityResult;\n    // Here you would typically send the new intent using the 'want' property\n    // For example: \n    // context.startAbility(want);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that monitors an ability's lifecycle using `AbilityDelegator.addAbilityMonitor` and waits for the ability to reach a specific state (e.g., `AbilityConstant.StateType.BACKGROUND`) using `AbilityDelegator.waitAbilityMonitor`. Once the state is reached, the function should retrieve the ability's `launchMode` (from `AbilityInfo`) and log it.",
    "input": "",
    "output": "import {AbilityConstant, AbilityDelegator, AbilityInfo} from '@kit.AbilityKit';\n\nexport function monitorAbilityLifecycle(\n  delegator: AbilityDelegator,\n  abilityName: string,\n  targetState: AbilityConstant.StateType\n): void {\n  const monitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (ability: any) => {\n      console.log(`Ability ${abilityName} created`);\n    },\n    onAbilityStateChange: (ability: any, state: AbilityConstant.StateType) => {\n      if (state === targetState) {\n        console.log(`Ability ${abilityName} reached state ${state}`);\n        const abilityInfo: AbilityInfo = ability.context.abilityInfo;\n        console.log(`Ability launchMode: ${abilityInfo.launchMode}`);\n      }\n    }\n  };\n\n  delegator.addAbilityMonitor(monitor);\n  delegator.waitAbilityMonitor(monitor);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a program that utilizes the `onMemoryLevel` method of `Ability` to monitor memory levels, and based on the memory state, modifies the `testCaseNames` property of `AbilityDelegatorArgs` to selectively run or skip memory-intensive test cases.",
    "input": "",
    "output": "import {Ability, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class MemoryAwareAbility extends Ability {\n  private abilityDelegatorArgs: AbilityDelegatorArgs;\n\n  constructor() {\n    super();\n    this.abilityDelegatorArgs = new AbilityDelegatorArgs();\n  }\n\n  onMemoryLevel(level: string): void {\n    if (level === 'low') {\n      this.abilityDelegatorArgs.testCaseNames = this.abilityDelegatorArgs.testCaseNames\n        .filter(testCase => !testCase.includes('memory_intensive'));\n    }\n  }\n\n  getAbilityDelegatorArgs(): AbilityDelegatorArgs {\n    return this.abilityDelegatorArgs;\n  }\n\n  setTestCaseNames(testCaseNames: string[]): void {\n    this.abilityDelegatorArgs.testCaseNames = testCaseNames;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator` to start a specific ability (using `startAbility`) and then creates an `AbilityMonitor` to track its window stage events (using `onWindowStageCreate` and `onWindowStageDestroy`). The function should register the monitor with the `AbilityDelegator` (using `addAbilityMonitor`), wait for the window stage to be created (using `waitAbilityMonitor`), and then execute a shell command (using `executeShellCommand`) to verify the ability's window stage status.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function monitorAbilityWindowStage(abilityDelegator: AbilityDelegator, abilityName: string, moduleName: string): void {\n  const abilityMonitor: AbilityMonitor = new AbilityMonitor();\n  abilityMonitor.abilityName = abilityName;\n  abilityMonitor.moduleName = moduleName;\n\n  let windowStageCreated = false;\n  abilityMonitor.onWindowStageCreate = () => {\n    windowStageCreated = true;\n  };\n\n  abilityMonitor.onWindowStageDestroy = () => {\n    windowStageCreated = false;\n  };\n\n  abilityDelegator.addAbilityMonitor(abilityMonitor);\n  abilityDelegator.startAbility({\n    abilityName: abilityName,\n    moduleName: moduleName\n  });\n\n  abilityDelegator.waitAbilityMonitor(abilityMonitor, (err, data) => {\n    if (err) {\n      console.error(`Failed to wait for ability monitor: ${err.message}`);\n      return;\n    }\n\n    if (windowStageCreated) {\n      abilityDelegator.executeShellCommand('wm dump', (err, data) => {\n        if (err) {\n          console.error(`Failed to execute shell command: ${err.message}`);\n          return;\n        }\n        console.log(`Window stage status: ${data}`);\n      });\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test scenario where `startAbility` from `AbilityDelegator` is used to launch an ability, and then `doAbilityForeground` and `doAbilityBackground` from `AbilityDelegator` are used to simulate foreground and background transitions. Use `onAbilityForeground` and `onAbilityBackground` from `AbilityLifecycleCallback` to verify the state changes and print confirmation messages.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityDelegator} from '@kit.AbilityKit';\n\nexport class TestAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(ability) {\n    console.log('Ability has entered the foreground');\n  }\n\n  onAbilityBackground(ability) {\n    console.log('Ability has entered the background');\n  }\n}\n\nexport async function testAbilityLifecycle(delegator: AbilityDelegator, want) {\n  const callback = new TestAbilityLifecycleCallback();\n  delegator.addAbilityLifecycleCallback(callback);\n\n  await delegator.startAbility(want);\n  await delegator.doAbilityForeground();\n  await delegator.doAbilityBackground();\n\n  delegator.removeAbilityLifecycleCallback(callback);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `getCurrentTopAbility` method of `AbilityDelegator` to retrieve the current top ability, then checks if it is visible by accessing the `isVisible` property of `AbilityInfo`, and finally prints the result using the `printSync` method of `AbilityDelegator`.",
    "input": "",
    "output": "import { AbilityInfo, AbilityDelegator } from '@kit.AbilityKit';\n\nexport function checkTopAbilityVisibility(delegator: AbilityDelegator): void {\n  const topAbility: AbilityInfo | null = delegator.getCurrentTopAbility();\n  if (topAbility) {\n    const isVisible: boolean = topAbility.isVisible;\n    delegator.printSync(`Top ability visibility: ${isVisible}`);\n  } else {\n    delegator.printSync('No top ability found');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that handles the app's state transitions by first checking the current state type using `AbilityConstant.StateType` and then calling `Ability.onMemoryLevel` to assess the memory level. If the state type is `BACKGROUND` and the memory level is `LOW`, save critical data and prepare for termination using `AbilityConstant.OnSaveResult` and `AbilityConstant.PrepareTermination`.",
    "input": "",
    "output": "import {AbilityConstant, Ability} from '@kit.AbilityKit';\n\nexport function handleStateTransition(ability: Ability): void {\n  const currentState: AbilityConstant.StateType = ability.getState();\n  const memoryLevel: AbilityConstant.MemoryLevel = ability.onMemoryLevel();\n\n  if (currentState === AbilityConstant.StateType.BACKGROUND && memoryLevel === AbilityConstant.MemoryLevel.LOW) {\n    const saveResult: AbilityConstant.OnSaveResult = ability.onSaveData();\n    const prepareResult: AbilityConstant.PrepareTermination = ability.prepareTerminate();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature that utilizes the `onWindowStageActive` method of `AbilityLifecycleCallback` to detect when a window stage becomes active, and then accesses the `processName` and `startTime` properties from the `AbilityRunningInfo` object to track and display the performance metrics of the active window stage.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class PerformanceTracker extends AbilityLifecycleCallback {\n  onWindowStageActive(abilityRunningInfo: AbilityRunningInfo): void {\n    const processName: string = abilityRunningInfo.processName;\n    const startTime: number = abilityRunningInfo.startTime;\n    \n    console.log(`Process Name: ${processName}`);\n    console.log(`Start Time: ${startTime}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.getCurrentTopAbility` to fetch the topmost ability, then passes the `name` property of this ability to `AbilityMonitor` to set up a monitor for its lifecycle events (`onAbilityForeground` and `onAbilityBackground`), and finally uses `AbilityInfo.type` to determine the type of the ability being monitored.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegator, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function setupAbilityMonitor(delegator: AbilityDelegator): void {\n  const topAbility: AbilityInfo | null = delegator.getCurrentTopAbility();\n  if (topAbility === null) {\n    return;\n  }\n\n  const monitor: AbilityMonitor = {\n    abilityName: topAbility.name,\n    onAbilityForeground: (ability: AbilityInfo) => {\n      console.log(`Ability ${ability.name} entered foreground`);\n    },\n    onAbilityBackground: (ability: AbilityInfo) => {\n      console.log(`Ability ${ability.name} entered background`);\n    }\n  };\n\n  delegator.addAbilityMonitor(monitor);\n  console.log(`Monitoring ability type: ${topAbility.type}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that monitors the ability's state changes using the `onWindowStageActive` and `onWindowStageInactive` methods of `AbilityLifecycleCallback`. Depending on the state change, the function should use the `MemoryLevel` enum from `AbilityConstant` to log the current memory level and adjust the ability's resource usage accordingly (e.g., freeing resources if the memory level is `CRITICAL`).",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private currentMemoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel.NORMAL;\n\n  onWindowStageActive(): void {\n    this.currentMemoryLevel = AbilityConstant.MemoryLevel.NORMAL;\n    console.log(`Current memory level: ${this.currentMemoryLevel}`);\n    this.adjustResourceUsage();\n  }\n\n  onWindowStageInactive(): void {\n    this.currentMemoryLevel = AbilityConstant.MemoryLevel.CRITICAL;\n    console.log(`Current memory level: ${this.currentMemoryLevel}`);\n    this.adjustResourceUsage();\n  }\n\n  private adjustResourceUsage(): void {\n    if (this.currentMemoryLevel === AbilityConstant.MemoryLevel.CRITICAL) {\n      this.freeResources();\n    } else {\n      this.allocateResources();\n    }\n  }\n\n  private freeResources(): void {\n    console.log('Freeing resources due to critical memory level');\n  }\n\n  private allocateResources(): void {\n    console.log('Allocating resources due to normal memory level');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch an ability with a specified `bundleName` and `abilityName`, then uses `AbilityMonitor.onAbilityCreate` to monitor the creation of the ability, and finally checks the `enabled` property of the created ability using `AbilityInfo` to verify its status.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegator, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function startAndMonitorAbility(\n  delegator: AbilityDelegator,\n  bundleName: string,\n  abilityName: string\n): Promise<boolean> {\n  return new Promise((resolve) => {\n    const monitor: AbilityMonitor = {\n      abilityName: abilityName,\n      onAbilityCreate: (ability) => {\n        const abilityInfo: AbilityInfo = ability.context.abilityInfo;\n        resolve(abilityInfo.enabled);\n      }\n    };\n\n    delegator.addAbilityMonitor(monitor);\n    delegator.startAbility({\n      bundleName: bundleName,\n      abilityName: abilityName\n    }).catch(() => {\n      resolve(false);\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility that monitors the window stage lifecycle of an ability. Use the `AbilityLifecycleCallback` methods `onWindowStageCreate` and `onWindowStageDestroy` to detect stage changes, and then retrieve the `AbilityRunningInfo` properties (`uid` and `ability`) to log the unique identifier and name of the ability associated with the window stage.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class WindowStageMonitor extends AbilityLifecycleCallback {\n  onWindowStageCreate(abilityRunningInfo: AbilityRunningInfo): void {\n    console.log(`Window stage created for ability: ${abilityRunningInfo.ability}, UID: ${abilityRunningInfo.uid}`);\n  }\n\n  onWindowStageDestroy(abilityRunningInfo: AbilityRunningInfo): void {\n    console.log(`Window stage destroyed for ability: ${abilityRunningInfo.ability}, UID: ${abilityRunningInfo.uid}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `LaunchReason` enum from `AbilityConstant` to determine the reason for launching an ability, and then constructs an `AbilityResult` object with the `resultCode` property set based on the launch reason (e.g., `0` for normal launch, `1` for error). Pass this `AbilityResult` object to another function that logs the result using the `want` property of `AbilityResult`.",
    "input": "",
    "output": "import { AbilityConstant, AbilityResult } from '@kit.AbilityKit';\n\nexport function determineLaunchReason(launchReason: AbilityConstant.LaunchReason): AbilityResult {\n  let resultCode: number;\n  switch (launchReason) {\n    case AbilityConstant.LaunchReason.NORMAL:\n      resultCode = 0;\n      break;\n    case AbilityConstant.LaunchReason.ERROR:\n      resultCode = 1;\n      break;\n    default:\n      resultCode = -1;\n  }\n  return { resultCode: resultCode, want: undefined };\n}\n\nexport function logAbilityResult(result: AbilityResult): void {\n  console.log(`AbilityResult - resultCode: ${result.resultCode}, want: ${result.want}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that monitors an ability's state changes using `AbilityMonitor.onAbilityForeground` and `AbilityMonitor.onAbilityBackground`, then uses `AbilityConstant.StateType` to verify the current state of the ability, and finally updates the `want` property in `AbilityResult` with the ability's state information for further processing.",
    "input": "",
    "output": "import {AbilityConstant, AbilityResult, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function monitorAbilityStateChanges(abilityName: string, moduleName: string): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.abilityName = abilityName;\n  monitor.moduleName = moduleName;\n\n  monitor.onAbilityForeground = (ability) => {\n    const state: AbilityConstant.StateType = AbilityConstant.StateType.FOREGROUND;\n    const abilityResult: AbilityResult = {\n      resultCode: 0,\n      want: {\n        bundleName: abilityName,\n        moduleName: moduleName,\n        parameters: {\n          state: state\n        }\n      }\n    };\n    return abilityResult;\n  };\n\n  monitor.onAbilityBackground = (ability) => {\n    const state: AbilityConstant.StateType = AbilityConstant.StateType.BACKGROUND;\n    const abilityResult: AbilityResult = {\n      resultCode: 0,\n      want: {\n        bundleName: abilityName,\n        moduleName: moduleName,\n        parameters: {\n          state: state\n        }\n      }\n    };\n    return abilityResult;\n  };\n\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` instance to monitor an ability with a specific `abilityName` and `moduleName`, then passes this monitor to an `AbilityDelegatorArgs` instance by setting its `parameters` property. The function should trigger `onAbilityCreate` and `onAbilityForeground` events and verify the ability lifecycle transitions using the delegator args.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function createAbilityMonitorAndDelegatorArgs(abilityName: string, moduleName: string): AbilityDelegatorArgs {\n  const abilityMonitor: AbilityMonitor = new AbilityMonitor();\n  abilityMonitor.abilityName = abilityName;\n  abilityMonitor.moduleName = moduleName;\n\n  abilityMonitor.onAbilityCreate = (ability) => {\n    console.log(`Ability created: ${ability}`);\n  };\n\n  abilityMonitor.onAbilityForeground = (ability) => {\n    console.log(`Ability in foreground: ${ability}`);\n  };\n\n  const delegatorArgs: AbilityDelegatorArgs = new AbilityDelegatorArgs();\n  delegatorArgs.parameters = {\n    abilityMonitor: abilityMonitor\n  };\n\n  return delegatorArgs;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a test scenario where an `AbilityDelegatorArgs` object is configured with `testCaseNames` and `testRunnerClassName` to run a suite of tests, and then an `AbilityMonitor` is attached (via its `onWindowStageCreate` and `onWindowStageDestroy` callbacks) to validate the window stage lifecycle of the abilities under test, ensuring the test runner logs the results.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class TestScenario {\n  private abilityDelegatorArgs: AbilityDelegatorArgs;\n  private abilityMonitor: AbilityMonitor;\n\n  constructor() {\n    this.abilityDelegatorArgs = {\n      testCaseNames: ['TestCase1', 'TestCase2'],\n      testRunnerClassName: 'TestRunner',\n      bundleName: 'com.example.test',\n      parameters: {}\n    };\n\n    this.abilityMonitor = new AbilityMonitor({\n      abilityName: 'TestAbility',\n      moduleName: 'entry',\n      onWindowStageCreate: (windowStage) => {\n        console.log('WindowStage created for TestAbility');\n      },\n      onWindowStageDestroy: () => {\n        console.log('WindowStage destroyed for TestAbility');\n      }\n    });\n  }\n\n  public getAbilityDelegatorArgs(): AbilityDelegatorArgs {\n    return this.abilityDelegatorArgs;\n  }\n\n  public getAbilityMonitor(): AbilityMonitor {\n    return this.abilityMonitor;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `onConfigurationUpdate` method of `Ability` to monitor system configuration changes, and then triggers the `onMemoryLevel` method of `Ability` to optimize memory allocation if the configuration change indicates a low-memory scenario (e.g., switching to a resource-intensive mode).",
    "input": "",
    "output": "import { Ability } from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  onConfigurationUpdate(newConfig: Ability.Configuration) {\n    super.onConfigurationUpdate(newConfig);\n    if (newConfig.memoryLevel === 'low') {\n      this.onMemoryLevel('low');\n    }\n  }\n\n  onMemoryLevel(level: string) {\n    // Implement memory optimization logic here\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that starts an ability using `AbilityDelegator.startAbility` with a target ability's `AbilityInfo` (retrieved via its `bundleName` and `name` properties), then monitors its foreground/background state transitions using `AbilityMonitor.onAbilityForeground` and `AbilityMonitor.onAbilityBackground`, and finally reports the ability's state changes using `AbilityDelegator.getAbilityState`.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityInfo, AbilityDelegator} from '@kit.AbilityKit';\n\nexport function monitorAbilityState(delegator: AbilityDelegator, abilityInfo: AbilityInfo): void {\n  const monitor = new AbilityMonitor();\n  monitor.abilityName = abilityInfo.name;\n  monitor.moduleName = abilityInfo.moduleName;\n\n  monitor.onAbilityForeground = (ability) => {\n    const state = delegator.getAbilityState(ability);\n    console.log(`Ability ${abilityInfo.name} is in foreground. State: ${state}`);\n  };\n\n  monitor.onAbilityBackground = (ability) => {\n    const state = delegator.getAbilityState(ability);\n    console.log(`Ability ${abilityInfo.name} is in background. State: ${state}`);\n  };\n\n  delegator.addAbilityMonitor(monitor);\n  delegator.startAbility({\n    bundleName: abilityInfo.bundleName,\n    abilityName: abilityInfo.name\n  }).then(() => {\n    console.log(`Ability ${abilityInfo.name} started successfully`);\n  }).catch((err) => {\n    console.error(`Failed to start ability ${abilityInfo.name}: ${err}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks the `deviceTypes` and `deviceCapabilities` properties of an `AbilityInfo` object to determine if the current device supports the ability, then uses the `onMemoryLevel` method of the `Ability` class to adjust the application's memory usage based on the device's capabilities and type.",
    "input": "",
    "output": "import {Ability, AbilityInfo} from '@kit.AbilityKit';\n\nexport function checkDeviceSupportAndAdjustMemory(abilityInfo: AbilityInfo, ability: Ability): void {\n  const supportedDeviceTypes: string[] = abilityInfo.deviceTypes;\n  const requiredCapabilities: string[] = abilityInfo.deviceCapabilities;\n  \n  // Check if the current device type is supported\n  const isDeviceTypeSupported: boolean = supportedDeviceTypes.includes('default'); // Assuming 'default' is the current device type\n  \n  // Check if all required capabilities are available\n  let isCapabilitySupported: boolean = true;\n  if (requiredCapabilities && requiredCapabilities.length > 0) {\n    // Logic to check capabilities would go here, but since we can't use other APIs, we assume true\n    isCapabilitySupported = true;\n  }\n  \n  if (isDeviceTypeSupported && isCapabilitySupported) {\n    // Adjust memory based on device capabilities and type\n    ability.onMemoryLevel(1); // Assuming level 1 is appropriate for supported devices\n  } else {\n    ability.onMemoryLevel(0); // Lower memory level for unsupported devices\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch an ability and then uses `AbilityInfo.bundleName` and `AbilityInfo.name` to verify the launched ability's identity. Finally, use `AbilityLifecycleCallback.onAbilityCreate` to monitor and log the creation of the ability.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityInfo, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport function startAndVerifyAbility(delegator: AbilityDelegator, want: Want): void {\n  const abilityMonitor = {\n    abilityName: '',\n    onAbilityCreate: (abilityInfo: AbilityInfo) => {\n      console.log(`Ability created: ${abilityInfo.bundleName}/${abilityInfo.name}`);\n    }\n  } as AbilityLifecycleCallback;\n\n  delegator.addAbilityMonitor(abilityMonitor);\n  delegator.startAbility(want).then(() => {\n    console.log('Ability started successfully');\n  }).catch((err: Error) => {\n    console.error(`Failed to start ability: ${err.message}`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first adds an ability monitor using `AbilityDelegator.addAbilityMonitor`, then starts an ability using `AbilityDelegator.startAbility`, and finally waits for the monitor to trigger using `AbilityDelegator.waitAbilityMonitor`. The function should return the `AbilityRunningInfo` object provided by the monitor, and verify its `processName` property matches the expected value.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityDelegator} from '@kit.AbilityKit';\n\nexport async function startAndMonitorAbility(\n  delegator: AbilityDelegator,\n  want: Want,\n  expectedProcessName: string\n): Promise<AbilityRunningInfo> {\n  const monitor = delegator.addAbilityMonitor({\n    onAbilityCreate: (abilityInfo: AbilityRunningInfo) => {\n      return abilityInfo.processName === expectedProcessName;\n    }\n  });\n\n  await delegator.startAbility(want);\n  const abilityInfo: AbilityRunningInfo = await delegator.waitAbilityMonitor(monitor);\n\n  if (abilityInfo.processName !== expectedProcessName) {\n    throw new Error(`Process name does not match. Expected: ${expectedProcessName}, Actual: ${abilityInfo.processName}`);\n  }\n\n  return abilityInfo;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityMonitor` to monitor the lifecycle events of an ability (e.g., `onAbilityCreate` and `onAbilityDestroy`). When the ability is destroyed, pass the `abilityName` from the `AbilityMonitor` to the `want` property of `AbilityResult` and set the `resultCode` to indicate the termination status.",
    "input": "",
    "output": "import {AbilityResult, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function monitorAbilityLifecycle(): AbilityMonitor {\n  const monitor: AbilityMonitor = {\n    abilityName: '',\n    onAbilityCreate: (ability) => {\n      console.log(`Ability created: ${ability.abilityInfo.name}`);\n    },\n    onAbilityDestroy: (ability) => {\n      console.log(`Ability destroyed: ${ability.abilityInfo.name}`);\n      const result: AbilityResult = {\n        resultCode: 0,\n        want: {\n          bundleName: '',\n          abilityName: ability.abilityInfo.name\n        }\n      };\n      return result;\n    }\n  };\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityMonitor.onAbilityCreate` to detect when a specific ability is created, then checks the `LaunchReason` from `AbilityConstant` to determine the reason for the launch, and finally sets the `resultCode` in `AbilityResult` based on whether the launch reason was valid or not.",
    "input": "",
    "output": "import {AbilityConstant, AbilityResult, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function monitorAbilityCreation(abilityName: string, validLaunchReasons: AbilityConstant.LaunchReason[]): AbilityMonitor {\n  const monitor: AbilityMonitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (ability) => {\n      const launchReason: AbilityConstant.LaunchReason = ability.launchReason;\n      const result: AbilityResult = {\n        resultCode: validLaunchReasons.includes(launchReason) ? 0 : -1\n      };\n      ability.setResult(result);\n    }\n  };\n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `AbilityRunningInfo` of a currently running ability using its `pid` property, then uses the `bundleName` from this object to fetch the corresponding `AbilityInfo` by matching it with the `bundleName` property of `AbilityInfo`. Finally, display the `label` and `description` of the ability from the `AbilityInfo` object.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityInfo, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function getAbilityInfoByPid(pid: number): void {\n  const runningInfo: AbilityRunningInfo | undefined = getAbilityRunningInfoByPid(pid);\n  if (!runningInfo) {\n    console.error('No running ability found with the given pid');\n    return;\n  }\n\n  const bundleName: string = runningInfo.bundleName;\n  const abilityInfo: AbilityInfo | undefined = getAbilityInfoByBundleName(bundleName);\n  if (!abilityInfo) {\n    console.error('No ability info found with the given bundle name');\n    return;\n  }\n\n  console.log(`Label: ${abilityInfo.label}, Description: ${abilityInfo.description}`);\n}\n\nfunction getAbilityRunningInfoByPid(pid: number): AbilityRunningInfo | undefined {\n  // Implementation to get AbilityRunningInfo by pid\n  // This is a placeholder for the actual implementation\n  return undefined;\n}\n\nfunction getAbilityInfoByBundleName(bundleName: string): AbilityInfo | undefined {\n  // Implementation to get AbilityInfo by bundleName\n  // This is a placeholder for the actual implementation\n  return undefined;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onAbilityCreate` method of `AbilityLifecycleCallback` to initialize an ability, and then checks the current memory level using the `onMemoryLevel` method of `Ability` to log a warning if the memory level is `MemoryLevel.LOW` (from `AbilityConstant`).",
    "input": "",
    "output": "import {AbilityConstant, AbilityLifecycleCallback, Ability} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(ability: Ability): void {\n    // Initialize the ability here\n    console.log('Ability initialized');\n  }\n\n  onMemoryLevel(ability: Ability, level: AbilityConstant.MemoryLevel): void {\n    if (level === AbilityConstant.MemoryLevel.LOW) {\n      console.warn('Memory level is LOW');\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `startTime` property of an `AbilityRunningInfo` object to calculate the duration the ability has been running. If the duration exceeds a threshold, the function should call the `onMemoryLevel` method of the `Ability` class with a `HIGH` memory level (from `AbilityConstant.MemoryLevel`) and return the duration in seconds.",
    "input": "",
    "output": "import {AbilityRunningInfo, Ability, AbilityConstant} from '@kit.AbilityKit';\n\nexport function checkAbilityRunningDuration(abilityRunningInfo: AbilityRunningInfo, ability: Ability, threshold: number): number {\n  const currentTime = new Date().getTime();\n  const startTime = abilityRunningInfo.startTime;\n  const duration = (currentTime - startTime) / 1000; // Convert to seconds\n\n  if (duration > threshold) {\n    ability.onMemoryLevel(AbilityConstant.MemoryLevel.HIGH);\n  }\n\n  return duration;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Design a function that uses the `pid` and `uid` properties from `AbilityRunningInfo` to generate a unique process identifier, then checks the `MemoryLevel` from `AbilityConstant` to determine if the process should be optimized or terminated. The function should return a recommendation based on the cross-referenced data from both APIs.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function checkProcessOptimization(info: AbilityRunningInfo): string {\n  const uniqueId = `${info.pid}_${info.uid}`;\n  \n  switch (info.ability.memoryLevel) {\n    case AbilityConstant.MemoryLevel.MEMORY_LEVEL_LOW:\n      return `Process ${uniqueId} should be optimized due to low memory level.`;\n    case AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE:\n      return `Process ${uniqueId} should be monitored for potential optimization.`;\n    case AbilityConstant.MemoryLevel.MEMORY_LEVEL_CRITICAL:\n      return `Process ${uniqueId} should be terminated immediately due to critical memory level.`;\n    default:\n      return `Process ${uniqueId} is operating normally.`;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that monitors the device's memory level using `Ability.onMemoryLevel` and checks if the current memory level matches `AbilityConstant.MemoryLevel.LOW`. If it does, trigger a cleanup process and log the event with the reason `AbilityConstant.LastExitReason.MEMORY_LOW`.",
    "input": "",
    "output": "import {AbilityConstant, Ability} from '@kit.AbilityKit';\n\nexport function monitorMemoryLevel(ability: Ability): void {\n  ability.onMemoryLevel((level: AbilityConstant.MemoryLevel) => {\n    if (level === AbilityConstant.MemoryLevel.LOW) {\n      // Trigger cleanup process here\n      console.log('Cleanup process triggered due to low memory');\n      // Log the event with the reason MEMORY_LOW\n      console.log(`Last exit reason: ${AbilityConstant.LastExitReason.MEMORY_LOW}`);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature that tracks the foreground and background state changes of an ability. Use the `AbilityLifecycleCallback` methods `onAbilityForeground` and `onAbilityBackground` to detect state transitions, and then query the `AbilityRunningInfo` properties (`abilityState` and `processName`) to log the current state and the process name of the ability.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(abilityRunningInfo: AbilityRunningInfo): void {\n    console.log(`Ability entered foreground. State: ${abilityRunningInfo.abilityState}, Process: ${abilityRunningInfo.processName}`);\n  }\n\n  onAbilityBackground(abilityRunningInfo: AbilityRunningInfo): void {\n    console.log(`Ability entered background. State: ${abilityRunningInfo.abilityState}, Process: ${abilityRunningInfo.processName}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes `AbilityDelegator.addAbilityMonitor` to set up a monitor for an ability with a specific `moduleName`, then uses `AbilityDelegator.waitAbilityMonitor` to wait for the ability to be created, and finally retrieves the `skills` property of the ability using `AbilityInfo` to analyze its capabilities.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegator, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function monitorAndAnalyzeAbility(delegator: AbilityDelegator, moduleName: string): Promise<Array<string> | undefined> {\n  return new Promise((resolve, reject) => {\n    const monitor: AbilityMonitor = {\n      moduleName: moduleName,\n      onAbilityCreate: (ability: AbilityInfo) => {\n        resolve(ability.skills);\n      }\n    };\n\n    delegator.addAbilityMonitor(monitor, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      delegator.waitAbilityMonitor(monitor, 5000, (err, ability) => {\n        if (err) {\n          reject(err);\n        } else if (!ability) {\n          reject(new Error('Ability not created within timeout'));\n        }\n      });\n    });\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch a specific ability, then uses `AbilityDelegator.waitAbilityMonitor` to wait for the ability to be ready, and finally checks the `AbilityResult.resultCode` to verify if the ability was launched successfully.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityResult} from '@kit.AbilityKit';\n\nexport async function launchAndVerifyAbility(delegator: AbilityDelegator, want: Want): Promise<boolean> {\n  const monitor = delegator.addAbilityMonitor(want.abilityName);\n  \n  try {\n    await delegator.startAbility(want);\n    const result: AbilityResult = await delegator.waitAbilityMonitor(monitor);\n    \n    return result.resultCode === 0;\n  } finally {\n    delegator.removeAbilityMonitor(monitor);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that uses `AbilityLifecycleCallback.onWindowStageCreate` to detect when a window stage is created for an ability. Then, use `AbilityRunningInfo` to fetch the `processName` and `startTime` of the associated ability and store them in a global variable for later analysis.",
    "input": "",
    "output": "import { AbilityLifecycleCallback, AbilityRunningInfo } from '@kit.AbilityKit';\n\nlet globalAbilityInfo: {\n  processName: string;\n  startTime: number;\n} | null = null;\n\nexport class CustomAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onWindowStageCreate(windowStage) {\n    const abilityContext = windowStage.getContext();\n    if (abilityContext) {\n      const abilityRunningInfo: AbilityRunningInfo = abilityContext.getAbilityRunningInfo();\n      globalAbilityInfo = {\n        processName: abilityRunningInfo.processName,\n        startTime: abilityRunningInfo.startTime\n      };\n    }\n  }\n}\n\nexport function getGlobalAbilityInfo() {\n  return globalAbilityInfo;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onAbilityForeground` method of `AbilityLifecycleCallback` to bring an ability to the foreground and then calls the `onWindowStageActive` method of the same API to activate the window stage. The function should handle any errors that occur during the transition and log the success or failure of each step.",
    "input": "",
    "output": "import { AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  private abilityContext: any;\n\n  constructor(context: any) {\n    super();\n    this.abilityContext = context;\n  }\n\n  async bringAbilityToForeground() {\n    try {\n      await this.onAbilityForeground(this.abilityContext);\n      console.log('Successfully brought ability to foreground');\n      try {\n        await this.onWindowStageActive(this.abilityContext);\n        console.log('Successfully activated window stage');\n      } catch (error) {\n        console.error('Failed to activate window stage:', error);\n      }\n    } catch (error) {\n      console.error('Failed to bring ability to foreground:', error);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that first adds an ability monitor using `AbilityDelegator.addAbilityMonitorSync`, then starts an ability with `AbilityDelegator.startAbility`, and finally waits for the monitor to trigger using `AbilityDelegator.waitAbilityMonitor` to confirm the ability's lifecycle state change.",
    "input": "",
    "output": "import {AbilityDelegator, Ability, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function monitorAndStartAbility(delegator: AbilityDelegator, want: Want): void {\n  const abilityName = 'AbilityToMonitor';\n  const monitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (ability: Ability) => {\n      console.log(`Ability ${abilityName} created`);\n    },\n    onAbilityForeground: (ability: Ability) => {\n      console.log(`Ability ${abilityName} foreground`);\n    },\n    onAbilityBackground: (ability: Ability) => {\n      console.log(`Ability ${abilityName} background`);\n    },\n    onAbilityDestroy: (ability: Ability) => {\n      console.log(`Ability ${abilityName} destroyed`);\n    },\n    onWindowStageCreate: (ability: Ability) => {\n      console.log(`Ability ${abilityName} window stage created`);\n    },\n    onWindowStageRestore: (ability: Ability) => {\n      console.log(`Ability ${abilityName} window stage restored`);\n    },\n    onWindowStageDestroy: (ability: Ability) => {\n      console.log(`Ability ${abilityName} window stage destroyed`);\n    }\n  };\n\n  delegator.addAbilityMonitorSync(monitor);\n  delegator.startAbility(want);\n  delegator.waitAbilityMonitor(monitor);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.addAbilityMonitor` to set up a monitor for an ability, then uses `AbilityDelegator.waitAbilityMonitor` to wait for the ability to be launched. Once the ability is detected, use `AbilityInfo.type` and `AbilityInfo.launchMode` from the monitored ability's `AbilityInfo` object to log its details.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityInfo, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function monitorAndLogAbility(abilityDelegator: AbilityDelegator, abilityName: string): void {\n  const abilityMonitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (abilityInfo: AbilityInfo) => {\n      console.log(`Ability type: ${abilityInfo.type}`);\n      console.log(`Ability launch mode: ${abilityInfo.launchMode}`);\n    }\n  };\n\n  abilityDelegator.addAbilityMonitor(abilityMonitor);\n  abilityDelegator.waitAbilityMonitor(abilityMonitor);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `WindowMode` enum from `AbilityConstant` to determine the current window mode of the ability. Then, create an `AbilityDelegatorArgs` object with the `testCaseNames` property set to specific test cases and dynamically adjust the test cases based on the window mode (e.g., skip certain tests in fullscreen mode).",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityConstant} from '@kit.AbilityKit';\n\nexport function getWindowModeTests(windowMode: AbilityConstant.WindowMode): AbilityDelegatorArgs {\n  const testCaseNames: string[] = ['testCase1', 'testCase2', 'testCase3'];\n  \n  if (windowMode === AbilityConstant.WindowMode.WINDOW_MODE_FULLSCREEN) {\n    // Skip testCase2 in fullscreen mode\n    testCaseNames.splice(testCaseNames.indexOf('testCase2'), 1);\n  }\n  \n  const args: AbilityDelegatorArgs = {\n    testCaseNames: testCaseNames\n  };\n  \n  return args;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that initializes an `AbilityDelegatorArgs` object with the `parameters` property set to a key-value map and the `testRunnerClassName` property set to a specific test runner class. Use the `StateType` enum from `AbilityConstant` to check the current state of the ability and conditionally modify the `parameters` map based on the state.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityConstant} from '@kit.AbilityKit';\n\nexport function initializeAbilityDelegatorArgs(testRunnerClassName: string, state: AbilityConstant.StateType): AbilityDelegatorArgs {\n  const args = new AbilityDelegatorArgs();\n  args.testRunnerClassName = testRunnerClassName;\n  args.parameters = {};\n\n  if (state === AbilityConstant.StateType.READY) {\n    args.parameters['state'] = 'READY';\n  } else if (state === AbilityConstant.StateType.INACTIVE) {\n    args.parameters['state'] = 'INACTIVE';\n  } else if (state === AbilityConstant.StateType.ACTIVE) {\n    args.parameters['state'] = 'ACTIVE';\n  } else if (state === AbilityConstant.StateType.BACKGROUND) {\n    args.parameters['state'] = 'BACKGROUND';\n  }\n\n  return args;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that compares two `AbilityRunningInfo` objects by their `startTime` and returns an `AbilityResult` object where the `resultCode` indicates which ability started first (1 or 2) and the `want` property includes the `processName` and `pid` of the earlier-started ability.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityResult} from '@kit.AbilityKit';\n\nexport function compareAbilityStartTime(ability1: AbilityRunningInfo, ability2: AbilityRunningInfo): AbilityResult {\n  let result: AbilityResult = {\n    resultCode: 0,\n    want: {\n      processName: '',\n      pid: 0\n    }\n  };\n\n  if (ability1.startTime < ability2.startTime) {\n    result.resultCode = 1;\n    result.want = {\n      processName: ability1.processName,\n      pid: ability1.pid\n    };\n  } else {\n    result.resultCode = 2;\n    result.want = {\n      processName: ability2.processName,\n      pid: ability2.pid\n    };\n  }\n\n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that employs the `onAbilityDestroy` method of `AbilityLifecycleCallback` to identify when an ability is destroyed, and then uses the `uid` and `ability` properties from the `AbilityRunningInfo` object to generate a cleanup report for the terminated ability.",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class CleanupReportCallback extends AbilityLifecycleCallback {\n  onAbilityDestroy(abilityRunningInfo: AbilityRunningInfo): void {\n    const uid = abilityRunningInfo.uid;\n    const ability = abilityRunningInfo.ability;\n    const cleanupReport = `Cleanup Report: Ability with UID ${uid} and name ${ability} has been destroyed.`;\n    console.log(cleanupReport);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the current running ability's `AbilityRunningInfo` (including `abilityState`, `pid`, and `processName`) and uses the `StateType` enum from `AbilityConstant` to determine if the ability is in a `FOREGROUND` state. If it is, log the process details; otherwise, log the reason using the `LastExitReason` enum from `AbilityConstant`.",
    "input": "",
    "output": "import { AbilityConstant, AbilityRunningInfo } from '@kit.AbilityKit';\n\nexport function checkAbilityState() {\n  const runningInfo: AbilityRunningInfo = {\n    ability: undefined,\n    abilityState: AbilityConstant.StateType.BACKGROUND,\n    pid: 1234,\n    processName: 'sample_process',\n    startTime: 0,\n    uid: 0\n  };\n\n  if (runningInfo.abilityState === AbilityConstant.StateType.FOREGROUND) {\n    console.log(`Process Details - PID: ${runningInfo.pid}, Process Name: ${runningInfo.processName}`);\n  } else {\n    const lastExitReason: AbilityConstant.LastExitReason = AbilityConstant.LastExitReason.UNKNOWN;\n    console.log(`Ability is not in foreground. Last Exit Reason: ${lastExitReason}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `processName` from `AbilityRunningInfo` to filter all running abilities in the same process. For each matching ability, fetch its `AbilityInfo` using the `bundleName` and `moduleName` properties, then compile a list of all `permissions` required by these abilities from the `AbilityInfo` objects.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityInfo, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\n/**\n * Filters running abilities by process name and compiles a list of their permissions.\n * @param runningInfos - Array of AbilityRunningInfo objects.\n * @param processName - The process name to filter abilities by.\n * @returns A list of permissions required by the filtered abilities.\n */\nexport function getPermissionsByProcessName(runningInfos: AbilityRunningInfo[], processName: string): string[] {\n  const permissions: string[] = [];\n  \n  for (const runningInfo of runningInfos) {\n    if (runningInfo.processName === processName) {\n      const abilityInfo: AbilityInfo = runningInfo.ability;\n      if (abilityInfo.permissions && abilityInfo.permissions.length > 0) {\n        permissions.push(...abilityInfo.permissions);\n      }\n    }\n  }\n  \n  return permissions;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks the `MemoryLevel` enum from `AbilityConstant` to determine the current memory state of the device. Based on the memory level, set the `resultCode` property of an `AbilityResult` object (e.g., `200` for low memory, `300` for critical memory). Then, use the `want` property of `AbilityResult` to trigger a cleanup process if the memory level is critical.",
    "input": "",
    "output": "import { AbilityConstant, AbilityResult } from '@kit.AbilityKit';\n\nexport function checkMemoryLevel(): AbilityResult {\n  const abilityResult: AbilityResult = new AbilityResult();\n  const memoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel;\n  \n  switch (memoryLevel) {\n    case AbilityConstant.MemoryLevel.LOW:\n      abilityResult.resultCode = 200;\n      break;\n    case AbilityConstant.MemoryLevel.CRITICAL:\n      abilityResult.resultCode = 300;\n      abilityResult.want = {\n        bundleName: 'cleanup',\n        abilityName: 'cleanupAbility',\n        action: 'action.cleanup'\n      };\n      break;\n    default:\n      abilityResult.resultCode = 0;\n      break;\n  }\n  \n  return abilityResult;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks if an ability is visible (`isVisible` property from `AbilityInfo`) and has the required permissions (`permissions` property from `AbilityInfo`). If both conditions are met, use the `want` property from `AbilityResult` to start the ability and return the `resultCode` from the `AbilityResult` object.",
    "input": "",
    "output": "import {AbilityInfo, AbilityResult} from '@kit.AbilityKit';\n\nexport function checkAndStartAbility(abilityInfo: AbilityInfo, abilityResult: AbilityResult): number {\n  if (abilityInfo.isVisible && abilityInfo.permissions && abilityInfo.permissions.length > 0) {\n    if (abilityResult.want) {\n      return abilityResult.resultCode;\n    }\n  }\n  return -1;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that compares the `resultCode` properties of two different `AbilityResult` objects to determine which operation was more successful (lower resultCode indicates better success). Then, use the `want` property of the better-performing `AbilityResult` to log the intent details.",
    "input": "",
    "output": "import { AbilityResult } from '@kit.AbilityKit';\n\nexport function compareAndLogBetterResult(result1: AbilityResult, result2: AbilityResult): void {\n  const betterResult = result1.resultCode <= result2.resultCode ? result1 : result2;\n  console.log(`Better result intent details: ${JSON.stringify(betterResult.want)}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.getCurrentTopAbility` to retrieve the current top ability, then checks its state using `AbilityDelegator.getAbilityState`, and finally uses the state information to construct an `AbilityResult` object with the `resultCode` and `want` properties to report the ability's status.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityResult} from '@kit.AbilityKit';\n\nexport function getAbilityStatus(abilityDelegator: AbilityDelegator): AbilityResult {\n  const topAbility = abilityDelegator.getCurrentTopAbility();\n  if (!topAbility) {\n    return {\n      resultCode: -1,\n      want: undefined\n    };\n  }\n  \n  const abilityState = abilityDelegator.getAbilityState(topAbility);\n  \n  return {\n    resultCode: abilityState,\n    want: topAbility.want\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that checks the `MemoryLevel` enum from `AbilityConstant` to determine the current memory state of the device, and then uses the `PrepareTermination` enum from `AbilityConstant` to decide whether the ability should prepare for termination or continue running based on the memory level.",
    "input": "",
    "output": "import { AbilityConstant } from '@kit.AbilityKit';\n\nexport function checkMemoryAndPrepareTermination(): boolean {\n  const memoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel.MEMORY_LEVEL_MODERATE;\n  const prepareTermination: AbilityConstant.PrepareTermination = AbilityConstant.PrepareTermination.PREPARE_TERMINATION_YES;\n\n  switch (memoryLevel) {\n    case AbilityConstant.MemoryLevel.MEMORY_LEVEL_LOW:\n    case AbilityConstant.MemoryLevel.MEMORY_LEVEL_CRITICAL:\n      return prepareTermination === AbilityConstant.PrepareTermination.PREPARE_TERMINATION_YES;\n    default:\n      return false;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature that uses the `onMemoryLevel` method of `Ability` to detect high memory usage and then retrieves the `uid` and `ability` properties from `AbilityRunningInfo` to identify and log which ability is consuming excessive resources.",
    "input": "",
    "output": "import {Ability, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport class MemoryMonitorAbility extends Ability {\n  onMemoryLevel(level: string): void {\n    if (level === 'high') {\n      const runningInfo: AbilityRunningInfo = this.context.getAbilityRunningInfo();\n      const uid: number = runningInfo.uid;\n      const abilityName: string = runningInfo.ability?.name || 'unknown';\n      console.log(`High memory usage detected. UID: ${uid}, Ability: ${abilityName}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `StateType` enum from `AbilityConstant` to check the current state of an ability. Depending on the state, create an `AbilityResult` object with a specific `resultCode` (e.g., `100` for active, `400` for inactive). Pass this `AbilityResult` object to another function that uses the `want` property to navigate to a different ability or display a notification based on the result code.",
    "input": "",
    "output": "import { AbilityConstant, AbilityResult } from '@kit.AbilityKit';\n\nexport function checkAbilityState(currentState: AbilityConstant.StateType): AbilityResult {\n  let resultCode: number;\n  switch (currentState) {\n    case AbilityConstant.StateType.ACTIVE:\n      resultCode = 100;\n      break;\n    case AbilityConstant.StateType.INACTIVE:\n      resultCode = 400;\n      break;\n    default:\n      resultCode = 0;\n      break;\n  }\n  const abilityResult: AbilityResult = {\n    resultCode: resultCode,\n    want: {}\n  };\n  return abilityResult;\n}\n\nexport function handleAbilityResult(abilityResult: AbilityResult): void {\n  if (abilityResult.resultCode === 100) {\n    // Navigate to another ability\n    console.log('Navigating to another ability');\n  } else if (abilityResult.resultCode === 400) {\n    // Display notification\n    console.log('Displaying notification');\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegator.startAbility` to launch a specific ability, then uses `AbilityDelegator.getCurrentTopAbility` to retrieve the `AbilityRunningInfo` of the top ability, and finally checks if the `abilityState` property of the returned `AbilityRunningInfo` matches the expected state (e.g., FOREGROUND).",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityDelegator} from '@kit.AbilityKit';\n\nexport async function checkTopAbilityState(\n  delegator: AbilityDelegator,\n  want: Want,\n  expectedState: number\n): Promise<boolean> {\n  try {\n    await delegator.startAbility(want);\n    const topAbility: AbilityRunningInfo = delegator.getCurrentTopAbility();\n    return topAbility.abilityState === expectedState;\n  } catch (error) {\n    console.error(`Failed to check top ability state: ${error}`);\n    return false;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `startTime` from `AbilityRunningInfo` to calculate the duration an ability has been running, and then maps this duration to a `LaunchReason` from `AbilityConstant` (e.g., short duration maps to `LaunchReason.COLD_START`, long duration maps to `LaunchReason.HOT_START`). The function should return the inferred launch reason based on the interaction between the two APIs.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function inferLaunchReason(abilityInfo: AbilityRunningInfo): AbilityConstant.LaunchReason {\n  const currentTime = new Date().getTime();\n  const startTime = abilityInfo.startTime;\n  const duration = currentTime - startTime;\n  \n  // Assuming a threshold of 5000ms (5 seconds) to differentiate between cold and hot start\n  const COLD_START_THRESHOLD = 5000;\n  \n  if (duration <= COLD_START_THRESHOLD) {\n    return AbilityConstant.LaunchReason.COLD_START;\n  } else {\n    return AbilityConstant.LaunchReason.HOT_START;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes an `AbilityRunningInfo` object, extracts its `abilityState` and `pid`, and passes these to the `onMemoryLevel` method of the `Ability` class to dynamically adjust memory usage based on the current state of the ability (e.g., increasing memory allocation if the state is 'active').",
    "input": "",
    "output": "import {AbilityRunningInfo, Ability} from '@kit.AbilityKit';\n\nexport function adjustMemoryUsage(abilityInfo: AbilityRunningInfo, ability: Ability): void {\n  const {abilityState, pid} = abilityInfo;\n  ability.onMemoryLevel(abilityState, pid);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test scenario where you use `AbilityMonitor` to track an ability's window stage events (onWindowStageCreate, onWindowStageDestroy). Pass this monitor to `AbilityDelegator` using `addAbilityMonitorSync`. Then, use `executeShellCommand` to simulate a background/foreground transition and verify the ability's state changes with `getAbilityState`.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function testAbilityMonitorScenario() {\n  const abilityName = 'testAbility';\n  const moduleName = 'testModule';\n  \n  const abilityDelegatorArgs: AbilityDelegatorArgs = {\n    bundleName: 'com.example.test',\n    parameters: {},\n    testCaseNames: ['testAbilityMonitorScenario'],\n    testRunnerClassName: 'TestRunner'\n  };\n  \n  const abilityDelegator = AbilityDelegator.getAbilityDelegator(abilityDelegatorArgs);\n  \n  let windowStageCreateCalled = false;\n  let windowStageDestroyCalled = false;\n  \n  const abilityMonitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onWindowStageCreate: () => {\n      windowStageCreateCalled = true;\n    },\n    onWindowStageDestroy: () => {\n      windowStageDestroyCalled = true;\n    }\n  };\n  \n  abilityDelegator.addAbilityMonitorSync(abilityMonitor);\n  \n  abilityDelegator.executeShellCommand('am start -n com.example.test/.testAbility');\n  \n  const initialState = abilityDelegator.getAbilityState(abilityName);\n  \n  abilityDelegator.executeShellCommand('input keyevent KEYCODE_HOME');\n  \n  const backgroundState = abilityDelegator.getAbilityState(abilityName);\n  \n  abilityDelegator.executeShellCommand('am start -n com.example.test/.testAbility');\n  \n  const foregroundState = abilityDelegator.getAbilityState(abilityName);\n  \n  abilityDelegator.removeAbilityMonitorSync(abilityMonitor);\n  \n  return {\n    windowStageCreateCalled,\n    windowStageDestroyCalled,\n    initialState,\n    backgroundState,\n    foregroundState\n  };\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a utility that leverages `AbilityMonitor.onAbilityForeground` to detect when an ability comes to the foreground and then uses `AbilityLifecycleCallback.onAbilityForeground` to trigger a custom notification or update the UI based on the ability's new state.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class AbilityStateMonitor {\n  private abilityMonitor: AbilityMonitor;\n  private lifecycleCallback: AbilityLifecycleCallback;\n\n  constructor() {\n    this.abilityMonitor = {\n      abilityName: '',\n      moduleName: '',\n      onAbilityForeground: (ability) => {\n        this.handleAbilityForeground(ability);\n      }\n    };\n\n    this.lifecycleCallback = {\n      onAbilityForeground: (ability) => {\n        this.handleAbilityForeground(ability);\n      }\n    };\n  }\n\n  private handleAbilityForeground(ability: any): void {\n    // Custom notification or UI update logic here\n    console.log(`Ability ${ability.abilityInfo.name} is now in the foreground`);\n  }\n\n  public startMonitoring(abilityName: string, moduleName: string): void {\n    this.abilityMonitor.abilityName = abilityName;\n    this.abilityMonitor.moduleName = moduleName;\n    // Register the monitor and callback\n    // Note: Actual registration code depends on the framework's API\n  }\n\n  public stopMonitoring(): void {\n    // Unregister the monitor and callback\n    // Note: Actual unregistration code depends on the framework's API\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that sets up an `AbilityMonitor` to track foreground/background transitions (`onAbilityForeground`, `onAbilityBackground`) of a specific ability, and then uses the `startTime` property from `AbilityRunningInfo` to calculate and report the duration the ability spent in the foreground state.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityResult, AbilityMonitor} from '@kit.AbilityKit';\n\nexport class AbilityDurationTracker {\n  private abilityMonitor: AbilityMonitor;\n  private foregroundStartTime: number = 0;\n  private totalForegroundDuration: number = 0;\n\n  constructor(abilityName: string, moduleName: string) {\n    this.abilityMonitor = {\n      abilityName: abilityName,\n      moduleName: moduleName,\n      onAbilityForeground: (abilityRunningInfo: AbilityRunningInfo) => {\n        this.foregroundStartTime = abilityRunningInfo.startTime;\n      },\n      onAbilityBackground: (abilityRunningInfo: AbilityRunningInfo) => {\n        if (this.foregroundStartTime > 0) {\n          this.totalForegroundDuration += abilityRunningInfo.startTime - this.foregroundStartTime;\n          this.foregroundStartTime = 0;\n        }\n      }\n    };\n  }\n\n  public getAbilityMonitor(): AbilityMonitor {\n    return this.abilityMonitor;\n  }\n\n  public getTotalForegroundDuration(): number {\n    return this.totalForegroundDuration;\n  }\n\n  public resetDuration(): void {\n    this.totalForegroundDuration = 0;\n    this.foregroundStartTime = 0;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test case that uses `AbilityDelegatorArgs.testCaseNames` to define the test scenario, then employs `AbilityDelegator.executeShellCommand` to simulate a system event, and uses `AbilityDelegator.waitAbilityMonitor` to ensure the ability responds correctly to the event.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function testAbilityResponse() {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    testCaseNames: ['testAbilityResponse'],\n    bundleName: 'com.example.myapplication',\n    parameters: {},\n    testRunnerClassName: ''\n  };\n\n  const abilityDelegator = new AbilityDelegator(delegatorArgs);\n  const monitor = abilityDelegator.addAbilityMonitorSync({\n    abilityName: 'MainAbility',\n    onAbilityCreate: (data) => {\n      console.log('Ability created:', data);\n    }\n  });\n\n  abilityDelegator.executeShellCommand('input keyevent KEYCODE_HOME').then(() => {\n    console.log('Shell command executed');\n  }).catch((err) => {\n    console.error('Shell command failed:', err);\n  });\n\n  abilityDelegator.waitAbilityMonitor(monitor, 5000).then((data) => {\n    console.log('Ability monitor triggered:', data);\n    abilityDelegator.finishTest('Test completed successfully', 0);\n  }).catch((err) => {\n    console.error('Ability monitor failed:', err);\n    abilityDelegator.finishTest('Test failed', 1);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.executeShellCommand` to simulate a low-memory event (e.g., `AbilityConstant.MemoryLevel.LOW`) and then checks the ability's `memoryLevel` (from `AbilityInfo`) to confirm the event was handled. The function should also verify if the ability's `supportWindowModes` (from `AbilityInfo`) includes the expected window mode (e.g., `AbilityConstant.WindowMode.FULLSCREEN`).",
    "input": "",
    "output": "import {AbilityConstant, AbilityDelegator, AbilityInfo} from '@kit.AbilityKit';\n\nexport function simulateLowMemoryAndCheckWindowMode(\n  delegator: AbilityDelegator,\n  abilityInfo: AbilityInfo,\n  expectedWindowMode: AbilityConstant.WindowMode\n): boolean {\n  // Simulate low memory event\n  const command = 'memory pressure low';\n  delegator.executeShellCommand(command, (err, data) => {\n    if (err) {\n      console.error(`Failed to execute shell command: ${err.message}`);\n      return false;\n    }\n    console.log(`Shell command executed successfully: ${data}`);\n  });\n\n  // Check memory level\n  const isMemoryLow = abilityInfo.memoryLevel === AbilityConstant.MemoryLevel.LOW;\n  \n  // Check window mode support\n  const supportsExpectedWindowMode = abilityInfo.supportWindowModes.includes(expectedWindowMode);\n  \n  return isMemoryLow && supportsExpectedWindowMode;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that registers an `AbilityLifecycleCallback` to monitor the lifecycle events of an `Ability`. Use the `onAbilityCreate` method of `AbilityLifecycleCallback` to log when an ability is created, and then use the `abilityName` property of `AbilityMonitor` to filter and track only specific abilities by name.",
    "input": "",
    "output": "import {Ability, AbilityLifecycleCallback, AbilityMonitor} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(ability: Ability): void {\n    console.log(`Ability created: ${ability.context.abilityInfo.name}`);\n  }\n}\n\nexport function registerAbilityMonitor(abilityName: string): void {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.abilityName = abilityName;\n  \n  const callback: MyAbilityLifecycleCallback = new MyAbilityLifecycleCallback();\n  monitor.onAbilityCreate = callback.onAbilityCreate.bind(callback);\n  \n  // Assuming there is a global Ability context or manager to register the monitor\n  // For example: AbilityContext.registerAbilityMonitor(monitor);\n  // Since the exact registration method is not provided in the API, this is a placeholder\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that checks the current `MemoryLevel` from `AbilityConstant` and, based on its value (e.g., `MEMORY_LEVEL_LOW`), triggers a `PrepareTermination` state transition in `AbilityConstant` to gracefully handle resource cleanup before termination.",
    "input": "",
    "output": "import { AbilityConstant } from '@kit.AbilityKit';\n\nexport function checkMemoryLevelAndPrepareTermination(): void {\n  const memoryLevel: AbilityConstant.MemoryLevel = AbilityConstant.MemoryLevel.MEMORY_LEVEL_LOW;\n  if (memoryLevel === AbilityConstant.MemoryLevel.MEMORY_LEVEL_LOW) {\n    AbilityConstant.PrepareTermination();\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that retrieves the `AbilityInfo` of the current ability using `Ability.context.abilityInfo`, then checks if the ability supports window modes by accessing the `supportWindowModes` property of `AbilityInfo`. Based on this, call `Ability.onConfigurationUpdate` to handle potential configuration changes if window modes are supported.",
    "input": "",
    "output": "import {Ability, AbilityInfo} from '@kit.AbilityKit';\n\nexport function checkWindowModesSupport(context: Ability): void {\n  const abilityInfo: AbilityInfo = context.abilityInfo;\n  if (abilityInfo.supportWindowModes) {\n    context.onConfigurationUpdate((config) => {\n      // Handle configuration changes here\n    });\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the current top ability using `AbilityDelegator.getCurrentTopAbility`, then checks its visibility status using `AbilityInfo.isVisible`. If the ability is visible, use `AbilityLifecycleCallback.onAbilityForeground` to log its transition to the foreground.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityInfo, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport function checkTopAbilityVisibility(abilityDelegator: AbilityDelegator, callback: AbilityLifecycleCallback): void {\n  const topAbility: AbilityInfo | null = abilityDelegator.getCurrentTopAbility();\n  if (topAbility && topAbility.isVisible) {\n    callback.onAbilityForeground(topAbility);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that compares the `startTime` of two `AbilityRunningInfo` objects to determine which ability started earlier, and then uses the `abilityState` property to check if the earlier-started ability is still running. If it is, log its `uid` and `ability` name.",
    "input": "",
    "output": "import {AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function compareAndLogEarlierAbility(ability1: AbilityRunningInfo, ability2: AbilityRunningInfo): void {\n  const earlierAbility = ability1.startTime < ability2.startTime ? ability1 : ability2;\n  if (earlierAbility.abilityState === 0) { // Assuming 0 represents running state\n    console.log(`UID: ${earlierAbility.uid}, Ability: ${earlierAbility.ability}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityMonitor` to listen for the `onWindowStageCreate` event of an ability. When the event is triggered, create an `AbilityResult` object with a `resultCode` indicating success and populate the `want` property with details from the event. Pass this `AbilityResult` to another function that logs the `resultCode` and `want` properties.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityResult} from '@kit.AbilityKit';\n\nexport function setupAbilityMonitor(): AbilityMonitor {\n  const monitor: AbilityMonitor = {\n    onWindowStageCreate: (ability) => {\n      const abilityResult: AbilityResult = {\n        resultCode: 0,\n        want: ability.want\n      };\n      logAbilityResult(abilityResult);\n    }\n  };\n  return monitor;\n}\n\nexport function logAbilityResult(abilityResult: AbilityResult): void {\n  console.log(`resultCode: ${abilityResult.resultCode}, want: ${JSON.stringify(abilityResult.want)}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test scenario where you use `AbilityDelegatorArgs.testCaseNames` to define test cases, then use `AbilityDelegator.executeShellCommand` to set up the test environment, and finally use `AbilityDelegator.waitAbilityMonitor` to wait for the ability to reach the desired state before asserting the test results.",
    "input": "",
    "output": "import { AbilityDelegator, AbilityDelegatorArgs } from '@kit.AbilityKit';\n\nexport function createTestScenario() {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    testCaseNames: ['testCase1', 'testCase2'],\n    bundleName: 'com.example.test',\n    testRunnerClassName: 'TestRunner',\n    parameters: {}\n  };\n\n  const abilityDelegator = new AbilityDelegator(delegatorArgs);\n\n  export async function setupTestEnvironment() {\n    const command = 'setup_command';\n    const timeout = 5000;\n    const result = await abilityDelegator.executeShellCommand(command, timeout);\n    if (result.code !== 0) {\n      throw new Error(`Failed to execute shell command: ${result.message}`);\n    }\n  }\n\n  export async function waitForAbilityState(abilityName: string, state: number, timeout: number) {\n    const monitor = {\n      abilityName: abilityName,\n      onAbilityCreate: (data) => {},\n      onAbilityForeground: (data) => {},\n      onAbilityBackground: (data) => {},\n      onAbilityDestroy: (data) => {}\n    };\n    abilityDelegator.addAbilityMonitor(monitor);\n    const ability = await abilityDelegator.waitAbilityMonitor(monitor, timeout);\n    const currentState = abilityDelegator.getAbilityState(ability);\n    if (currentState !== state) {\n      throw new Error(`Ability state is ${currentState}, expected ${state}`);\n    }\n    abilityDelegator.removeAbilityMonitor(monitor);\n  }\n\n  export async function runTestScenario() {\n    try {\n      await setupTestEnvironment();\n      await waitForAbilityState('MainAbility', 2, 10000);\n      console.log('Test scenario passed');\n    } catch (error) {\n      console.error(`Test scenario failed: ${error.message}`);\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityMonitor` instance to monitor the lifecycle events of an ability with a specific `abilityName` and `moduleName`. Use the `onAbilityCreate` callback to trigger the creation of an `AbilityResult` object with a custom `resultCode` and `want` property, then return this object as the result of the function.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityResult} from '@kit.AbilityKit';\n\nexport function createAbilityMonitor(abilityName: string, moduleName: string, resultCode: number, want: object): AbilityMonitor {\n  const monitor: AbilityMonitor = new AbilityMonitor();\n  monitor.abilityName = abilityName;\n  monitor.moduleName = moduleName;\n  \n  monitor.onAbilityCreate = (): AbilityResult => {\n    const result: AbilityResult = new AbilityResult();\n    result.resultCode = resultCode;\n    result.want = want;\n    return result;\n  };\n  \n  return monitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `LaunchReason` enum from `AbilityConstant` to determine the reason for launching an ability, and then based on the launch reason, uses the `WindowMode` enum from `AbilityConstant` to set the appropriate window mode for the ability (e.g., fullscreen or floating).",
    "input": "",
    "output": "import { AbilityConstant } from '@kit.AbilityKit';\n\nexport function setWindowModeBasedOnLaunchReason(launchReason: AbilityConstant.LaunchReason): AbilityConstant.WindowMode {\n  let windowMode: AbilityConstant.WindowMode;\n  switch (launchReason) {\n    case AbilityConstant.LaunchReason.START_ABILITY:\n    case AbilityConstant.LaunchReason.CALL:\n      windowMode = AbilityConstant.WindowMode.FULLSCREEN;\n      break;\n    case AbilityConstant.LaunchReason.DIALOG:\n      windowMode = AbilityConstant.WindowMode.FLOATING;\n      break;\n    default:\n      windowMode = AbilityConstant.WindowMode.FULLSCREEN;\n  }\n  return windowMode;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.addAbilityStageMonitorSync` to monitor an ability stage, then calls `AbilityDelegator.getCurrentTopAbility` to retrieve the top ability, and finally uses `AbilityDelegator.removeAbilityStageMonitorSync` to remove the monitor after validation.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function monitorAndValidateTopAbility(abilityDelegator: AbilityDelegator, monitorName: string): void {\n  const abilityStageMonitor = {\n    moduleName: 'entry',\n    srcEntrance: './ets/Application/MyAbilityStage.ts',\n  };\n\n  abilityDelegator.addAbilityStageMonitorSync(monitorName, abilityStageMonitor);\n  const topAbility = abilityDelegator.getCurrentTopAbility();\n  \n  if (topAbility) {\n    console.log('Top ability validated:', topAbility);\n  } else {\n    console.error('No top ability found');\n  }\n  \n  abilityDelegator.removeAbilityStageMonitorSync(monitorName);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses the `LaunchReason` enum from `AbilityConstant` to determine the reason for the app launch (e.g., `LaunchReason.START_ABILITY`). Based on the launch reason, use the `onConfigurationUpdate` method of `Ability` to adjust the app's configuration dynamically (e.g., changing the theme or layout) to match the launch context.",
    "input": "",
    "output": "import {Ability, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbility extends Ability {\n  onConfigurationUpdate(newConfig: Ability.Configuration): void {\n    const launchReason: AbilityConstant.LaunchReason = this.launchReason;\n    \n    switch (launchReason) {\n      case AbilityConstant.LaunchReason.START_ABILITY:\n        // Adjust configuration for START_ABILITY\n        break;\n      case AbilityConstant.LaunchReason.CALL:\n        // Adjust configuration for CALL\n        break;\n      case AbilityConstant.LaunchReason.CONTINUATION:\n        // Adjust configuration for CONTINUATION\n        break;\n      default:\n        // Default configuration adjustments\n        break;\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `resultCode` property of `AbilityResult` to check if an ability execution was successful (resultCode == 0), and if so, extracts the `want` property from the same `AbilityResult` object to start a new ability. Then, use the `pid` and `uid` properties from `AbilityRunningInfo` to verify the newly started ability's process and user ID.",
    "input": "",
    "output": "import {AbilityResult, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function checkAndStartAbility(abilityResult: AbilityResult, abilityRunningInfo: AbilityRunningInfo): void {\n  if (abilityResult.resultCode === 0 && abilityResult.want) {\n    // Start new ability using want property\n    // Assuming there's a context available to start the ability\n    // For example: context.startAbility(abilityResult.want);\n    \n    // Verify the newly started ability's process and user ID\n    const pid = abilityRunningInfo.pid;\n    const uid = abilityRunningInfo.uid;\n    \n    // Perform verification logic here\n    // For example: console.log(`New ability PID: ${pid}, UID: ${uid}`);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityMonitor.onAbilityCreate` to detect when a new ability is created, and then registers a callback using `AbilityLifecycleCallback.onAbilityDestroy` to monitor when that same ability is destroyed. The function should log the lifecycle events (creation and destruction) of the specified ability.",
    "input": "",
    "output": "import { AbilityMonitor, AbilityLifecycleCallback } from '@kit.AbilityKit';\n\nexport function monitorAbilityLifecycle(abilityName: string, moduleName: string): void {\n  const abilityMonitor: AbilityMonitor = {\n    abilityName: abilityName,\n    moduleName: moduleName,\n    onAbilityCreate: (ability) => {\n      console.log(`Ability created: ${abilityName}`);\n      const lifecycleCallback: AbilityLifecycleCallback = {\n        onAbilityDestroy: (destroyedAbility) => {\n          if (destroyedAbility.context.abilityInfo.name === abilityName) {\n            console.log(`Ability destroyed: ${abilityName}`);\n          }\n        }\n      };\n      ability.registerAbilityLifecycleCallback(lifecycleCallback);\n    }\n  };\n  globalThis.abilityMonitor = abilityMonitor;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that retrieves the current top ability using `AbilityDelegator.getCurrentTopAbility`, then verifies its visibility by checking the `AbilityInfo.isVisible` property. The function should return true if the top ability is visible and false otherwise.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegator, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function checkTopAbilityVisibility(abilityDelegator: AbilityDelegator): boolean {\n  const topAbility: AbilityInfo | null = abilityDelegator.getCurrentTopAbility();\n  if (topAbility && topAbility.isVisible !== undefined) {\n    return topAbility.isVisible;\n  }\n  return false;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a utility that uses `AbilityMonitor` to listen for an ability's creation and destruction events (via `onAbilityCreate` and `onAbilityDestroy`) and dynamically updates the `parameters` property of an `AbilityDelegatorArgs` object to include these events as part of the test execution context, enabling conditional test flows based on the ability's lifecycle state.",
    "input": "",
    "output": "import {AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class AbilityLifecycleMonitor {\n  private abilityDelegatorArgs: AbilityDelegatorArgs;\n  private monitor: AbilityMonitor;\n\n  constructor(args: AbilityDelegatorArgs) {\n    this.abilityDelegatorArgs = args;\n    this.monitor = new AbilityMonitor();\n  }\n\n  public setupMonitor(abilityName: string, moduleName: string): void {\n    this.monitor.abilityName = abilityName;\n    this.monitor.moduleName = moduleName;\n\n    this.monitor.onAbilityCreate = (ability) => {\n      this.updateParameters('onAbilityCreate', ability);\n    };\n\n    this.monitor.onAbilityDestroy = (ability) => {\n      this.updateParameters('onAbilityDestroy', ability);\n    };\n  }\n\n  private updateParameters(eventType: string, ability: any): void {\n    if (!this.abilityDelegatorArgs.parameters) {\n      this.abilityDelegatorArgs.parameters = {};\n    }\n    this.abilityDelegatorArgs.parameters[eventType] = ability;\n  }\n\n  public getMonitor(): AbilityMonitor {\n    return this.monitor;\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that creates an `AbilityDelegatorArgs` object with the `bundleName` property set to a specific bundle name and the `testCaseNames` property populated with test case names. Then, use the `LaunchReason` enum from `AbilityConstant` to determine the launch reason for the ability and log it alongside the bundle name.",
    "input": "",
    "output": "import {AbilityDelegatorArgs, AbilityConstant} from '@kit.AbilityKit';\n\nexport function createAbilityDelegatorArgs(bundleName: string, testCaseNames: string[]): AbilityDelegatorArgs {\n  const args = new AbilityDelegatorArgs();\n  args.bundleName = bundleName;\n  args.testCaseNames = testCaseNames;\n  return args;\n}\n\nexport function logLaunchReason(bundleName: string, reason: AbilityConstant.LaunchReason): void {\n  console.log(`Bundle Name: ${bundleName}, Launch Reason: ${AbilityConstant.LaunchReason[reason]}`);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses `AbilityDelegatorArgs.bundleName` to specify the target bundle, then uses `AbilityDelegator.startAbility` to launch the specified ability, and finally uses `AbilityDelegator.waitAbilityMonitor` to verify that the ability reaches the foreground state.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function launchAndVerifyAbility(bundleName: string, abilityName: string, abilityDelegator: AbilityDelegator): void {\n  const abilityDelegatorArgs: AbilityDelegatorArgs = {\n    bundleName: bundleName\n  };\n\n  const want = {\n    bundleName: bundleName,\n    abilityName: abilityName\n  };\n\n  const monitor = {\n    abilityName: abilityName,\n    onAbilityCreate: (data) => {\n      console.log(`Ability ${abilityName} created`);\n    },\n    onAbilityForeground: (data) => {\n      console.log(`Ability ${abilityName} reached foreground`);\n    },\n    onAbilityBackground: (data) => {\n      console.log(`Ability ${abilityName} moved to background`);\n    },\n    onAbilityDestroy: (data) => {\n      console.log(`Ability ${abilityName} destroyed`);\n    }\n  };\n\n  abilityDelegator.addAbilityMonitor(monitor);\n  abilityDelegator.startAbility(want);\n  abilityDelegator.waitAbilityMonitor(monitor, (err, data) => {\n    if (err) {\n      console.error(`Error waiting for ability monitor: ${err}`);\n      return;\n    }\n    console.log(`Ability ${abilityName} state verified`);\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature where the `onConfigurationUpdate` method of one `Ability` instance is used to detect system-wide configuration changes, and then the `onMemoryLevel` method of a second `Ability` instance is invoked to release non-critical resources if the system enters a low-memory state.",
    "input": "",
    "output": "import { Ability } from '@kit.AbilityKit';\n\nexport class FirstAbility extends Ability {\n  onConfigurationUpdate(newConfig: any) {\n    // Detect system-wide configuration changes\n    console.log('Configuration updated:', newConfig);\n  }\n}\n\nexport class SecondAbility extends Ability {\n  onMemoryLevel(level: string) {\n    // Release non-critical resources if the system enters a low-memory state\n    if (level === 'low') {\n      console.log('Releasing non-critical resources due to low memory state');\n    }\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a test case that uses `AbilityDelegatorArgs` to define a mock list (setMockList) and test runner class. Pass these args to `AbilityDelegator` and use `waitAbilityMonitor` to wait for a specific ability (monitored via `AbilityMonitor`'s abilityName property) to reach a foreground state. Then, use `doAbilityBackground` and `doAbilityForeground` to test the ability's resilience to state changes.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityMonitor, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport class AbilityTestRunner {\n  private abilityDelegator: AbilityDelegator;\n  private abilityMonitor: AbilityMonitor;\n\n  constructor() {\n    const delegatorArgs: AbilityDelegatorArgs = {\n      bundleName: 'com.example.myapplication',\n      parameters: {},\n      testCaseNames: ['testAbilityStateChanges'],\n      testRunnerClassName: 'AbilityTestRunner'\n    };\n\n    this.abilityDelegator = new AbilityDelegator(delegatorArgs);\n    this.abilityMonitor = new AbilityMonitor({\n      abilityName: 'com.example.myapplication.MainAbility'\n    });\n  }\n\n  async testAbilityStateChanges(): Promise<void> {\n    this.abilityDelegator.setMockList(['mockAbility']);\n    this.abilityDelegator.addAbilityMonitor(this.abilityMonitor);\n\n    await this.abilityDelegator.waitAbilityMonitor(this.abilityMonitor, {foreground: true});\n\n    await this.abilityDelegator.doAbilityBackground(this.abilityMonitor.abilityName);\n    await this.abilityDelegator.doAbilityForeground(this.abilityMonitor.abilityName);\n\n    this.abilityDelegator.removeAbilityMonitor(this.abilityMonitor);\n    this.abilityDelegator.finishTest('Test completed successfully', 0);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that leverages `onAbilityForeground` from `AbilityLifecycleCallback` to detect when an Ability comes to the foreground, and then uses `onMemoryLevel` from `Ability` to check the current memory level and adjust resource usage (e.g., freeing up memory if the level is critical).",
    "input": "",
    "output": "import {Ability, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MemoryMonitorCallback extends AbilityLifecycleCallback {\n  onAbilityForeground(ability: Ability): void {\n    const memoryLevel = ability.onMemoryLevel();\n    if (memoryLevel === Ability.MemoryLevel.MEMORY_LEVEL_CRITICAL) {\n      // Free up memory or adjust resource usage here\n    }\n  }\n}\n\nexport class MyAbility extends Ability {\n  private memoryMonitorCallback: MemoryMonitorCallback = new MemoryMonitorCallback();\n\n  onCreate(): void {\n    this.registerAbilityLifecycleCallback(this.memoryMonitorCallback);\n  }\n\n  onDestroy(): void {\n    this.unregisterAbilityLifecycleCallback(this.memoryMonitorCallback);\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that compares the `startTime` of two `AbilityRunningInfo` objects to determine which ability started earlier, then generates an `AbilityResult` object where the `want` property includes the `processName` of the earlier ability and the `resultCode` is set to `1` if the first ability started earlier, otherwise `2`.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityResult} from '@kit.AbilityKit';\n\nexport function compareStartTimeAndGenerateResult(abilityInfo1: AbilityRunningInfo, abilityInfo2: AbilityRunningInfo): AbilityResult {\n  const result: AbilityResult = {\n    resultCode: abilityInfo1.startTime < abilityInfo2.startTime ? 1 : 2,\n    want: {\n      processName: abilityInfo1.startTime < abilityInfo2.startTime ? abilityInfo1.processName : abilityInfo2.processName\n    }\n  };\n  return result;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Write a function that uses the `onAbilityCreate` method of `AbilityLifecycleCallback` to initialize an ability, and then checks the `LaunchReason` enum from `AbilityConstant` to determine the reason for the ability's launch. Based on the launch reason, the function should either call `onAbilityForeground` (if the reason is `LAUNCHER`) or `onAbilityBackground` (if the reason is `BACKGROUND`).",
    "input": "",
    "output": "import {AbilityLifecycleCallback, AbilityConstant} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityCreate(want, launchParam, abilityConstant: AbilityConstant.LaunchReason) {\n    if (abilityConstant === AbilityConstant.LaunchReason.LAUNCHER) {\n      this.onAbilityForeground();\n    } else if (abilityConstant === AbilityConstant.LaunchReason.BACKGROUND) {\n      this.onAbilityBackground();\n    }\n  }\n\n  private onAbilityForeground() {\n    // Implementation for foreground\n  }\n\n  private onAbilityBackground() {\n    // Implementation for background\n  }\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.executeShellCommand` to run a shell command and collect process IDs, then uses `AbilityDelegator.getAbilityState` to verify the state of each corresponding ability by matching the PID with the `pid` property from `AbilityRunningInfo`.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityRunningInfo} from '@kit.AbilityKit';\n\nexport function verifyAbilityStatesByPid(delegator: AbilityDelegator, command: string): void {\n  delegator.executeShellCommand(command, (err, data) => {\n    if (err) {\n      console.error(`executeShellCommand failed, error: ${err.message}`);\n      return;\n    }\n\n    const pids: number[] = parsePidsFromOutput(data);\n    if (pids.length === 0) {\n      console.error('No PIDs found in command output');\n      return;\n    }\n\n    const abilityStates: Map<number, AbilityRunningInfo> = new Map();\n    const abilityInfos: AbilityRunningInfo[] = delegator.getAbilityState();\n\n    for (const info of abilityInfos) {\n      if (pids.includes(info.pid)) {\n        abilityStates.set(info.pid, info);\n      }\n    }\n\n    for (const pid of pids) {\n      if (abilityStates.has(pid)) {\n        const info = abilityStates.get(pid);\n        console.log(`PID: ${pid}, AbilityState: ${info?.abilityState}`);\n      } else {\n        console.log(`PID: ${pid} has no corresponding ability`);\n      }\n    }\n  });\n}\n\nfunction parsePidsFromOutput(output: string): number[] {\n  const lines = output.split('\\n');\n  const pids: number[] = [];\n\n  for (const line of lines) {\n    const pidMatch = line.match(/^\\s*(\\d+)\\s*/);\n    if (pidMatch) {\n      const pid = parseInt(pidMatch[1], 10);\n      if (!isNaN(pid)) {\n        pids.push(pid);\n      }\n    }\n  }\n\n  return pids;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a feature where an `AbilityLifecycleCallback` is used to detect when an ability enters the background using `onAbilityBackground`. Upon detection, use the `onMemoryLevel` method of the `Ability` class to check the current memory level and perform cleanup or optimization tasks if the memory level is critical.",
    "input": "",
    "output": "import {Ability, AbilityLifecycleCallback, AbilityMonitor} from '@kit.AbilityKit';\n\nexport class MyAbilityLifecycleCallback extends AbilityLifecycleCallback {\n  onAbilityBackground(ability: Ability): void {\n    const memoryLevel = ability.onMemoryLevel();\n    if (memoryLevel === 'CRITICAL') {\n      // Perform cleanup or optimization tasks here\n      console.log('Critical memory level detected. Performing cleanup tasks.');\n    }\n  }\n}\n\nexport function registerAbilityLifecycleCallback(): void {\n  const callback = new MyAbilityLifecycleCallback();\n  const monitor = new AbilityMonitor();\n  monitor.onAbilityBackground = callback.onAbilityBackground.bind(callback);\n  // Register the monitor with the Ability context as needed\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a test case that starts an ability using `AbilityDelegator.startAbility`, monitors its window stage events using `AbilityMonitor` (with `onWindowStageCreate` and `onWindowStageDestroy` properties), and then uses `AbilityDelegator.waitAbilityMonitor` to wait for the ability to be destroyed before asserting the test result.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityMonitor} from '@kit.AbilityKit';\n\nexport function testStartAbilityAndMonitorLifecycle() {\n  const delegator = AbilityDelegator.getDelegator();\n  const want = {\n    bundleName: 'com.example.myapplication',\n    abilityName: 'EntryAbility'\n  };\n\n  const monitor: AbilityMonitor = {\n    abilityName: 'EntryAbility',\n    onWindowStageCreate: (ability) => {\n      console.log('onWindowStageCreate');\n    },\n    onWindowStageDestroy: (ability) => {\n      console.log('onWindowStageDestroy');\n    }\n  };\n\n  delegator.addAbilityMonitor(monitor);\n  delegator.startAbility(want);\n  delegator.waitAbilityMonitor(monitor);\n\n  console.log('Test completed');\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegator.addAbilityMonitor` to set up a monitor for an ability, then uses `AbilityDelegator.doAbilityBackground` to send the ability to the background, and finally verifies the transition using `AbilityDelegator.waitAbilityMonitor` to confirm the background state.",
    "input": "",
    "output": "import {AbilityDelegator, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function monitorAbilityBackgroundTransition(delegator: AbilityDelegator, abilityName: string): Promise<boolean> {\n  return new Promise<boolean>((resolve, reject) => {\n    try {\n      const monitor = delegator.addAbilityMonitor({\n        abilityName: abilityName,\n        onAbilityBackground: () => {\n          resolve(true);\n        }\n      });\n\n      delegator.doAbilityBackground(abilityName);\n\n      delegator.waitAbilityMonitor(monitor, 5000).then(() => {\n        delegator.removeAbilityMonitor(monitor);\n      }).catch(() => {\n        delegator.removeAbilityMonitor(monitor);\n        resolve(false);\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that takes an `AbilityRunningInfo` object and checks if the `abilityState` matches any of the `ContinueState` values from `AbilityConstant`. The function should return a boolean indicating whether the ability can continue running or needs to be terminated, using properties from both APIs.",
    "input": "",
    "output": "import {AbilityRunningInfo, AbilityConstant} from '@kit.AbilityKit';\n\nexport function canContinueRunning(abilityInfo: AbilityRunningInfo): boolean {\n  const continueStates = [\n    AbilityConstant.ContinueState.ABOUT_TO_CONTINUE,\n    AbilityConstant.ContinueState.CONTINUE,\n    AbilityConstant.ContinueState.REJECT_CONTINUE\n  ];\n  \n  return continueStates.includes(abilityInfo.abilityState);\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that uses `AbilityDelegatorArgs.bundleName` to specify a target bundle, then monitors the ability stage using `AbilityDelegator.addAbilityStageMonitorSync`. The function should return the monitor result once the target ability stage is detected.",
    "input": "",
    "output": "import {AbilityInfo, AbilityDelegator, AbilityDelegatorArgs} from '@kit.AbilityKit';\n\nexport function monitorAbilityStage(bundleName: string, delegator: AbilityDelegator): boolean {\n  const delegatorArgs: AbilityDelegatorArgs = {\n    bundleName: bundleName\n  };\n\n  const abilityStageMonitor = delegator.addAbilityStageMonitorSync(delegatorArgs);\n  const result = delegator.waitAbilityStageMonitor(abilityStageMonitor, 5000);\n  \n  return result !== null;\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Create a function that utilizes the `onMemoryLevel` method of `Ability` to monitor memory levels, and based on the memory level, calls either `onAbilityBackground` or `onAbilityForeground` methods of `AbilityLifecycleCallback` to manage the ability's lifecycle state in response to memory pressure.",
    "input": "",
    "output": "import {Ability, AbilityResult, AbilityLifecycleCallback} from '@kit.AbilityKit';\n\nexport class MemoryMonitorAbility extends Ability {\n  private lifecycleCallback: AbilityLifecycleCallback;\n\n  constructor() {\n    super();\n    this.lifecycleCallback = new AbilityLifecycleCallbackImpl();\n  }\n\n  onMemoryLevel(level: number): AbilityResult {\n    if (level < 0) {\n      return {\n        resultCode: -1,\n        want: {}\n      };\n    }\n\n    if (level >= 3) {\n      this.lifecycleCallback.onAbilityBackground(this.context);\n    } else {\n      this.lifecycleCallback.onAbilityForeground(this.context);\n    }\n\n    return {\n      resultCode: 0,\n      want: {}\n    };\n  }\n}\n\nclass AbilityLifecycleCallbackImpl extends AbilityLifecycleCallback {\n  onAbilityBackground(ability: Ability): void {\n    // Handle background state\n  }\n\n  onAbilityForeground(ability: Ability): void {\n    // Handle foreground state\n  }\n\n  onAbilityContinue(ability: Ability): void {}\n  onAbilityCreate(ability: Ability): void {}\n  onAbilityDestroy(ability: Ability): void {}\n  onWindowStageActive(ability: Ability): void {}\n  onWindowStageCreate(ability: Ability): void {}\n  onWindowStageDestroy(ability: Ability): void {}\n  onWindowStageInactive(ability: Ability): void {}\n}",
    "system": "",
    "history": []
  },
  {
    "instruction": "Implement a function that takes an array of `AbilityResult` objects, filters out those with non-zero `resultCode`, and then collects the `want` properties from the remaining objects to create a summary report of all successful ability intents.",
    "input": "",
    "output": "import { AbilityResult } from '@kit.AbilityKit';\n\nexport function getSuccessfulAbilityIntents(results: AbilityResult[]): object[] {\n  const successfulResults = results.filter((result) => result.resultCode === 0);\n  return successfulResults.map((result) => result.want);\n}",
    "system": "",
    "history": []
  }
]