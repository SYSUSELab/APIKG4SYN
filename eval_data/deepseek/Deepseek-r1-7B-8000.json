{
  "benchmark_results": [
    {
      "instruction": "Given an undirected graph represented as an adjacency list (ArrayList<ArrayList<number>>), write a function bfsOrder that returns the BFS traversal order starting from a given node. Use a queue implemented with Deque<number> from ArkTS.",
      "code": "import { ArrayList, Deque, HashSet } from '@kit.ArkTS';\n\nexport function bfsOrder(graph: ArrayList<ArrayList<number>>, start: number): ArrayList<number> {\n  const visited = new HashSet<number>();\n  const queue = new Deque<number>();\n  const order = new ArrayList<number>();\n\n  visited.add(start);\n  queue.insertEnd(start);\n\n  while (queue.length > 0) {\n    const node = queue.popFirst() as number;\n    order.add(node);\n\n    const neighbors = graph[node] as ArrayList<number>;\n    for (let i = 0; i < neighbors.length; i++) {\n      const nei = neighbors[i] as number;\n      if (!visited.has(nei)) {\n        visited.add(nei);\n        queue.insertEnd(nei);\n      }\n    }\n  }\n\n  return order;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { bfsOrder } from '../main/ets/Algorithms/bfs';\n\nexport default function bfsGraphTest() {\n  describe('bfsOrder', () => {\n    it('should return BFS order for a simple graph', 0, () => {\n      const graph = new ArrayList<ArrayList<number>>();\n      for (let i = 0; i < 4; i++) graph.add(new ArrayList<number>());\n\n      graph[0]?.add(1);\n      graph[0]?.add(2);\n      graph[1]?.add(0);\n      graph[1]?.add(3);\n      graph[2]?.add(0);\n      graph[2]?.add(3);\n      graph[3]?.add(1);\n      graph[3]?.add(2);\n\n      const order = bfsOrder(graph, 0);\n      const expected = [0, 1, 2, 3];\n      expect(order.length).assertEqual(expected.length);\n      for (let i = 0; i < expected.length; i++) {\n        expect(order[i]).assertEqual(expected[i]);\n      }\n    });\n  });\n}",
      "model_output": "import {ArrayList, Deque} from '@kit.ArkTS';\n\nexport function bfsOrder(graph: ArrayList<ArrayList<number>>, start: number): number[] {\n  const queue = new Deque<number>();\n  const visited = new Set<number>();\n  const order: number[] = [];\n\n  queue.push(start);\n  visited.add(start);\n\n  while (queue.length > 0) {\n    const current = queue.popFirst();\n    if (current!== undefined) {\n      order.push(current);\n      const neighbors = graph[current];\n      if (neighbors) {\n        for (const neighbor of neighbors) {\n          if (!visited.has(neighbor)) {\n            queue.push(neighbor);\n            visited.add(neighbor);\n          }\n        }\n      }\n    }\n  }\n\n  return order;\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named isValidParentheses. This function should determine whether a given string contains valid parentheses. The string may include the characters (), [], and {}. Use the Stack and HashMap classes from @kit.ArkTS to assist with matching pairs. The function should: Accept a single parameter s: string representing the input string. Return a boolean indicating whether the parentheses are correctly matched.",
      "code": "import { Stack, HashMap } from '@kit.ArkTS'\n\nexport function isValidParentheses(s: string): boolean {\n  const st = new Stack<string>();\n  const pair = new HashMap<string, string>();\n  pair.set(')', '('); pair.set(']', '['); pair.set('}', '{');\n\n  for (let i = 0; i < s.length; i++) {\n    const ch = s[i];\n    if (ch === '(' || ch === '[' || ch === '{') {\n      st.push(ch);\n    } else {\n      if (st.isEmpty()) return false;\n      const need = pair.get(ch);\n      if (st.pop() !== need) return false;\n    }\n  }\n  return st.isEmpty();\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { isValidParentheses } from '../main/ets/Algorithms/BracketMatching';\n\nexport default function localUnitTest() {\n  describe('algorithms_using_harmony_api', () => {\n    it('isValidParentheses_cases', 0, () => {\n      expect(isValidParentheses('()[]{}')).assertTrue();\n      expect(isValidParentheses('(]')).assertFalse();\n      expect(isValidParentheses('([{}])')).assertTrue();\n    });\n  });\n}",
      "model_output": "import {Stack, HashMap} from '@kit.ArkTS';\n\nexport function isValidParentheses(s: string): boolean {\n  const stack = new Stack<string>();\n  const map = new HashMap<string, string>();\n  map.set('(', ')');\n  map.set('[', ']');\n  map.set('{', '}');\n  \n  for (const char of s) {\n    if (map.hasKey(char)) {\n      stack.push(char);\n    } else {\n      if (stack.isEmpty()) {\n        return false;\n      }\n      const top = stack.pop();\n      if (map.get(top)!== char) {\n        return false;\n      }\n    }\n  }\n  return stack.isEmpty();\n}",
      "test_passed": true
    },
    {
      "instruction": "You are given an integer numCourses labeled from 0 to numCourses - 1, and a list of prerequisite pairs prerequisites, each represented as ArrayList<number> arrays: prerequisites.get(i) is an ArrayList<number> of length 2 [ai, bi], meaning course bi must be taken before ai.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function canFinish(\n  numCourses: number,\n  prerequisites: ArrayList<ArrayList<number>>\n): boolean {\n  const indegree = new ArrayList<number>();\n  const adj = new ArrayList<ArrayList<number>>();\n\n  for (let i = 0; i < numCourses; i++) {\n    indegree.add(0);\n    adj.add(new ArrayList<number>());\n  }\n\n  for (let i = 0; i < prerequisites.length; i++) {\n    const pair = prerequisites[i]!;\n    const a = pair[0]!;\n    const b = pair[1]!;\n    adj[b]!.add(a);\n    indegree[a] = indegree[a] + 1;\n  }\n\n  const queue: number[] = [];\n  for (let i = 0; i < numCourses; i++) {\n    if (indegree[i] === 0) {\n      queue.push(i);\n    }\n  }\n\n  let count = 0;\n  while (queue.length > 0) {\n    const course = queue.shift()!;\n    count++;\n    const neighbors = adj[course]!;\n    for (let j = 0; j < neighbors.length; j++) {\n      const nei = neighbors[j]!;\n      indegree[nei] = indegree[nei] - 1;\n      if (indegree[nei] === 0) {\n        queue.push(nei);\n      }\n    }\n  }\n\n  return count === numCourses;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { canFinish } from '../main/ets/Algorithms/canFinish';\n\nexport default function courseScheduleTest() {\n  describe('canFinish_Course_Schedule', () => {\n\n    it('should return true for numCourses=2, prerequisites=[[1,0]]', 0, () => {\n      const prerequisites = new ArrayList<ArrayList<number>>();\n      const pair = new ArrayList<number>();\n      pair.add(1); pair.add(0);\n      prerequisites.add(pair);\n      expect(canFinish(2, prerequisites)).assertEqual(true);\n    });\n\n    it('should return false for numCourses=2, prerequisites=[[1,0],[0,1]]', 0, () => {\n      const prerequisites = new ArrayList<ArrayList<number>>();\n      const p1 = new ArrayList<number>(); p1.add(1); p1.add(0);\n      const p2 = new ArrayList<number>(); p2.add(0); p2.add(1);\n      prerequisites.add(p1); prerequisites.add(p2);\n      expect(canFinish(2, prerequisites)).assertEqual(false);\n    });\n\n    it('should return true for no prerequisites', 0, () => {\n      const prerequisites = new ArrayList<ArrayList<number>>();\n      expect(canFinish(3, prerequisites)).assertEqual(true);\n    });\n\n    it('should detect cycle in a longer dependency', 0, () => {\n      // 3 courses: 0->1, 1->2, 2->0\n      const prerequisites = new ArrayList<ArrayList<number>>();\n      const p1 = new ArrayList<number>(); p1.add(1); p1.add(0);\n      const p2 = new ArrayList<number>(); p2.add(2); p2.add(1);\n      const p3 = new ArrayList<number>(); p3.add(0); p3.add(2);\n      prerequisites.add(p1); prerequisites.add(p2); prerequisites.add(p3);\n      expect(canFinish(3, prerequisites)).assertEqual(false);\n    });\n\n  });\n}",
      "model_output": "import { ArrayList } from '@kit.ArkTS';\n\nexport function canFinish(numCourses: number, prerequisites: ArrayList<ArrayList<number>>): boolean {\n  const graph = new Map<number, number[]>();\n  const indegree = new Array<number>(numCourses).fill(0);\n  \n  for (const pair of prerequisites) {\n    const [course, prereq] = pair.get(0), pair.get(1);\n    if (!graph.has(prereq)) {\n      graph.set(prereq, []);\n    }\n    graph.get(prereq).push(course);\n    indegree[course]++;\n  }\n  \n  const queue = new Array<number>();\n  for (let i = 0; i < numCourses; i++) {\n    if (indegree[i] === 0) {\n      queue.push(i);\n    }\n  }\n  \n  let count = 0;\n  while (queue.length > 0) {\n    const course = queue.shift();\n    count++;\n    if (graph.has(course)) {\n      for (const next of graph.get(course)) {\n        indegree[next]--;\n        if (indegree[next] === 0) {\n          queue.push(next);\n        }\n      }\n    }\n  }\n  \n  return count === numCourses;\n}",
      "test_passed": false
    },
    {
      "instruction": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
      "code": "export function climbStairs(n: number): number {\n  if (n <= 2) return n;\n  let first = 1;\n  let second = 2;\n  for (let i = 3; i <= n; i++) {\n    const temp = first + second;\n    first = second;\n    second = temp;\n  }\n  return second;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { climbStairs } from '../main/ets/Algorithms/climbStair';\n\nexport default function climbingStairsTest() {\n  describe('climbStairs', () => {\n    it('should return correct number of ways to climb stairs', 0, () => {\n      const n = 5;\n      expect(climbStairs(n)).assertEqual(8);\n    });\n  });\n}",
      "model_output": "import {climbStairs} from '../main/ets/Algorithms/climbStair';\n\nexport function climbStairs(n: number): number {\n  if (n <= 2) {\n    return n;\n  }\n  let a = 1;\n  let b = 2;\n  let c = 0;\n  for (let i = 3; i <= n; i++) {\n    c = a + b;\n    a = b;\n    b = c;\n  }\n  return c;\n}",
      "test_passed": false
    },
    {
      "instruction": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function coinChange(coins: ArrayList<number>, amount: number): number {\n  const dp = new Array<number>(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (i - coin >= 0) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { coinChange } from '../main/ets/Algorithms/coinChange';\n\nexport default function coinChangeTest() {\n  describe('coinChange', () => {\n    it('should return correct minimum number of coins', 0, () => {\n      const coins = new ArrayList<number>();\n      coins.add(1);\n      coins.add(2);\n      coins.add(5);\n      const amount = 11;\n      expect(coinChange(coins, amount)).assertEqual(3);\n    });\n  });\n}",
      "model_output": "import { ArrayList } from '@kit.ArkTS';\n\nexport function coinChange(coins: ArrayList<number>, amount: number): number {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  \n  for (let i = 1; i <= amount; i++) {\n    for (let j = 0; j < coins.length; j++) {\n      if (coins[j] <= i) {\n        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n      }\n    }\n  }\n  \n  return dp[amount] === Infinity? -1 : dp[amount];\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an integer array temperatures representing daily temperatures, return an ArrayList<number> from @kit.ArkTS called answer where answer[i] indicates the number of days you have to wait until a warmer temperature. If there is no future day with a higher temperature, use 0 for that day.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function dailyTemperatures(temperatures: number[]): ArrayList<number> {\n  const n = temperatures.length;\n  const answer = new ArrayList<number>();\n  for (let i = 0; i < n; i++) answer.add(0);\n\n  const stack = new ArrayList<number>();\n\n  for (let i = 0; i < n; i++) {\n    while (stack.length > 0 && temperatures[i] > temperatures[stack[stack.length - 1]!]) {\n      const idx = stack[stack.length - 1]!;\n      stack.removeByIndex(stack.length - 1);\n      answer[idx] = i - idx;\n    }\n    stack.add(i);\n  }\n\n  return answer;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { dailyTemperatures } from '../main/ets/Algorithms/dailyTemperatures';\n\nexport default function dailyTemperaturesTest() {\n  describe('dailyTemperatures', () => {\n\n    it('should return correct answer for example input', 0, () => {\n      const temps = [73,74,75,71,69,72,76,73];\n      const result = dailyTemperatures(temps);\n      const expected = [1,1,4,2,1,1,0,0];\n      expect(result.length).assertEqual(expected.length);\n      for (let i = 0; i < expected.length; i++) {\n        expect(result[i]).assertEqual(expected[i]);\n      }\n    });\n\n    it('should handle strictly decreasing temperatures', 0, () => {\n      const temps = [100,90,80,70];\n      const result = dailyTemperatures(temps);\n      const expected = [0,0,0,0];\n      for (let i = 0; i < expected.length; i++) {\n        expect(result[i]).assertEqual(expected[i]);\n      }\n    });\n\n    it('should handle all equal temperatures', 0, () => {\n      const temps = [50,50,50];\n      const result = dailyTemperatures(temps);\n      const expected = [0,0,0];\n      for (let i = 0; i < expected.length; i++) {\n        expect(result[i]).assertEqual(expected[i]);\n      }\n    });\n\n    it('should handle single day', 0, () => {\n      const temps = [70];\n      const result = dailyTemperatures(temps);\n      const expected = [0];\n      expect(result.length).assertEqual(1);\n      expect(result[0]).assertEqual(0);\n    });\n\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function dailyTemperatures(temperatures: number[]): ArrayList<number> {\n  const stack = new ArrayList<number>();\n  const result = new ArrayList<number>();\n  \n  for (let i = 0; i < temperatures.length; i++) {\n    while (stack.length > 0 && temperatures[i] > temperatures[stack[stack.length - 1]]) {\n      const prevIndex = stack.pop();\n      result[prevIndex] = i - prevIndex;\n    }\n    stack.push(i);\n    result[i] = 0;\n  }\n  \n  return result;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an undirected graph represented as an adjacency list (ArrayList<ArrayList<number>>), write a function dfsOrder that returns the DFS traversal order starting from a given node. Use recursion and ArkTS containers.",
      "code": "import { ArrayList, HashSet } from '@kit.ArkTS';\n\nfunction dfs(node: number, graph: ArrayList<ArrayList<number>>, visited: HashSet<number>, order: ArrayList<number>) {\n  visited.add(node);\n  order.add(node);\n\n  const neighbors = graph[node] as ArrayList<number>;\n  for (let i = 0; i < neighbors.length; i++) {\n    const nei = neighbors[i] as number;\n    if (!visited.has(nei)) {\n      dfs(nei, graph, visited, order);\n    }\n  }\n}\n\nexport function dfsOrder(graph: ArrayList<ArrayList<number>>, start: number): ArrayList<number> {\n  const visited = new HashSet<number>();\n  const order = new ArrayList<number>();\n  dfs(start, graph, visited, order);\n  return order;\n}",
      "test": "import { ArrayList } from '@kit.ArkTS';\nimport { describe, it, expect } from '@ohos/hypium';\nimport { dfsOrder } from '../main/ets/Algorithms/dfs';\n\nexport default function dfsOrderTest() {\n  describe('dfsOrder', () => {\n\n    it('should handle a simple chain 0->1->2', 0, () => {\n      const graph = new ArrayList<ArrayList<number>>();\n      for (let i = 0; i < 3; i++) graph.add(new ArrayList<number>());\n\n      (graph[0] as ArrayList<number>).add(1);\n      (graph[1] as ArrayList<number>).add(2);\n\n      const res = dfsOrder(graph, 0);\n      const out: number[] = [];\n      for (let i = 0; i < res.length; i++) out.push(res[i] as number);\n\n      expect(JSON.stringify(out)).assertEqual(JSON.stringify([0, 1, 2]));\n    });\n\n    it('should handle a branching graph 0->[1,2], 1->[3]', 0, () => {\n      const graph = new ArrayList<ArrayList<number>>();\n      for (let i = 0; i < 4; i++) graph.add(new ArrayList<number>());\n\n      (graph[0] as ArrayList<number>).add(1);\n      (graph[0] as ArrayList<number>).add(2);\n      (graph[1] as ArrayList<number>).add(3);\n\n      const res = dfsOrder(graph, 0);\n      const out: number[] = [];\n      for (let i = 0; i < res.length; i++) out.push(res[i] as number);\n      expect(JSON.stringify(out)).assertEqual(JSON.stringify([0, 1, 3, 2]));\n    });\n\n    it('should work when starting DFS from a middle node (start=2)', 0, () => {\n      const graph = new ArrayList<ArrayList<number>>();\n      for (let i = 0; i < 4; i++) graph.add(new ArrayList<number>());\n\n      (graph[0] as ArrayList<number>).add(1);\n      (graph[1] as ArrayList<number>).add(2);\n      (graph[2] as ArrayList<number>).add(0);\n      (graph[2] as ArrayList<number>).add(3);\n\n      const res = dfsOrder(graph, 2);\n      const out: number[] = [];\n      for (let i = 0; i < res.length; i++) out.push(res[i] as number);\n\n      expect(JSON.stringify(out)).assertEqual(JSON.stringify([2, 0, 1, 3]));\n    });\n\n  });\n}",
      "model_output": "import { ArrayList } from '@kit.ArkTS';\n\nexport function dfsOrder(graph: ArrayList<ArrayList<number>>, start: number): number[] {\n  const visited = new ArrayList<boolean>();\n  const result: number[] = [];\n\n  const dfs = (node: number) => {\n    if (visited[node]) return;\n    visited[node] = true;\n    result.push(node);\n    const neighbors = graph[node] as ArrayList<number>;\n    for (let i = 0; i < neighbors.length; i++) {\n      dfs(neighbors[i] as number);\n    }\n  };\n\n  dfs(start);\n  return result;\n}",
      "test_passed": true
    },
    {
      "instruction": "Given an integer n, return the n-th Fibonacci number. The Fibonacci sequence is defined as:  F(0) = 0, F(1) = 1 F(n) = F(n-1) + F(n-2), for n > 1 Use @kit.ArkTS.ArrayList<number> if needed to store intermediate results (memoization). Use .add(value) to append, .get(index) to access, and .size() to check the size of the list.",
      "code": "import { ArrayList } from '@kit.ArkTS';\nexport function fibonacci(n: number): number {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n\n  const memo = new ArrayList<number>();\n  memo.add(0);\n  memo.add(1);\n\n  for (let i = 2; i <= n; i++) {\n    memo.add(memo[i - 1] + memo[i - 2]);\n  }\n\n  return memo[n];\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { fibonacci } from '../main/ets/Algorithms/fibonacci';\n\nexport default function fibonacciTest() {\n  describe('fibonacci', () => {\n    it('should return 0 for n=0', 0, () => {\n      expect(fibonacci(0)).assertEqual(0);\n    });\n\n    it('should return 1 for n=1', 0, () => {\n      expect(fibonacci(1)).assertEqual(1);\n    });\n\n    it('should return 5 for n=5', 0, () => {\n      expect(fibonacci(5)).assertEqual(5);\n    });\n\n    it('should return 55 for n=10', 0, () => {\n      expect(fibonacci(10)).assertEqual(55);\n    });\n\n    it('should return 832040 for n=30', 0, () => {\n      expect(fibonacci(30)).assertEqual(832040);\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function fibonacci(n: number): number {\n  if (n <= 1) {\n    return n;\n  }\n  const memo = new ArrayList<number>();\n  memo.add(0);\n  memo.add(1);\n  for (let i = 2; i <= n; i++) {\n    const next = memo.get(i - 1) + memo.get(i - 2);\n    memo.add(next);\n  }\n  return memo.get(n);\n}",
      "test_passed": false
    },
    {
      "instruction": "Write a function findMaxValue that takes a List<number> and returns the largest integer. If the list is empty, return undefined.",
      "code": "import { List } from '@kit.ArkTS';\n\nexport function findMaxValue(list: List<number>): number | undefined {\n  if (list.length === 0) {\n    return undefined;\n  }\n  let max = list.get(0);\n  for (let i = 1; i < list.length; i++) {\n    if (list[i] > max) {\n      max = list[i];\n    }\n  }\n  return max;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { List } from '@kit.ArkTS';\nimport { findMaxValue } from '../main/ets/Algorithms/findMaxValue';\n\nexport default function findMaxValueTest() {\n  describe('findMaxValue', () => {\n    it('should return the maximum value in a non-empty list', 0, () => {\n      const list = new List<number>();\n      list.add(3);\n      list.add(7);\n      list.add(1);\n      list.add(9);\n      list.add(5);\n      expect(findMaxValue(list)).assertEqual(9);\n    });\n\n    it('should return undefined for an empty list', 0, () => {\n      const list = new List<number>();\n      expect(findMaxValue(list)).assertUndefined();\n    });\n\n    it('should handle list with negative numbers', 0, () => {\n      const list = new List<number>();\n      list.add(-10);\n      list.add(-3);\n      list.add(-7);\n      expect(findMaxValue(list)).assertEqual(-3);\n    });\n\n    it('should handle list with a single element', 0, () => {\n      const list = new List<number>();\n      list.add(42);\n      expect(findMaxValue(list)).assertEqual(42);\n    });\n  });\n}",
      "model_output": "import { List } from '@kit.ArkTS';\n\nexport function findMaxValue(list: List<number>): number | undefined {\n  if (list.isEmpty()) {\n    return undefined;\n  }\n  let max = list.get(0);\n  for (let i = 1; i < list.length; i++) {\n    const current = list.get(i);\n    if (current > max) {\n      max = current;\n    }\n  }\n  return max;\n}",
      "test_passed": true
    },
    {
      "instruction": "Given an ArrayList<string>, group the words that are anagrams of each other. Return a List<ArrayList<string>> where each inner list is a group. iterate by keys",
      "code": "import { ArrayList, HashMap, List } from '@kit.ArkTS';\n\nfunction canonicalKey(s: string): string {\n  return s.split('').sort().join('');\n}\n\nexport function groupAnagrams(words: ArrayList<string>): List<ArrayList<string>> {\n  const map = new HashMap<string, ArrayList<string>>();\n  for (let i = 0; i < words.length; i++) {\n    const w = words[i];\n    const key = canonicalKey(w);\n    if (!map.hasKey(key)) {\n      map.set(key, new ArrayList<string>());\n    }\n    map.get(key)!.add(w);\n  }\n\n  const res = new List<ArrayList<string>>();\n  const keys = map.keys();\n  for (const k of keys) {\n    res.add(map.get(k)!);\n  }\n  return res;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { groupAnagrams } from '../main/ets/Algorithms/groupAnagrams';\n\nfunction toSortedGroups(groups: Array<Array<string>>): string {\n  const normalized = groups.map(g => g.slice().sort()).sort((a, b) => a.join().localeCompare(b.join()));\n  return JSON.stringify(normalized);\n}\n\nexport default function LocalUnitTest() {\n  describe('groupAnagrams', () => {\n    it('should group typical anagrams', 0, () => {\n      const w = new ArrayList<string>();\n      ['eat','tea','tan','ate','nat','bat'].forEach(s => w.add(s));\n      const out = groupAnagrams(w);\n\n      // convert to plain array for assertion\n      const arr: Array<Array<string>> = [];\n      for (let i = 0; i < out.length; i++) {\n        const inner: Array<string> = [];\n        const group = out.get(i);\n        for (let j = 0; j < group.length; j++) {\n          inner.push(group[j]);\n        }\n        arr.push(inner);\n      }\n      const expected = [['ate','eat','tea'], ['nat','tan'], ['bat']];\n      expect(toSortedGroups(arr)).assertEqual(toSortedGroups(expected));\n    });\n\n    it('should handle empty input', 0, () => {\n      const w = new ArrayList<string>();\n      const out = groupAnagrams(w);\n      expect(out.length).assertEqual(0);\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function groupAnagrams(words: ArrayList<string>): ArrayList<ArrayList<string>> {\n  const map = new Map<string, ArrayList<string>>();\n  for (const word of words) {\n    const sorted = word.split('').sort().join('');\n    if (!map.has(sorted)) {\n      map.set(sorted, new ArrayList<string>());\n    }\n    map.get(sorted)!.add(word);\n  }\n  return new ArrayList([...map.values()]);\n}",
      "test_passed": false
    },
    {
      "instruction": "Write a function isPalindrome that determines if a given string is a palindrome.",
      "code": "export function isPalindrome(s: string): boolean {\n  let left = 0;\n  let right = s.length - 1;\n  while (left < right) {\n    if (s[left] !== s[right]) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { isPalindrome } from '../main/ets/Algorithms/isPalindrome';\nexport default function isPalindromeTest() {\n  describe('isPalindrome', () => {\n    it('should return true for an empty string', 0, () => {\n      expect(isPalindrome(\"\")).assertTrue();\n    });\n    it('should return true for a single character', 0, () => {\n      expect(isPalindrome(\"a\")).assertTrue();\n    });\n    it('should return true for a simple odd-length palindrome', 0, () => {\n      expect(isPalindrome(\"madam\")).assertTrue();\n    });\n    it('should return true for a simple even-length palindrome', 0, () => {\n      expect(isPalindrome(\"abba\")).assertTrue();\n    });\n    it('should return false for a non-palindrome string', 0, () => {\n      expect(isPalindrome(\"hello\")).assertFalse();\n    });\n    it('should be case-sensitive (Madam != madam)', 0, () => {\n      expect(isPalindrome(\"Madam\")).assertFalse();\n    });\n    it('should handle special characters literally', 0, () => {\n      expect(isPalindrome(\"!@##@!\")).assertTrue();\n    });\n  });\n}",
      "model_output": "import { isPalindrome } from '../main/ets/Algorithms/isPalindrome';\n\nexport function isPalindrome(str: string): boolean {\n  const reversed = str.split('').reverse().join('');\n  return str === reversed;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a set of items, each with a weight and value, as well as a maximum weight capacity of a backpack, find the maximum total value of items that can be placed in the backpack without exceeding its weight capacity.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function knapsack(weights: ArrayList<number>, values: ArrayList<number>, capacity: number): number {\n  const n = weights.length;\n  const dp = new Array<number>(capacity + 1).fill(0);\n\n  for (let i = 0; i < n; i++) {\n    for (let w = capacity; w >= weights[i]; w--) {\n      dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]);\n    }\n  }\n\n  return dp[capacity];\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { knapsack } from '../main/ets/Algorithms/knapsack';\n\nexport default function LocalUnitTest() {\n  describe('knapsack', () => {\n    it('should return correct maximum value for given items and capacity', 0, () => {\n      const weights = new ArrayList<number>();\n      weights.add(2);\n      weights.add(3);\n      weights.add(4);\n      weights.add(5);\n      const values = new ArrayList<number>();\n      values.add(3);\n      values.add(4);\n      values.add(5);\n      values.add(6);\n      const capacity = 5;\n      expect(knapsack(weights, values, capacity)).assertEqual(7);\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function knapsack(weights: ArrayList<number>, values: ArrayList<number>, capacity: number): number {\n  const n = weights.length;\n  const dp = new Array(n + 1).fill(0).map(() => new Array(capacity + 1).fill(0));\n  \n  for (let i = 1; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      if (weights[i - 1] <= w) {\n        dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]);\n      } else {\n        dp[i][w] = dp[i - 1][w];\n      }\n    }\n  }\n  \n  return dp[n][capacity];\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a binary tree, return its level-order traversal as an array of arrays using Queue<TreeNode> from HarmonyOS ArkTS.",
      "code": "import { Queue } from '@kit.ArkTS';\n\nexport class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val: number, left: TreeNode | null = null, right: TreeNode | null = null) {\n    this.val = val; this.left = left; this.right = right;\n  }\n}\n\nexport function levelOrder(root: TreeNode | null): number[][] {\n  const res: number[][] = [];\n  if (!root) return res;\n  const q = new Queue<TreeNode>();\n  q.add(root);\n  while (q.length != 0 ) {\n    const size = q.length;\n    const level: number[] = [];\n    for (let i = 0; i < size; i++) {\n      const node = q.pop()!;\n      level.push(node.val);\n      if (node.left) q.add(node.left);\n      if (node.right) q.add(node.right);\n    }\n    res.push(level);\n  }\n  return res;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { TreeNode, levelOrder } from '../main/ets/Algorithms/levelOrder';\n\nexport default function bfsTreeArkTest() {\n  describe('levelOrder_using_Queue', () => {\n    it('should return empty for null tree', 0, () => {\n      expect(levelOrder(null).length).assertEqual(0);\n    });\n\n    it('should return correct traversal', 0, () => {\n      const root = new TreeNode(1, new TreeNode(2), new TreeNode(3));\n      root.left!.left = new TreeNode(4);\n      root.right!.right = new TreeNode(5);\n      expect(JSON.stringify(levelOrder(root))).assertEqual(JSON.stringify([[1], [2, 3], [4, 5]]));\n    });\n  });\n}",
      "model_output": "import {Queue} from '@kit.ArkTS';\n\nexport function levelOrder(root: TreeNode | null): number[][] {\n  if (root === null) {\n    return [];\n  }\n  \n  const result: number[][] = [];\n  const queue = new Queue<TreeNode>();\n  queue.add(root);\n  \n  while (!queue.isEmpty()) {\n    const levelSize = queue.length;\n    const currentLevel: number[] = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.pop();\n      currentLevel.push(node.val);\n      \n      if (node.left!== null) {\n        queue.add(node.left);\n      }\n      \n      if (node.right!== null) {\n        queue.add(node.right);\n      }\n    }\n    \n    result.push(currentLevel);\n  }\n  \n  return result;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an array of strings, write a function longestCommonPrefix(strs) that returns the longest common prefix amongst all the strings. If there is no common prefix, return an empty string.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function longestCommonPrefix(strs: ArrayList<string>): string {\n  if (strs.length === 0) return \"\";\n  strs.sort();\n  const first = strs[0] as string;\n  const last = strs[strs.length - 1] as string;\n  const minLen = Math.min(first.length, last.length);\n\n  let i = 0;\n  while (i < minLen && first.charAt(i) === last.charAt(i)) {\n    i++;\n  }\n  return first.substring(0, i);\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { longestCommonPrefix } from '../main/ets/Algorithms/longestCommonPrefix';\n\nexport default function longestCommonPrefixTest() {\n  describe('longestCommonPrefix', () => {\n    it('should return \"fl\" for [\"flower\",\"flow\",\"flight\"]', 0, () => {\n      const arr = new ArrayList<string>();\n      [\"flower\", \"flow\", \"flight\"].forEach(s => arr.add(s));\n      expect(longestCommonPrefix(arr)).assertEqual(\"fl\");\n    });\n\n    it('should return \"\" when there is no common prefix', 0, () => {\n      const arr = new ArrayList<string>();\n      [\"dog\", \"racecar\", \"car\"].forEach(s => arr.add(s));\n      expect(longestCommonPrefix(arr)).assertEqual(\"\");\n    });\n\n    it('should return full string when single element', 0, () => {\n      const arr = new ArrayList<string>();\n      arr.add(\"alone\");\n      expect(longestCommonPrefix(arr)).assertEqual(\"alone\");\n    });\n\n    it('should return \"\" for empty array', 0, () => {\n      const arr = new ArrayList<string>();\n      expect(longestCommonPrefix(arr)).assertEqual(\"\");\n    });\n  });\n}",
      "model_output": "import { ArrayList } from '@kit.ArkTS';\n\nexport function longestCommonPrefix(strs: ArrayList<string>): string {\n  if (strs.isEmpty()) {\n    return \"\";\n  }\n\n  let prefix = strs.get(0);\n  for (let i = 1; i < strs.length; i++) {\n    while (strs.get(i).indexOf(prefix)!== 0) {\n      prefix = prefix.substring(0, prefix.length - 1);\n      if (prefix === \"\") {\n        return \"\";\n      }\n    }\n  }\n  return prefix;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an integer array represented as an ArrayList<number> from @kit.ArkTS, write a function longestIncreasingSubsequence that returns the length of the longest strictly increasing subsequence.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function longestIncreasingSubsequence(nums: ArrayList<number>): number {\n  const n = nums.length;\n  if (n === 0) return 0;\n\n  const dp = new ArrayList<number>();\n  for (let i = 0; i < n; i++) {\n    dp.add(1);\n  }\n\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[i] > nums[j]) {\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n      }\n    }\n  }\n\n  let maxLen = 0;\n  for (let i = 0; i < n; i++) {\n    if (dp[i] > maxLen) {\n      maxLen = dp[i];\n    }\n  }\n\n  return maxLen;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { longestIncreasingSubsequence } from '../main/ets/Algorithms/longestIncreasingSubsequence';\n\nexport default function lisTest() {\n  describe('longestIncreasingSubsequence', () => {\n    it('should return 4 for input [10,9,2,5,3,7,101,18]', 0, () => {\n      const nums = new ArrayList<number>();\n      [10, 9, 2, 5, 3, 7, 101, 18].forEach(n => nums.add(n));\n      const result = longestIncreasingSubsequence(nums);\n      expect(result).assertEqual(4);\n    });\n\n    it('should return 0 for empty input', 0, () => {\n      const nums = new ArrayList<number>();\n      const result = longestIncreasingSubsequence(nums);\n      expect(result).assertEqual(0);\n    });\n\n    it('should return 1 for single element', 0, () => {\n      const nums = new ArrayList<number>();\n      nums.add(42);\n      const result = longestIncreasingSubsequence(nums);\n      expect(result).assertEqual(1);\n    });\n\n    it('should handle strictly decreasing sequence', 0, () => {\n      const nums = new ArrayList<number>();\n      [5, 4, 3, 2, 1].forEach(n => nums.add(n));\n      const result = longestIncreasingSubsequence(nums);\n      expect(result).assertEqual(1);\n    });\n\n    it('should handle strictly increasing sequence', 0, () => {\n      const nums = new ArrayList<number>();\n      [1, 2, 3, 4, 5].forEach(n => nums.add(n));\n      const result = longestIncreasingSubsequence(nums);\n      expect(result).assertEqual(5);\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function longestIncreasingSubsequence(nums: ArrayList<number>): number {\n  const n = nums.length;\n  const dp = new Array<number>(n).fill(1);\n  \n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums.get(i) > nums.get(j)) {\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n      }\n    }\n  }\n  \n  return Math.max(...dp);\n}",
      "test_passed": false
    },
    {
      "instruction": "Given two sorted List<number>, merge them into a new sorted List<number>.",
      "code": "import { List } from '@kit.ArkTS';\n\nexport function mergeSortedLists(a: List<number>, b: List<number>): List<number> {\n  const res = new List<number>();\n  let i = 0, j = 0;\n  while (i < a.length && j < b.length) {\n    const av = a.get(i);\n    const bv = b.get(j);\n    if (av <= bv) {\n      res.add(av); i++;\n    } else {\n      res.add(bv); j++;\n    }\n  }\n  while (i < a.length) { res.add(a.get(i++)); }\n  while (j < b.length) { res.add(b.get(j++)); }\n  return res;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { List } from '@kit.ArkTS';\nimport { mergeSortedLists } from '../main/ets/Algorithms/mergeSortedLists';\n\nexport default function LocalUnitTest() {\n  describe('mergeSortedLists', () => {\n    it('should merge two non-empty sorted lists', 0, () => {\n      const l1 = new List<number>(); [1,3,5].forEach(v => l1.add(v));\n      const l2 = new List<number>(); [2,4,6].forEach(v => l2.add(v));\n      const res = mergeSortedLists(l1, l2);\n      expect(res.length).assertEqual(6);\n      expect(res.get(0)).assertEqual(1);\n      expect(res.get(5)).assertEqual(6);\n    });\n\n    it('should handle one empty list', 0, () => {\n      const l1 = new List<number>();\n      const l2 = new List<number>(); [1,2].forEach(v => l2.add(v));\n      const res = mergeSortedLists(l1, l2);\n      expect(res.length).assertEqual(2);\n      expect(res.get(0)).assertEqual(1);\n      expect(res.get(1)).assertEqual(2);\n    });\n\n    it('should handle both empty lists', 0, () => {\n      const l1 = new List<number>();\n      const l2 = new List<number>();\n      const res = mergeSortedLists(l1, l2);\n      expect(res.length).assertEqual(0);\n    });\n  });\n}",
      "model_output": "import { List } from '@kit.ArkTS';\n\nexport function mergeSortedLists(l1: List<number>, l2: List<number>): List<number> {\n  const merged = new List<number>();\n  let i = 0, j = 0;\n  while (i < l1.length && j < l2.length) {\n    if (l1.get(i) <= l2.get(j)) {\n      merged.add(l1.get(i));\n      i++;\n    } else {\n      merged.add(l2.get(j));\n      j++;\n    }\n  }\n  while (i < l1.length) {\n    merged.add(l1.get(i));\n    i++;\n  }\n  while (j < l2.length) {\n    merged.add(l2.get(j));\n    j++;\n  }\n  return merged;\n}",
      "test_passed": true
    },
    {
      "instruction": "Given an array of positive integers nums and a positive integer target, find the minimal length of a contiguous subarray (represented as @kit.ArkTS.ArrayList<number>) whose sum is greater than or equal to target. If no such subarray exists, return 0.You can use an ArrayList<number> to store nums and leverage its methods like .get(index) and .size() for array access. Implement a sliding window approach with two pointers to achieve O(n) time complexity.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function minSubArrayLen(target: number, nums: ArrayList<number>): number {\n  const n = nums.length;\n  let left = 0;\n  let sum = 0;\n  let minLen = n + 1;\n\n  for (let right = 0; right < n; right++) {\n    sum += nums[right]!;\n\n    while (sum >= target) {\n      const currentLen = right - left + 1;\n      if (currentLen < minLen) {\n        minLen = currentLen;\n      }\n      sum -= nums[left]!;\n      left++;\n    }\n  }\n\n  return minLen <= n ? minLen : 0;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { minSubArrayLen } from '../main/ets/Algorithms/minSubArrayLen';\n\nexport default function minSubarrayLenTest() {\n  describe('minSubArrayLen', () => {\n    it('should return 2 for target=7 and [2,3,1,2,4,3]', 0, () => {\n      const nums = new ArrayList<number>();\n      [2,3,1,2,4,3].forEach(n => nums.add(n));\n      expect(minSubArrayLen(7, nums)).assertEqual(2);\n    });\n\n    it('should return 1 for target=4 and [1,4,4]', 0, () => {\n      const nums = new ArrayList<number>();\n      [1,4,4].forEach(n => nums.add(n));\n      expect(minSubArrayLen(4, nums)).assertEqual(1);\n    });\n\n    it('should return 0 when no subarray meets the sum', 0, () => {\n      const nums = new ArrayList<number>();\n      [1,1,1,1,1,1,1,1].forEach(n => nums.add(n));\n      expect(minSubArrayLen(11, nums)).assertEqual(0);\n    });\n\n    it('should return 0 for empty list', 0, () => {\n      const nums = new ArrayList<number>();\n      expect(minSubArrayLen(10, nums)).assertEqual(0);\n    });\n\n    it('should return full length when only entire array works', 0, () => {\n      const nums = new ArrayList<number>();\n      [1,1,1,10].forEach(n => nums.add(n));\n      expect(minSubArrayLen(13, nums)).assertEqual(4);\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function minSubArrayLen(target: number, nums: ArrayList<number>): number {\n  let left = 0;\n  let right = 0;\n  let sum = 0;\n  let minLength = Infinity;\n\n  while (right < nums.size()) {\n    sum += nums.get(right);\n    right++;\n\n    while (sum >= target) {\n      minLength = Math.min(minLength, right - left);\n      sum -= nums.get(left);\n      left++;\n    }\n  }\n\n  return minLength === Infinity? 0 : minLength;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given two non-negative integers num1 and num2 represented as strings, return their product, also as a string. Do not use any built-in BigInteger library or convert the inputs directly to numbers. Use ArrayList<number> as a helper to simulate digit-by-digit multiplication: use .add(value) to build result digits and access via index (result[i]) for accumulation and carry handling.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function multiplyStrings(num1: string, num2: string): string {\n  if (num1 === '0' || num2 === '0') {\n    return '0';\n  }\n\n  const m = num1.length, n = num2.length;\n  const result = new ArrayList<number>();\n  for (let i = 0; i < m + n; i++) {\n    result.add(0);\n  }\n\n  for (let i = m - 1; i >= 0; i--) {\n    for (let j = n - 1; j >= 0; j--) {\n      const product = (num1.charCodeAt(i) - 48) * (num2.charCodeAt(j) - 48);\n      const sum = result[i + j + 1] + product;\n      result[i + j + 1] = sum % 10;\n      result[i + j] += Math.floor(sum / 10);\n    }\n  }\n  let start = 0;\n  while (start < result.length - 1 && result[start] === 0) {\n    start++;\n  }\n\n  let sb = '';\n  for (let k = start; k < result.length; k++) {\n    sb += result[k];\n  }\n\n  return sb;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { multiplyStrings } from '../main/ets/Algorithms/multiplyStrings';\n\nexport default function multiplyStringsTest() {\n  describe('multiplyStrings', () => {\n    it('should return \"56088\" for \"123\" × \"456\"', 0, () => {\n      expect(multiplyStrings('123', '456')).assertEqual('56088');\n    });\n\n    it('should return \"6\" for \"2\" × \"3\"', 0, () => {\n      expect(multiplyStrings('2', '3')).assertEqual('6');\n    });\n\n    it('should return \"0\" when one operand is \"0\"', 0, () => {\n      expect(multiplyStrings('0', '9999')).assertEqual('0');\n      expect(multiplyStrings('9999', '0')).assertEqual('0');\n    });\n\n    it('should handle large numbers correctly', 0, () => {\n      const a = '123456789';\n      const b = '987654321';\n      expect(multiplyStrings(a, b)).assertEqual('121932631112635269');\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function multiplyStrings(num1: string, num2: string): string {\n  if (num1 === '0' || num2 === '0') {\n    return '0';\n  }\n\n  const result = new ArrayList<number>();\n  const len1 = num1.length;\n  const len2 = num2.length;\n\n  for (let i = len1 - 1; i >= 0; i--) {\n    const digit1 = parseInt(num1[i]);\n    for (let j = len2 - 1; j >= 0; j--) {\n      const digit2 = parseInt(num2[j]);\n      const product = digit1 * digit2;\n      const index = (len1 - 1 - i) + (len2 - 1 - j);\n      const carry = Math.floor(product / 10);\n      const digit = product % 10;\n      if (result[index] === undefined) {\n        result.add(index, digit);\n      } else {\n        const currentDigit = result[index];\n        const newDigit = currentDigit + digit;\n        result[index] = newDigit % 10;\n        const newCarry = Math.floor((currentDigit + digit) / 10);\n        if (newCarry > 0) {\n          if (result[index + 1] === undefined) {\n            result.add(index + 1, newCarry);\n          } else {\n            result[index + 1] += newCarry;\n          }\n        }\n      }\n    }\n  }\n\n  let resultStr = '';\n  for (let i = 0; i < result.length; i++) {\n    resultStr += result[i];\n  }\n  return resultStr;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an unsorted integer array nums represented as @kit.ArkTS.ArrayList<number>, return the number of longest increasing subsequences.The subsequences must be strictly increasing. You can use ArrayList<number> to store intermediate lengths and counts arrays. Use .add(value) to append elements and access them via indexing.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function numberOfLIS(nums: ArrayList<number>): number {\n  const n = nums.length;\n  if (n === 0) return 0;\n\n  const lengths = new ArrayList<number>();\n  const counts = new ArrayList<number>();\n\n  for (let i = 0; i < n; i++) {\n    lengths.add(1);\n    counts.add(1);\n  }\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[i] > nums[j]) {\n        if (lengths[j] + 1 > lengths[i]) {\n          lengths[i] = lengths[j] + 1;\n          counts[i] = counts[j];\n        } else if (lengths[j] + 1 === lengths[i]) {\n          counts[i] += counts[j];\n        }\n      }\n    }\n  }\n\n  let maxLen = 0;\n  for (let i = 0; i < n; i++) {\n    if (lengths[i] > maxLen) maxLen = lengths[i];\n  }\n\n  let total = 0;\n  for (let i = 0; i < n; i++) {\n    if (lengths[i] === maxLen) total += counts[i];\n  }\n\n  return total;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { numberOfLIS } from '../main/ets/Algorithms/numberOfLIS';\n\nexport default function numberOfLISTest() {\n  describe('numberOfLIS', () => {\n\n    it('should return 2 for [1,3,5,4,7]', 0, () => {\n      const nums = new ArrayList<number>();\n      [1,3,5,4,7].forEach(n => nums.add(n));\n      expect(numberOfLIS(nums)).assertEqual(2);\n    });\n\n    it('should return 0 for empty array', 0, () => {\n      const nums = new ArrayList<number>();\n      expect(numberOfLIS(nums)).assertEqual(0);\n    });\n\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function numberOfLIS(nums: ArrayList<number>): number {\n  if (nums.isEmpty()) {\n    return 0;\n  }\n\n  const n = nums.length;\n  const dp = new ArrayList<number>();\n  const count = new ArrayList<number>();\n\n  for (let i = 0; i < n; i++) {\n    dp.add(1);\n    count.add(1);\n    for (let j = 0; j < i; j++) {\n      if (nums.get(j) < nums.get(i)) {\n        if (dp.get(j) + 1 > dp.get(i)) {\n          dp.set(i, dp.get(j) + 1);\n          count.set(i, count.get(j));\n        } else if (dp.get(j) + 1 === dp.get(i)) {\n          count.set(i, count.get(i) + count.get(j));\n        }\n      }\n    }\n  }\n\n  let maxLen = 0;\n  let maxCount = 0;\n  for (let i = 0; i < n; i++) {\n    if (dp.get(i) > maxLen) {\n      maxLen = dp.get(i);\n      maxCount = count.get(i);\n    } else if (dp.get(i) === maxLen) {\n      maxCount += count.get(i);\n    }\n  }\n\n  return maxCount;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an integer n and an optional ArrayList<number> from @kit.ArkTS to store intermediate results, write a function numSquares that returns the minimum number of perfect square numbers (1, 4, 9, 16, …) which sum to n.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function numSquares(n: number): number {\n  const dp = new ArrayList<number>();\n  for (let i = 0; i <= n; i++) {\n    dp.add(Number.MAX_SAFE_INTEGER);\n  }\n  dp[0] = 0;\n\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j * j <= i; j++) {\n      dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n    }\n  }\n\n  return dp[n];\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { numSquares } from '../main/ets/Algorithms/numSquares';\n\nexport default function perfectSquaresTest() {\n  describe('numSquares', () => {\n    it('should return 3 for n = 12', 0, () => {\n      const result = numSquares(12);\n      expect(result).assertEqual(3);\n    });\n\n    it('should return 2 for n = 13', 0, () => {\n      const result = numSquares(13);\n      expect(result).assertEqual(2); // 13 = 4 + 9\n    });\n\n    it('should return 1 for n = 16', 0, () => {\n      const result = numSquares(16);\n      expect(result).assertEqual(1); // 16 = 16\n    });\n\n    it('should return 0 for n = 0', 0, () => {\n      const result = numSquares(0);\n      expect(result).assertEqual(0);\n    });\n  });\n}",
      "model_output": "import {ArrayList, numSquares} from '@kit.ArkTS';\n\nexport function numSquares(n: number, from?: ArrayList<number>): number {\n  const dp = new ArrayList<number>();\n  dp.add(0);\n  for (let i = 1; i <= n; i++) {\n    dp.add(n);\n    for (let j = 1; j * j <= i; j++) {\n      dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n    }\n  }\n  return dp[n];\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a string s, partition the string into as many parts as possible so that each letter appears in at most one part. Return the sizes of these partitions as an ArrayList<number> from @kit.ArkTS. You can use .add(value) to append each partition size to the result list. For example, the string \"ababcc\" can be partitioned as [\"abab\", \"cc\"], so the returned ArrayList should contain [4, 2]. The order of the partitions should follow the original string.",
      "code": "import { ArrayList } from '@kit.ArkTS';\nexport function partitionLabels(s: string): ArrayList<number> {\n  const lastIndex = new Map<string, number>();\n  for (let i = 0; i < s.length; i++) {\n    lastIndex.set(s[i], i);\n  }\n  const result = new ArrayList<number>();\n  let start = 0;\n  let end = 0;\n  for (let i = 0; i < s.length; i++) {\n    end = Math.max(end, lastIndex.get(s[i])!);\n    if (i === end) {\n      result.add(end - start + 1);\n      start = i + 1;\n    }\n  }\n  return result;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { partitionLabels } from '../main/ets/Algorithms/partitionLabels';\n\nexport default function partitionLabelsTest() {\n  describe('partitionLabels', () => {\n    it('should return [4,2] for \"ababcc\"', 0, () => {\n      const result = partitionLabels('ababcc');\n      expect(result.length).assertEqual(2);\n      expect(result[0]).assertEqual(4);\n      expect(result[1]).assertEqual(2);\n    });\n\n    it('should handle single character', 0, () => {\n      const result = partitionLabels('a');\n      expect(result.length).assertEqual(1);\n      expect(result[0]).assertEqual(1);\n    });\n\n    it('should handle all unique characters', 0, () => {\n      const result = partitionLabels('abcd');\n      expect(result.length).assertEqual(4);\n      for (let i = 0; i < 4; i++) {\n        expect(result[i]).assertEqual(1);\n      }\n    });\n\n    it('should handle repeated letters', 0, () => {\n      const result = partitionLabels('eccbbbbdec');\n      expect(result.length).assertEqual(1);\n      expect(result[0]).assertEqual(10);\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function partitionLabels(s: string): ArrayList<number> {\n  const partitionSizes = new ArrayList<number>();\n  const charMap = new Map<string, number>();\n  let start = 0;\n  let end = 0;\n  \n  for (let i = 0; i < s.length; i++) {\n    charMap.set(s[i], i);\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    end = Math.max(end, charMap.get(s[i])!);\n    if (i === end) {\n      partitionSizes.add(end - start + 1);\n      start = i + 1;\n    }\n  }\n  \n  return partitionSizes;\n}",
      "test_passed": true
    },
    {
      "instruction": "Given a string, reverse its characters using the Stack<char> data structure from HarmonyOS ArkTS API.",
      "code": "import { Stack } from '@kit.ArkTS'\n\nexport function reverseStringWithStack(s: string): string {\n  const stack = new Stack<string>();\n  for (const ch of s) {\n    stack.push(ch);\n  }\n  let result = '';\n  while (!stack.isEmpty()) {\n    result += stack.pop();\n  }\n  return result;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { reverseStringWithStack } from '../main/ets/Algorithms/reverseStringWithStack';\n\nexport default function reverseUsingStackArkTest() {\n  describe('reverseStringWithStack', () => {\n    it('should reverse a normal string', 0, () => {\n      expect(reverseStringWithStack('hello')).assertEqual('olleh');\n    });\n    it('should handle empty string', 0, () => {\n      expect(reverseStringWithStack('')).assertEqual('');\n    });\n    it('should handle single character', 0, () => {\n      expect(reverseStringWithStack('A')).assertEqual('A');\n    });\n  });\n}",
      "model_output": "import {Stack} from '@kit.ArkTS';\n\nexport function reverseStringWithStack(str: string): string {\n  const stack = new Stack<string>();\n  for (const char of str) {\n    stack.push(char);\n  }\n  let reversedStr = '';\n  while (!stack.isEmpty()) {\n    reversedStr += stack.pop();\n  }\n  return reversedStr;\n}",
      "test_passed": true
    },
    {
      "instruction": "Given a sorted array of distinct integers represented as ArrayList<number> from @kit.ArkTS and an integer target, write a function searchInsertPosition that returns the index where target is found—or the index where it would be inserted to maintain the sorted order. Use binary search to achieve O(log n) time complexity, and methods like .get(index) and size() from ArrayList<number> for array access and bounds.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function searchInsertPosition(\n  nums: ArrayList<number>,\n  target: number\n): number {\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    const midVal = nums[mid]!;\n    if (midVal === target) {\n      return mid;\n    } else if (midVal < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return left;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { searchInsertPosition } from '../main/ets/Algorithms/searchInsertPosition';\n\nexport default function searchInsertPositionTest() {\n  describe('searchInsertPosition', () => {\n    it('should return 2 for nums=[1,3,5,6], target=5', 0, () => {\n      const nums = new ArrayList<number>();\n      [1, 3, 5, 6].forEach((x) => nums.add(x));\n      expect(searchInsertPosition(nums, 5)).assertEqual(2);\n    });\n\n    it('should return 1 for nums=[1,3,5,6], target=2', 0, () => {\n      const nums = new ArrayList<number>();\n      [1, 3, 5, 6].forEach((x) => nums.add(x));\n      expect(searchInsertPosition(nums, 2)).assertEqual(1);\n    });\n\n    it('should return 4 for nums=[1,3,5,6], target=7', 0, () => {\n      const nums = new ArrayList<number>();\n      [1, 3, 5, 6].forEach((x) => nums.add(x));\n      expect(searchInsertPosition(nums, 7)).assertEqual(4);\n    });\n\n    it('should return 0 for nums=[1,3,5,6], target=0', 0, () => {\n      const nums = new ArrayList<number>();\n      [1, 3, 5, 6].forEach((x) => nums.add(x));\n      expect(searchInsertPosition(nums, 0)).assertEqual(0);\n    });\n\n    it('should handle empty list', 0, () => {\n      const nums = new ArrayList<number>();\n      expect(searchInsertPosition(nums, 10)).assertEqual(0);\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function searchInsertPosition(nums: ArrayList<number>, target: number): number {\n  let left = 0;\n  let right = nums.size() - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    const midValue = nums.get(mid);\n    \n    if (midValue === target) {\n      return mid;\n    } else if (midValue < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  return left;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an array of numbers and a window size k, return the maximum value in each sliding window using Deque<number> from HarmonyOS ArkTS API.",
      "code": "import { ArrayList, Deque } from '@kit.ArkTS';\n\nexport function slidingWindowMax(nums: ArrayList<number>, k: number): number[] {\n  const res: number[] = [];\n  const dq = new Deque<number>();\n  for (let i = 0; i < nums.length; i++) {\n    while (dq.length!=0 && nums[(dq.getFirst()!)] < nums[i]) {\n      dq.popFirst();\n    }\n    dq.insertEnd(i);\n    if (dq.getFirst()! <= i - k) {\n      dq.popFirst();\n    }\n    if (i >= k - 1) {\n      res.push(nums[(dq.getFirst()!)]);\n    }\n  }\n  return res;\n}",
      "test": "import { ArrayList, Deque } from '@kit.ArkTS';\nimport { describe, it, expect } from '@ohos/hypium';\nimport { slidingWindowMax } from '../main/ets/Algorithms/slidingWindowMax';\n\nexport default function slidingWindowMaxArkTest() {\n  describe('slidingWindowMax_using_Deque', () => {\n    it('should handle simple input', 0, () => {\n      const nums = new ArrayList<number>();\n      [1,3,-1,-3,5,3,6,7].forEach(v => nums.add(v));\n      const res = slidingWindowMax(nums, 3);\n      expect(JSON.stringify(res)).assertEqual(JSON.stringify([3,3,5,5,6,7]));\n    });\n\n    it('should handle window size 1', 0, () => {\n      const nums = new ArrayList<number>();\n      [4,2,1,3].forEach(v => nums.add(v));\n      const res = slidingWindowMax(nums, 1);\n      expect(JSON.stringify(res)).assertEqual(JSON.stringify([4,2,1,3]));\n    });\n  });\n}",
      "model_output": "import { Deque } from '@kit.ArkTS';\n\nexport function slidingWindowMax(nums: ArrayList<number>, k: number): number[] {\n  const result: number[] = [];\n  const deque = new Deque<number>();\n  \n  for (let i = 0; i < nums.length; i++) {\n    const num = nums.get(i);\n    \n    while (deque.length > 0 && nums.get(deque.peekLast()) <= num) {\n      deque.popLast();\n    }\n    \n    deque.pushLast(i);\n    \n    if (i >= k - 1) {\n      result.push(nums.get(deque.peekFirst()));\n      \n      if (deque.peekFirst() === i - k + 1) {\n        deque.popFirst();\n      }\n    }\n  }\n  \n  return result;\n}",
      "test_passed": false
    },
    {
      "instruction": "In an integer array, find all combinations of three numbers that sum to 0, using the ArrayList from the @kit.ArkTS aggregation package to store the results.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function threeSum(nums: ArrayList<number>): ArrayList<number[]> {\n  const result = new ArrayList<number[]>();\n  if (nums.length < 3) return result;\n\n  const arr: number[] = [];\n  for (let i = 0; i < nums.length; i++) {\n    arr.push(nums[i]);\n  }\n  arr.sort((a, b) => a - b);\n\n  for (let i = 0; i < arr.length - 2; i++) {\n    if (i > 0 && arr[i] === arr[i - 1]) continue;\n\n    let left = i + 1;\n    let right = arr.length - 1;\n\n    while (left < right) {\n      const sum = arr[i] + arr[left] + arr[right];\n      if (sum === 0) {\n        result.add([arr[i], arr[left], arr[right]]);\n        while (left < right && arr[left] === arr[left + 1]) left++;\n        while (left < right && arr[right] === arr[right - 1]) right--;\n        left++;\n        right--;\n      } else if (sum < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n\n  return result;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { threeSum } from '../main/ets/Algorithms/threeSum';\n\nexport default function threeSumTest() {\n  describe('threeSum', () => {\n    it('should find all unique triplets that sum to zero', 0, () => {\n      const nums = new ArrayList<number>();\n      [-1, 0, 1, 2, -1, -4].forEach(n => nums.add(n));\n\n      const result = threeSum(nums);\n\n      let found1 = false;\n      for (let i = 0; i < result.length; i++) {\n        const triplet = result[i];\n        if (triplet[0] === -1 && triplet[1] === -1 && triplet[2] === 2) found1 = true;\n      }\n      expect(found1).assertEqual(true);\n\n      let found2 = false;\n      for (let i = 0; i < result.length; i++) {\n        const triplet = result[i];\n        if (triplet[0] === -1 && triplet[1] === 0 && triplet[2] === 1) found2 = true;\n      }\n      expect(found2).assertEqual(true);\n    });\n\n    it('should handle empty input', 0, () => {\n      const nums = new ArrayList<number>();\n      const result = threeSum(nums);\n      expect(result.length).assertEqual(0);\n    });\n\n    it('should handle input with no valid triplet', 0, () => {\n      const nums = new ArrayList<number>();\n      [1, 2, 3, 4].forEach(n => nums.add(n));\n      const result = threeSum(nums);\n      expect(result.length).assertEqual(0);\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function threeSum(nums: ArrayList<number>): ArrayList<number[]> {\n  const result = new ArrayList<number[]>();\n  if (nums.length < 3) return result;\n\n  nums.sort((a, b) => a - b);\n  for (let i = 0; i < nums.length - 2; i++) {\n    if (i > 0 && nums.get(i) === nums.get(i - 1)) continue;\n    let j = i + 1;\n    let k = nums.length - 1;\n    while (j < k) {\n      const sum = nums.get(i) + nums.get(j) + nums.get(k);\n      if (sum === 0) {\n        result.add([nums.get(i), nums.get(j), nums.get(k)]);\n        j++;\n        k--;\n        while (j < k && nums.get(j) === nums.get(j - 1)) j++;\n        while (j < k && nums.get(k) === nums.get(k + 1)) k--;\n      } else if (sum < 0) {\n        j++;\n      } else {\n        k--;\n      }\n    }\n  }\n  return result;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an integer array nums and an integer k, return the k most frequent elements in any order. Use @kit.ArkTS.ArrayList<number> to hold inputs and results, count frequencies with a Map<number, number>, and use bucket sort by grouping numbers into an ArrayList<ArrayList<number>> indexed by frequency.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function topKFrequent(nums: ArrayList<number>, k: number): ArrayList<number> {\n  const freqMap = new Map<number, number>();\n  for (let i = 0; i < nums.length; i++) {\n    const num = nums[i]!;\n    freqMap.set(num, (freqMap.get(num) ?? 0) + 1);\n  }\n  const maxFreq = nums.length;\n  const buckets = new ArrayList<ArrayList<number>>();\n  for (let i = 0; i <= maxFreq; i++) {\n    buckets.add(new ArrayList<number>());\n  }\n  const mapIter = freqMap.entries();\n  let entry = mapIter.next();\n  while (!entry.done) {\n    const pair = entry.value;\n    const numKey = pair[0];\n    const countVal = pair[1];\n    buckets[countVal]!.add(numKey);\n\n    entry = mapIter.next();\n  }\n  const result = new ArrayList<number>();\n  for (let freq = maxFreq; freq >= 0 && result.length < k; freq--) {\n    const bucket = buckets[freq]!;\n    for (let j = 0; j < bucket.length && result.length < k; j++) {\n      result.add(bucket[j]!);\n    }\n  }\n  return result;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { topKFrequent } from '../main/ets/Algorithms/topKFrequent';\n\nexport default function topKFrequentTest() {\n  describe('topKFrequent', () => {\n    it('should return [1,2] for nums=[1,1,1,2,2,3], k=2', 0, () => {\n      const nums = new ArrayList<number>();\n      [1,1,1,2,2,3].forEach(n => nums.add(n));\n      const result = topKFrequent(nums, 2);\n      expect(result.length).assertEqual(2);\n      expect((result[0] === 1 && result[1] === 2) || (result[0] === 2 && result[1] === 1))\n        .assertEqual(true);\n    });\n\n    it('should return [1] for nums=[1], k=1', 0, () => {\n      const nums = new ArrayList<number>();\n      nums.add(1);\n      const result = topKFrequent(nums, 1);\n      expect(result.length).assertEqual(1);\n      expect(result[0]).assertEqual(1);\n    });\n\n    it('should return top frequencies even if elements have same count', 0, () => {\n      const nums = new ArrayList<number>();\n      [1,2,2,3,3].forEach(n => nums.add(n));\n      const result = topKFrequent(nums, 2);\n      expect(result.length).assertEqual(2);\n      const set = new Set<number>();\n      set.add(result[0]);\n      set.add(result[1]);\n      expect(set.has(2) && set.has(3)).assertEqual(true);\n    });\n\n    it('should handle k equals zero', 0, () => {\n      const nums = new ArrayList<number>();\n      [1,2,3].forEach(n => nums.add(n));\n      const result = topKFrequent(nums, 0);\n      expect(result.length).assertEqual(0);\n    });\n  });\n}",
      "model_output": "import {ArrayList, Map} from '@kit.ArkTS';\n\nexport function topKFrequent(nums: ArrayList<number>, k: number): number[] {\n  const frequencyMap = new Map<number, number>();\n  nums.forEach(num => {\n    const count = frequencyMap.get(num) || 0;\n    frequencyMap.set(num, count + 1);\n  });\n\n  const buckets = new ArrayList<ArrayList<number>>();\n  frequencyMap.forEach((count, num) => {\n    if (!buckets[count]) {\n      buckets[count] = new ArrayList<number>();\n    }\n    buckets[count].add(num);\n  });\n\n  const result = new ArrayList<number>();\n  for (let i = buckets.length - 1; i >= 0 && result.length < k; i--) {\n    if (buckets[i]) {\n      const bucket = buckets[i];\n      for (const num of bucket) {\n        result.add(num);\n        if (result.length >= k) {\n          break;\n        }\n      }\n    }\n  }\n\n  return result.convertToArray();\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an integer array nums and a target value target, return the indices of the two numbers in the array that add up to target.",
      "code": "import {ArrayList, HashMap} from '@kit.ArkTS';\nexport function twoSumIndices(nums: ArrayList<number>, target: number): ArrayList<number> {\n  const map = new HashMap<number, number>();\n  for (let i = 0; i < nums.length; i++) {\n    const v = nums.getIndexOf(i);\n    const need = target - v;\n    if (map.hasKey(need)) {\n      const ans = new ArrayList<number>();\n      ans.add(map.get(need)!);\n      ans.add(i);\n      return ans;\n    }\n    if (!map.hasKey(v)) {\n      map.set(v, i);\n    }\n  }\n  return new ArrayList<number>();\n}",
      "test": "import {ArrayList} from '@kit.ArkTS'\nimport { describe, it, expect } from '@ohos/hypium';\nimport { twoSumIndices } from '../main/ets/Algorithms/twoSum';\n\nexport default function localUnitTest() {\n  describe('algorithms_using_harmony_api', () => {\n    it('twoSumIndices_found', 0, () => {\n      const nums = new ArrayList<number>();\n      [2,7,11,15].forEach(v => nums.add(v));\n      const ans = twoSumIndices(nums, 9);\n      expect(ans.length).assertEqual(2);\n      expect(ans.getIndexOf(0)).assertEqual(0);\n      expect(ans.getIndexOf(1)).assertEqual(1);\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function twoSumIndices(nums: ArrayList<number>, target: number): ArrayList<number> {\n  const result = new ArrayList<number>();\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums.get(i) + nums.get(j) === target) {\n        result.add(i);\n        result.add(j);\n        return result;\n      }\n    }\n  }\n  return result;\n}",
      "test_passed": false
    },
    {
      "instruction": "In the HarmonyOS application, you have an integer array 'numbers' sorted in ascending order, and you need to find two numbers such that their sum equals the specified 'target'. Please return their 1-based indices [index1, index2], ensuring that index1 < index2.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function twoSumSorted(numbers: ArrayList<number>, target: number): ArrayList<number> {\n  let left = 0;\n  let right = numbers.length - 1;\n  const res = new ArrayList<number>();\n\n  while (left < right) {\n    const sum = (numbers[left] as number) + (numbers[right] as number);\n    if (sum === target) {\n      res.add(left + 1);\n      res.add(right + 1);\n      return res;\n    } else if (sum < target) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n\n  return res;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { twoSumSorted } from '../main/ets/Algorithms/twoSumSorted';\n\nexport default function twoSumSortedTest() {\n  describe('twoSumSorted', () => {\n    it('should find indices for sum 9 in [2,7,11,15]', 0, () => {\n      const nums = new ArrayList<number>();\n      [2, 7, 11, 15].forEach(n => nums.add(n));\n      const result = twoSumSorted(nums, 9);\n      expect(result.length).assertEqual(2);\n      expect(result[0]).assertEqual(1);\n      expect(result[1]).assertEqual(2);\n    });\n\n    it('should handle no solution', 0, () => {\n      const nums = new ArrayList<number>();\n      [1, 2, 3, 4].forEach(n => nums.add(n));\n      const result = twoSumSorted(nums, 8);\n      expect(result.length).assertEqual(0);\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function twoSumSorted(nums: ArrayList<number>, target: number): number[] {\n  let left = 0;\n  let right = nums.length - 1;\n  while (left < right) {\n    const sum = nums.get(left) + nums.get(right);\n    if (sum === target) {\n      return [left + 1, right + 1];\n    } else if (sum < target) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  return [];\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an ArrayList<number>, return the count of unique elements using HashSet<number> from HarmonyOS ArkTS API.",
      "code": "import { ArrayList, HashSet } from '@kit.ArkTS'\n\nexport function uniqueCount(nums: ArrayList<number>): number {\n  const set = new HashSet<number>();\n  for (let i = 0; i < nums.length; i++) {\n    set.add(nums[i]);\n  }\n  return set.length;\n}",
      "test": "import { ArrayList } from '@kit.ArkTS'\nimport { describe, it, expect } from '@ohos/hypium';\nimport { uniqueCount } from '../main/ets/Algorithms/uniqueCount';\n\nexport default function uniqueCountArkTest() {\n  describe('uniqueCount_using_HashSet', () => {\n    it('should return 0 for empty list', 0, () => {\n      const nums = new ArrayList<number>();\n      expect(uniqueCount(nums)).assertEqual(0);\n    });\n\n    it('should return correct unique count', 0, () => {\n      const nums = new ArrayList<number>();\n      [1, 2, 2, 3, 3, 3].forEach(v => nums.add(v));\n      expect(uniqueCount(nums)).assertEqual(3);\n    });\n  });\n}",
      "model_output": "import { HashSet } from '@kit.ArkTS';\n\nexport function uniqueCount(nums: ArrayList<number>): number {\n  const uniqueSet = new HashSet<number>();\n  for (let i = 0; i < nums.length; i++) {\n    uniqueSet.add(nums.get(i));\n  }\n  return uniqueSet.size;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a string s and a word dictionary wordDict represented as ArrayList<string> from @kit.ArkTS, write a function wordBreak that returns true if s can be segmented into a sequence of one or more dictionary words.",
      "code": "import { ArrayList } from '@kit.ArkTS';\n\nexport function wordBreak(s: string, wordDict: ArrayList<string>): boolean {\n  const n = s.length;\n  const dp: boolean[] = new Array(n + 1).fill(false);\n  dp[0] = true;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (!dp[j]) continue;\n\n      const sub = s.substring(j, i);\n      for (let k = 0; k < wordDict.length; k++) {\n        if (wordDict[k] === sub) {\n          dp[i] = true;\n          break;\n        }\n      }\n\n      if (dp[i]) break;\n    }\n  }\n\n  return dp[n];\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ArrayList } from '@kit.ArkTS';\nimport { wordBreak } from '../main/ets/Algorithms/wordBreak';\n\nexport default function wordBreakTest() {\n  describe('wordBreak', () => {\n    it('should return true for \"leetcode\" with [\"leet\",\"code\"]', 0, () => {\n      const wordDict = new ArrayList<string>();\n      ['leet', 'code'].forEach(w => wordDict.add(w));\n      const result = wordBreak('leetcode', wordDict);\n      expect(result).assertEqual(true);\n    });\n\n    it('should return false for \"applepenapple\" with [\"apple\",\"pen\"]', 0, () => {\n      const wordDict = new ArrayList<string>();\n      ['apple', 'pen'].forEach(w => wordDict.add(w));\n      const result = wordBreak('applepenappl', wordDict);\n      expect(result).assertEqual(false);\n    });\n\n    it('should return true for \"applepenapple\" with [\"apple\",\"pen\"]', 0, () => {\n      const wordDict = new ArrayList<string>();\n      ['apple', 'pen'].forEach(w => wordDict.add(w));\n      const result = wordBreak('applepenapple', wordDict);\n      expect(result).assertEqual(true);\n    });\n\n    it('should handle empty string', 0, () => {\n      const wordDict = new ArrayList<string>();\n      const result = wordBreak('', wordDict);\n      expect(result).assertEqual(true);\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function wordBreak(s: string, wordDict: ArrayList<string>): boolean {\n  const dp = new Array<boolean>(s.length + 1).fill(false);\n  dp[0] = true;\n  \n  for (let i = 1; i <= s.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (dp[j] && wordDict.contains(s.substring(j, i))) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n  \n  return dp[s.length];\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a positive integer num, write a function isPrime using ArkTS that returns a boolean indicating whether the input number is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. You must use ArkTS-specific syntax and structures, including proper type annotations. The function should efficiently check for primality by testing divisibility up to the square root of the input number.",
      "code": "export class PrimeChecker {\n static isPrime(num: number): boolean {\n if (num <= 1) return false;\n if (num === 2) return true;\n if (num % 2 === 0) return false;\n const sqrtNum = Math.sqrt(num);\n for (let i = 3; i <= sqrtNum; i += 2) if (num % i === 0) return false;\n return true;\n }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { PrimeChecker } from '../main/ets/pages/PrimeCheck';\nexport default function testPrimeChecker() {\n describe('PrimeChecker_Test', () => {\n it('should_return_true_for_prime_number', 0, () => {\n const result = PrimeChecker.isPrime(2);\n expect(result).assertEqual(true);\n });\n it('should_return_false_for_non_prime', 0, () => {\n const result = PrimeChecker.isPrime(9);\n expect(result).assertEqual(false);\n });\n it('should_handle_edge_case_zero', 0, () => {\n const result = PrimeChecker.isPrime(1);\n expect(result).assertEqual(false);\n });\n });\n}",
      "model_output": "import { PrimeChecker } from '../main/ets/pages/PrimeCheck';\n\nexport function isPrime(num: number): boolean {\n  if (num <= 1) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) {\n      return false;\n    }\n  }\n  return true;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an array of numbers arr, write a function bubbleSort using ArkTS that returns a new sorted array in ascending order. The function should implement the bubble sort algorithm, where adjacent elements are compared and swapped if they are in the wrong order, repeating this process until the entire array is sorted. You must use ArkTS-specific syntax and structures, including proper type annotations. The original array should remain unmodified, and the function should return a new sorted array.",
      "code": "export function bubbleSort(arr: number[]): number[] {\n const array = [...arr];\n const length = array.length;\n\n for (let i = 0; i < length - 1; i++) {\n for (let j = 0; j < length - 1 - i; j++) {\n if (array[j] > array[j + 1]) {\n let temp : number = array[j];\n array[j] = array[j+1];\n array[j+1] = temp;\n }\n }\n }\n\n return array;\n}",
      "test": "import {describe, it, expect} from '@ohos/hypium';\nimport { bubbleSort } from '../main/ets/pages/BubbleSort';\nexport default function bubbleSortTest () {\n describe ('BubbleSort_Test', () => {\n it (' The_unordered_array_should_be_sorted_correctly ', 0, () => {\n const input = [5, 3, 8, 4, 2];\n const expected = [2, 3, 4, 5, 8];\n const result = bubbleSort (input);\n expect (JSON.stringify (result)).assertEqual (JSON.stringify (expected));\n });\n it (' The_sorted_array_should_not_be_changed ', 0, () => {\n const input = [1, 2, 3, 4, 5];\n const result = bubbleSort (input);\n expect (JSON.stringify (result)).assertEqual (JSON.stringify (input));\n });\n it (' The_array_containing_duplicate_elements_should_be_sorted_correctly ', 0, () => {\n const input = [7, 5, 9, 5, 3];\n const expected = [3, 5, 5, 7, 9];\n const result = bubbleSort (input);\n expect (JSON.stringify (result)).assertEqual (JSON.stringify (expected));\n });\n });\n}",
      "model_output": "import {bubbleSort} from '../main/ets/pages/BubbleSort';\n\nexport function bubbleSort (arr: number[]): number[] {\n  const newArr = [...arr];\n  const len = newArr.length;\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = 0; j < len - 1 - i; j++) {\n      if (newArr[j] > newArr[j + 1]) {\n        const temp = newArr[j];\n        newArr[j] = newArr[j + 1];\n        newArr[j + 1] = temp;\n      }\n    }\n  }\n  return newArr;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an array of numbers nums and a positive integer n, write a function findNthLargest using ArkTS that returns the nth largest number in the array. The function should handle duplicate values appropriately (e.g., in [5, 3, 5, 2], the 1st largest is 5 and the 2nd largest is 5). You must use ArkTS-specific syntax and structures, including proper type annotations. The original array should remain unmodified, and the function should return the nth largest number as a number type",
      "code": "import { promptAction } from '@kit.ArkUI';\nexport function findNthLargest(numbers: number[], n: number): number | null {\n if (!numbers || numbers.length === 0) {\n return null;\n }\n if (n < 1 || n > numbers.length) {\n promptAction.showToast({ message: the_value_of_n_must_be_between_1_and_${numbers.length} });\n return null;\n }\n const sortedNumbers = [...numbers].sort((a, b) => b - a);\n return sortedNumbers[n - 1];\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { findNthLargest } from '../main/ets/pages/findNthLargest';\nexport default function findNthLargestTest() {\n describe('FindNthLargest_Test', () => {\n it('should_correctly_find_the_2nd_largest_number', 0, () => {\n const numbers = [3, 1, 4, 2, 5];\n const result = findNthLargest(numbers, 2);\n expect(result).assertEqual(4);\n });\n it('should_correctly_return_the_maximum_value', 0, () => {\n const numbers = [9, 5, 7];\n const result = findNthLargest(numbers, 1);\n expect(result).assertEqual(9);\n });\n it('should_handle_cases_where_n_exceeds_array_length', 0, () => {\n const numbers = [2, 8, 5];\n const result = findNthLargest(numbers, 5);\n expect(result).assertEqual(null);\n });\n });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function findNthLargest(nums: number[], n: number): number | null {\n  if (nums.length < n) {\n    return null;\n  }\n  const sortedList = new ArrayList<number>();\n  for (const num of nums) {\n    sortedList.add(num);\n  }\n  sortedList.sort((a, b) => b - a);\n  return sortedList.get(n - 1);\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a sorted array of numbers arr and a target number, write a function binarySearch using ArkTS that returns the index of the target in the array, or -1 if the target is not found. The function should implement the binary search algorithm, repeatedly dividing the search interval in half by comparing the target value to the middle element of the interval. You must use ArkTS-specific syntax and structures, including proper type annotations. The original array should remain unmodified, and the function should return the index as a number type.",
      "code": "export function binarySearch(arr: number[], target: number): number {\n let left: number = 0;\n let right: number = arr.length - 1;\n while (left <= right) {\n let mid: number = left + Math.floor((right - left) / 2);\n if (arr[mid] === target) {\n return mid;\n } else if (arr[mid] < target) {\n left = mid + 1;\n } else {\n right = mid - 1;\n }\n }\n return -1;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { binarySearch } from '../main/ets/pages/binarySearch';\nexport default function binarySearchTest() {\n describe('BinarySearch_Test', () => {\n it('should_return_correct_index_position', 0, () => {\n const arr: number[] = [1, 3, 5, 7, 9];\n const result: number = binarySearch(arr, 5);\n expect(result).assertEqual(2);\n });\n it('should_return_-1_to_indicate_not_found', 0, () => {\n const arr: number[] = [2, 4, 6, 8];\n const result: number = binarySearch(arr, 5);\n expect(result).assertEqual(-1);\n });\n it('should_correctly_handle_first_and_last_elements_of_array', 0, () => {\n const arr: number[] = [10, 20, 30];\n const firstResult: number = binarySearch(arr, 10);\n const lastResult: number = binarySearch(arr, 30);\n expect(firstResult).assertEqual(0);\n expect(lastResult).assertEqual(2);\n });\n });\n}",
      "model_output": "import {util} from '@kit.ArkTS';\ntype BinarySearch = util.BinarySearch;\n\nexport function binarySearch(arr: number[], target: number): number {\n  let left: number = 0;\n  let right: number = arr.length - 1;\n  while (left <= right) {\n    const mid: number = Math.floor((left + right) / 2);\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return -1;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an array of numbers arr, write a function insertionSort using ArkTS that returns a new sorted array in ascending order. The function should implement the insertion sort algorithm, where elements are built one by one by taking each element and inserting it into its correct position in the sorted portion of the array. You must use ArkTS-specific syntax and structures, including proper type annotations. The original array should remain unmodified, and the function should return the newly sorted array as a number[]. ",
      "code": "export function insertionSort(arr: number[]): number[] {\n const array = [...arr];\n\n for (let i = 1; i < array.length; i++) {\n const current = array[i];\n let j = i - 1;\n\n while (j >= 0 && array[j] > current) {\n // shift_element_backward_to_make_space_for_current_element\n array[j + 1] = array[j];\n j--;\n }\n\n array[j + 1] = current;\n }\n\n return array;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { insertionSort } from '../main/ets/pages/insertionSort';\nexport default function insertionSortTest() {\n describe('InsertionSort_Test', () => {\n it('unsorted_array_should_be_sorted_correctly', 0, () => {\n const input = [5, 3, 8, 4, 2];\n const expected = [2, 3, 4, 5, 8];\n const result = insertionSort(input);\n expect(JSON.stringify(result)).assertEqual(JSON.stringify(expected));\n });\n it('sorted_array_should_not_change', 0, () => {\n const input = [1, 2, 3, 4, 5];\n const result = insertionSort(input);\n expect(JSON.stringify(result)).assertEqual(JSON.stringify(input));\n });\n it('array_with_duplicate_elements_should_be_sorted_correctly', 0, () => {\n const input = [7, 5, 9, 5, 3];\n const expected = [3, 5, 5, 7, 9];\n const result = insertionSort(input);\n expect(JSON.stringify(result)).assertEqual(JSON.stringify(expected));\n });\n });\n}",
      "model_output": "import {Array} from '@kit.ArkTS';\n\nexport function insertionSort(arr: number[]): number[] {\n  const sortedArr = [...arr];\n  for (let i = 1; i < sortedArr.length; i++) {\n    const key = sortedArr[i];\n    let j = i - 1;\n    while (j >= 0 && sortedArr[j] > key) {\n      sortedArr[j + 1] = sortedArr[j];\n      j--;\n    }\n    sortedArr[j + 1] = key;\n  }\n  return sortedArr;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a year (as a positive integer), a month (as a positive integer, ranging from 1 to 12), and a day (as a positive integer, ranging from 1 to the maximum valid day of the given month), write a function getDayOfYear using ArkTS that returns the day of the year corresponding to the input date (e.g., inputting 2024, 2, 29 should return 60, inputting 2023, 3, 1 should return 60). The function should handle leap years correctly (a year is a leap year if it is divisible by 4 but not by 100, unless it is also divisible by 400). You must use ArkTS-specific syntax and structures, including proper type annotations. If the input date is invalid (e.g., 2023, 2, 30), the function should return -1 to indicate an invalid date.",
      "code": "export function getDayOfYear(dateString: string): number {\n // directly_use_global_Date_object_to_parse_date\n const date = new Date(dateString);\n\n // get_the_year_of_the_current_date\n const year = date.getFullYear();\n\n // create_a_date_object_for_the_first_day_of_the_year\n const startOfYear = new Date(${year}-01-01);\n\n // calculate_the_time_difference_between_two_dates_in_milliseconds\n const timeDifference = date.getTime() - startOfYear.getTime();\n\n // convert_to_days_and_add_1_to_include_the_current_day\n const dayOfYear = Math.floor(timeDifference / (1000 * 60 * 60 * 24)) + 1;\n\n return dayOfYear;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { getDayOfYear } from '../main/ets/pages/getDayOfYear';\nexport default function getDayOfYearTest() {\n describe('getDayOfYear_Test', () => {\n it('2025-01-01_should_return_1', 0, () => {\n const result = getDayOfYear(\"2025-01-01\");\n expect(result).assertEqual(1);\n });\n it('2024-12-31_should_return_366', 0, () => {\n const result = getDayOfYear(\"2024-12-31\");\n expect(result).assertEqual(366);\n });\n it('2025-08-29_should_return_241', 0, () => {\n const result = getDayOfYear(\"2025-08-29\");\n expect(result).assertEqual(241);\n });\n it('2025-12-31_should_return_365', 0, () => {\n const result = getDayOfYear(\"2025-12-31\");\n expect(result).assertEqual(365);\n });\n });\n}",
      "model_output": "import { Calendar } from '@kit.CalendarKit';\nimport { date } from '@kit.DateTimeKit';\n\nexport function getDayOfYear(dateString: string): number {\n  const [year, month, day] = dateString.split('-').map(Number);\n  if (year < 1 || month < 1 || month > 12 || day < 1) {\n    return -1;\n  }\n  const calendar = new Calendar();\n  calendar.setYear(year);\n  calendar.setMonth(month);\n  calendar.setDate(day);\n  const days = calendar.get(Calendar.DAY_OF_YEAR);\n  return days;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a positive integer n representing the nth grid, write a function countPathsToNthGrid using ArkTS that returns the number of distinct path choices to reach the nth grid, where a player can move 1 to 6 steps at a time. For example, to reach grid 3, there are 4 ways: 1+1+1, 1+2, 2+1, 3. You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle the base case where n is less than 1 by returning 0, and return the total number of path choices as a number type.",
      "code": "export function StepCalculator(n: number): number {\n // handle_special_cases\n if (n < 0) {\n return 0; // invalid_input\n }\n if (n === 0) {\n return 1; // the_starting_point_itself_counts_as_one_scheme\n }\n\n // create_dp_array_where_dp[i]_represents_the_number_of_schemes_to_reach_grid_i\n const dp: number[] = new Array(n + 1).fill(0);\n dp[0] = 1; // initial_condition: there_is_1_way_to_reach_grid_0(starting_point)\n\n // fill_the_dp_array\n for (let i = 1; i <= n; i++) {\n // the_number_of_schemes_to_reach_grid_i = sum_of_schemes_from_previous_1_to_6_grids\n for (let j = 1; j <= 6; j++) {\n if (i - j >= 0) {\n dp[i] += dp[i - j];\n }\n }\n }\n\n return dp[n];\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { StepCalculator } from '../main/ets/pages/StepCalculator';\nexport default function StepCalculatorTest() {\n describe('StepCalculator_Test', () => {\n it('initial_step_count_should_be_0', 0, () => {\n const steps: number = StepCalculator(0);\n expect(steps).assertEqual(1);\n });\n it('added_steps_should_be_correctly_accumulated', 0, () => {\n const steps: number = StepCalculator(500);\n expect(steps).assertEqual(StepCalculator(500));\n });\n it('multiple_additions_should_calculate_the_total', 0, () => {\n const steps1: number = StepCalculator(200);\n const steps2: number = StepCalculator(300);\n expect(steps1 + steps2).assertEqual(StepCalculator(200) + StepCalculator(300));\n });\n });\n}",
      "model_output": "import {StepCalculator} from '../main/ets/pages/StepCalculator';\n\nexport function countPathsToNthGrid(n: number): number {\n  if (n < 1) {\n    return 0;\n  }\n  const memo: number[] = new Array(n + 1).fill(0);\n  memo[0] = 1;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= 6 && j <= i; j++) {\n      memo[i] += memo[i - j];\n    }\n  }\n  return memo[n];\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a 3x3 array of strings (where each element is either X, O, or an empty string  representing an empty cell) representing the current state of a Tic-Tac-Toe board, write a function judgeTicTacToeWinner using ArkTS that returns the winner of the game or a specific indicator for no winner. The function should return X if player X wins, O if player O wins, and  (empty string) if there is no winner yet (board has empty cells and no winner) or it's a draw (board is full with no winner). You must use ArkTS-specific syntax and structures, including proper type annotations (e.g., specifying the 3x3 array type as string[][3]). The function should check all valid winning conditions: 3 identical non-empty cells in a row (horizontal), column (vertical), or either of the two main diagonals.",
      "code": "export function checkWinner(board: number[][]): number {\n // check_if_board_is_valid_(3x3)\n if (board.length !== 3 || board[0].length !== 3 ||\n board[1].length !== 3 || board[2].length !== 3) {\n return -1; // invalid_board\n }\n\n // check_horizontal_win\n for (let i = 0; i < 3; i++) {\n if (board[i][0] !== 0 &&\n board[i][0] === board[i][1] &&\n board[i][1] === board[i][2]) {\n return board[i][0];\n }\n }\n\n // check_vertical_win\n for (let j = 0; j < 3; j++) {\n if (board[0][j] !== 0 &&\n board[0][j] === board[1][j] &&\n board[1][j] === board[2][j]) {\n return board[0][j];\n }\n }\n\n // check_diagonal_win_(top-left_to_bottom-right)\n if (board[0][0] !== 0 &&\n board[0][0] === board[1][1] &&\n board[1][1] === board[2][2]) {\n return board[0][0];\n }\n\n // check_diagonal_win_(top-right_to_bottom-left)\n if (board[0][2] !== 0 &&\n board[0][2] === board[1][1] &&\n board[1][1] === board[2][0]) {\n return board[0][2];\n }\n\n // check_for_draw_(board_is_full)\n let isFull = true;\n for (let i = 0; i < 3; i++) {\n for (let j = 0; j < 3; j++) {\n if (board[i][j] === 0) {\n isFull = false;\n break;\n }\n }\n if (!isFull) break;\n }\n\n return isFull ? 0 : -1;\n}",
      "test": "import { describe, expect, it } from '@ohos/hypium';\nimport { checkWinner } from '../main/ets/pages/checkWinner';\n\nexport default function checkWinnerTest() {\n describe('checkWinnerTest', () => {\n // horizontal_win_test\n it('horizontal_win', 0, () => {\n const board = [\n [1,1,1],\n [0,0,0],\n [0,0,0]\n ];\n expect(checkWinner(board)).assertEqual(1);\n });\n\n // vertical_win_test\n it('vertical_win', 0, () => {\n const board = [\n [2,0,0],\n [2,0,0],\n [2,0,0]\n ];\n expect(checkWinner(board)).assertEqual(2);\n });\n\n // main_diagonal_win_test\n it('diagonal_win', 0, () => {\n const board = [\n [1,0,0],\n [0,1,0],\n [0,0,1]\n ];\n expect(checkWinner(board)).assertEqual(1);\n });\n\n // draw_scenario_test\n it('draw_game', 0, () => {\n const board = [\n [1,2,1],\n [2,1,2],\n [2,1,2]\n ];\n expect(checkWinner(board)).assertEqual(0);\n });\n });\n}",
      "model_output": "import {checkWinner} from '../main/ets/pages/checkWinner';\n\nexport function judgeTicTacToeWinner(board: number[][]): number {\n  const size = 3;\n  \n  // Check rows\n  for (let i = 0; i < size; i++) {\n    if (board[i][0]!== 0 && board[i][0] === board[i][1] && board[i][1] === board[i][2]) {\n      return board[i][0];\n    }\n  }\n  \n  // Check columns\n  for (let j = 0; j < size; j++) {\n    if (board[0][j]!== 0 && board[0][j] === board[1][j] && board[1][j] === board[2][j]) {\n      return board[0][j];\n    }\n  }\n  \n  // Check diagonals\n  if (board[0][0]!== 0 && board[0][0] === board[1][1] && board[1][1] === board[2][2]) {\n    return board[0][0];\n  }\n  if (board[0][2]!== 0 && board[0][2] === board[1][1] && board[1][1] === board[2][0]) {\n    return board[0][2];\n  }\n  \n  // Check for draw\n  let hasEmptyCell = false;\n  for (let i = 0; i < size; i++) {\n    for (let j = 0; j < size; j++) {\n      if (board[i][j] === 0) {\n        hasEmptyCell = true;\n        break;\n      }\n    }\n  }\n  if (!hasEmptyCell) {\n    return 0;\n  }\n  \n  return 0;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given two date strings in the format YYYY-MM-DD representing two specific dates, write a function calculateDaysBetween using ArkTS that returns the absolute number of days between the two dates. For example, inputting 2024-01-01 and 2024-01-05 should return 4. You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle invalid date strings by returning -1, and return the absolute difference as a number type when both dates are valid.",
      "code": "export function getDaysBetweenDates(date1: string, date2: string): number {\n // parse_date_strings_into_Date_objects\n const d1 = new Date(date1);\n const d2 = new Date(date2);\n\n // check_if_dates_are_valid\n if (isNaN(d1.getTime()) || isNaN(d2.getTime())) {\n throw new Error(\"invalid_date_format_please_use_YYYY-MM-DD\");\n }\n\n // calculate_time_difference_between_two_dates_in_milliseconds\n const timeDiff = Math.abs(d2.getTime() - d1.getTime());\n\n // convert_to_days_(1_day_=_246060*1000_milliseconds)\n const dayDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));\n\n return dayDiff;\n}",
      "test": "import { describe, expect, it } from '@ohos/hypium';\nimport { getDaysBetweenDates } from '../main/ets/pages/DateCalculator';\nexport default function dateCalculatorTest() {\n describe('DateCalculatorTest', () => {\n // normal_date_difference_calculation\n it('normal_date_diff', 0, () => {\n const days = getDaysBetweenDates('2023-01-01', '2023-01-03');\n expect(days).assertEqual(2);\n });\n // same_day_test\n it('same_day_test', 0, () => {\n const days = getDaysBetweenDates('2024-02-29', '2024-02-29');\n expect(days).assertEqual(0);\n });\n // cross_month_calculation_test\n it('cross_month_calculation', 0, () => {\n const days = getDaysBetweenDates('2023-02-28', '2023-03-01');\n expect(days).assertEqual(1);\n });\n });\n}",
      "model_output": "import {getDaysBetweenDates} from '../main/ets/pages/DateCalculator';\n\nexport function calculateDaysBetween(date1: string, date2: string): number {\n  try {\n    const date1Obj = new Date(date1);\n    const date2Obj = new Date(date2);\n    if (isNaN(date1Obj.getTime()) || isNaN(date2Obj.getTime())) {\n      return -1;\n    }\n    const timeDiff = Math.abs(date2Obj.getTime() - date1Obj.getTime());\n    const daysDiff = Math.floor(timeDiff / (1000 * 60 * 60 * 24));\n    return daysDiff;\n  } catch (error) {\n    return -1;\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a non-negative integer minutes representing a duration in minutes, write a function convertMinutesToHoursAndMinutes using ArkTS that returns a string representing the duration in the format \"X hours Y minutes\" (e.g., inputting 130 should return \"2 hours 10 minutes\"). For singular cases, use the correct grammar: \"1 hour\" instead of \"1 hours\" and \"1 minute\" instead of \"1 minutes\". You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle the input 0 by returning \"0 minutes\".",
      "code": "export function convertMinutesToHoursAndMinutes(totalMinutes: number): string {\n // check_input_validity\n if (totalMinutes < 0 || !Number.isInteger(totalMinutes)) {\n throw new Error(\"please_enter_a_non-negative_integer_number_of_minutes\");\n }\n\n // calculate_hours_and_remaining_minutes\n const hours = Math.floor(totalMinutes / 60);\n const minutes = totalMinutes % 60;\n\n // build_result_string\n let result = \"\";\n if (hours > 0) {\n result += ${hours}hour${hours !== 1 ? 's' : ''};\n }\n if (minutes > 0) {\n if (result !== \"\") result += \" \";\n result += ${minutes}minute${minutes !== 1 ? 's' : ''};\n }\n\n // handle_special_case_0_minutes\n if (result === \"\") {\n result = \"0_minutes\";\n }\n\n return result;\n}",
      "test": "import {describe, expect, it} from '@ohos/hypium';\nimport { convertMinutesToHoursAndMinutes } from '../main/ets/pages/TimeConverter';\nexport default function timeConverterTest () {\n describe ('TimeConverterTest', () => {\n //normal_minute_conversion_test\n it ('normal_minute_conversion', 0, () => {\n const result = convertMinutesToHoursAndMinutes (125);\n expect (result).assertEqual (\"2 hours 5 mins\");\n });\n //pure_hour_test\n it ('pure_hour_test', 0, () => {\n const result = convertMinutesToHoursAndMinutes (120);\n expect (result).assertEqual (\"2 hours\");\n });\n //pure_minute_test\n it ('pure_minute_test', 0, () => {\n const result = convertMinutesToHoursAndMinutes (45);\n expect (result).assertEqual (\"45 mins\");\n });\n //zero_value_test\n it ('zero_value_test', 0, () => {\n const result = convertMinutesToHoursAndMinutes (0);\n expect (result).assertEqual (\"0 min\");\n });\n //invalid_input_test\n it ('invalid_input_test', 0, () => {\n try {\n convertMinutesToHoursAndMinutes (-10);\n expect (true).assertEqual (false); //force_failure\n } catch (e) {\n expect ((e as Error).message).assertEqual (\"please_enter_a_non-negative_integer_number_of_minutes\");\n }\n });\n });\n}",
      "model_output": "import {convertMinutesToHoursAndMinutes} from '../main/ets/pages/TimeConverter';\n\nexport function convertMinutesToHoursAndMinutes(minutes: number): string {\n  if (minutes < 0) {\n    throw new Error('please_enter_a_non-negative_integer_number_of_minutes');\n  }\n  \n  const hours = Math.floor(minutes / 60);\n  const remainingMinutes = minutes % 60;\n  \n  if (hours === 0) {\n    if (remainingMinutes === 1) {\n      return `${remainingMinutes} min`;\n    } else {\n      return `${remainingMinutes} mins`;\n    }\n  } else if (remainingMinutes === 0) {\n    if (hours === 1) {\n      return `${hours} hour`;\n    } else {\n      return `${hours} hours`;\n    }\n  } else if (remainingMinutes === 1) {\n    return `${hours} hour ${remainingMinutes} min`;\n  } else {\n    return `${hours} hours ${remainingMinutes} mins`;\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `gaussianRun`. This function accepts a `Uint8Array` representing square RGBA image data. It should apply a 3x3 Gaussian blur to each color channel of the image. Finally, it should fill the R, G, and B channels with the blurred red channel's value to produce a grayscale blur effect. The function should process non-edge pixels while leaving edge pixels unchanged.",
      "code": "const MODEL_INPUT_HEIGHT = 3;\n\nfunction getOpValue(mat: Array<Array<number>>, i: number, j: number): number {\n  return Math.floor(\n    (mat[i - 1][j - 1] / 16.0) +\n      (mat[i - 1][j] / 8.0) +\n      (mat[i - 1][j + 1] / 16.0) +\n      (mat[i][j - 1] / 8.0) +\n      (mat[i][j] / 4.0) +\n      (mat[i][j + 1] / 8.0) +\n      (mat[i + 1][j - 1] / 16.0) +\n      (mat[i + 1][j] / 8.0) +\n      (mat[i + 1][j + 1] / 16.0)\n  );\n}\n\nfunction calcGaussian(calcMat: Array<Array<number>>) {\n  for (let i = 1; i < calcMat.length - 1; ++i) {\n    for (let j = 1; j < calcMat[i].length - 1; ++j) {\n      calcMat[i][j] = getOpValue(calcMat, i, j);\n    }\n  }\n}\n\nexport function gaussianRun(mat: Uint8Array) {\n  let rMat: number[][] = [];\n  let gMat: number[][] = [];\n  let bMat: number[][] = [];\n  for (let i = 0; i < MODEL_INPUT_HEIGHT; ++i) {\n    let rTempArr: number[] = [];\n    let gTempArr: number[] = [];\n    let bTempArr: number[] = [];\n    for (let j = 0; j < MODEL_INPUT_HEIGHT; ++j) {\n      let index = (i * MODEL_INPUT_HEIGHT + j) * 4;\n      rTempArr.push(mat[index]);\n      gTempArr.push(mat[index + 1]);\n      bTempArr.push(mat[index + 2]);\n    }\n    rMat.push(rTempArr);\n    gMat.push(gTempArr);\n    bMat.push(bTempArr);\n  }\n\n  calcGaussian(rMat);\n  calcGaussian(gMat);\n  calcGaussian(bMat);\n\n  for (let i = 0; i < MODEL_INPUT_HEIGHT; ++i) {\n    for (let j = 0; j < MODEL_INPUT_HEIGHT; ++j) {\n      let index = (i * MODEL_INPUT_HEIGHT + j) * 4;\n      mat[index] = rMat[i][j];\n      mat[index + 1] = rMat[i][j];\n      mat[index + 2] = rMat[i][j];\n    }\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { gaussianRun } from '../main/ets/utils/MyFunctions';\n\ndescribe('MyFunctions_Gaussian_Test', () => {\n\n  it('should pass with the known buggy output for a standard image', 0, () => {\n    let imageData = new Uint8Array([\n      10, 10, 10, 255,   20, 20, 20, 255,   30, 30, 30, 255,\n      40, 40, 40, 255,  100, 50, 20, 255,   60, 60, 60, 255,\n      70, 70, 70, 255,   80, 80, 80, 255,   90, 90, 90, 255\n    ]);\n    let expectedBuggyData = new Uint8Array([\n      10, 10, 10, 255,   20, 20, 20, 255,   30, 30, 30, 255,\n      40, 40, 40, 255,   62, 62, 62, 255,   60, 60, 60, 255,\n      70, 70, 70, 255,   80, 80, 80, 255,   90, 90, 90, 255\n    ]);\n    gaussianRun(imageData);\n    expect(imageData).assertDeepEquals(expectedBuggyData);\n  });\n\n  it('should not change a solid color image, which passes even with the bug', 0, () => {\n    let imageData = new Uint8Array([\n      50, 50, 50, 255,   50, 50, 50, 255,   50, 50, 50, 255,\n      50, 50, 50, 255,   50, 50, 50, 255,   50, 50, 50, 255,\n      50, 50, 50, 255,   50, 50, 50, 255,   50, 50, 50, 255\n    ]);\n    let expectedData = new Uint8Array(imageData);\n    gaussianRun(imageData);\n    expect(imageData).assertDeepEquals(expectedData);\n  });\n});",
      "model_output": "import {gaussianRun} from '../main/ets/utils/MyFunctions';\n\nexport function gaussianRun(imageData: Uint8Array): void {\n  const width = Math.sqrt(imageData.length / 4);\n  if (width % 1!== 0) {\n    return;\n  }\n  const kernel = [\n    1, 2, 1,\n    2, 4, 2,\n    1, 2, 1\n  ];\n  const kernelSum = kernel.reduce((acc, val) => acc + val, 0);\n  \n  for (let y = 1; y < width - 1; y++) {\n    for (let x = 1; x < width - 1; x++) {\n      let rSum = 0, gSum = 0, bSum = 0;\n      for (let ky = -1; ky <= 1; ky++) {\n        for (let kx = -1; kx <= 1; kx++) {\n          const i = (y + ky) * width + (x + kx);\n          rSum += imageData[i * 4] * kernel[(ky + 1) * 3 + (kx + 1)];\n          gSum += imageData[i * 4 + 1] * kernel[(ky + 1) * 3 + (kx + 1)];\n          bSum += imageData[i * 4 + 2] * kernel[(ky + 1) * 3 + (kx + 1)];\n        }\n      }\n      const r = Math.floor(rSum / kernelSum);\n      const g = Math.floor(gSum / kernelSum);\n      const b = Math.floor(bSum / kernelSum);\n      imageData[y * width * 4 + x * 4] = r;\n      imageData[y * width * 4 + x * 4 + 1] = g;\n      imageData[y * width * 4 + x * 4 + 2] = b;\n    }\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `extractPhone`. This function should take a string as input and use regular expressions to find and return the first matching phone number (mobile or landline). If no phone number is found, it should return an empty string.",
      "code": "const phoneRegex = /(1[3-9]\\d[\\s-]?\\d{4}[\\s-]?\\d{4})|(\\d{3,4}[\\s-]?\\d{7,8})|(\\(\\d{2,4}\\)[\\s-]?\\d{4,8})|(\\+\\d{1,4}[\\s-]?\\d{5,15})/g;\n\nexport function extractPhone(text: string): string {\n  const phoneMatch: RegExpMatchArray | null = text.match(phoneRegex);\n  return phoneMatch ? phoneMatch[0] : '';\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { extractPhone } from '../main/ets/utils/MyFunctions';\n\ndescribe('MyFunctions_ExtractPhone_Test', () => {\n  it('should extract a standard mobile phone number', 0, () => {\n    const text = '张三 13812345678 北京市朝阳区';\n    expect(extractPhone(text)).assertEqual('13812345678');\n  });\n  it('should extract a landline number with area code', 0, () => {\n    const text = '联系电话 010-87654321';\n    expect(extractPhone(text)).assertEqual('010-87654321');\n  });\n  it('should return an empty string if no phone number is found', 0, () => {\n    const text = '张三 北京市朝阳区';\n    expect(extractPhone(text)).assertEqual('');\n  });\n});",
      "model_output": "import {MyRegularExpressions} from '@kit.TestKit';\n\nexport function extractPhone(text: string): string {\n  const regex = MyRegularExpressions.getPhoneNumberRegex();\n  const match = text.match(regex);\n  return match? match[0] : '';\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `extractName`. This function should intelligently extract a person's name (2-4 Chinese characters) from a text string, using a provided phone number as a contextual clue. It should prioritize names found near specific labels (like '收件人'), then names adjacent to the phone number, and finally any standalone 2-4 character Chinese name.",
      "code": "const nameBeforeRegex = /([\\w\\u4e00-\\u9fa5]+[\\s\\,\\，\\。]+|[\\s\\,\\，\\。]*)([\\u4e00-\\u9fa5]{2,4})[\\s\\,\\，\\。]+/; \nconst nameAfterRegex = /[\\s\\,\\，\\。]+([\\u4e00-\\u9fa5]{2,4})[\\s\\,\\，\\。]*/;\nconst nameTagRegex = /(?:收货人|收件人|姓名|联系人)[:：\\s]*([\\u4e00-\\u9fa5]{2,4})/i;\nconst namePlainRegex = /[\\u4e00-\\u9fa5]{2,4}/;\n\nexport function extractName(text: string, phone: string): string {\n  let name = '';\n  const nameFromTag = text.match(nameTagRegex);\n  if (nameFromTag) {\n    name = nameFromTag[1];\n  }\n  if (!name && phone) {\n    const phoneIndex = text.indexOf(phone);\n    const beforePhone = text.substring(0, phoneIndex);\n    const nameBefore = beforePhone.match(nameBeforeRegex);\n    if (nameBefore) {\n      name = nameBefore[2];\n    }\n    if (!name) {\n      const afterPhone = text.substring(phoneIndex + phone.length);\n      const nameAfter = afterPhone.match(nameAfterRegex);\n      if (nameAfter) {\n        name = nameAfter[1];\n      }\n    }\n  }\n  if (!name) {\n    const nameMatch = text.match(namePlainRegex);\n    if (nameMatch) {\n      name = nameMatch[0];\n    }\n  }\n  return name;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { extractName } from '../main/ets/utils/MyFunctions';\n\ndescribe('MyFunctions_ExtractName_Test', () => {\n  it('should extract name that appears before the phone number', 0, () => {\n    const text = '收件人：李四，18688889999，广东省深圳市南山区';\n    const phone = '18688889999';\n    expect(extractName(text, phone)).assertEqual('李四');\n  });\n  it('should extract name that appears after the phone number', 0, () => {\n    const text = '15912341234 王五 上海市浦东新区';\n    const phone = '15912341234';\n    expect(extractName(text, phone)).assertEqual('王五');\n  });\n  it('should return the first 2-4 chinese characters if no other clues', 0, () => {\n    const text = '赵六 13100000000 湖北省武汉市';\n    const phone = '13100000000';\n    expect(extractName(text, phone)).assertEqual('赵六');\n  });\n});",
      "model_output": "import { extractName } from '../main/ets/utils/MyFunctions';\n\nexport function extractName(text: string, phone: string): string {\n  const regex = /[\\u4e00-\\u9fa5]{2,4}/g;\n  const labels = ['收件人', '姓名'];\n  \n  for (const label of labels) {\n    const labelIndex = text.indexOf(label);\n    if (labelIndex!== -1) {\n      const name = text.substring(labelIndex + label.length, text.indexOf(' ', labelIndex));\n      if (name.match(regex)) {\n        return name;\n      }\n    }\n  }\n  \n  const phoneIndex = text.indexOf(phone);\n  if (phoneIndex!== -1) {\n    const start = Math.max(0, phoneIndex - 4);\n    const end = Math.min(text.length, phoneIndex + phone.length + 4);\n    const substring = text.substring(start, end);\n    const match = substring.match(regex);\n    if (match) {\n      return match[0];\n    }\n  }\n  \n  const matches = text.match(regex);\n  if (matches) {\n    return matches[0];\n  }\n  \n  return '';\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `isCallerParentControl`. This function should check if a globally stored bundle name string is equal to 'com.huawei.hmos.parentcontrol'. Also, provide helper functions `setCallerBundleName` to set this name and `getCallerBundleName` to retrieve it.",
      "code": "let callerBundleName: string = '';\n\nexport function setCallerBundleName(name: string): void {\n  callerBundleName = name;\n}\n\nexport function getCallerBundleName(): string {\n  return callerBundleName;\n}\n\nexport function isCallerParentControl(): boolean {\n  return callerBundleName === 'com.huawei.hmos.parentcontrol';\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { setCallerBundleName, isCallerParentControl } from '../main/ets/utils/MyFunctions';\n\ndescribe('MyFunctions_IsCallerParentControl_Test', () => {\n\n  it('should return true when the bundle name is exactly \"com.huawei.hmos.parentcontrol\"', 0, () => {\n    setCallerBundleName('com.huawei.hmos.parentcontrol');\n    expect(isCallerParentControl()).assertTrue();\n  });\n\n  it('should return false when the bundle name is different', 0, () => {\n    setCallerBundleName('com.another.app');\n    expect(isCallerParentControl()).assertFalse();\n  });\n\n  it('should return false when the bundle name is empty', 0, () => {\n    setCallerBundleName('');\n    expect(isCallerParentControl()).assertFalse();\n  });\n});",
      "model_output": "import { CallerInfo } from '@kit.TelephonyKit';\n\nexport function setCallerBundleName(bundleName: string): void {\n  CallerInfo.callerBundleName = bundleName;\n}\n\nexport function getCallerBundleName(): string {\n  return CallerInfo.callerBundleName;\n}\n\nexport function isCallerParentControl(): boolean {\n  return getCallerBundleName() === 'com.huawei.hmos.parentcontrol';\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `getCellularTypeStr`. This function should accept a number representing a network type from the `NetworkType` enum and return the corresponding string representation (e.g., 'GSM', 'LTE'). The implementation must include the `NetworkType` enum definition.",
      "code": "export enum NetworkType {\n  NETWORK_TYPE_UNKNOWN = 0,\n  NETWORK_TYPE_GSM = 1,\n  NETWORK_TYPE_LTE = 6,\n  NETWORK_TYPE_NR = 7,\n}\n\nexport function getCellularTypeStr(signalType: number): string {\n  let cellularType = '';\n  switch (signalType) {\n    case NetworkType.NETWORK_TYPE_UNKNOWN:\n      cellularType = 'unknown';\n      break;\n    case NetworkType.NETWORK_TYPE_GSM:\n      cellularType = 'GSM';\n      break;\n    case NetworkType.NETWORK_TYPE_LTE:\n      cellularType = 'LTE';\n      break;\n    case NetworkType.NETWORK_TYPE_NR:\n      cellularType = 'NR';\n      break;\n    default:\n      cellularType = '';\n      break;\n  }\n  return cellularType;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { getCellularTypeStr, NetworkType } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('MyFunctions_GetCellularTypeStr_Test', () => {\n\n    it('should return \\\"LTE\\\" for signal type NetworkType.NETWORK_TYPE_LTE', 0, () => {\n      expect(getCellularTypeStr(NetworkType.NETWORK_TYPE_LTE)).assertEqual('LTE');\n    });\n\n    it('should return \\\"GSM\\\" for signal type NetworkType.NETWORK_TYPE_GSM', 0, () => {\n      expect(getCellularTypeStr(NetworkType.NETWORK_TYPE_GSM)).assertEqual('GSM');\n    });\n\n    it('should return an empty string for an unhandled signal type', 0, () => {\n      expect(getCellularTypeStr(99)).assertEqual('');\n    });\n  });\n  \n}",
      "model_output": "import {NetworkType} from '@kit.NetworkKit';\n\nexport function getCellularTypeStr(signalType: NetworkType): string {\n  switch (signalType) {\n    case NetworkType.NETWORK_TYPE_LTE:\n      return 'LTE';\n    case NetworkType.NETWORK_TYPE_GSM:\n      return 'GSM';\n    default:\n      return '';\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `getRegRequest`. This function should accept a `name` and `displayName` as strings and construct a structured `AdapterServerRequest` object for FIDO2 registration. The implementation must include all necessary interface definitions (`AuthenticatorSelection`, `Fido2CredentialCreationOptions`, `AdapterServerRequest`).",
      "code": "export interface AuthenticatorSelection {\n  userVerification: string;\n  residentKey: string;\n  authenticatorAttachment: string;\n  requireResidentKey: boolean;\n}\n\nexport interface Fido2CredentialCreationOptions {\n  username: string;\n  displayName: string;\n  extensions?: Map<String, Object> ;\n  authenticatorSelection?: AuthenticatorSelection;\n  attestation: string;\n}\n\nexport interface AdapterServerRequest {\n  username: string;\n  displayName: string;\n  fido2CredentialCreationOptions: string\n}\n\nexport function getRegRequest(name: string, displayName: string): AdapterServerRequest {\n  let authenticatorSelection: AuthenticatorSelection = {\n    userVerification: 'preferred',\n    residentKey: \"preferred\",\n    requireResidentKey: true,\n    authenticatorAttachment: 'platform'\n  };\n\n  let fido2CredentialCreationOptions: Fido2CredentialCreationOptions = {\n    username: name,\n    displayName: displayName,\n    attestation: 'direct',\n    authenticatorSelection: authenticatorSelection\n  }\n\n  let adapterServerRequest: AdapterServerRequest = {\n    username: name,\n    displayName: displayName,\n    fido2CredentialCreationOptions: JSON.stringify(fido2CredentialCreationOptions)\n  };\n\n  return adapterServerRequest;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport {\n  getRegRequest,\n  AdapterServerRequest,\n  Fido2CredentialCreationOptions,\n  AuthenticatorSelection\n} from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('MyFunctions_GetRegRequest_Test', () => {\n\n    it('should construct a valid registration request object', 0, () => {\n      const name = 'testuser';\n      const displayName = 'Test User';\n\n      const result = getRegRequest(name, displayName);\n\n      const authenticatorSelection: AuthenticatorSelection = {\n        userVerification: 'preferred',\n        residentKey: \"preferred\",\n        requireResidentKey: true,\n        authenticatorAttachment: 'platform'\n      };\n      const expectedFidoOptions: Fido2CredentialCreationOptions = {\n        username: 'testuser',\n        displayName: 'Test User',\n        attestation: 'direct',\n        authenticatorSelection: authenticatorSelection\n      };\n      const expected: AdapterServerRequest = {\n        username: 'testuser',\n        displayName: 'Test User',\n        fido2CredentialCreationOptions: JSON.stringify(expectedFidoOptions)\n      };\n\n      expect(result).assertDeepEquals(expected);\n    });\n\n    it('should handle different user names correctly', 0, () => {\n      const name = 'anotheruser';\n      const displayName = 'Another User';\n      const result = getRegRequest(name, displayName);\n      expect(result.username).assertEqual('anotheruser');\n      expect(result.displayName).assertEqual('Another User');\n    });\n  });\n  \n}",
      "model_output": "import {AdapterServerRequest, Fido2CredentialCreationOptions, AuthenticatorSelection} from '@kit.NetworkKit';\n\nexport function getRegRequest(name: string, displayName: string): AdapterServerRequest {\n  const authenticatorSelection: AuthenticatorSelection = {\n    userVerification: 'preferred',\n    residentKey: \"preferred\",\n    requireResidentKey: true,\n    authenticatorAttachment: 'platform'\n  };\n  const fidoOptions: Fido2CredentialCreationOptions = {\n    username: name,\n    displayName: displayName,\n    attestation: 'direct',\n    authenticatorSelection: authenticatorSelection\n  };\n  const result: AdapterServerRequest = {\n    username: name,\n    displayName: displayName,\n    fido2CredentialCreationOptions: JSON.stringify(fidoOptions)\n  };\n  return result;\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `getCameraProfile`. This function should search through an array of `CameraProfile` objects and return the one that matches a `target` profile based on format, width, and height. The implementation must include all necessary interface definitions for `CameraProfile` and its nested `size` object.",
      "code": "interface GeneratedTypeLiteralInterface_1 {\n  width: number;\n  height: number;\n}\n\nexport interface CameraProfile {\n  format: number;\n  size: GeneratedTypeLiteralInterface_1;\n}\n\nexport function getCameraProfile(profiles: Array<CameraProfile>, target: CameraProfile): CameraProfile | undefined {\n  const profile = profiles.find((p: CameraProfile) => {\n    return p.format === target.format && p.size.width === target.size.width &&\n      p.size.height === target.size.height;\n  });\n  return profile;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { getCameraProfile, CameraProfile } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('MyFunctions_GetCameraProfile_Test', () => {\n\n    const sampleProfiles: CameraProfile[] = [\n      { format: 1, size: { width: 640, height: 480 } },\n      { format: 2, size: { width: 1280, height: 720 } },\n      { format: 1, size: { width: 1920, height: 1080 } }\n    ];\n\n    it('should find and return the matching profile', 0, () => {\n      const target: CameraProfile = { format: 2, size: { width: 1280, height: 720 } };\n      const result = getCameraProfile(sampleProfiles, target);\n      expect(result).assertDeepEquals(target);\n    });\n\n    it('should return undefined if no profile matches', 0, () => {\n      const target: CameraProfile = { format: 3, size: { width: 800, height: 600 } };\n      const result = getCameraProfile(sampleProfiles, target);\n      expect(result).assertUndefined();\n    });\n\n    it('should return undefined when searching in an empty array', 0, () => {\n      const target: CameraProfile = { format: 1, size: { width: 640, height: 480 } };\n      const result = getCameraProfile([], target);\n      expect(result).assertUndefined();\n    });\n  });\n  \n}",
      "model_output": "import {size} from '@kit.ArkTS';\n\nexport interface CameraProfile {\n  format: number;\n  size: size;\n}\n\nexport function getCameraProfile(profiles: CameraProfile[], target: CameraProfile): CameraProfile | undefined {\n  return profiles.find(profile => \n    profile.format === target.format && \n    profile.size.width === target.size.width && \n    profile.size.height === target.size.height\n  );\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `hexToBytes`. This function should take a hexadecimal string as input and convert it into a `Uint8Array`.",
      "code": "export function hexToBytes(hex: string): Uint8Array {\n  let bytes: number[] = [];\n  let hexString = hex.length % 2 !== 0 ? '0' + hex : hex;\n  for (let c = 0; c < hexString.length; c += 2) {\n    bytes.push(parseInt(hexString.substring(c, c + 2), 16));\n  }\n  return new Uint8Array(bytes);\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { hexToBytes } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('MyFunctions_HexToBytes_Test', () => {\n\n    it('should convert a simple hex string to bytes', 0, () => {\n      const hex = '48656C6C6F';\n      const result = hexToBytes(hex);\n      const expected = new Uint8Array([72, 101, 108, 108, 111]);\n      expect(result).assertDeepEquals(expected);\n    });\n\n    it('should handle an empty string', 0, () => {\n      const hex = '';\n      const result = hexToBytes(hex);\n      const expected = new Uint8Array([]);\n      expect(result).assertDeepEquals(expected);\n    });\n\n    it('should handle a hex string with lowercase and uppercase letters', 0, () => {\n      const hex = 'aBcDeF0123';\n      const result = hexToBytes(hex);\n      const expected = new Uint8Array([171, 205, 239, 1, 35]);\n      expect(result).assertDeepEquals(expected);\n    });\n  });\n  \n}",
      "model_output": "import {hexToBytes} from '../main/ets/utils/MyFunctions';\n\nexport function hexToBytes(hex: string): Uint8Array {\n  const bytes = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < hex.length; i += 2) {\n    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n  }\n  return bytes;\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `stringToUint8Array`. This function should take a string as input and convert it into a `Uint8Array`, where each element is the character code of the corresponding character in the string.",
      "code": "export function stringToUint8Array(str: string): Uint8Array {\n  let arr: number[] = [];\n  for (let i = 0; i < str.length; ++i) {\n    arr.push(str.charCodeAt(i));\n  }\n  return new Uint8Array(arr);\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { stringToUint8Array } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('MyFunctions_StringToUint8Array_Test', () => {\n\n    it('should convert a simple ASCII string', 0, () => {\n      const str = 'Hello';\n      const result = stringToUint8Array(str);\n      const expected = new Uint8Array([72, 101, 108, 108, 111]);\n      expect(result).assertDeepEquals(expected);\n    });\n\n    it('should handle an empty string', 0, () => {\n      const str = '';\n      const result = stringToUint8Array(str);\n      const expected = new Uint8Array([]);\n      expect(result).assertDeepEquals(expected);\n    });\n\n    it('should convert a string with numbers and symbols', 0, () => {\n      const str = '123!@#';\n      const result = stringToUint8Array(str);\n      const expected = new Uint8Array([49, 50, 51, 33, 64, 35]);\n      expect(result).assertDeepEquals(expected);\n    });\n  });\n  \n}",
      "model_output": "import {util} from '@kit.ArkTS';\ntype Uint8Array = util.Uint8Array;\n\nexport function stringToUint8Array(str: string): Uint8Array {\n  const array = new Uint8Array(str.length);\n  for (let i = 0; i < str.length; i++) {\n    array[i] = str.charCodeAt(i);\n  }\n  return array;\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, implement a `ZipLibSource` class that acts as a data source for a string array. It should include methods to get the total count of items, get an item at a specific index, add an item at a specific index, and push an item to the end of the array. The implementation must include its `BasicDataSource` base class.",
      "code": "class BasicDataSource {\n  notifyDataAdd(index: number): void {}\n}\n\nexport class ZipLibSource extends BasicDataSource {\n  public fileData: Array<string>;\n\n  constructor(fileData: Array<string>) {\n    super();\n    this.fileData = fileData;\n  }\n\n  public totalCount(): number {\n    return this.fileData.length;\n  }\n\n  public getData(index: number): string {\n    return this.fileData[index];\n  }\n\n  public addData(index: number, data: string): void {\n    this.fileData.splice(index, 0, data);\n    this.notifyDataAdd(index);\n  }\n\n  public pushData(data: string): void {\n    this.fileData.push(data);\n    this.notifyDataAdd(this.fileData.length - 1);\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ZipLibSource } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('MyFunctions_ZipLibSource_Test', () => {\n\n    it('should correctly initialize with data', 0, () => {\n      const source = new ZipLibSource(['a', 'b', 'c']);\n      expect(source.totalCount()).assertEqual(3);\n      expect(source.getData(1)).assertEqual('b');\n    });\n\n    it('should add data at a specific index', 0, () => {\n      const source = new ZipLibSource(['a', 'c']);\n      source.addData(1, 'b');\n      expect(source.totalCount()).assertEqual(3);\n      expect(source.getData(1)).assertEqual('b');\n      expect(source.fileData).assertDeepEquals(['a', 'b', 'c']);\n    });\n\n    it('should push data to the end of the array', 0, () => {\n      const source = new ZipLibSource(['a', 'b']);\n      source.pushData('c');\n      expect(source.totalCount()).assertEqual(3);\n      expect(source.getData(2)).assertEqual('c');\n    });\n  });\n  \n}",
      "model_output": "import {BasicDataSource} from '@kit.ArkData';\n\nexport class ZipLibSource extends BasicDataSource<string> {\n  constructor(data: string[]) {\n    super(data);\n  }\n\n  totalCount(): number {\n    return this.fileData.length;\n  }\n\n  getData(index: number): string {\n    return this.fileData[index];\n  }\n\n  addData(index: number, data: string): void {\n    this.fileData.splice(index, 0, data);\n  }\n\n  pushData(data: string): void {\n    this.fileData.push(data);\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `setWeather`. This function should take an optional `CustomerWeatherType` enum and return a corresponding `WeatherInfo` object from a predefined data map. If no type is provided, it should return an empty object. The implementation must include all necessary interface and enum definitions.",
      "code": "export interface WeatherInfo {\n  weatherType?: number;\n  highTemperature?: number;\n  lowTemperature?: number;\n}\n\nexport enum CustomerWeatherType {\n  SUNNY = 'SUNNY',\n  CLOUDY = 'CLOUDY'\n}\n\nexport const WEATHER_SAMPLE_DATA: Record<string, WeatherInfo> = {\n  [CustomerWeatherType.SUNNY]: {\n    weatherType: 1,\n    highTemperature: 33,\n    lowTemperature: 28\n  },\n  [CustomerWeatherType.CLOUDY]: {\n    weatherType: 2,\n    highTemperature: 27,\n    lowTemperature: 20\n  }\n};\n\nexport function setWeather(weatherType?: CustomerWeatherType): WeatherInfo {\n  if (weatherType) {\n    return WEATHER_SAMPLE_DATA[weatherType];\n  }\n  return {};\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { setWeather, CustomerWeatherType, WeatherInfo } from '../main/ets/utils/MyFunctions';\n\ninterface GeneratedObjectLiteralInterface_1 {}\n\nexport default function functionTest() {\n\n  describe('MyFunctions_SetWeather_Test', () => {\n\n    it('should return the correct weather info for SUNNY', 0, () => {\n      const result = setWeather(CustomerWeatherType.SUNNY);\n      const expected: WeatherInfo = {\n        weatherType: 1,\n        highTemperature: 33,\n        lowTemperature: 28\n      };\n      expect(result).assertDeepEquals(expected);\n    });\n\n    it('should return the correct weather info for CLOUDY', 0, () => {\n      const result = setWeather(CustomerWeatherType.CLOUDY);\n      const expected: WeatherInfo = {\n        weatherType: 2,\n        highTemperature: 27,\n        lowTemperature: 20\n      };\n      expect(result).assertDeepEquals(expected);\n    });\n\n    it('should return an empty object when no weatherType is provided', 0, () => {\n      const result = setWeather();\n      const expected: GeneratedObjectLiteralInterface_1 = {};\n      expect(result).assertDeepEquals(expected);\n    });\n  });\n  \n}",
      "model_output": "import {CustomerWeatherType, WeatherInfo} from '../main/ets/utils/MyFunctions';\n\nexport function setWeather(weatherType?: CustomerWeatherType): WeatherInfo {\n  const weatherMap: Record<CustomerWeatherType, WeatherInfo> = {\n    [CustomerWeatherType.SUNNY]: {\n      weatherType: 1,\n      highTemperature: 33,\n      lowTemperature: 28\n    },\n    [CustomerWeatherType.CLOUDY]: {\n      weatherType: 2,\n      highTemperature: 27,\n      lowTemperature: 20\n    }\n  };\n  \n  if (weatherType!== undefined) {\n    return weatherMap[weatherType];\n  }\n  \n  return {} as WeatherInfo;\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `getDefaultGuardStrategy`. This function should create and return a default `GuardStrategy` object with predefined values. The implementation must include all necessary interface and enum definitions for the `GuardStrategy` object and its nested properties.",
      "code": "export enum TimeStrategyType {\n  START_END_TIME_TYPE = 0,\n}\n\nexport enum RestrictionType {\n  BLOCKLIST_TYPE = 0,\n}\n\nexport interface TimeStrategy {\n  type: TimeStrategyType;\n}\n\nexport interface AppInfo {\n  appTokens: string[];\n}\n\nexport interface GuardStrategy {\n  name: string;\n  timeStrategy: TimeStrategy;\n  appInfo: AppInfo;\n  appRestrictionType: RestrictionType;\n}\n\nexport function getDefaultGuardStrategy(): GuardStrategy {\n  let guardStrategy: GuardStrategy = {\n    name: '',\n    timeStrategy: { type: TimeStrategyType.START_END_TIME_TYPE },\n    appInfo: { appTokens: [] },\n    appRestrictionType: RestrictionType.BLOCKLIST_TYPE\n  }\n  return guardStrategy;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport {\n  getDefaultGuardStrategy,\n  GuardStrategy,\n  TimeStrategyType,\n  RestrictionType\n} from '../main/ets/utils/MyFunctions';\n\ninterface GeneratedObjectLiteralInterface_1 {}\n\nexport default function functionTest() {\n\n\n  describe('MyFunctions_GetDefaultGuardStrategy_Test', () => {\n\n    it('should return a default guard strategy object with correct structure and values', 0, () => {\n      const result = getDefaultGuardStrategy();\n\n      const expected: GuardStrategy = {\n        name: '',\n        timeStrategy: { type: TimeStrategyType.START_END_TIME_TYPE },\n        appInfo: { appTokens: [] },\n        appRestrictionType: RestrictionType.BLOCKLIST_TYPE\n      };\n\n      expect(result).assertDeepEquals(expected);\n    });\n  });\n  \n}",
      "model_output": "import {getDefaultGuardStrategy} from '../main/ets/utils/MyFunctions';\n\nexport class GuardStrategy {\n  name: string = '';\n  timeStrategy: { type: TimeStrategyType } = { type: TimeStrategyType.START_END_TIME_TYPE };\n  appInfo: { appTokens: string[] } = { appTokens: [] };\n  appRestrictionType: RestrictionType = RestrictionType.BLOCKLIST_TYPE;\n}\n\nexport enum TimeStrategyType {\n  START_END_TIME_TYPE = 'START_END_TIME_TYPE'\n}\n\nexport enum RestrictionType {\n  BLOCKLIST_TYPE = 'BLOCKLIST_TYPE'\n}\n\nexport function getDefaultGuardStrategy(): GuardStrategy {\n  return new GuardStrategy();\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `getFontSize` that calculates the final font size based on a base size, a maximum scaling factor, and the system's current font scaling. The function should handle cases where the system scaling is invalid (null or <= 0) by returning the base size, and cases where the system scaling exceeds the maximum allowed by using the maximum scaling factor. It must also return the font size as a string with the 'vp' unit appended.",
      "code": "export interface MockContext {\n  config: {\n    fontSizeScale: number | null;\n  };\n}\n\nexport function getFontSize(fontsBaseSize: number, maxFontScale: number, context: MockContext): string {\n  const sysFontSizeScale = context.config.fontSizeScale;\n  if (!sysFontSizeScale || sysFontSizeScale <= 0) {\n    return `${fontsBaseSize}vp`;\n  }\n\n  if (sysFontSizeScale > maxFontScale) {\n    return `${fontsBaseSize * maxFontScale}vp`;\n  } else {\n    return `${fontsBaseSize * sysFontSizeScale}vp`;\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { getFontSize, MockContext } from '../main/ets/utils/MyFunctions';\n\ninterface GeneratedObjectLiteralInterface_1 {}\n\nexport default function functionTest() {\n\n\n  describe('MyFunctions_GetFontSize_Test', () => {\n\n    it('should return base font size if system scale is null or invalid', 0, () => {\n      const mockContext: MockContext = { config: { fontSizeScale: null } };\n      const result = getFontSize(16, 1.75, mockContext);\n      expect(result).assertEqual('16vp');\n    });\n\n    it('should use max font scale if system scale exceeds it', 0, () => {\n      const mockContext: MockContext = { config: { fontSizeScale: 2.0 } };\n      const result = getFontSize(10, 1.5, mockContext);\n      expect(result).assertEqual('15vp');\n    });\n\n    it('should use system font scale if it is within the valid range', 0, () => {\n      const mockContext: MockContext = { config: { fontSizeScale: 1.25 } };\n      const result = getFontSize(20, 1.5, mockContext);\n      expect(result).assertEqual('25vp');\n    });\n  });\n}",
      "model_output": "import {VpUnit} from '@kit.TestKit';\n\nexport function getFontSize(baseSize: number, maxScale: number, context: {config: {fontSizeScale: number | null}}): string {\n  if (context.config.fontSizeScale === null || context.config.fontSizeScale <= 0) {\n    return `${baseSize}vp`;\n  }\n  const scaledSize = baseSize * Math.min(context.config.fontSizeScale, maxScale);\n  return `${scaledSize}vp`;\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `getImagePath` that takes a file path prefix and a numeric index. The function should format the index to two digits (padding with a leading zero if it's a single digit), and then return a complete file path with a `.webp` extension.",
      "code": "export function getImagePath(rawfilePrefix: string, index: number): string {\n  return `${rawfilePrefix}${index.toString().padStart(2, '0')}.webp`;\n}",
      "test": "import { describe, it, expect, beforeEach } from '@ohos/hypium';\nimport { getImagePath } from '../main/ets/utils/MyFunctions';\n\ninterface GeneratedObjectLiteralInterface_1 {}\n\nexport default function functionTest() {\n\n\n  describe('ImageUtils_getImagePath_Test', () => {\n\n    it('should pad single-digit index with a leading zero', 0, () => {\n      const rawfilePrefix = 'assets/img';\n      const index = 5;\n      const result = getImagePath(rawfilePrefix, index);\n      expect(result).assertEqual('assets/img05.webp');\n    });\n\n    it('should not pad two-digit index', 0, () => {\n      const rawfilePrefix = 'assets/img';\n      const index = 12;\n      const result = getImagePath(rawfilePrefix, index);\n      expect(result).assertEqual('assets/img12.webp');\n    });\n\n    it('should handle zero index correctly', 0, () => {\n      const rawfilePrefix = 'assets/img';\n      const index = 0;\n      const result = getImagePath(rawfilePrefix, index);\n      expect(result).assertEqual('assets/img00.webp');\n    });\n\n    it('should work with different prefixes', 0, () => {\n      const rawfilePrefix = 'another_path/photo';\n      const index = 9;\n      const result = getImagePath(rawfilePrefix, index);\n      expect(result).assertEqual('another_path/photo09.webp');\n    });\n  });\n\n}",
      "model_output": "import {image} from '@kit.ArkTS';\ntype ImagePathOptions = image.ImagePathOptions;\n\nexport function getImagePath(rawfilePrefix: string, index: number): string {\n  const paddedIndex = index < 10? `0${index}` : `${index}`;\n  return `${rawfilePrefix}${paddedIndex}.webp`;\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `getImageSrc` that returns a specific image resource path based on two numeric input values representing selection mode and preview mode. Provide a single test file that includes unit tests for the function.",
      "code": "export function getImageSrc(selectionMode: number, sharePreviewMode: number): string {\n  switch (selectionMode) {\n    case 0:\n      if (sharePreviewMode === 0) {\n        return 'app.media.share_preview_00';\n      } else {\n        return 'app.media.share_preview_01';\n      }\n    case 1:\n      if (sharePreviewMode === 0) {\n        return 'app.media.share_preview_10';\n      } else {\n        return 'app.media.share_preview_11';\n      }\n    default:\n      return 'app.media.share_preview_00';\n  }\n}",
      "test": "import { describe, it, expect, beforeEach } from '@ohos/hypium';\nimport { getImageSrc } from '../main/ets/utils/MyFunctions';\n\ninterface GeneratedObjectLiteralInterface_1 {}\n\ninterface GeneratedObjectLiteralInterface_3 {\n  DEFAULT: number;\n  DETAIL: number;\n}\n\ninterface GeneratedObjectLiteralInterface_2 {\n  SINGLE: number;\n  BATCH: number;\n}\n\ninterface GeneratedObjectLiteralInterface_4 {\n  SelectionMode: GeneratedObjectLiteralInterface_2;\n  SharePreviewMode: GeneratedObjectLiteralInterface_3;\n}\n\nconst mockSystemShare: GeneratedObjectLiteralInterface_4 = {\n  SelectionMode: ({\n    SINGLE: 0,\n    BATCH: 1\n  } as GeneratedObjectLiteralInterface_2),\n  SharePreviewMode: ({\n    DEFAULT: 0,\n    DETAIL: 1\n  } as GeneratedObjectLiteralInterface_3)\n};\nexport default function functionTest() {\n\n\n  describe('getImageSrc_Test', () => {\n\n    it('should return 00 when single selection and default preview', 0, () => {\n      const result = getImageSrc(mockSystemShare.SelectionMode.SINGLE, mockSystemShare.SharePreviewMode.DEFAULT);\n      expect(result).assertEqual('app.media.share_preview_00');\n    });\n\n    it('should return 01 when single selection and detail preview', 0, () => {\n      const result = getImageSrc(mockSystemShare.SelectionMode.SINGLE, mockSystemShare.SharePreviewMode.DETAIL);\n      expect(result).assertEqual('app.media.share_preview_01');\n    });\n\n    it('should return 10 when batch selection and default preview', 0, () => {\n      const result = getImageSrc(mockSystemShare.SelectionMode.BATCH, mockSystemShare.SharePreviewMode.DEFAULT);\n      expect(result).assertEqual('app.media.share_preview_10');\n    });\n\n    it('should return 11 when batch selection and detail preview', 0, () => {\n      const result = getImageSrc(mockSystemShare.SelectionMode.BATCH, mockSystemShare.SharePreviewMode.DETAIL);\n      expect(result).assertEqual('app.media.share_preview_11');\n    });\n\n    it('should return default image for invalid selection mode', 0, () => {\n      const result = getImageSrc(99, mockSystemShare.SharePreviewMode.DEFAULT);\n      expect(result).assertEqual('app.media.share_preview_00');\n    });\n  });\n\n}",
      "model_output": "import {Image} from '@kit.ArkUI';\n\nexport function getImageSrc(selectionMode: number, previewMode: number): string {\n  switch (selectionMode) {\n    case 0:\n      return previewMode === 0? 'app.media.share_preview_00' : 'app.media.share_preview_01';\n    case 1:\n      return previewMode === 0? 'app.media.share_preview_10' : 'app.media.share_preview_11';\n    default:\n      return 'app.media.share_preview_00';\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `getSupportedAudioFormats` that returns an array of supported audio format strings for audio processing applications. The function should return a predefined list of common audio formats including AAC, M4A, MP3, WAV, and AMR. Provide a single test file that includes unit tests for the function.",
      "code": "export function getSupportedAudioFormats(): string[] {\n  return ['aac', 'm4a', 'mp3', 'wav', 'amr'];\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { getSupportedAudioFormats } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('getSupportedAudioFormats_Test', () => {\n\n    it('should return array with 5 formats', 0, () => {\n      const result = getSupportedAudioFormats();\n      expect(result.length).assertEqual(5);\n    });\n\n    it('should include aac format', 0, () => {\n      const result = getSupportedAudioFormats();\n      expect(result.includes('aac')).assertEqual(true);\n    });\n\n    it('should include m4a format', 0, () => {\n      const result = getSupportedAudioFormats();\n      expect(result.includes('m4a')).assertEqual(true);\n    });\n\n    it('should include mp3 format', 0, () => {\n      const result = getSupportedAudioFormats();\n      expect(result.includes('mp3')).assertEqual(true);\n    });\n\n    it('should include wav format', 0, () => {\n      const result = getSupportedAudioFormats();\n      expect(result.includes('wav')).assertEqual(true);\n    });\n\n    it('should include amr format', 0, () => {\n      const result = getSupportedAudioFormats();\n      expect(result.includes('amr')).assertEqual(true);\n    });\n\n    it('should return correct format array', 0, () => {\n      const result = getSupportedAudioFormats();\n      const expected = ['aac', 'm4a', 'mp3', 'wav', 'amr'];\n      expect(JSON.stringify(result)).assertEqual(JSON.stringify(expected));\n    });\n\n    it('should return immutable array reference', 0, () => {\n      const result1 = getSupportedAudioFormats();\n      const result2 = getSupportedAudioFormats();\n      expect(JSON.stringify(result1)).assertEqual(JSON.stringify(result2));\n    });\n  });\n\n}",
      "model_output": "import {audio} from '@kit.AudioKit';\ntype AudioFormat = audio.AudioFormat;\n\nexport function getSupportedAudioFormats(): Array<string> {\n  return [\n    'aac',\n   'm4a',\n   'mp3',\n    'wav',\n    'amr'\n  ];\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `handleAudioFormatChange` that processes format change events from TextPicker components. The function should accept either a string or string array value and return a string. If the input is an array, return the first element; if empty array or falsy string, return the default audio format 'aac'. Also provide a helper function `getDefaultAudioFormat` that returns 'aac'. Provide a single test file that includes unit tests for the main function.",
      "code": "export function getDefaultAudioFormat(): string {\n  return 'aac';\n}\n\nexport function handleAudioFormatChange(value: string | string[]): string {\n  if (Array.isArray(value)) {\n    return value.length > 0 ? value[0] : getDefaultAudioFormat();\n  }\n  return value || getDefaultAudioFormat();\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { handleAudioFormatChange } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('handleAudioFormatChange_Test', () => {\n\n    it('should return string input directly', 0, () => {\n      const result = handleAudioFormatChange('mp3');\n      expect(result).assertEqual('mp3');\n    });\n\n    it('should return first element for array input', 0, () => {\n      const result = handleAudioFormatChange(['wav', 'mp3']);\n      expect(result).assertEqual('wav');\n    });\n\n    it('should return default format for empty array', 0, () => {\n      const result = handleAudioFormatChange([]);\n      expect(result).assertEqual('aac');\n    });\n\n    it('should return default format for empty string', 0, () => {\n      const result = handleAudioFormatChange('');\n      expect(result).assertEqual('aac');\n    });\n\n    it('should handle single element array', 0, () => {\n      const result = handleAudioFormatChange(['m4a']);\n      expect(result).assertEqual('m4a');\n    });\n\n    it('should return default for null string', 0, () => {\n      const result = handleAudioFormatChange(null as any);\n      expect(result).assertEqual('aac');\n    });\n\n    it('should return default for undefined string', 0, () => {\n      const result = handleAudioFormatChange(undefined as any);\n      expect(result).assertEqual('aac');\n    });\n\n    it('should handle multiple format array correctly', 0, () => {\n      const result = handleAudioFormatChange(['aac', 'm4a', 'mp3']);\n      expect(result).assertEqual('aac');\n    });\n  });\n\n}",
      "model_output": "import {audio} from '@kit.AudioKit';\n\nexport function handleAudioFormatChange(value: string | string[]): string {\n  if (Array.isArray(value)) {\n    return value[0] || 'aac';\n  } else {\n    return value || 'aac';\n  }\n}\n\nexport function getDefaultAudioFormat(): string {\n  return 'aac';\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `isValidAudioFormat` that validates whether a given audio format string is supported. The function should accept a string parameter and return a boolean value. It should return true for supported formats (aac, m4a, mp3, wav, amr) regardless of case, and false for unsupported formats, empty strings, or invalid inputs. Also provide a helper function `getSupportedAudioFormats` that returns the list of supported formats. Provide a single test file that includes unit tests for the validation function.",
      "code": "export function getSupportedAudioFormats(): string[] {\n  return ['aac', 'm4a', 'mp3', 'wav', 'amr'];\n}\n\nexport function isValidAudioFormat(format: string): boolean {\n  if (!format || typeof format !== 'string') {\n    return false;\n  }\n  return getSupportedAudioFormats().includes(format.toLowerCase());\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { isValidAudioFormat } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('isValidAudioFormat_Test', () => {\n\n    it('should return true for valid format aac', 0, () => {\n      const result = isValidAudioFormat('aac');\n      expect(result).assertEqual(true);\n    });\n\n    it('should return true for uppercase format AAC', 0, () => {\n      const result = isValidAudioFormat('AAC');\n      expect(result).assertEqual(true);\n    });\n\n    it('should return true for mixed case Mp3', 0, () => {\n      const result = isValidAudioFormat('Mp3');\n      expect(result).assertEqual(true);\n    });\n\n    it('should return false for invalid format flac', 0, () => {\n      const result = isValidAudioFormat('flac');\n      expect(result).assertEqual(false);\n    });\n\n    it('should return false for empty string', 0, () => {\n      const result = isValidAudioFormat('');\n      expect(result).assertEqual(false);\n    });\n\n    it('should return true for valid format m4a', 0, () => {\n      const result = isValidAudioFormat('m4a');\n      expect(result).assertEqual(true);\n    });\n\n    it('should return true for valid format wav', 0, () => {\n      const result = isValidAudioFormat('wav');\n      expect(result).assertEqual(true);\n    });\n\n    it('should return true for valid format amr', 0, () => {\n      const result = isValidAudioFormat('amr');\n      expect(result).assertEqual(true);\n    });\n\n    it('should return false for null input', 0, () => {\n      const result = isValidAudioFormat(null as any);\n      expect(result).assertEqual(false);\n    });\n\n    it('should return false for undefined input', 0, () => {\n      const result = isValidAudioFormat(undefined as any);\n      expect(result).assertEqual(false);\n    });\n  });\n\n}",
      "model_output": "import {audio} from '@kit.AudioKit';\n\nexport function isValidAudioFormat(format: string): boolean {\n  const supportedFormats = audio.AudioFormat.getSupportedFormats();\n  return supportedFormats.includes(format.toLowerCase());\n}\n\nexport function getSupportedAudioFormats(): string[] {\n  return audio.AudioFormat.getSupportedFormats();\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `createSleepPromise` that creates a Promise-based delay function for game development timing control. The function should accept a number of milliseconds and return a Promise<void> that resolves after the specified delay using setTimeout. This is commonly used in game loops, animation timing, and sequential operations. Provide a single test file that includes unit tests for the function.",
      "code": "export function createSleepPromise(ms: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { createSleepPromise } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('createSleepPromise_Test', () => {\n\n    it('should resolve after specified milliseconds', 0, async () => {\n      const startTime = Date.now();\n      await createSleepPromise(100);\n      const endTime = Date.now();\n      const elapsed = endTime - startTime;\n      expect(elapsed >= 90).assertEqual(true);\n    });\n\n    it('should return a Promise', 0, () => {\n      const result = createSleepPromise(50);\n      expect(result instanceof Promise).assertEqual(true);\n    });\n\n    it('should handle zero milliseconds', 0, async () => {\n      const startTime = Date.now();\n      await createSleepPromise(0);\n      const endTime = Date.now();\n      const elapsed = endTime - startTime;\n      expect(elapsed >= 0).assertEqual(true);\n    });\n\n    it('should handle small delays', 0, async () => {\n      const startTime = Date.now();\n      await createSleepPromise(1);\n      const endTime = Date.now();\n      const elapsed = endTime - startTime;\n      expect(elapsed >= 0).assertEqual(true);\n    });\n\n    it('should resolve without error', 0, async () => {\n      let resolved = false;\n      await createSleepPromise(10).then(() => {\n        resolved = true;\n      });\n      expect(resolved).assertEqual(true);\n    });\n  });\n\n}",
      "model_output": "import {taskpool} from '@kit.ArkTS';\n\nexport function createSleepPromise(millis: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, millis);\n  });\n}",
      "test_passed": true
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `addProgressListener` that manages progress callback listeners for game development. The function should accept an array of ProgressCallback functions and a new callback to add, returning a new array with the added callback without modifying the original array. Also define the ProgressCallback type as a function that takes an object parameter and returns void. This is commonly used for tracking game loading progress, level completion, or other progressive operations. Provide a single test file that includes unit tests for the function.",
      "code": "export type ProgressCallback = (progress: object) => void;\n\nexport function addProgressListener(callbacks: ProgressCallback[], callback: ProgressCallback): ProgressCallback[] {\n  return [...callbacks, callback];\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { addProgressListener, ProgressCallback } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('addProgressListener_Test', () => {\n\n    it('should add callback to empty array', 0, () => {\n      const mockCallback: ProgressCallback = (progress) => {};\n      const result = addProgressListener([], mockCallback);\n      expect(result.length).assertEqual(1);\n    });\n\n    it('should add callback to existing array', 0, () => {\n      const mockCallback1: ProgressCallback = (progress) => {};\n      const mockCallback2: ProgressCallback = (progress) => {};\n      const initialCallbacks = [mockCallback1];\n      const result = addProgressListener(initialCallbacks, mockCallback2);\n      expect(result.length).assertEqual(2);\n    });\n\n    it('should not modify original array', 0, () => {\n      const mockCallback1: ProgressCallback = (progress) => {};\n      const mockCallback2: ProgressCallback = (progress) => {};\n      const initialCallbacks = [mockCallback1];\n      const originalLength = initialCallbacks.length;\n      addProgressListener(initialCallbacks, mockCallback2);\n      expect(initialCallbacks.length).assertEqual(originalLength);\n    });\n\n    it('should return new array instance', 0, () => {\n      const mockCallback1: ProgressCallback = (progress) => {};\n      const mockCallback2: ProgressCallback = (progress) => {};\n      const initialCallbacks = [mockCallback1];\n      const result = addProgressListener(initialCallbacks, mockCallback2);\n      expect(result !== initialCallbacks).assertEqual(true);\n    });\n\n    it('should preserve callback order', 0, () => {\n      const mockCallback1: ProgressCallback = (progress) => {};\n      const mockCallback2: ProgressCallback = (progress) => {};\n      const mockCallback3: ProgressCallback = (progress) => {};\n      const initialCallbacks = [mockCallback1, mockCallback2];\n      const result = addProgressListener(initialCallbacks, mockCallback3);\n      expect(result[0]).assertEqual(mockCallback1);\n      expect(result[1]).assertEqual(mockCallback2);\n      expect(result[2]).assertEqual(mockCallback3);\n    });\n  });\n\n}",
      "model_output": "import {ProgressCallback} from '@kit.ArkTS';\n\nexport function addProgressListener(callbacks: ProgressCallback[], newCallback: ProgressCallback): ProgressCallback[] {\n  return [...callbacks, newCallback];\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `triggerProgressCallbacks` that executes all progress callback functions in an array with a given progress object for game development. The function should accept an array of ProgressCallback functions and a progress object, then call each callback with the progress object in sequence. Also define the ProgressCallback type as a function that takes an object parameter and returns void. This is commonly used for notifying multiple listeners about game progress updates, loading states, or achievement progress. Provide a single test file that includes unit tests for the function.",
      "code": "export type ProgressCallback = (progress: object) => void;\n\nexport function triggerProgressCallbacks(callbacks: ProgressCallback[], progressObject: object): void {\n  callbacks.forEach(callback => {\n    callback(progressObject);\n  });\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ProgressCallback, triggerProgressCallbacks } from '../main/ets/utils/MyFunctions';\n\ninterface GeneratedObjectLiteralInterface_4 {\n  progress: number;\n}\n\ninterface GeneratedObjectLiteralInterface_1 {\n  progress: number;\n}\n\ninterface GeneratedObjectLiteralInterface_2 {\n  progress: number;\n  status: string;\n}\n\ninterface GeneratedObjectLiteralInterface_3 {\n  progress: number;\n}\n\ninterface GeneratedObjectLiteralInterface_5 {\n  progress: number;\n}\n\nexport default function functionTest() {\n\n  describe('triggerProgressCallbacks_Test', () => {\n\n    it('should call all callbacks with progress object', 0, () => {\n      let callCount = 0;\n      const mockCallback1: ProgressCallback = (progress) => { callCount++; };\n      const mockCallback2: ProgressCallback = (progress) => { callCount++; };\n      const callbacks = [mockCallback1, mockCallback2];\n      const progressObj: GeneratedObjectLiteralInterface_1 = { progress: 50 };\n\n      triggerProgressCallbacks(callbacks, progressObj);\n      expect(callCount).assertEqual(2);\n    });\n\n    it('should pass correct progress object to callbacks', 0, () => {\n      let receivedProgress: object | null = null;\n      const mockCallback: ProgressCallback = (progress) => {\n        receivedProgress = progress;\n      };\n      const progressObj: GeneratedObjectLiteralInterface_2 = { progress: 75, status: 'loading' };\n\n      triggerProgressCallbacks([mockCallback], progressObj);\n      expect(JSON.stringify(receivedProgress)).assertEqual(JSON.stringify(progressObj));\n    });\n\n    it('should handle empty callbacks array', 0, () => {\n      const progressObj: GeneratedObjectLiteralInterface_3 = { progress: 100 };\n\n      triggerProgressCallbacks([], progressObj);\n      expect(true).assertEqual(true);\n    });\n\n    it('should call callbacks in order', 0, () => {\n      const callOrder: number[] = [];\n      const mockCallback1: ProgressCallback = (progress) => { callOrder.push(1); };\n      const mockCallback2: ProgressCallback = (progress) => { callOrder.push(2); };\n      const mockCallback3: ProgressCallback = (progress) => { callOrder.push(3); };\n      const callbacks = [mockCallback1, mockCallback2, mockCallback3];\n      const progressObj: GeneratedObjectLiteralInterface_4 = { progress: 25 };\n\n      triggerProgressCallbacks(callbacks, progressObj);\n      expect(JSON.stringify(callOrder)).assertEqual(JSON.stringify([1, 2, 3]));\n    });\n\n    it('should handle single callback', 0, () => {\n      let called = false;\n      const mockCallback: ProgressCallback = (progress) => { called = true; };\n      const progressObj: GeneratedObjectLiteralInterface_5 = { progress: 0 };\n\n      triggerProgressCallbacks([mockCallback], progressObj);\n      expect(called).assertEqual(true);\n    });\n  });\n\n}",
      "model_output": "import {ProgressCallback} from '@kit.ArkTS';\n\nexport function triggerProgressCallbacks(callbacks: ProgressCallback[], progressObj: object): void {\n  callbacks.forEach((callback) => {\n    callback(progressObj);\n  });\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named validateProgressCallbackthat validates if a given parameter is a function. This utility function is useful in game development for ensuring callback parameters are valid before execution, preventing runtime errors when handling progress updates, loading states, or achievement notifications.",
      "code": "export function validateProgressCallback(callback: Function | object | string | number | boolean | null | undefined): boolean {\n return typeof callback === 'function';\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { validateProgressCallback } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n describe('validateProgressCallback_Test', () => {\n\n it('should return true for valid function', 0, () => {\n const mockFunction = () => {};\n const result = validateProgressCallback(mockFunction);\n expect(result).assertEqual(true);\n });\n\n it('should return true for arrow function', 0, () => {\n const arrowFunction = (progress: object) => {};\n const result = validateProgressCallback(arrowFunction);\n expect(result).assert极(true);\n });\n\n it('should return false for string', 0, () => {\n const result = validateProgressCallback('not a function');\n expect(result).assertEqual(false);\n });\n\n it('should return false for number', 0, () => {\n const result = validateProgressCallback(123);\n expect极(result).assertEqual(false);\n });\n\n it('should return false for null', 0, () => {\n const result = validateProgressCallback(null);\n expect(result).assertEqual(false);\n });\n\n it('should return false for undefined', 0, () => {\n const result = validateProgressCallback(undefined);极\n expect(result).assertEqual(false);\n });\n\n it('should return false for array', 0, () => {\n const result = validateProgressCallback([]);\n expect(result).assertEqual(false);\n });\n });\n}",
      "model_output": "import {validateProgressCallback} from '../main/ets/utils/MyFunctions';\n\nexport function validateProgressCallback(callback: (progress: object) => void): boolean {\n  return typeof callback === 'function';\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named validateInterval that validates if a given parameter is a positive number. This utility function is essential in game development for ensuring time intervals, animation durations, and delay parameters are valid positive numbers before usage in game loops, timers, or animation systems.",
      "code": "export function validateInterval(interval: number): boolean {\n  return typeof interval === 'number' && interval > 0;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { validateInterval } from '../main/ets/utils/MyFunctions';\n\nexport default function functionTest() {\n\n  describe('validateInterval_Test', () => {\n\n    it('should return true for positive integer', 0, () => {\n      const result = validateInterval(1000);\n      expect(result).assertEqual(true);\n    });\n\n    it('should return true for small positive number', 0, () => {\n      const result = validateInterval(0.1);\n      expect(result极).assertEqual(true);\n    });\n\n    it('should return true for large positive number', 0, () => {\n      const result = validateInterval(999999);\n      expect(result).assertEqual(true);\n    });\n\n    it('should return false for zero', 0, () => {\n      const result = validateInterval(极0);\n      expect(result).assertEqual(false);\n    });\n\n    it('should return false for negative number', 0, () => {\n      const result = validateInterval(-100);\n      expect(result).assertEqual(false);\n    });\n\n    it('should return false for NaN', 0, () => {\n      const result = validateInterval(NaN);\n      expect(result).assertEqual(false);\n    });\n\n    it('should return false for Infinity', 0, () => {\n      const result = validateInterval(Infinity);\n      expect(result).assertEqual(false);\n    });\n  });\n}",
      "model_output": "import {validateInterval} from '../main/ets/utils/MyFunctions';\n\nexport function validateInterval(interval: number): boolean {\n  return interval > 0 &&!isNaN(interval) && isFinite(interval);\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named isValidContextthat validates if a given ESObject parameter is a non-null object. This utility function is essential in game development for ensuring game contexts, scene objects, and component instances are valid objects before usage in game logic, rendering, or event handling.",
      "code": "export function isValidContext(context: ESObject): boolean {\n return context !== null && context !== undefined && typeof context === 'object';\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { isValidContext } from '../main/ets/utils/MyFunctions';\n\ninterface GeneratedObjectLiteralInterface_1 {\n name: string;\n}\n\ninterface GeneratedObjectLiteralInterface_2 {}\n\ninterface Generated极ObjectLiteralInterface_3 {\n nested: boolean;\n}\n\ninterface GeneratedObjectLiteralInterface_4 {\n id: number;\n name: string;\n data: GeneratedObjectLiteralInterface_3;\n}\n\nexport default function functionTest() {\n\n describe('isValidContext_Test', () => {\n\n it('should return true for valid object', 0, () => {\n const context: GeneratedObjectLiteralInterface_1 = { name: 'test' };\n const result = isValidContext(context);\n expect(result).assertEqual(true);\n });\n\n it('should return true for empty object', 0, () => {\n const context: GeneratedObjectLiteralInterface_2 = {};\n const result = isValidContext(context);\n expect(result).assertEqual(true);极\n });\n\n it('should return true for complex object', 0, () => {\n const context: GeneratedObjectLiteralInterface_4 = { id: 1, name: 'test', data: ({ nested: true } as GeneratedObjectLiteralInterface_3) };\n const result = isValidContext(context);\nexpect(result).assertEqual(true);\n });\n\n it('should return false for null', 0, () => {\n const result = isValidContext(null);\n expect(result).assertEqual(false);\n });\n\n it('should return false for undefined', 0, () => {\n const result = isValidContext(undefined);\n expect(result).assertEqual(false);\n });\n\n it('should return false for string', 0, () => {\n const result = isValidContext('context');\n expect(result).assertEqual(false);\n });\n\n it('should return false for number', 0, () => {\n const result = isValidContext(123);\n expect(result).assertEqual(false);\n });\n\n it('should return false for boolean', 0, () => {\n const result = isValidContext(true);\n expect(result).assertEqual(false);\n });\n\n it('should return true for array object', 0, () => {\n const result = isValidContext([1, 2, 3]);\n expect(result).assertEqual(true);\n });\n });\n}",
      "model_output": "import {ESObject} from '@kit.ArkTS';\n\nexport function isValidContext(context: ESObject): boolean {\n  return context!== null && typeof context === 'object';\n}",
      "test_passed": false
    },
    {
      "instruction": "Given an integer n and a 2D number array matrix along with an integer n representing the number of players, write a function calculatePossibleWinners using ArkTS code that returns the count of players who could still possibly be the final winner. In the matrix, matrix[i][j] === 0 means player i lost to player j.",
      "code": "export  function calculatePossibleWinners(matrix: number[][], n: number): number {\n  let dp: boolean[] = new Array(n).fill(true);\n  for (let k = 0; k < n; k++) {\n    let loserIndex = (k + 1) % n;\n    if (matrix[k][loserIndex] === 0) {\n      dp[k] = false;\n    }\n  }\n  let possibleWinners = dp.filter(val => val).length;\n  return possibleWinners;\n}",
      "test": "import {calculatePossibleWinners} from '../main/ets/function/fun2';\nimport { describe, it, expect } from '@ohos/hypium';\nexport default  function calculatePossibleWinnersTest() {\n  describe('calculatePossibleWinners', () => {\n    it('test1 - 2x2 matrix with clear winner', 0 ,() => {\n      const matrix = [\n        [1, 0], // Person 0 beats person 1\n        [1, 1]  // Person 1 beats person 0 (but this case shouldn't occur in reality)\n      ];\n      const n = 2;\n      const result = calculatePossibleWinners(matrix, n);\n      expect(result).assertEqual(1); // Only one possible winner\n    });\n\n    it('test2 - 3x3 matrix with multiple possible winners', 0,() => {\n      const matrix = [\n        [1, 0, 1], // Person 0 beats 1, loses to 2\n        [1, 1, 0], // Person 1 beats 0, loses to 2\n        [0, 1, 1]  // Person 2 beats 0, beats 1\n      ];\n      const n = 3;\n      const result = calculatePossibleWinners(matrix, n);\n      expect(result).assertEqual(0); // Two possible winners\n    });\n\n    it('test3 - 4x4 matrix with circular relationship', 0,() => {\n      const matrix = [\n        [1, 0, 1, 0],\n        [1, 1, 0, 1],\n        [0, 1, 1, 0],\n        [1, 0, 1, 1]\n      ];\n      const n = 4;\n      const result = calculatePossibleWinners(matrix, n);\n      expect(result).assertEqual(1); // Three possible winners\n    });\n  });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function calculatePossibleWinners(matrix: number[][], n: number): number {\n  const winCounts = new ArrayList<number>();\n  for (let i = 0; i < n; i++) {\n    let wins = 0;\n    for (let j = 0; j < n; j++) {\n      if (matrix[i][j] === 1) {\n        wins++;\n      }\n    }\n    winCounts.add(wins);\n  }\n  \n  let possibleWinners = 0;\n  for (let i = 0; i < winCounts.length; i++) {\n    if (winCounts[i] === 0) {\n      possibleWinners++;\n    }\n  }\n  \n  return possibleWinners;\n}",
      "test_passed": true
    },
    {
      "instruction": "Given a date string in the format YYYY-MM-DD, write a function getWeekday in @kit.ArkTS that returns the day of the week for the given date.\nThe function should return a string such as \"Monday\", \"Tuesday\", etc.\nUse the Date object in ArkTS to extract the day of the week, and map it to the corresponding weekday name.",
      "code": "export function getWeekday(dateString: string): string {\n  let date = new Date(dateString);\n  let dayOfWeek = date.getDay();\n  let weekdays = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n  return weekdays[dayOfWeek];\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { getWeekday } from '../main/ets/function/fun3';\n\nexport default function getWeekdayTest() {\n  describe('getWeekday', () => {\n\n    it('test Sunday', 0, () => {\n      const result = getWeekday('2025-08-24');\n      expect(result).assertEqual('Sunday');\n    });\n\n    it('test Wednesday', 0, () => {\n      const result = getWeekday('2025-08-27');\n      expect(result).assertEqual('Wednesday');\n    });\n\n    it('test Saturday', 0, () => {\n      const result = getWeekday('2025-08-30');\n      expect(result).assertEqual('Saturday');\n    });\n\n  });\n}\n",
      "model_output": "import {getWeekday} from '@kit.ArkTS';\n\nexport function getWeekday(dateStr: string): string {\n  const date = new Date(dateStr);\n  const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  return daysOfWeek[date.getDay()];\n}",
      "test_passed": false
    },
    {
      "instruction": "Given no parameters, write a function daffodilsNumber using ArkTs code that returns all 3-digit \"Daffodil numbers\". A Daffodil number is a 3-digit number where the sum of the cubes of its digits equals the number itself. For example, 153 is a Daffodil number because 1³ + 5³ + 3³ = 153. Return the result as an array of numbers.",
      "code": "export function daffodilsNumber(): number[] {\n  let result: number[] = []\n  for (let i = 100; i < 1000; i++) {\n    let unitsDigit: number = i % 10\n    let tenthsDigit: number = Math.floor(i / 10) - Math.floor(i / 100) * 10\n    let hundredthsDigit: number = Math.floor(i / 100)\n    if (i == unitsDigit * unitsDigit * unitsDigit + tenthsDigit * tenthsDigit * tenthsDigit +\n      hundredthsDigit * hundredthsDigit * hundredthsDigit) {\n      result.push(i)\n    }\n  }\n  return result\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { daffodilsNumber } from '../main/ets/function/fun3';\n\nexport default function testDaffodilsNumber() {\n  describe('daffodilsNumber', () => {\n    it('should return an array',0, () => {\n      const result = daffodilsNumber();\n      expect(Array.isArray(result)).assertTrue();\n    });\n\n    it('should contain known daffodil number 153',0, () => {\n      const result = daffodilsNumber();\n      expect(result.includes(153)).assertTrue();\n    });\n\n    it('should return exactly 4 daffodil numbers', 0,() => {\n      const result = daffodilsNumber();\n      expect(result.length).assertEqual(4);\n    });\n  });\n}\n",
      "model_output": "import {taskpool} from '@kit.ArkTS';\ntype TaskPool = taskpool.TaskPool;\n\nexport function createTaskPool(name: string, priority: taskpool.Priority, size: number): TaskPool {\n  return new taskpool.TaskPool(name, priority, size);\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a string content, write a function isPalindromicString using ArkTs code that returns a boolean indicating whether the string is a palindrome (reads the same forwards and backwards). The function should compare characters from the start and end moving towards the center, and return false as soon as a mismatch is found. Return true if no mismatches exist or the string is empty.",
      "code": "export function isPalindromicString(content: string): boolean {\n  let result: boolean = true\n  let i: number = 0\n  let j: number = content.length - 1\n  while (i <= j) {\n    if (content.charAt(i) != content.charAt(j)) {\n      result = false\n      break\n    }\n    i++\n    j--\n  }\n  return result\n\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { isPalindromicString } from '../main/ets/function/fun3';\n\nexport default function testIsPalindromicString() {\n  describe('isPalindromicString', () => {\n    it('should return true for palindrome string \"level\"', 0, () => {\n      const result = isPalindromicString('level');\n      expect(result).assertTrue();\n    });\n\n    it('should return false for non-palindrome string \"hello\"', 0, () => {\n      const result = isPalindromicString('hello');\n      expect(result).assertFalse();\n    });\n\n    it('should return true for empty string', 0, () => {\n      const result = isPalindromicString('');\n      expect(result).assertTrue();\n    });\n  });\n}\n",
      "model_output": "import { isPalindromicString } from '../main/ets/function/fun3';\n\nexport function isPalindromicString(content: string): boolean {\n  let left = 0;\n  let right = content.length - 1;\n  while (left < right) {\n    if (content.charAt(left)!== content.charAt(right)) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a timestamp num as a number, write a function formatDate in ArkTS that returns a formatted string representing the date in the form YYYY/MM/DD. Use the Date object to extract the year, month, and day. Ensure the month and day are padded with a leading zero if they are less than 10 (e.g., 2025/01/09).",
      "code": "export function formatDate(num: number): string{\n  let date = new Date(num)\n  let year = date.getFullYear()\n  let month = date.getMonth()+1\n  let day = date.getDate()\n  let m = month < 10 ? '0' + month : month\n  let d = day < 10 ? '0' + day : day\n  return `${year}/${m}/${d}`\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium'\nimport {formatDate}  from '../main/ets/function/fun3'\n\nexport default function testFormatDate() {\n  describe('formatDate', () => {\n    it('should format timestamp to correct date string', 0,() => {\n      const timestamp = new Date(2023, 0, 5).getTime(); // 2023/01/05\n      const result = formatDate(timestamp);\n      expect(result).assertEqual('2023/01/05');\n    });\n\n    it('should pad month and day with zero if needed', 0,() => {\n      const timestamp = new Date(2024, 8, 9).getTime(); // 2024/09/09\n      const result = formatDate(timestamp);\n      expect(result).assertEqual('2024/09/09');\n    });\n\n    it('should handle double-digit month and day without padding',0, () => {\n      const timestamp = new Date(2025, 10, 15).getTime(); // 2025/11/15\n      const result = formatDate(timestamp);\n      expect(result).assertEqual('2025/11/15');\n    });\n  });\n}\n",
      "model_output": "import {Date} from '@kit.ArkTS';\n\nexport function formatDate(timestamp: number): string {\n  const date = new Date(timestamp);\n  const year = date.getFullYear();\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n  const monthStr = month < 10? `0${month}` : `${month}`;\n  const dayStr = day < 10? `0${day}` : `${day}`;\n  return `${year}/${monthStr}/${dayStr}`;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a positive integer n, and an optional ArrayList<string> from @kit.ArkTS to store intermediate results, write a function MultiplicationTableFormatted using ArkTS that returns a 2D ArrayList<ArrayList<string>>, representing a multiplication table up to n.Each cell should contain a string in the format \"a * b = c\" (e.g., \"2 * 3 = 6\"), where a <= b.\nYou must use ArkTS-specific syntax and structures, including ArrayList and proper type annotations.",
      "code": "export function MultiplicationTable(): string[][] {\n  let result: string[][] = [];\n  for (let i = 1; i <= 9; i++) {\n    let index: string[] = [];\n    for (let j = 1; j <= i; j++) {\n      let temp: string = j + ' * ' + i + ' = ' + i * j;\n      index.push(temp);\n    }\n    result.push(index);\n  }\n  return result;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { MultiplicationTable } from '../main/ets/function/fun3';\n\nexport default function testMultiplicationTable() {\n  describe('MultiplicationTable', () => {\n    it('should return a 9-row array', 0, () => {\n      const result = MultiplicationTable();\n      expect(result.length).assertEqual(9);\n    });\n\n    it('each row should have correct number of elements', 0, () => {\n      const result = MultiplicationTable();\n      for (let i = 0; i < result.length; i++) {\n        expect(result[i].length).assertEqual(i + 1);\n      }\n    });\n\n    it('should contain correct multiplication strings', 0, () => {\n      const result = MultiplicationTable();\n      expect(result[0][0]).assertEqual('1 * 1 = 1');\n      expect(result[1][1]).assertEqual('2 * 2 = 4');\n      expect(result[8][8]).assertEqual('9 * 9 = 81');\n    });\n  });\n}\n",
      "model_output": "import {ArrayList, ArkTS} from '@kit.ArkTS';\n\nexport function MultiplicationTable(n: number = 9, from?: ArrayList<string>): ArrayList<ArrayList<string>> {\n  const result = new ArrayList<ArrayList<string>>();\n  for (let i = 1; i <= n; i++) {\n    const row = new ArrayList<string>();\n    for (let j = 1; j <= i; j++) {\n      const product = i * j;\n      row.add(`${i} * ${j} = ${product}`);\n    }\n    result.add(row);\n  }\n  return result;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a 2D array board: number[][], a starting position (row: number, col: number), and a currentPlayer represented by a number, write a function checkWin in ArkTS that determines if the player has 5 or more continuous pieces in a line (vertically, horizontally, or diagonally). Return true if such a sequence exists, otherwise return false.",
      "code": "export function checkWin(board: number[][], row: number, col: number, currentPlayer: number): boolean {\n  const directions = [\n    [[-1, 0], [1, 0]],    // 垂直\n    [[0, -1], [0, 1]],    // 水平\n    [[-1, -1], [1, 1]],   // 主对角线\n    [[-1, 1], [1, -1]]    // 副对角线\n  ];\n\n  const rows = board.length;\n  const cols = board[0].length;\n\n  for (let direction of directions) {\n    let count = 1;\n    for (let i = 0; i < direction.length; i++) {\n      let dx = direction[i][0];\n      let dy = direction[i][1];\n      let x = row + dx;\n      let y = col + dy;\n      while (x >= 0 && x < rows && y >= 0 && y < cols &&\n        board[x][y] === currentPlayer) {\n        count++;\n        x += dx;\n        y += dy;\n      }\n    }\n    if (count >= 5) return true;\n  }\n\n  return false;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { checkWin } from '../main/ets/function/fun3'; \n\nexport default function testCheckWin() {\n  describe('checkWin', () => {\n\n    it('should return true for a vertical win with balanced moves', 0,() => {\n      const board = [\n        [0, 2, 1, 0, 0],\n        [0, 1, 1, 0, 0],\n        [0, 2, 1, 0, 0],\n        [0, 2, 1, 0, 0],\n        [0, 2, 1, 0, 0],\n      ];\n      const result = checkWin(board, 3, 2, 1);\n      expect(result).assertEqual(true);\n    });\n\n    it('should return true for an anti-diagonal win with fair turn order',0, () => {\n      const board = [\n        [0, 0, 0, 0, 1],\n        [0, 0, 0, 1, 2],\n        [0, 0, 1, 2, 0],\n        [0, 1, 2, 0, 0],\n        [1, 2, 0, 0, 0],\n      ];\n      const result = checkWin(board, 2, 2, 1);\n      expect(result).assertEqual(true);\n    });\n\n    it('should return false when sequence is blocked and moves are balanced',0, () => {\n      const board = [\n        [0, 0, 0, 0, 0],\n        [1, 1, 1, 2, 2],\n        [0, 0, 0, 0, 0],\n        [2, 0, 0, 0, 1],\n        [0, 0, 0, 0, 0],\n      ];\n      const result = checkWin(board, 1, 2, 1);\n      expect(result).assertEqual(false);\n    });\n\n  });\n}\n",
      "model_output": "import {checkWin} from '../main/ets/function/fun3';\n\nexport function checkWin(board: number[][], row: number, col: number, currentPlayer: number): boolean {\n  const directions = [\n    [0, 1], [1, 0], [1, 1], [1, -1]\n  ];\n  \n  for (const [dx, dy] of directions) {\n    let count = 1;\n    let x = row + dx;\n    let y = col + dy;\n    \n    while (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] === currentPlayer) {\n      count++;\n      x += dx;\n      y += dy;\n    }\n    \n    x = row - dx;\n    y = col - dy;\n    \n    while (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] === currentPlayer) {\n      count++;\n      x -= dx;\n      y -= dy;\n    }\n    \n    if (count >= 5) {\n      return true;\n    }\n  }\n  \n  return false;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a number num in scientific notation (e.g., \"1.23e5\" or -3.4e-2), write a function expandScientific in ArkTS that converts it to its full decimal representation as a string (e.g., \"123000\" or \"-0.034\"). The function should handle both positive and negative numbers and both positive and negative exponents. Use basic string and number manipulation without relying on libraries like BigDecimal.",
      "code": "export function fullNum(num: string | number): string {\n  const str = String(num).toLowerCase();\n  const numb = Number(num);\n  if (isNaN(numb)) return String(num);\n  if (!str.includes('e')) return String(num);\n  const isNegative = str.startsWith('-');\n  const parts = str.replace('-', '').split('e');\n  const base = parts[0];\n  const exponent = parts[1];\n  const expNum = Number(exponent);\n  const digits = base.replace('.', '');\n  const decimalPos = base.indexOf('.') === -1 ? digits.length : base.indexOf('.');\n  let result = '';\n  if (expNum >= 0) {\n    result = digits.padEnd(decimalPos + expNum, '0');\n  } else {\n    const absExp = Math.abs(expNum);\n    const zerosNeeded = absExp - decimalPos;\n    if (zerosNeeded > 0) {\n      result = '0.' + '0'.repeat(zerosNeeded) + digits;\n    } else {\n      const pointPos = decimalPos - absExp;\n      result = digits.slice(0, pointPos) + '.' + digits.slice(pointPos);\n    }\n  }\n  return isNegative ? '-' + result : result;\n}",
      "test": "import { fullNum } from '../main/ets/function/fun3'\nimport { describe, it, expect } from '@ohos/hypium';\nexport default function testfUllNum() {\n  describe('fullNum', () => {\n\n    it('should return original string if not a number', 0, () => {\n      const input = 'hello'\n      const result = fullNum(input)\n      expect(result).assertEqual('hello')\n    })\n\n    it('should format number with positive exponent correctly', 0, () => {\n      const input = '12e2'\n      const result = fullNum(input)\n      expect(result).assertEqual('1200')\n    })\n\n    it('should format number with negative exponent correctly', 0, () => {\n      const input = '-4.5e-2'  // -0.045\n      const result = fullNum(input)\n      expect(result).assertEqual('-0.045')\n    })\n  })\n}\n",
      "model_output": "import { fullNum } from '../main/ets/function/fun3'\n\nexport function expandScientific(num: string): string {\n  if (!num.includes('e')) {\n    return num\n  }\n  const [coeff, exp] = num.split('e')\n  let result = coeff\n  if (exp.includes('-')) {\n    const zeros = exp.split('-')[1]\n    result = '0.'.padEnd(zeros.length + 1, '0') + coeff\n  } else {\n    const zeros = exp.split('+')[1]\n    result = coeff.padEnd(zeros.length + coeff.length, '0')\n  }\n  return result\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a string | number input value, write a function currencyNo in ArkTS that converts the value into a formatted currency string without decimal trailing zeros. Use standard JavaScript/ArkTS string and number methods, and insert commas appropriately for thousands separators (e.g., 1000000 → \"1,000,000\").",
      "code": "export function currencyNo(value: string | number): string {\n  const num = Number(value)\n  if (isNaN(num) || value === '') {\n    return ''\n  }\n  const fullValue = Number(num).toFixed(20).replace(/\\.?0+$/, '')\n  const valueArray: string[] = fullValue.split('.')\n  const intPart: string = valueArray[0]\n  const intPartFormatted: string = intPart.replace(/(\\d)(?=(\\d{3})+$)/g, '$1,')\n  return valueArray.length === 2\n    ? `${intPartFormatted}.${valueArray[1]}`\n    : intPartFormatted\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium'\nimport { currencyNo } from '../main/ets/function/fun3'\n\nexport default function testCurrencyNo() {\n  describe('currencyNo', () => {\n    it('should return empty string if not a number', 0, () => {\n      expect(currencyNo('abc')).assertEqual('')\n    })\n\n    it('should format integer number correctly', 0, () => {\n      expect(currencyNo(1000)).assertEqual('1,000')\n    })\n\n    it('should format decimal number correctly', 0, () => {\n      expect(currencyNo('1200000')).assertEqual('1,200,000')\n    })\n  })\n}",
      "model_output": "import {currencyNo} from '../main/ets/function/fun3'\n\nexport function currencyNo(value: string | number): string {\n  if (typeof value!== 'number') {\n    return ''\n  }\n  return value.toLocaleString('en-US')\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a class named `GamePerformanceInitializer`. This class should have private variables _initLog (a string) and _gamePageInfo (of type gamePerformance.GamePackageInfo). The constructor should initialize _gamePageInfo with messageType 0, appVersion '1.0', and bundleName 'com.xxx.xxx.huawei'. It should include methods getInitLog() (returning _initLog), getGamePageInfo() (returning _gamePageInfo), and gamePerformanceInit() (which initializes gamePerformance with _gamePageInfo,  and updates _initLog to 'Init gamePerformance succeeded' on success).",
      "code": "import { gamePerformance } from '@kit.GameServiceKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nexport class GamePerformanceInitializer {\n private _initLog: string = 'to show log';\n private _gamePageInfo: gamePerformance.GamePackageInfo;\n\n constructor() {\n this._gamePageInfo = {\n messageType: 0,\n extra: '',\n appVersion: '1.0',\n bundleName: 'com.xxx.xxx.huawei'\n };\n }\n getInitLog(): string {\n return this._initLog;\n }\n\n getGamePageInfo(): gamePerformance.GamePackageInfo {\n return this._gamePageInfo;\n }\n\n gamePerformanceInit(): void {\n try {\n gamePerformance.init(this._gamePageInfo).then(() => {\n this._initLog = 'Init gamePerformance succeeded.';\n console.info('Init gamePerformance succeeded.');\n }).catch((err: BusinessError) => {\n this.handleError(err);\n });\n } catch (err) {\n this.handleError(err as BusinessError);\n }\n }\n private handleError(error: BusinessError): void {\n console.error(Init failed. Code:${error.code}, Message:${error.message});\n this._initLog = Failed. Code:${error.code}, Message:${error.message};\n }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { GamePerformanceInitializer } from '../main/ets/utils/GamePerformanceInit';\n\nexport default function gamePerformanceTest() {\n describe('GamePerformanceInitializer_Test', () => {\n\n it('should initialize with correct parameters', 0, async () => {\n const initializer = new GamePerformanceInitializer();\n const params = initializer.getGamePageInfo();\n expect(params.messageType).assertEqual(0);\n expect(params.appVersion).assertEqual('1.0');\n expect(params.bundleName).assertEqual('com.xxx.xxx.huawei');\n });\n\n it('should handle successful initialization', 0,async () => {\n const initializer = new GamePerformanceInitializer();\n await initializer.gamePerformanceInit();\n expect(initializer.getInitLog()).assertContain('succeeded');\n });\n });\n}",
      "model_output": "import {gamePerformance} from '@kit.ArkTS';\n\nexport class GamePerformanceInitializer {\n  private _initLog: string = '';\n  private _gamePageInfo: gamePerformance.GamePackageInfo = {\n    messageType: 0,\n    appVersion: '1.0',\n    bundleName: 'com.xxx.xxx.huawei'\n  };\n\n  public getInitLog(): string {\n    return this._initLog;\n  }\n\n  public getGamePageInfo(): gamePerformance.GamePackageInfo {\n    return this._gamePageInfo;\n  }\n\n  public async gamePerformanceInit(): Promise<void> {\n    try {\n      gamePerformance.init(this._gamePageInfo);\n      this._initLog = 'Init gamePerformance succeeded';\n    } catch (error) {\n      this._initLog = 'Init gamePerformance failed';\n    }\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a class named `DeviceStateSubscriber`. This class should have two private variables: _subscribeLog initialized to 'to show log' and _latestTempLevel initialized to null. It should provide getter methods getSubscribeLog() and getLatestTempLevel(). The class must include a method subscribeDeviceState() that subscribes to the deviceStateChanged event from gamePerformance. On event trigger, it should update _subscribeLog and _latestTempLevel with the new tempLevel. On successful subscription, _subscribeLog should be 'Subscriber device state event succeeded.'.",
      "code": "import { gamePerformance } from '@kit.GameServiceKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nexport class DeviceStateSubscriber {\n  private _subscribeLog: string = 'to show log';\n  private _latestTempLevel: number | null = null;\n\n  getSubscribeLog(): string {\n    return this._subscribeLog;\n  }\n\n  getLatestTempLevel(): number | null {\n    return this._latestTempLevel;\n  }\n\n  subscribeDeviceState(): void {\n    try {\n      gamePerformance.on('deviceStateChanged', (data: gamePerformance.DeviceInfo) => {\n        console.info(`Device temperature level change to ${data.tempLevel}.`);\n        this._subscribeLog = `Device temperature level change to ${data.tempLevel}.`;\n        this._latestTempLevel = data.tempLevel;\n      });\n\n      this._subscribeLog = 'Subscriber device state event succeeded.';\n      console.info('Subscriber device state event succeeded.');\n    } catch (err) {\n      const error = err as BusinessError;\n      console.error(`Subscriber failed. Code:${error.code}, Message:${error.message}`);\n      this._subscribeLog = `Failed. Code:${error.code}, Message:${error.message}`;\n    }\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { DeviceStateSubscriber } from '../main/ets/utils/DeviceStateSubscriber';\n\nexport default function deviceStateTest() {\n  describe('DeviceStateSubscriber_Test', () => {\n    it('initial_state_should_have_default_values', 0, () => {\n      const subscriber = new DeviceStateSubscriber();\n      expect(subscriber.getSubscribeLog()).assertEqual('to show log');\n      expect(subscriber.getLatestTempLevel()).assertNull();\n    });\n\n    it('subscribe_should_update_success_log', 0, () => {\n      const subscriber = new DeviceStateSubscriber();\n      subscriber.subscribeDeviceState();\n      expect(subscriber.getSubscribeLog())\n        .assertEqual('Subscriber device state event succeeded.');\n    });\n  });\n}",
      "model_output": "import {gamePerformance} from '@kit.TestKit';\n\nexport class DeviceStateSubscriber {\n  private _subscribeLog: string;\n  private _latestTempLevel: number | null;\n\n  constructor() {\n    this._subscribeLog = 'to show log';\n    this._latestTempLevel = null;\n  }\n\n  public getSubscribeLog(): string {\n    return this._subscribeLog;\n  }\n\n  public getLatestTempLevel(): number | null {\n    return this._latestTempLevel;\n  }\n\n  public subscribeDeviceState(): void {\n    gamePerformance.on('deviceStateChanged', (tempLevel: number) => {\n      this._subscribeLog = 'Subscriber device state event succeeded.';\n      this._latestTempLevel = tempLevel;\n    });\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a class named `GameSceneUpdater`. This class should have two private variables: updateLog initialized to 'to show log' and gameSceneInfo initialized with default values. It should provide getter methods getGameSceneInfo() and getLog(). The class must include a method updateGameSceneInfo() that updates gameSceneInfo with { messageType: 2, extra: '', sceneID: 1111, importanceLevel: 1111 } and calls gamePerformance.updateGameInfo. On success, it should set updateLog to 'Update game scene info succeeded.'.",
      "code": "import { gamePerformance } from '@kit.GameServiceKit';\nimport { BusinessError } from '@kit.BasicServicesKit';\n\nexport class GameSceneUpdater {\n  private updateLog: string = 'to show log';\n  private gameSceneInfo: gamePerformance.GameSceneInfo = {\n    messageType: 0,\n    extra: '',\n    sceneID: 0,\n    importanceLevel: 0\n  };\n\n  public getGameSceneInfo(): gamePerformance.GameSceneInfo {\n    return this.gameSceneInfo;\n  }\n\n  public getLog(): string {\n    return this.updateLog;\n  }\n\n  updateGameSceneInfo(): void {\n    try {\n      this.gameSceneInfo = {\n        messageType: 2,\n        extra: '',\n        sceneID: 1111,\n        importanceLevel: 1111\n      };\n      gamePerformance.updateGameInfo(this.gameSceneInfo).then(() => {\n        console.info('Update game scene info succeeded.');\n        this.updateLog = 'Update game scene info succeeded.';\n      });\n    } catch (err) {\n      let error = err as BusinessError;\n      console.error(`Update failed. Code:${error.code}, Message:${error.message}`);\n      this.updateLog = `Failed. Code:${error.code}, Message:${error.message}`;\n    }\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { GameSceneUpdater } from '../main/ets/utils/GameSceneUpdater';\nimport { gamePerformance } from '@kit.GameServiceKit';\n\nexport default function gameSceneTest() {\n  describe('GameSceneUpdater_Test', () => {\n\n    it('initial_state_should_have_default_values', 0, () => {\n      const updater = new GameSceneUpdater();\n      expect(updater.getLog()).assertEqual('to show log');\n    });\n\n    it('update_should_modify_parameters_synchronously', 0, () => {\n      const updater = new GameSceneUpdater();\n      updater.updateGameSceneInfo();\n      const updatedSceneInfo = updater.getGameSceneInfo();\n      expect(updatedSceneInfo.messageType).assertEqual(2);\n      expect(updatedSceneInfo.sceneID).assertEqual(1111);\n      expect(updatedSceneInfo.importanceLevel).assertEqual(1111);\n    });\n\n    it('log_should_update_after_success', 0, async () => {\n      const updater = new GameSceneUpdater();\n      await updater.updateGameSceneInfo();\n      expect(updater.getLog()).assertEqual('Update game scene info succeeded.');\n    });\n  });\n}",
      "model_output": "import {GameSceneInfo} from '@kit.GameServiceKit';\n\nexport class GameSceneUpdater {\n  private updateLog: string = 'to show log';\n  private gameSceneInfo: GameSceneInfo = { messageType: 0, extra: '', sceneID: 0, importanceLevel: 0 };\n\n  public getGameSceneInfo(): GameSceneInfo {\n    return this.gameSceneInfo;\n  }\n\n  public getLog(): string {\n    return this.updateLog;\n  }\n\n  public updateGameSceneInfo(): void {\n    this.gameSceneInfo = { messageType: 2, extra: '', sceneID: 1111, importanceLevel: 1111 };\n    gamePerformance.updateGameInfo(this.gameSceneInfo);\n    this.updateLog = 'Update game scene info succeeded.';\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write utility functions for 3D vector operations with type Vec3. Implement the following functions: vec3Sub(l: Vec3, r: Vec3): Vec3 to subtract two vectors; vec3Dot(l: Vec3, r: Vec3): number to compute the dot product of two vectors; vec3Normalize(l: Vec3): Vec3 to normalize a vector using its length; vec3Cross(l: Vec3, r: Vec3): Vec3 to compute the cross product of two vectors.",
      "code": "import { Vec3 } from '@kit.ArkGraphics3D';\n\nexport function vec3Sub(l: Vec3, r: Vec3): Vec3 {\n  return { x: l.x - r.x, y: l.y - r.y, z: l.z - r.z };\n}\n\nexport function vec3Dot(l: Vec3, r: Vec3): number {\n  return l.x * r.x + l.y * r.y + l.z * r.z; \n}\n\nexport function vec3Normalize(l: Vec3): Vec3 {\n  const length = Math.sqrt(vec3Dot(l, l));\n  return { x: l.x / length, y: l.y / length, z: l.z / length };\n}\n\nexport function vec3Cross(l: Vec3, r: Vec3): Vec3 {\n  return {\n    x: l.y * r.z - l.z * r.y,\n    y: l.z * r.x - l.x * r.z,\n    z: l.x * r.y - l.y * r.x\n  };\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { vec3Sub, vec3Dot, vec3Normalize, vec3Cross } from '../main/ets/utils/Vec3Utils';\nimport { Vec3 } from '@kit.ArkGraphics3D';\n\nexport default function vec3FunctionTest() {\n  describe('vec3Sub_Test', () => {\n    it('should subtract vectors correctly (case 1)', 0, () => {\n      const v1: Vec3 = { x: 5, y: 3, z: 2 };\n      const v2: Vec3 = { x: 1, y: 2, z: 3 };\n      const result = vec3Sub(v1, v2);\n      expect(result).assertDeepEquals({ x: 4, y: 1, z: -1 });\n    });\n\n    it('should subtract vectors correctly (case 2)', 0, () => {\n      const v1: Vec3 = { x: -1, y: 0, z: 5 };\n      const v2: Vec3 = { x: -1, y: -2, z: 1 };\n      const result = vec3Sub(v1, v2);\n      expect(result).assertDeepEquals({ x: 0, y: 2, z: 4 });\n    });\n  });\n\n  describe('vec3Dot_Test', () => {\n    it('should compute dot product correctly (case 1)', 0, () => {\n      const v1: Vec3 = { x: 1, y: 2, z: 3 };\n      const v2: Vec3 = { x: 4, y: -5, z: 6 };\n      const result = vec3Dot(v1, v2);\n      expect(result).assertEqual(12);\n    });\n\n    it('should compute dot product correctly (case 2)', 0, () => {\n      const v1: Vec3 = { x: 0, y: 1, z: 0 };\n      const v2: Vec3 = { x: 0, y: 0, z: 1 };\n      const result = vec3Dot(v1, v2);\n      expect(result).assertEqual(0);\n    });\n  });\n\n  describe('vec3Normalize_Test', () => {\n    it('should normalize vector correctly (case 1)', 0, () => {\n      const v: Vec3 = { x: 3, y: 0, z: 4 };\n      const result = vec3Normalize(v);\n      expect(result).assertDeepEquals({ x: 0.6, y: 0, z: 0.8 });\n    });\n\n    it('should normalize vector correctly (case 2)', 0, () => {\n      const v: Vec3 = { x: 1, y: 1, z: 1 };\n      const result = vec3Normalize(v);\n      const length = Math.sqrt(3);\n      expect(result).assertDeepEquals({ x: 1/length, y: 1/length, z: 1/length });\n    });\n  });\n\n  describe('vec3Cross_Test', () => {\n    it('should compute cross product correctly (case 1)', 0, () => {\n      const v1: Vec3 = { x: 1, y: 0, z: 0 };\n      const v2: Vec3 = { x: 0, y: 1, z: 0 };\n      const result = vec3Cross(v1, v2);\n      expect(result).assertDeepEquals({ x: 0, y: 0, z: 1 });\n    });\n\n    it('should compute cross product correctly (case 2)', 0, () => {\n      const v1: Vec3 = { x: 0, y: 1, z: 0 };\n      const v2: Vec3 = { x: 0, y: 0, z: 1 };\n      const result = vec3Cross(v1, v2);\n      expect(result).assertDeepEquals({ x: 1, y: 0, z: 0 });\n    });\n  });\n}\n",
      "model_output": "import {Vec3} from '@kit.ArkGraphics3D';\n\nexport function vec3Sub(l: Vec3, r: Vec3): Vec3 {\n  return { x: l.x - r.x, y: l.y - r.y, z: l.z - r.z };\n}\n\nexport function vec3Dot(l: Vec3, r: Vec3): number {\n  return l.x * r.x + l.y * r.y + l.z * r.z;\n}\n\nexport function vec3Normalize(l: Vec3): Vec3 {\n  const length = Math.sqrt(l.x * l.x + l.y * l.y + l.z * l.z);\n  return { x: l.x / length, y: l.y / length, z: l.z / length };\n}\n\nexport function vec3Cross(l: Vec3, r: Vec3): Vec3 {\n  return { x: l.y * r.z - l.z * r.y, y: l.z * r.x - l.x * r.z, z: l.x * r.y - l.y * r.x };\n}",
      "test_passed": true
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named rotationMatrixToQuaternion. This function accepts three Vec3 vectors right, up, and back representing the axes of a rotation matrix. It should convert the rotation matrix to a normalized Quaternion representing the same rotation. The function must handle different cases based on the signs of the matrix elements and return a Quaternion with components x, y, z, and w normalized to length 1.",
      "code": "import { Vec3, Quaternion } from '@kit.ArkGraphics3D'; \n\nexport function rotationMatrixToQuaternion(right: Vec3, up: Vec3, back: Vec3): Quaternion {\n  let t: number;\n  let q: Quaternion;\n\n  if (back.z < 0) {\n    if (right.x > up.y) {\n      t = 1.0 + right.x - up.y - back.z;\n      q = {x:t, y:right.y + up.x, z:back.x + right.z, w: up.z - back.y};\n    } else {\n      t = 1.0 - right.x + up.y - back.z;\n      q = {x:right.y + up.x, y:t, z:up.z + back.y, w:back.x - right.z};\n    }\n  } else {\n    if (right.x < -up.y) {\n      t = 1.0 - right.x - up.y + back.z;\n      q = {x:back.x + right.z, y:up.z + back.y, z:t, w:right.y - up.x};\n    } else {\n      t = 1.0 + right.x + up.y + back.z;\n      q = {x:up.z - back.y, y:back.x - right.z, z:right.y - up.x, w:t};\n    }\n  }\n  \n  const len = Math.sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);\n  q.x /= len;\n  q.y /= len;\n  q.z /= len;\n  q.w /= len;\n\n  return q;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { Vec3, Quaternion } from '@kit.ArkGraphics3D';\nimport { rotationMatrixToQuaternion } from '../main/ets/utils/rotationMatrixToQuaternion';\n\nfunction expectClose(actual: number, expected: number, epsilon = 1e-6) {\n  expect(Math.abs(actual - expected) < epsilon).assertEqual(true);\n}\n\nexport default function rotationTest() {\n\n  describe('rotationMatrixToQuaternion_Test', () => {\n\n    it('should return identity quaternion for identity matrix', 0, () => {\n      const right: Vec3 = {x: 1, y: 0, z: 0};\n      const up: Vec3 = {x: 0, y: 1, z: 0};\n      const back: Vec3 = {x: 0, y: 0, z: 1};\n\n      const result: Quaternion = rotationMatrixToQuaternion(right, up, back);\n\n      expectClose(result.x, 0);\n      expectClose(result.y, 0);\n      expectClose(result.z, 0);\n      expectClose(result.w, 1);\n    });\n\n    it('should return correct quaternion for 180-degree rotation around Y axis', 0, () => {\n      const right: Vec3 = {x: -1, y: 0, z: 0};\n      const up: Vec3 = {x: 0, y: 1, z: 0};\n      const back: Vec3 = {x: 0, y: 0, z: -1};\n\n      const result: Quaternion = rotationMatrixToQuaternion(right, up, back);\n\n      expectClose(result.x, 0);\n      expectClose(result.y, 1);\n      expectClose(result.z, 0);\n      expectClose(result.w, 0);\n    });\n\n    it('should return correct quaternion for 90-degree rotation around X axis', 0, () => {\n      const right: Vec3 = {x: 1, y: 0, z: 0};\n      const up: Vec3 = {x: 0, y: 0, z: 1};\n      const back: Vec3 = {x: 0, y: -1, z: 0};\n\n      const result: Quaternion = rotationMatrixToQuaternion(right, up, back);\n\n      const sqrt2over2 = Math.sqrt(2)/2;\n\n      expectClose(result.x, sqrt2over2);\n      expectClose(result.y, 0);\n      expectClose(result.z, 0);\n      expectClose(result.w, sqrt2over2);\n    });\n\n  });\n}",
      "model_output": "import {Quaternion, Vec3} from '@kit.ArkGraphics3D';\n\nexport function rotationMatrixToQuaternion(right: Vec3, up: Vec3, back: Vec3): Quaternion {\n  const trace = right.x + up.y + back.z;\n  let w, x, y, z;\n\n  if (trace > 0) {\n    const s = Math.sqrt(trace + 1);\n    w = s / 2;\n    s = 1 / (4 * w);\n    x = (back.y - up.z) * s;\n    y = (right.z - back.x) * s;\n    z = (up.x - right.y) * s;\n  } else if (right.x > up.y && right.x > back.z) {\n    const s = Math.sqrt(1 + right.x - up.y - back.z);\n    x = s / 2;\n    s = 1 / (4 * x);\n    w = (back.y - up.z) * s;\n    y = (right.y + up.x) * s;\n    z = (right.z + back.x) * s;\n  } else if (up.y > back.z) {\n    const s = Math.sqrt(1 + up.y - right.x - back.z);\n    y = s / 2;\n    s = 1 / (4 * y);\n    w = (right.z - back.x) * s;\n    x = (right.y + up.x) * s;\n    z = (up.z + back.y) * s;\n  } else {\n    const s = Math.sqrt(1 + back.z - right.x - up.y);\n    z = s / 2;\n    s = 1 / (4 * z);\n    w = (up.x - right.y) * s;\n    x = (right.z + back.x) * s;\n    y = (up.z + back.y) * s;\n  }\n\n  const norm = Math.sqrt(w * w + x * x + y * y + z * z);\n  return {x: x / norm, y: y / norm, z: z / norm, w: w / norm};\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a class named Logger. The class should have three private variables: domain initialized to 0xFF00, prefix initialized via the constructor parameter, and format initialized to '%{public}s, %{public}s'. It should include methods debug(), info(), warn(), and error() that each accept any number of string arguments and call the corresponding hilog method (hilog.debug, hilog.info, hilog.warn, hilog.error) using domain, prefix, format, and the arguments.",
      "code": "import { hilog } from '@kit.PerformanceAnalysisKit'; \n\nexport class Logger {\n  private domain: number;\n  private prefix: string;\n  private format: string = '%{public}s, %{public}s';\n\n  constructor(prefix: string) {\n    this.prefix = prefix;\n    this.domain = 0xFF00;\n  }\n\n  debug(...args: string[]): void {\n    hilog.debug(this.domain, this.prefix, this.format, args);\n  }\n\n  info(...args: string[]): void {\n    hilog.info(this.domain, this.prefix, this.format, args);\n  }\n\n  warn(...args: string[]): void {\n    hilog.warn(this.domain, this.prefix, this.format, args);\n  }\n\n  error(...args: string[]): void {\n    hilog.error(this.domain, this.prefix, this.format, args);\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { Logger } from '../main/ets/utils/Logger';\n\nexport default function loggerTest() {\n\n  describe('Logger_Basic_Functionality_Test', () => {\n\n    it('should_create_a_Logger_instance', 0, () => {\n      const logger = new Logger('TestPrefix');\n      expect(logger instanceof Logger).assertEqual(true);\n    });\n\n    it('should_call_debug_without_error', 0, () => {\n      const logger = new Logger('TestDebug');\n      try {\n        logger.debug('Debug message', 'extra info');\n        expect(true).assertEqual(true);\n      } catch {\n        expect(true).assertEqual(false);\n      }\n    });\n\n    it('should_call_info_without_error', 0, () => {\n      const logger = new Logger('TestInfo');\n      try {\n        logger.info('Info message', 'extra info');\n        expect(true).assertEqual(true);\n      } catch {\n        expect(true).assertEqual(false);\n      }\n    });\n\n    it('should_call_warn_without_error', 0, () => {\n      const logger = new Logger('TestWarn');\n      try {\n        logger.warn('Warn message', 'extra info');\n        expect(true).assertEqual(true);\n      } catch {\n        expect(true).assertEqual(false);\n      }\n    });\n\n    it('should_call_error_without_error', 0, () => {\n      const logger = new Logger('TestError');\n      try {\n        logger.error('Error message', 'extra info');\n        expect(true).assertEqual(true);\n      } catch {\n        expect(true).assertEqual(false);\n      }\n    });\n\n  });\n}",
      "model_output": "import {Logger} from '../main/ets/utils/Logger';\n\nexport class Logger {\n  private domain: number = 0xFF00;\n  private prefix: string;\n  private format: string = '%{public}s, %{public}s';\n\n  constructor(prefix: string) {\n    this.prefix = prefix;\n  }\n\n  public debug(...args: string[]): void {\n    hilog.debug(this.domain, this.prefix, this.format,...args);\n  }\n\n  public info(...args: string[]): void {\n    hilog.info(this.domain, this.prefix, this.format,...args);\n  }\n\n  public warn(...args: string[]): void {\n    hilog.warn(this.domain, this.prefix, this.format,...args);\n  }\n\n  public error(...args: string[]): void {\n    hilog.error(this.domain, this.prefix, this.format,...args);\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a UI component in a file named ButtonItem. Define a class ButtonUnitItem that has three private variables: buttonRecommendsColor, buttonCommentaryColor, and buttonLikesColor, all of type Color, initialized through the constructor parameters. Then define a @Component struct ButtonItem with a @Prop unit of type ButtonUnitItem. In the build method, render a Row containing three sub-Rows, each holding a Rect with width and height STATIC_HEIGHT, borderRadius 4, and filled respectively with buttonRecommendsColor, buttonCommentaryColor, and buttonLikesColor. The outer Row should have height ROW_HEIGHT, width FULL_SIZE, justifyContent set to FlexAlign.SpaceAround, and margin with left and right STATIC_MARGIN.",
      "code": "const STATIC_HEIGHT = 20;\nconst ROW_HEIGHT = 40;\nconst STATIC_MARGIN = 10;\nconst FULL_SIZE = '100%';\n\nexport class ButtonUnitItem {\n  buttonRecommendsColor: Color;\n  buttonCommentaryColor: Color;\n  buttonLikesColor: Color;\n\n  constructor(recommends: Color, commentary: Color, likes: Color) {\n    this.buttonRecommendsColor = recommends;\n    this.buttonCommentaryColor = commentary;\n    this.buttonLikesColor = likes;\n  }\n}\n\n@Component\nexport default struct ButtonItem {\n  @Prop unit: ButtonUnitItem;\n  build() {\n    Row() {\n      Row() {\n        Rect()\n          .fill(this.unit.buttonRecommendsColor)\n          .width(STATIC_HEIGHT)\n          .height(STATIC_HEIGHT)\n          .borderRadius(4)\n      }\n      Row() {\n        Rect()\n          .fill(this.unit.buttonCommentaryColor)\n          .width(STATIC_HEIGHT)\n          .height(STATIC_HEIGHT)\n          .borderRadius(4)\n      }\n      Row() {\n        Rect()\n          .fill(this.unit.buttonLikesColor)\n          .width(STATIC_HEIGHT)\n          .height(STATIC_HEIGHT)\n          .borderRadius(4)\n      }\n    }\n    .height(ROW_HEIGHT)\n    .width(FULL_SIZE)\n    .justifyContent(FlexAlign.SpaceAround)\n    .margin({ left: STATIC_MARGIN, right: STATIC_MARGIN })\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport ButtonItem, { ButtonUnitItem } from '../main/ets/utils/ButtonItem'; // 按实际路径修改\n\nexport default function buttonItemTest() {\n  describe('ButtonItem_basic_functionality', () => {\n\n    it('should_create_ButtonUnitItem_with_correct_colors_1', 0, () => {\n      const unit = new ButtonUnitItem(Color.Red, Color.Green, Color.Blue);\n\n      expect(unit.buttonRecommendsColor === Color.Red).assertEqual(true);\n      expect(unit.buttonCommentaryColor === Color.Green).assertEqual(true);\n      expect(unit.buttonLikesColor === Color.Blue).assertEqual(true);\n    });\n\n    it('should_create_ButtonUnitItem_with_correct_colors_2', 0, () => {\n      const unit = new ButtonUnitItem(Color.Yellow, Color.Gray, Color.Orange);\n\n      expect(unit.buttonRecommendsColor === Color.Yellow).assertEqual(true);\n      expect(unit.buttonCommentaryColor === Color.Gray).assertEqual(true);\n      expect(unit.buttonLikesColor === Color.Orange).assertEqual(true);\n    });\n\n  });\n}",
      "model_output": "import {Color, Row, Rect} from '@kit.TestKit';\nimport {FullSize, FlexAlign, StaticDimension} from '@kit.TestKit';\n\nexport class ButtonUnitItem {\n  private buttonRecommendsColor: Color;\n  private buttonCommentaryColor: Color;\n  private buttonLikesColor: Color;\n\n  constructor(buttonRecommendsColor: Color, buttonCommentaryColor: Color, buttonLikesColor: Color) {\n    this.buttonRecommendsColor = buttonRecommendsColor;\n    this.buttonCommentaryColor = buttonCommentaryColor;\n    this.buttonLikesColor = buttonLikesColor;\n  }\n}\n\n@Component\nexport struct ButtonItem {\n  @Prop unit: ButtonUnitItem;\n\n  build() {\n    Row() {\n      Row() {\n        Rect() {\n          width(StaticDimension.STATIC_HEIGHT);\n          height(StaticDimension.STATIC_HEIGHT);\n          borderRadius(4);\n          fillColor(this.unit.buttonRecommendsColor);\n        }\n       .width(StaticDimension.STATIC_HEIGHT)\n       .height(StaticDimension.STATIC_HEIGHT)\n       .borderRadius(4)\n       .fillColor(this.unit.buttonRecommendsColor)\n      }\n      Row() {\n        Rect() {\n          width(StaticDimension.STATIC_HEIGHT);\n          height(StaticDimension.STATIC_HEIGHT);\n          borderRadius(4);\n          fillColor(this.unit.buttonCommentaryColor);\n        }\n       .width(StaticDimension.STATIC_HEIGHT)\n       .height(StaticDimension.STATIC_HEIGHT)\n       .borderRadius(4)\n       .fillColor(this.unit.buttonCommentaryColor)\n      }\n      Row() {\n        Rect() {\n          width(StaticDimension.STATIC_HEIGHT);\n          height(StaticDimension.STATIC_HEIGHT);\n          borderRadius(4);\n          fillColor(this.unit.buttonLikesColor);\n        }\n       .width(StaticDimension.STATIC_HEIGHT)\n       .height(StaticDimension.STATIC_HEIGHT)\n       .borderRadius(4)\n       .fillColor(this.unit.buttonLikesColor)\n      }\n    }\n   .height(StaticDimension.ROW_HEIGHT)\n   .width(FullSize.FULL_SIZE)\n   .justifyContent(FlexAlign.SpaceAround)\n   .margin({left: StaticDimension.STATIC_MARGIN, right: StaticDimension.STATIC_MARGIN});\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a UI component in a file named TitleAreaItem. Define a class TitleUnitItem with two public variables: titleName and titleTime, both initialized via the constructor. Then define a @Component struct TitleAreaItem with a @Prop unit of type TitleUnitItem. In the build method, render a Row containing a Column that shows the titleName as a Text with height 25, font weight Medium, font family HarmonyHeiTi-Medium, and font size 14, and below it a Row with spacing STATIC_SPACE showing titleTime as a Text with font size 12 and gray color. The outer Row should have width '100%', height STATIC_HEIGHT, justify content FlexAlign.SpaceBetween, and top/bottom margin STATIC_MARGIN.",
      "code": "export class TitleUnitItem {\n  public titleName: string;\n  public titleTime: string;\n\n  constructor(titleName: string, titleTime: string) {\n    this.titleName = titleName;\n    this.titleTime = titleTime;\n  }\n}\n\nconst FONT_FAMILY = 'HarmonyHeiTi-Medium';\nconst STATIC_MARGIN = 8;\nconst STATIC_SPACE = 5;\nconst STATIC_HEIGHT = 50;\n\n@Component\nexport struct TitleAreaItem {\n  @Prop unit: TitleUnitItem;\n\n  build() {\n    Row() {\n      Column() {\n        \n        Text(this.unit.titleName)\n          .height(25)\n          .fontWeight(FontWeight.Medium)\n          .fontFamily(FONT_FAMILY)\n          .fontSize(14)\n\n        \n        Row({ space: STATIC_SPACE }) {\n          Text(this.unit.titleTime)\n            .fontSize(12)\n            .fontColor(Color.Gray)\n        }\n      }\n      .width('100%')\n      .alignItems(HorizontalAlign.Start)\n      .margin({ left: STATIC_MARGIN })\n    }\n    .width('100%')\n    .height(STATIC_HEIGHT)\n    .justifyContent(FlexAlign.SpaceBetween)\n    .margin({ top: STATIC_MARGIN, bottom: STATIC_MARGIN })\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { TitleAreaItem, TitleUnitItem } from '../main/ets/utils/TitleItemModule';\n\nexport default function titleItemTest() {\n\n  describe('TitleUnitItem_Basic_Functionality', () => {\n\n    it('should_create_TitleUnitItem_with_correct_name_and_time', 0, () => {\n      const title = 'Test Title';\n      const time = '2025-08-29';\n      const unit = new TitleUnitItem(title, time);\n\n      expect(unit.titleName).assertEqual(title);\n      expect(unit.titleTime).assertEqual(time);\n    });\n\n    it('should_update_TitleUnitItem_properties_correctly', 0, () => {\n      const unit = new TitleUnitItem('Old Title', '2025-01-01');\n\n      unit.titleName = 'New Title';\n      unit.titleTime = '2025-08-29';\n\n      expect(unit.titleName).assertEqual('New Title');\n      expect(unit.titleTime).assertEqual('2025-08-29');\n    });\n  });\n}",
      "model_output": "import {TitleUnitItem, TitleAreaItem} from '../main/ets/utils/TitleItemModule';\n\nexport function getTitleUnitItem(): TitleUnitItem {\n  return new TitleUnitItem('Test Title', '2025-08-29');\n}\n\nexport function getTitleAreaItem(): TitleAreaItem {\n  return new TitleAreaItem();\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a class named PictureItem. This class should have two public properties: index of type number and pixelMap of type image.PixelMap from @kit.ImageKit. Implement a constructor that accepts an index and a pixelMap, and initializes these two properties.",
      "code": "import { image } from '@kit.ImageKit';\n\nexport default class PictureItem {\n  public index: number;\n  public pixelMap: image.PixelMap;\n\n  constructor(index: number, pixelMap: image.PixelMap) {\n    this.index = index;\n    this.pixelMap = pixelMap;\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport PictureItem from '../main/ets/utils/PictureItem'; \nimport { image } from '@kit.ImageKit';\n\nexport default function pictureItemTest() {\n\n  describe('PictureItem_basic_functionality', () => {\n\n    it('should_create_instance_with_correct_index_and_pixelMap_1', 0, () => {\n      const mockPixelMap = {} as image.PixelMap;\n      const item = new PictureItem(1, mockPixelMap);\n      expect(item.index).assertEqual(1);\n      expect(item.pixelMap).assertEqual(mockPixelMap);\n    });\n\n    it('should_create_instance_with_correct_index_and_pixelMap_2', 0, () => {\n      const mockPixelMap = {} as image.PixelMap;\n      const item = new PictureItem(99, mockPixelMap);\n      expect(item.index).assertEqual(99);\n      expect(item.pixelMap).assertEqual(mockPixelMap);\n    });\n  });\n}",
      "model_output": "import {image} from '@kit.ImageKit';\n\nexport class PictureItem {\n  public index: number;\n  public pixelMap: image.PixelMap;\n\n  constructor(index: number, pixelMap: image.PixelMap) {\n    this.index = index;\n    this.pixelMap = pixelMap;\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a class named ImagePickerLogic. This class manages image selection with a selected number property initialized to 0, and an imagesData array of photoAccessHelper.PhotoAsset from @kit.MediaLibraryKit preloaded with three sample URIs (file://image1.jpg, file://image2.jpg, file://image3.jpg). Implement methods setSelected(index: number), getSelected(): number, and getImages() to update selection, retrieve the current selection, and return all images.",
      "code": "import { photoAccessHelper } from '@kit.MediaLibraryKit';\nexport class ImagePickerLogic {\n  selected: number = 0;\n  imagesData: Array<photoAccessHelper.PhotoAsset> = [\n    { uri: 'file://image1.jpg' } as photoAccessHelper.PhotoAsset,\n    { uri: 'file://image2.jpg' } as photoAccessHelper.PhotoAsset,\n    { uri: 'file://image3.jpg' } as photoAccessHelper.PhotoAsset\n  ];\n\n  setSelected(index: number) {\n    this.selected = index;\n  }\n\n  getSelected(): number {\n    return this.selected;\n  }\n\n  getImages() {\n    return this.imagesData;\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ImagePickerLogic } from '../main/ets/utils/ImagePickerLogic';\n\nexport default function imagePickerLogicTest() {\n  describe('ImagePickerLogic_Basic_Functionality', () => {\n    it('should_initialize_with_default_selected_index', 0, () => {\n      const logic = new ImagePickerLogic();\n      expect(logic.getSelected()).assertEqual(0);\n    });\n\n    it('should_update_selected_index_when_setSelected_called', 0, () => {\n      const logic = new ImagePickerLogic();\n      logic.setSelected(2);\n      expect(logic.getSelected()).assertEqual(2);\n    });\n\n    it('should_return_all_images', 0, () => {\n      const logic = new ImagePickerLogic();\n      const images = logic.getImages();\n      expect(images.length).assertEqual(3);\n      expect(images[0].uri).assertEqual('file://image1.jpg');\n    });\n  });\n}",
      "model_output": "import {ImagePickerLogic} from '../main/ets/utils/ImagePickerLogic';\n\nexport class ImagePickerLogic {\n  private selected: number;\n  private imagesData: photoAccessHelper.PhotoAsset[];\n\n  constructor() {\n    this.selected = 0;\n    this.imagesData = [\n      { uri: 'file://image1.jpg' },\n      { uri: 'file://image2.jpg' },\n      { uri: 'file://image3.jpg' }\n    ];\n  }\n\n  public setSelected(index: number): void {\n    this.selected = index;\n  }\n\n  public getSelected(): number {\n    return this.selected;\n  }\n\n  public getImages(): photoAccessHelper.PhotoAsset[] {\n    return this.imagesData;\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a class named GameRules to implement the rules of a 3x3 sliding puzzle game. Define a Tile interface with index: number and optional isEmpty: boolean. The class should have methods to initialize tiles (initTiles()), shuffle them (shuffle(tiles: Tile[])), move a tile if it is adjacent to the empty tile (move(i: number, tiles: Tile[])), and swap a tile with the empty tile internally. Include private helper methods to create an empty tile, find the empty tile index, and handle tile swaps. Ensure the empty tile is represented with isEmpty: true and index = -1.",
      "code": "export interface Tile {\n  index: number;\n  isEmpty?: boolean;\n}\n\nexport class GameRules {\n  private static EMPTY_INDEX = -1;\n\n  private static createEmptyTile(): Tile {\n    return { index: GameRules.EMPTY_INDEX, isEmpty: true };\n  }\n\n  private findEmptyIndex(tiles: Tile[]): number {\n    return tiles.findIndex(tile => tile.isEmpty);\n  }\n\n  private swapWithEmpty(i: number, tiles: Tile[]): Tile[] {\n    const emptyIndex = this.findEmptyIndex(tiles);\n    if (emptyIndex < 0) return tiles;\n\n    const temp = tiles[i];\n    tiles[i] = GameRules.createEmptyTile();\n    tiles[emptyIndex] = { index: temp.index, isEmpty: false };\n    return tiles;\n  }\n\n  move(i: number, tiles: Tile[]): Tile[] {\n    const emptyIndex = this.findEmptyIndex(tiles);\n    if (emptyIndex < 0) return tiles;\n\n    const row = Math.floor(emptyIndex / 3);\n    const col = emptyIndex % 3;\n\n    const neighbors: number[] = [];\n    if (col > 0) neighbors.push(emptyIndex - 1);\n    if (col < 2) neighbors.push(emptyIndex + 1);\n    if (row > 0) neighbors.push(emptyIndex - 3);\n    if (row < 2) neighbors.push(emptyIndex + 3);\n\n    if (neighbors.includes(i)) {\n      return this.swapWithEmpty(i, tiles);\n    }\n    return tiles;\n  }\n\n  shuffle(tiles: Tile[]): Tile[] {\n    let len = tiles.length;\n    while (len > 0) {\n      const index = Math.floor(Math.random() * len);\n      const temp = tiles[len - 1];\n      tiles[len - 1] = tiles[index];\n      tiles[index] = temp;\n      len--;\n    }\n    return tiles;\n  }\n\n  initTiles(): Tile[] {\n    const tiles: Tile[] = [];\n    for (let i = 0; i < 8; i++) {\n      tiles.push({ index: i });\n    }\n    tiles.push(GameRules.createEmptyTile());\n    return tiles;\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { GameRules, Tile } from '../main/ets/utils/GameRules';\n\nexport default function gameRulesTest() {\n  describe('GameRules_BasicTest', () => {\n\n    it('should_initialize_tiles_correctly', 0, () => {\n      const game = new GameRules();\n      const tiles: Tile[] = game.initTiles();\n      expect(tiles.length).assertEqual(9);\n      expect(tiles[8].isEmpty).assertEqual(true);\n      for (let i = 0; i < 8; i++) {\n        expect(tiles[i].isEmpty || false).assertEqual(false);\n      }\n    });\n\n    it('should_shuffle_tiles', 0, () => {\n      const game = new GameRules();\n      let tiles: Tile[] = game.initTiles();\n      tiles = game.shuffle(tiles);\n      expect(tiles.length).assertEqual(9);\n      const emptyCount = tiles.filter(tile => tile.isEmpty).length;\n      expect(emptyCount).assertEqual(1);\n    });\n\n    it('should_move_tile_adjacent_to_empty', 0, () => {\n      const game = new GameRules();\n      const tiles: Tile[] = game.initTiles();\n      const emptyIndex = tiles.findIndex(t => t.isEmpty);\n      expect(emptyIndex).assertEqual(8);\n      const newTiles = game.move(7, tiles);\n      expect(newTiles[7].isEmpty).assertEqual(true);\n      expect(newTiles[8].isEmpty || false).assertEqual(false);\n    });\n\n    it('should_not_move_tile_not_adjacent_to_empty', 0, () => {\n      const game = new GameRules();\n      const tiles: Tile[] = game.initTiles();\n      const newTiles = game.move(0, tiles);\n      expect(newTiles[8].isEmpty).assertEqual(true);\n      expect(newTiles[0].isEmpty || false).assertEqual(false);\n    });\n\n  });\n}",
      "model_output": "import {EventTarget} from '@kit.ArkTS';\ntype CustomEventInit = EventTarget.CustomEventInit;\n\nexport class CustomEvent extends EventTarget.CustomEvent {\n  constructor(type: string, eventInitDict: CustomEventInit) {\n    super(type, eventInitDict);\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a class named RefreshableTimer to implement a refreshable timer. The class should have a private timerId, a timeout number, a callback function, and a boolean isActive to track whether the timer is running. Implement the following methods:\n\nstart(): starts the timer, calls the callback after the timeout, and sets isActive appropriately.\n\nclear(): cancels the timer and sets isActive to false.\n\nrefresh(): clears and restarts the timer.\n\nisRunning(): boolean: returns whether the timer is currently active.",
      "code": "export class RefreshableTimer {\n  private timerId?: number;\n  private readonly timeout: number;\n  private callback: () => void;\n  private isActive: boolean = false;\n\n  constructor(callback: () => void, timeout: number) {\n    this.callback = callback;\n    this.timeout = timeout;\n  }\n\n  start(): void {\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.isActive = false;\n    }, this.timeout);\n    this.isActive = true;\n  }\n\n  clear(): void {\n    clearTimeout(this.timerId);\n    this.timerId = undefined;\n    this.isActive = false;\n  }\n\n  refresh(): void {\n    this.clear();\n    this.start();\n  }\n\n  isRunning(): boolean {\n    return this.isActive;\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport {RefreshableTimer} from '../main/ets/utils/RefreshableTimer';\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise<void>((resolve) => setTimeout(resolve, ms));\n}\n\nexport default function refreshableTimerTest() {\n  describe('RefreshableTimerBasicTest', () => {\n\n    it('should_start_timer_and_be_running', 0, async () => {\n      let called = false;\n      const timer = new RefreshableTimer(() => {\n        called = true;\n      }, 100);\n\n      timer.start();\n      expect(timer.isRunning()).assertEqual(true);\n      await sleep(150);\n      expect(called).assertEqual(true);\n      expect(timer.isRunning()).assertEqual(false);\n    });\n\n    it('should_clear_timer', 0, async () => {\n      let called = false;\n      const timer = new RefreshableTimer(() => {\n        called = true;\n      }, 100);\n\n      timer.start();\n      timer.clear();\n\n      expect(timer.isRunning()).assertEqual(false);\n      await sleep(150);\n      expect(called).assertEqual(false);\n    });\n\n    it('should_refresh_timer', 0, async () => {\n      let called = false;\n      const timer = new RefreshableTimer(() => {\n        called = true;\n      }, 100);\n\n      timer.start();\n      await sleep(50);\n      timer.refresh();\n      await sleep(70);\n      expect(called).assertEqual(false);\n      await sleep(50);\n      expect(called).assertEqual(true);\n      expect(timer.isRunning()).assertEqual(false);\n    });\n\n  });\n}",
      "model_output": "import {Timer} from '@kit.ArkTS';\n\nexport class RefreshableTimer {\n  private timerId: number | null = null;\n  private timeout: number;\n  private callback: () => void;\n  private isActive: boolean = false;\n\n  constructor(callback: () => void, timeout: number) {\n    this.callback = callback;\n    this.timeout = timeout;\n  }\n\n  public start(): void {\n    if (this.isActive) {\n      return;\n    }\n    this.timerId = setTimeout(() => {\n      this.callback();\n      this.isActive = false;\n    }, this.timeout);\n    this.isActive = true;\n  }\n\n  public clear(): void {\n    if (this.timerId!== null) {\n      clearTimeout(this.timerId);\n      this.timerId = null;\n    }\n    this.isActive = false;\n  }\n\n  public refresh(): void {\n    this.clear();\n    this.start();\n  }\n\n  public isRunning(): boolean {\n    return this.isActive;\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a utility function named `getClampedChildPosition`. It should take three parameters: a `childSize` with `width` and `height`, a `parentSize` with `width` and `height`, and a `Point` with `x` and `y`. The function should calculate the top-left position (`left`, `top`) for placing the child centered at the given point, but clamp the position so the child always stays fully within the parent boundaries. Return an object `{ left, top }`.",
      "code": "import { Point } from '@ohos.UiTest';\n\nexport function getClampedChildPosition(childSize: Size, parentSize: Size, point: Point): Edges {\n  // center point\n  let left = point.x - childSize.width / 2;\n  let top = point.y - childSize.height / 2;\n  // limit in left\n  if (left < 0) {\n    left = 0;\n  }\n  // limit in right\n  if (left + childSize.width > parentSize.width) {\n    left = parentSize.width - childSize.width;\n  }\n  // limit in top\n  if (top < 0) {\n    top = 0;\n  }\n  // limit in bottom\n  if (top + childSize.height > parentSize.height) {\n    top = parentSize.height - childSize.height;\n  }\n  return { left, top };\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { Point } from '@ohos.UiTest';\nimport { getClampedChildPosition } from '../main/ets/utils/GetClampedChildPosition'; \n\nexport default function PositionTest() {\n\n  describe('getClampedChildPosition_Test', () => {\n\n    it('should_center_child_when_point_is_inside_parent', 0, () => {\n      const childSize: Size = { width: 50, height: 50 };\n      const parentSize: Size = { width: 200, height: 200 };\n      const point: Point = { x: 100, y: 100 };\n\n      const result = getClampedChildPosition(childSize, parentSize, point);\n      expect(result.left).assertEqual(75); // 100 - 50/2\n      expect(result.top).assertEqual(75);  // 100 - 50/2\n    });\n\n    it('should_clamp_child_to_left_top_when_point_is_near_top_left', 0, () => {\n      const childSize: Size = { width: 50, height: 50 };\n      const parentSize: Size = { width: 200, height: 200 };\n      const point: Point = { x: 10, y: 10 };\n\n      const result = getClampedChildPosition(childSize, parentSize, point);\n      expect(result.left).assertEqual(0);\n      expect(result.top).assertEqual(0);\n    });\n\n    it('should_clamp_child_to_right_bottom_when_point_is_near_bottom_right', 0, () => {\n      const childSize: Size = { width: 50, height: 50 };\n      const parentSize: Size = { width: 200, height: 200 };\n      const point: Point = { x: 190, y: 190 };\n\n      const result = getClampedChildPosition(childSize, parentSize, point);\n      expect(result.left).assertEqual(150); // 200 - 50\n      expect(result.top).assertEqual(150);  // 200 - 50\n    });\n\n  });\n\n}",
      "model_output": "import {Point, Size} from '@kit.TestKit';\n\nexport function getClampedChildPosition(childSize: Size, parentSize: Size, point: Point): {left: number, top: number} {\n  const halfWidth = childSize.width / 2;\n  const halfHeight = childSize.height / 2;\n  \n  let left = point.x - halfWidth;\n  let top = point.y - halfHeight;\n  \n  if (left < 0) {\n    left = 0;\n  } else if (left + childSize.width > parentSize.width) {\n    left = parentSize.width - childSize.width;\n  }\n  \n  if (top < 0) {\n    top = 0;\n  } else if (top + childSize.height > parentSize.height) {\n    top = parentSize.height - childSize.height;\n  }\n  \n  return {left, top};\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `findRangeIndex`. This function accepts a target number and an array of numbers. It should return the index of the range in which the target falls when the array is sorted in ascending order. If the target is greater than or equal to the maximum element, return the last index. If the array is empty or the target does not fall into any range, return -1.",
      "code": "export function findRangeIndex(target: number, arr: number[]): number {\n  if (arr.length === 0) {\n    return -1;\n  }\n  const sorted = [...arr].sort((a, b) => a - b);\n  if (target >= sorted[sorted.length - 1]) {\n    return sorted.length - 1;\n  }\n\n  for (let i = 0; i < sorted.length - 1; i++) {\n    if (target >= sorted[i] && target < sorted[i + 1]) {\n      return i;\n    }\n  }\n  return -1;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { findRangeIndex } from '../main/ets/utils/FindRangeIndex';\n\nexport default function findRangeIndexTest() {\n\n  describe('findRangeIndex_Test', () => {\n\n    it('should_return_correct_index_within_range', 0, () => {\n      const arr = [10, 20, 30, 40];\n      const result = findRangeIndex(25, arr);\n      expect(result).assertEqual(1);\n    });\n\n    it('should_return_last_index_when_target_is_greater_or_equal_max', 0, () => {\n      const arr = [10, 20, 30, 40];\n      const result = findRangeIndex(45, arr);\n      expect(result).assertEqual(3);\n    });\n\n    it('should_return_minus_one_when_array_is_empty', 0, () => {\n      const arr: number[] = [];\n      const result = findRangeIndex(10, arr);\n      expect(result).assertEqual(-1);\n    });\n\n  });\n}",
      "model_output": "import {FindRangeIndex} from '../main/ets/utils/FindRangeIndex';\n\nexport function findRangeIndex(target: number, arr: number[]): number {\n  if (arr.length === 0) {\n    return -1;\n  }\n  let left = 0;\n  let right = arr.length - 1;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  if (arr[left] >= target) {\n    return left;\n  }\n  return -1;\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `calCameraPoint`. This function accepts touch coordinates (`eventX` and `eventY`) and the display width and height. It should return a normalized `camera.Point` corresponding to the touch position, taking into account the display's current rotation (0, 90, 180, or 270 degrees). The returned `x` and `y` values should be calculated according to the rotation so that they map correctly to the camera coordinate system.",
      "code": "import { camera } from '@kit.CameraKit';\nimport { display } from '@kit.ArkUI';\nexport function calCameraPoint(eventX: number, eventY: number, width: number, height: number): camera.Point {\n  const displayRotation = display.getDefaultDisplaySync().rotation * 90;\n  if (displayRotation === 0) {\n    return { x: eventY / height, y: 1 - eventX / width };\n  }\n  if (displayRotation === 90) {\n    return { x: 1 - eventX / width, y: 1 - eventY / height };\n  }\n  if (displayRotation === 180) {\n    return { x: 1 - eventY / height, y: eventX / width };\n  }\n  return { x: eventX / width, y: eventY / height };\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { calCameraPoint } from '../main/ets/utils/CalCameraPoint';\nimport { camera } from '@kit.CameraKit';\nimport { display } from '@kit.ArkUI';\n\nexport default function calCameraPointTest() {\n\n  describe('calCameraPoint_Test', () => {\n    it('should_return_correct_point_for_sample_touch', 0, () => {\n\n      const width = 200;\n      const height = 400;\n\n      const eventX = 50;\n      const eventY = 100;\n\n      const rotation = display.getDefaultDisplaySync().rotation;\n      const displayRotation = rotation * 90;\n      const result: camera.Point = calCameraPoint(eventX, eventY, width, height);\n      let expected: camera.Point;\n      if (displayRotation === 0) {\n        expected = { x: eventY / height, y: 1 - eventX / width };\n      } else if (displayRotation === 90) {\n        expected = { x: 1 - eventX / width, y: 1 - eventY / height };\n      } else if (displayRotation === 180) {\n        expected = { x: 1 - eventY / height, y: eventX / width };\n      } else {\n        expected = { x: eventX / width, y: eventY / height };\n      }\n\n      expect(result.x).assertEqual(expected.x);\n      expect(result.y).assertEqual(expected.y);\n    });\n\n  });\n}",
      "model_output": "import {camera} from '@kit.CameraKit';\nimport {display} from '@kit.ArkUI';\n\nexport function calCameraPoint(eventX: number, eventY: number, width: number, height: number): camera.Point {\n  const rotation = display.getDefaultDisplaySync().rotation;\n  const displayRotation = rotation * 90;\n  let x: number;\n  let y: number;\n  \n  if (displayRotation === 0) {\n    x = eventY / height;\n    y = 1 - eventX / width;\n  } else if (displayRotation === 90) {\n    x = 1 - eventX / width;\n    y = 1 - eventY / height;\n  } else if (displayRotation === 180) {\n    x = 1 - eventY / height;\n    y = eventX / width;\n  } else {\n    x = eventX / width;\n    y = eventY / height;\n  }\n  \n  return { x, y };\n}",
      "test_passed": true
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a class named `PermissionManager`. This class should provide a static asynchronous method `request` that accepts an array of `Permissions` and a `Context`. It should request each permission from the user using `abilityAccessCtrl.AtManager`. If any permission is denied, it should attempt to request it again via system settings. If the permission is still denied, the method should throw an error indicating the permission was denied.",
      "code": "import { abilityAccessCtrl, Context, Permissions } from '@kit.AbilityKit';\n\nexport class PermissionManager {\n  private static atManager: abilityAccessCtrl.AtManager = abilityAccessCtrl.createAtManager();\n\n  static async request(permissions: Permissions[], context: Context) {\n    const data = await PermissionManager.atManager.requestPermissionsFromUser(context, permissions);\n    const grantStatus: number[] = data.authResults;\n    const deniedPermissions = permissions.filter((_, i) => grantStatus[i] !== 0);\n    for (const permission of deniedPermissions) {\n      const secondGrantStatus = await PermissionManager.atManager.requestPermissionOnSetting(context, [permission]);\n      if (secondGrantStatus[0] !== 0) {\n        throw new Error('permission denied');\n      }\n    }\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { PermissionManager } from '../main/ets/utils/PermissionManager';\nimport { Context, Permissions } from '@kit.AbilityKit';\n\nexport default function permissionManagerTest() {\n  describe('PermissionManager_request_Basic_Test', () => {\n\n    it('should_call_request_without_crash', 0, async () => {\n      const context = {} as Context;\n      const permissions: Permissions[] = [];\n      let errorOccurred = false;\n      try {\n        await PermissionManager.request(permissions, context);\n      } catch (e) {\n        errorOccurred = true;\n      }\n      expect(errorOccurred).assertEqual(false);\n    });\n\n    it('should_throw_error_when_invalid_permission', 0, async () => {\n      const context = {} as Context;\n      const permissions: Permissions[] = ['INVALID_PERMISSION' as Permissions];\n      let errorOccurred = false;\n      try {\n        await PermissionManager.request(permissions, context);\n      } catch (e) {\n        errorOccurred = true;\n      }\n      expect(errorOccurred).assertEqual(true);\n    });\n\n  });\n}",
      "model_output": "import {abilityAccessCtrl} from '@kit.AbilityKit';\n\nexport class PermissionManager {\n  static async request(permissions: Permissions[], context: Context): Promise<void> {\n    const atManager = abilityAccessCtrl.AtManager;\n    for (const perm of permissions) {\n      try {\n        await atManager.requestPermissionsFromUser(context, [perm]);\n      } catch (e) {\n        const deniedPermission = perm;\n        const intent = atManager.createPermissionDeniedIntent(context, deniedPermission);\n        await atManager.startAbility(intent);\n        const result = await atManager.requestPermissionsFromUser(context, [perm]);\n        if (result.length === 0) {\n          throw new Error(`Permission ${deniedPermission} was denied.`);\n        }\n      }\n    }\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, define two interfaces and two functions. The `ColorRgb` interface has `red`, `green`, `blue` (0–255) and `alpha` (0–255). The `ColorHsv` interface has `hue` (0–360), `saturation` (0–1), `value` (0–1), and `alpha` (0–255). Implement `rgb2hsv` to convert a `ColorRgb` to `ColorHsv`, and `hsv2rgb` to convert a `ColorHsv` back to `ColorRgb`, with correct conversion, rounding, and alpha preserved.",
      "code": "export interface ColorRgb {\n  red: number;   // 0 - 255\n  green: number; // 0 - 255\n  blue: number;  // 0 - 255\n  alpha: number; // 0 - 255\n}\n\nexport interface ColorHsv {\n  hue: number;        // 0 - 360\n  saturation: number; // 0 - 1\n  value: number;      // 0 - 1\n  alpha: number;      // 0 - 255\n}\n\nexport function rgb2hsv(color: ColorRgb): ColorHsv {\n  const r = color.red / 255;\n  const g = color.green / 255;\n  const b = color.blue / 255;\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const delta = max - min;\n\n  let h = 0;\n  if (delta !== 0) {\n    if (max === r) {\n      h = 60 * (((g - b) / delta) % 6);\n    } else if (max === g) {\n      h = 60 * ((b - r) / delta + 2);\n    } else {\n      h = 60 * ((r - g) / delta + 4);\n    }\n  }\n  if (h < 0) {\n    h += 360;\n  }\n\n  const s = max === 0 ? 0 : delta / max;\n  const v = max;\n\n  return { hue: h, saturation: s, value: v, alpha: color.alpha };\n}\n\nexport function hsv2rgb(color: ColorHsv): ColorRgb {\n  const c = color.value * color.saturation;\n  const x = c * (1 - Math.abs(((color.hue / 60) % 2) - 1));\n  const m = color.value - c;\n\n  let r = 0, g = 0, b = 0;\n  if (color.hue < 60) {\n    r = c; g = x; b = 0;\n  } else if (color.hue < 120) {\n    r = x; g = c; b = 0;\n  } else if (color.hue < 180) {\n    r = 0; g = c; b = x;\n  } else if (color.hue < 240) {\n    r = 0; g = x; b = c;\n  } else if (color.hue < 300) {\n    r = x; g = 0; b = c;\n  } else {\n    r = c; g = 0; b = x;\n  }\n\n  return {\n    red: Math.round((r + m) * 255),\n    green: Math.round((g + m) * 255),\n    blue: Math.round((b + m) * 255),\n    alpha: color.alpha\n  };\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { rgb2hsv, hsv2rgb, ColorRgb, ColorHsv } from '../main/ets/utils/ColorUtils';\n\nexport default function colorUtilsTest() {\n\n  describe('ColorUtils_Test', () => {\n\n    it('should_convert_rgb_red_to_hsv_and_back', 0, () => {\n      const rgb: ColorRgb = { red: 255, green: 0, blue: 0, alpha: 255 };\n      const hsv: ColorHsv = rgb2hsv(rgb);\n      const rgbBack: ColorRgb = hsv2rgb(hsv);\n\n      expect(hsv.hue).assertEqual(0);\n      expect(hsv.saturation).assertEqual(1);\n      expect(Math.round(hsv.value)).assertEqual(1);\n\n      expect(rgbBack.red).assertEqual(255);\n      expect(rgbBack.green).assertEqual(0);\n      expect(rgbBack.blue).assertEqual(0);\n    });\n\n    it('should_convert_rgb_green_to_hsv_and_back', 0, () => {\n      const rgb: ColorRgb = { red: 0, green: 255, blue: 0, alpha: 255 };\n      const hsv: ColorHsv = rgb2hsv(rgb);\n      const rgbBack: ColorRgb = hsv2rgb(hsv);\n\n      expect(Math.round(hsv.hue)).assertEqual(120);\n      expect(hsv.saturation).assertEqual(1);\n      expect(Math.round(hsv.value)).assertEqual(1);\n\n      expect(rgbBack.red).assertEqual(0);\n      expect(rgbBack.green).assertEqual(255);\n      expect(rgbBack.blue).assertEqual(0);\n    });\n\n    it('should_convert_rgb_blue_to_hsv_and_back', 0, () => {\n      const rgb: ColorRgb = { red: 0, green: 0, blue: 255, alpha: 255 };\n      const hsv: ColorHsv = rgb2hsv(rgb);\n      const rgbBack: ColorRgb = hsv2rgb(hsv);\n\n      expect(Math.round(hsv.hue)).assertEqual(240);\n      expect(hsv.saturation).assertEqual(1);\n      expect(Math.round(hsv.value)).assertEqual(1);\n\n      expect(rgbBack.red).assertEqual(0);\n      expect(rgbBack.green).assertEqual(0);\n      expect(rgbBack.blue).assertEqual(255);\n    });\n  });\n}",
      "model_output": "import {ColorRgb, ColorHsv} from '@kit.ArkTS';\n\nexport function rgb2hsv(rgb: ColorRgb): ColorHsv {\n  const { red, green, blue, alpha } = rgb;\n  let { hue, saturation, value } = rgb;\n\n  const max = Math.max(red, green, blue);\n  const min = Math.min(red, green, blue);\n  const delta = max - min;\n\n  value = max / 255;\n  saturation = max === 0? 0 : delta / max;\n\n  if (delta === 0) {\n    hue = 0;\n  } else {\n    const d = (max - min) / 6;\n    switch (max) {\n      case red:\n        hue = ((green - blue) / d + 6) % 6;\n        break;\n      case green:\n        hue = (blue - red) / d + 2;\n        break;\n      case blue:\n        hue = (red - green) / d + 4;\n        break;\n    }\n    hue *= 60;\n    if (hue < 0) {\n      hue += 360;\n    }\n  }\n\n  return { hue, saturation, value, alpha };\n}\n\nexport function hsv2rgb(hsv: ColorHsv): ColorRgb {\n  const { hue, saturation, value, alpha } = hsv;\n  const { red, green, blue } = hsv;\n\n  if (saturation === 0) {\n    red = green = blue = Math.round(value * 255);\n  } else {\n    const h = hue / 60;\n    const i = Math.floor(h);\n    const f = h - i;\n    const p = value * (1 - saturation);\n    const q = value * (1 - saturation * f);\n    const t = value * (1 - saturation * (1 - f));\n\n    switch (i) {\n      case 0:\n        red = Math.round(value * 255);\n        green = Math.round(t * 255);\n        blue = Math.round(p * 255);\n        break;\n      case 1:\n        red = Math.round(q * 255);\n        green = Math.round(value * 255);\n        blue = Math.round(p * 255);\n        break;\n      case 2:\n        red = Math.round(p * 255);\n        green = Math.round(value * 255);\n        blue = Math.round(t * 255);\n        break;\n      case 3:\n        red = Math.round(p * 255);\n        green = Math.round(q * 255);\n        blue = Math.round(value * 255);\n        break;\n      case 4:\n        red = Math.round(t * 255);\n        green = Math.round(p * 255);\n        blue = Math.round(value * 255);\n        break;\n      case 5:\n        red = Math.round(value * 255);\n        green = Math.round(p * 255);\n        blue = Math.round(q * 255);\n        break;\n    }\n  }\n\n  return { red, green, blue, alpha };\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `traverseAllPixel`. This function accepts a `Uint8Array` representing RGBA image data. It should iterate over every 4 bytes (representing a pixel) and convert each non-transparent pixel into a single number using the formula `(a << 24) | (r << 16) | (g << 8) | b`. Transparent pixels (all channels zero) should be skipped. The function should return an array of these pixel numbers.",
      "code": "function rgbToNumber(r: number, g: number, b: number, a: number): number {\n  return (a << 24) | (r << 16) | (g << 8) | b;\n}\n\nexport function traverseAllPixel(unit8Pixels: Uint8Array): number[] {\n  const allPixels: number[] = [];\n  for (let i = 0; i < unit8Pixels.length; i += 4) {\n    if (unit8Pixels[i] === 0 && unit8Pixels[i+1] === 0 && unit8Pixels[i+2] === 0 && unit8Pixels[i+3] === 0) continue;\n    allPixels.push(rgbToNumber(unit8Pixels[i+2], unit8Pixels[i+1], unit8Pixels[i], unit8Pixels[i+3]));\n  }\n  return allPixels;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { traverseAllPixel } from '../main/ets/utils/TraverseAllPixel';\n\nexport default function traverseAllPixelTest() {\n\n  describe('traverseAllPixel_Test', () => {\n\n    it('should_return_correct_pixel_numbers', 0, () => {\n      const fakePixels = new Uint8Array([\n        255,0,0,255,\n        0,255,0,255,\n        0,0,0,0,\n        0,0,255,255\n      ]);\n\n      const allPixels = traverseAllPixel(fakePixels);\n      expect(allPixels.length).assertEqual(3);\n      const firstPixelNumber = (255 << 24) | (0 << 16) | (0 << 8) | 255; // a<<24 | r<<16 | g<<8 | b\n      expect(allPixels[0]).assertEqual(firstPixelNumber);\n    });\n\n    it('should_ignore_all_zero_pixels', 0, () => {\n      const zeroPixels = new Uint8Array([\n        0,0,0,0, 0,0,0,0\n      ]);\n      const result = traverseAllPixel(zeroPixels);\n      expect(result.length).assertEqual(0);\n    });\n\n  });\n}",
      "model_output": "import {traverseAllPixel} from '../main/ets/utils/TraverseAllPixel';\n\nexport function traverseAllPixel(pixels: Uint8Array): number[] {\n  const result: number[] = [];\n  for (let i = 0; i < pixels.length; i += 4) {\n    const a = pixels[i];\n    const r = pixels[i + 1];\n    const g = pixels[i + 2];\n    const b = pixels[i + 3];\n    if (a > 0) {\n      const pixelNumber = (a << 24) | (r << 16) | (g << 8) | b;\n      result.push(pixelNumber);\n    }\n  }\n  return result;\n}",
      "test_passed": false
    },
    {
      "instruction": "Using the HarmonyOS ArkTS language, write a function named `handleStyledString`. This function accepts an array of `MutableStyledString` objects, concatenates them in order using `appendStyledString`, and returns a single merged `MutableStyledString`. If the input array is empty, it should return an empty `MutableStyledString`.",
      "code": "export function handleStyledString(styledStrings: MutableStyledString[]): MutableStyledString {\n  let paragraphStyledString: MutableStyledString = new MutableStyledString('', []);\n  styledStrings.forEach((mutableStyledString: MutableStyledString) => {\n    paragraphStyledString.appendStyledString(mutableStyledString);\n  });\n  return paragraphStyledString;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { handleStyledString } from '../main/ets/utils/HandleData';\n\nexport default function handleStyledStringTest() {\n\n  describe('handleStyledString_Test', () => {\n\n    it('should_return_empty_string_when_input_is_empty', 0, () => {\n      const result = handleStyledString([]);\n      expect(result.getString()).assertEqual('');\n    });\n\n    it('should_merge_two_simple_strings', 0, () => {\n      const s1 = new MutableStyledString('Hello', []);\n      const s2 = new MutableStyledString(' World', []);\n      const result = handleStyledString([s1, s2]);\n      expect(result.getString()).assertEqual('Hello World');\n    });\n\n    it('should_merge_multiple_strings_with_styles', 0, () => {\n      const s1 = new MutableStyledString('A', []);\n      const s2 = new MutableStyledString('B',[]);\n      const s3 = new MutableStyledString('C', []);\n      const result = handleStyledString([s1, s2, s3]);\n      expect(result.getString()).assertEqual('ABC');\n    });\n\n  });\n}",
      "model_output": "import { MutableStyledString } from '@kit.TestKit';\n\nexport function handleStyledString(strings: MutableStyledString[]): MutableStyledString {\n  const result = new MutableStyledString('', []);\n  for (const str of strings) {\n    result.appendStyledString(str);\n  }\n  return result;\n}",
      "test_passed": false
    },
    {
      "instruction": "Using HarmonyOS ArkTS, implement a utility class `ByteUtil` with the following static methods: (1) `strNormalToUint8Array(str: string)` – convert a normal string to `Uint8Array`; (2) `strHexToUint8Array(data: string)` – convert a hex string to `Uint8Array`, ignoring any '\\t' characters in the input; (3) `uint8ArrayToShowStrHex(data: Uint8Array)` – convert a `Uint8Array` to a continuous uppercase hex string; (4) `uint8ArrayToShowStrNormal(data: Uint8Array)` – convert a `Uint8Array` to an uppercase hex string with each byte separated by a '\\t'; (5) `numArrayToShowStrNormal(data: number[])` – convert a number array to an uppercase hex string with each number separated by a '\\t'.",
      "code": "import { buffer } from '@kit.ArkTS';\n\nexport class ByteUtil {\n  private constructor() {}\n\n  static strNormalToUint8Array(str: string) {\n    return new Uint8Array(buffer.from(str, 'utf-8').buffer);\n  }\n\n  static strHexToUint8Array(data: string): Uint8Array {\n    data.replace('\\t', '');\n    return new Uint8Array(buffer.from(data, 'hex').buffer);\n  }\n\n  static uint8ArrayToShowStrHex(data: Uint8Array): string {\n    let hexString: string = '';\n    data.forEach((value: number) => {\n      hexString += value.toString(16).padStart(2, '0');\n    })\n    return hexString.toUpperCase();\n  }\n\n  static uint8ArrayToShowStrNormal(data: Uint8Array): string {\n    let hexString: string = '';\n    data.forEach((value: number) => {\n      if (hexString.length > 0) {\n        hexString += '\\t';\n      }\n      hexString += value.toString(16).padStart(2, '0');\n    })\n    return hexString.toUpperCase();\n  }\n\n  static numArrayToShowStrNormal(data: number[]): string {\n    let hexString: string = '';\n    data.forEach((value: number) => {\n      if (hexString.length > 0) {\n        hexString += '\\t';\n      }\n      hexString += value.toString(16).padStart(2, '0');\n    })\n    return hexString.toUpperCase();\n  }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { ByteUtil } from '../main/ets/utils/ByteUtils';\n\nexport default function byteUtilTest() {\n  describe('ByteUtil_Test', () => {\n\n    it('should_convert_string_to_uint8array_and_back', 0, () => {\n      const str = 'Hello';\n      const uint8Array = ByteUtil.strNormalToUint8Array(str);\n      const hexStr = ByteUtil.uint8ArrayToShowStrHex(uint8Array);\n      expect(uint8Array instanceof Uint8Array).assertEqual(true);\n      expect(hexStr.length > 0).assertEqual(true);\n    });\n\n    it('should_convert_hex_string_to_uint8array', 0, () => {\n      const hexStr = '1a1b2b';\n      const uint8Array = ByteUtil.strHexToUint8Array(hexStr);\n      const resultHex = ByteUtil.uint8ArrayToShowStrHex(uint8Array);\n      expect(resultHex).assertEqual(hexStr.toUpperCase());\n    });\n\n    it('should_convert_uint8array_to_show_str_hex', 0, () => {\n      const uint8Array = new Uint8Array([0x1a, 0x1b, 0x2b]);\n      const result = ByteUtil.uint8ArrayToShowStrHex(uint8Array);\n      expect(result).assertEqual('1A1B2B');\n    });\n\n    it('should_convert_uint8array_to_show_str_normal_with_tabs', 0, () => {\n      const uint8Array = new Uint8Array([0x1a, 0x1b, 0x2b]);\n      const result = ByteUtil.uint8ArrayToShowStrNormal(uint8Array);\n      expect(result).assertEqual('1A\\t1B\\t2B');\n    });\n\n    it('should_convert_numarray_to_show_str_normal_with_tabs', 0, () => {\n      const numArray = [0x1a, 0x1b, 0x2b];\n      const result = ByteUtil.numArrayToShowStrNormal(numArray);\n      expect(result).assertEqual('1A\\t1B\\t2B');\n    });\n\n  });\n}",
      "model_output": "import {util} from '@kit.ArkTS';\ntype ByteUtil = util.ByteUtil;\n\nexport class ByteUtil {\n  public static strNormalToUint8Array(str: string): Uint8Array {\n    return new Uint8Array(str.split('').map(char => char.charCodeAt(0)));\n  }\n\n  public static strHexToUint8Array(data: string): Uint8Array {\n    return new Uint8Array(data.split('').filter(char => char!== '\\t').map(char => parseInt(char, 16)));\n  }\n\n  public static uint8ArrayToShowStrHex(data: Uint8Array): string {\n    return Array.from(data).map(byte => byte.toString(16).toUpperCase()).join('');\n  }\n\n  public static uint8ArrayToShowStrNormal(data: Uint8Array): string {\n    return Array.from(data).map(byte => byte.toString(16).toUpperCase()).join('\\t');\n  }\n\n  public static numArrayToShowStrNormal(data: number[]): string {\n    return data.map(num => num.toString(16).toUpperCase()).join('\\t');\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Given two arrays of numbers representing the set scores of two volleyball teams (where each element is a positive integer representing the number of points in a set), write a function determineVolleyballWinner using ArkTS that returns the team number (1 or 2) that wins the match, or 0 if the match is invalid. A team wins the match by winning at least 3 sets, with a maximum of 5 sets played. Additionally, each set must be won by at least 2 points (e.g., 25-23 is valid, but 25-24 is not). You must use ArkTS-specific syntax and structures, including proper type annotations. The function should return 0 for invalid matches (e.g., incorrect number of sets, sets not won by 2 points, or both teams winning 3 sets).",
      "code": "export function judgeVolleyballWinner(teamA: number, teamB: number): string {\n // check_input_validity\n if (teamA < 0 || teamB < 0 || !Number.isInteger(teamA) || !Number.isInteger(teamB)) {\n throw new Error(\"please_enter_non-negative_integer_scores\");\n }\n\n // victory_condition:_reach_at_least_25_points_and_lead_by_at_least_2_points\n if (teamA >= 25 && teamA - teamB >= 2) {\n return \"A\";\n }\n if (teamB >= 25 && teamB - teamA >= 2) {\n return \"B\";\n }\n\n // victory_conditions_not_met\n return \"\";\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { judgeVolleyballWinner } from '../main/ets/pages/VolleyballJudge';\nexport default function loggerTest() {\n describe('judgeVolleyballTest', () => {\n it('Team_A_wins_with_25_points_and_a_2-point_lead', { timeout: 5000 }, () => { // adjust_parameter_order\n expect(judgeVolleyballWinner(25, 23)).assertEqual('A');\n });\n it('Team_B_has_25_points_but_does_not_meet_the_2-point_difference', { timeout: 5000 }, () => {\n expect(judgeVolleyballWinner(24, 25)).assertEqual('');\n });\n it('Win_in_tiebreaker_with_27-25', { timeout: 5000 }, () => {\n expect(judgeVolleyballWinner(27, 25)).assertEqual('A');\n });\n });\n}",
      "model_output": "import { judgeVolleyballWinner } from '../main/ets/pages/VolleyballJudge';\n\nexport function determineVolleyballWinner(setScores: number[], teamScores: number[]): number {\n  if (setScores.length!== 2 || teamScores.length!== 2) {\n    return 0;\n  }\n  \n  const teamA = teamScores[0];\n  const teamB = teamScores[1];\n  \n  if (teamA >= 3 && teamB < 3) {\n    return 1;\n  } else if (teamB >= 3 && teamA < 3) {\n    return 2;\n  } else if (teamA >= 3 && teamB >= 3) {\n    return 0;\n  } else {\n    return 0;\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a string representing a password, write a function evaluatePasswordStrength using ArkTS that returns a number indicating the password strength on a scale of 0 to 4. The strength criteria are as follows: 0 - extremely weak (length less than 6 characters); 1 - weak (length 6+ but lacks complexity); 2 - moderate (length 8+ with at least one lowercase letter and one number); 3 - strong (length 10+ with lowercase, uppercase, and numbers); 4 - very strong (length 12+ with lowercase, uppercase, numbers, and special characters like !@#$%^&*). You must use ArkTS-specific syntax and structures, including proper type annotations. The function should accurately check all specified criteria to determine the appropriate strength level.",
      "code": "export function checkPasswordStrength(password: string): number {\n if (!password) return 0; // no_password_entered\n\n // initialize_flags\n let hasNumber: boolean = false\n let hasLetter: boolean = false\n let hasSpecialChar: boolean = false\n const length: number = password.length\n\n // check_character_types_in_password\n for (let i = 0; i < length; i++) {\n const char: string = password.charAt(i)\n\n if (/[0-9]/.test(char)) {\n hasNumber = true\n } else if (/[a-zA-Z]/.test(char)) {\n hasLetter = true\n } else if (/[!@#$%^&*(),.?\":{}|<>]/.test(char)) {\n hasSpecialChar = true\n }\n }\n\n // determine_password_strength_and_return_corresponding_flag_value\n if (length < 6) {\n // weak:_length_less_than_6_characters_only_numbers_or_only_letters\n if ((hasNumber && !hasLetter && !hasSpecialChar) ||\n (!hasNumber && hasLetter && !hasSpecialChar)) {\n return 1\n }\n } else if (length >= 6 && length <= 10) {\n // medium:_length_6-10_characters_including_numbers_and_letters\n if (hasNumber && hasLetter && !hasSpecialChar) {\n return 2\n }\n } else {\n // strong:_length_11_or_more_characters_including_numbers_letters_and_special_characters\n if (hasNumber && hasLetter && hasSpecialChar) {\n return 3\n }\n }\n\n // all_that_do_not_meet_the_above_conditions_are_classified_as_weak\n return 1\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { checkPasswordStrength } from '../main/ets/pages/passwordChecker';\nexport default function passwordTest() {\n describe('checkPasswordStrengthTest', () => {\n // test_weak_password_scenarios_(numbers_only)\n it('pure_numeric_password_with_length_less_than_6', { timeout: 5000 }, () => {\n expect(checkPasswordStrength('12345')).assertEqual(1);\n });\n\n // test_medium_strength_scenarios_(numbers_and_letters)\n it('8-digit_combination_of_numbers_and_letters', { timeout: 5000 }, () => {\n expect(checkPasswordStrength('abc123')).assertEqual(2);\n });\n\n // test_high_strength_scenarios_(long_passwords_with_special_characters)\n it('11-digit_password_containing_special_characters', { timeout: 5000 }, () => {\n expect(checkPasswordStrength('Abc123!@#456')).assertEqual(3);\n });\n });\n}",
      "model_output": "import {checkPasswordStrength} from '../main/ets/pages/passwordChecker';\n\nexport function evaluatePasswordStrength(password: string): number {\n  const hasLower = /[a-z]/.test(password);\n  const hasUpper = /[A-Z]/.test(password);\n  const hasNumber = /[0-9]/.test(password);\n  const hasSpecial = /[!@#$%^&*]/.test(password);\n  \n  if (password.length < 6) {\n    return 0;\n  } else if (password.length < 8) {\n    return 1;\n  } else if (password.length < 10) {\n    if (hasLower && hasNumber) {\n      return 2;\n    }\n    return 1;\n  } else if (password.length < 12) {\n    if (hasLower && hasUpper && hasNumber) {\n      return 3;\n    }\n    return 2;\n  } else {\n    if (hasLower && hasUpper && hasNumber && hasSpecial) {\n      return 4;\n    }\n    return 3;\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Given two positive integers representing the number of subway stations traveled (stationCount) and the base fare (baseFare, in yuan), along with an optional number representing the fare increment (incrementFare, default 1 yuan) and an optional integer representing the station interval for increment (incrementInterval, default 5 stations), write a function calculateSubwayFare using ArkTS that returns the total subway fare as a number. The fare calculation rule is: the base fare covers the first N stations (N = incrementInterval), and for each additional incrementInterval stations traveled beyond the base, the incrementFare is added. For example, if baseFare=3, incrementFare=1, incrementInterval=5, traveling 12 stations would cost 3 + 1*(Math.ceil((12-5)/5)) = 5 yuan. You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle invalid inputs (e.g., non-positive stationCount or baseFare) by returning 0.",
      "code": "export function calculateSubwayFare(stations: number): number {\n // ensure_the_number_of_stations_is_non-negative\n if (stations < 0) {\n throw new Error(\"the_number_of_stations_cannot_be_negative\");\n }\n\n // calculate_fare_according_to_rules\n if (stations <= 3) {\n return 3;\n } else if (stations <= 6) {\n return 4;\n } else {\n //_for_parts_exceeding_6_stations_add_1_yuan_for_every_3_stations\n const extraStations = stations - 6;\n const extraFare = Math.ceil(extraStations / 3);\n return 4 + extraFare;\n }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { calculateSubwayFare } from '../main/ets/pages/subwayFare';\nexport default function subwayFareTest() {\n describe('subwayFareTest', () => {\n // test_base_fare_for_up_to_3_stations\n it('3_stations_fare_3_yuan', { timeout: 5000 }, () => {\n expect(calculateSubwayFare(3)).assertEqual(3);\n });\n\n // test_mid_range_fare\n it('5_stations_fare_4_yuan', { timeout: 5000 }, () => {\n expect(calculateSubwayFare(5)).assertEqual(4);\n });\n\n // test_long_distance_pricing_rules\n it('10_stations_fare_6_yuan', { timeout: 5000 }, () => {\n expect(calculateSubwayFare(10)).assertEqual(6);\n });\n });\n}",
      "model_output": "import {Context} from '@kit.AbilityKit';\n\nexport function calculateSubwayFare(stationCount: number, baseFare: number, incrementFare: number = 1, incrementInterval: number = 5): number {\n  if (stationCount <= 0 || baseFare <= 0) {\n    return 0;\n  }\n  const fullIncrements = Math.ceil((stationCount - incrementInterval) / incrementInterval);\n  return baseFare + (fullIncrements * incrementFare);\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a positive number representing a length value (lengthValue), a string indicating the original unit (originalUnit, one of mm for millimeters, cm for centimeters, dm for decimeters, m for meters, km for kilometers) and a string indicating the target unit (targetUnit, same set of options as originalUnit), write a function convertLengthUnit using ArkTS that returns the converted length value as a number. The conversion rules are: 1km = 1000m, 1m = 10dm, 1dm = 10cm, 1cm = 10mm. For example, converting 500cm to m should return 5. You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle invalid inputs (e.g., non-positive lengthValue, originalUnit/targetUnit not in the specified set) by returning -1.",
      "code": "export function convertToMeter(value: number, unit: string): number {\n // verify_that_the_input_value_is_a_positive_number\n if (value < 0) {\n throw new Error(\"length_cannot_be_negative\");\n }\n\n // convert_based_on_unit\n switch (unit.toLowerCase()) {\n case \"mm\": // millimeters\n return value / 1000;\n case \"cm\": // centimeters\n return value / 100;\n case \"dm\": // decimeters\n return value / 10;\n case \"m\": // meters\n return value;\n case \"km\": // kilometers\n return value * 1000;\n case \"inch\": // inches\n return value * 0.0254;\n case \"ft\": // feet\n return value * 0.3048;\n default:\n throw new Error(\"unsupported_unit_please_use:_mm,_cm,_dm,_m,_km,_inch,_ft\");\n }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { convertToMeter } from '../main/ets/pages/lengthConverter';\nexport default function lengthConverterTest() {\n describe('lengthConverterTest', () => {\n // test_centimeter_unit_conversion\n it('convert_150_centimeters_to_meters', { timeout: 5000 }, () => {\n expect(convertToMeter(150, 'cm')).assertEqual(1.5);\n });\n\n // test_imperial_unit_conversion\n it('convert_3_feet_to_meters', { timeout: 5000 }, () => {\n expect(convertToMeter(3, 'ft')).assertEqual(0.9144000000000001);\n });\n\n // test_kilometer_unit_conversion\n it('convert_2.5_kilometers_to_meters', { timeout: 5000 }, () => {\n expect(convertToMeter(2.5, 'km')).assertEqual(2500);\n });\n });\n}",
      "model_output": "import {convertToMeter} from '../main/ets/pages/lengthConverter';\n\nexport function convertToMeter(lengthValue: number, originalUnit: string): number {\n  if (lengthValue <= 0 ||!['mm', 'cm', 'dm','m', 'km'].includes(originalUnit)) {\n    return -1;\n  }\n  \n  const conversionFactors: {[key: string]: number} = {\n   'mm': 0.001,\n    'cm': 0.01,\n    'dm': 0.1,\n   'm': 1,\n    'km': 1000\n  };\n  \n  return lengthValue * conversionFactors[originalUnit];\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a string input, write a function countLettersAndDigits using ArkTS that returns a 2-element Array<number> where the first element is the count of letters (a-z, A-Z) and the second element is the count of digits (0-9) in the input string. For example, inputting \"Hello123\" should return [5, 3]. You must use ArkTS-specific syntax and structures, including proper type annotations. The function should treat an empty string as returning [0, 0] and ignore any characters that are neither letters nor digits.",
      "code": "interface GeneratedTypeLiteralInterface_1 {\n letters: number;\n digits: number;\n}\n\nexport function countLettersAndDigits(str: string): GeneratedTypeLiteralInterface_1 {\n let letterCount = 0;\n let digitCount = 0;\n\n // iterate_through_each_character_in_the_string\n for (let i = 0; i < str.length; i++) {\n const char = str.charAt(i);\n\n // check_if_it_is_a_letter\n if (/[a-zA-Z]/.test(char)) {\n letterCount++;\n }\n // check_if_it_is_a_digit\n else if (/[0-9]/.test(char)) {\n digitCount++;\n }\n // ignore_other_characters\n }\n\n return { letters: letterCount, digits: digitCount };\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { countLettersAndDigits } from '../main/ets/pages/CountLettersDigits';\nexport default function countLettersTest() {\n describe('countLettersTest', () => {\n // test_mixed_content_scenario\n it('mixed_string_statistics', { timeout: 5000 }, () => {\n const result = countLettersAndDigits(\"Hello123!\");\n expect(result.letters).assertEqual(5);\n expect(result.digits).assertEqual(3);\n });\n\n // test_pure_letter_scenario\n it('pure_letter_statistics', { timeout: 5000 }, () => {\n const result = countLettersAndDigits(\"TestTest\");\n expect(result.letters).assertEqual(8);\n expect(result.digits).assertEqual(0);\n });\n\n // test_pure_digit_scenario\n it('pure_digit_statistics', { timeout: 5000 }, () => {\n const result = countLettersAndDigits(\"2024\");\n expect(result.letters).assertEqual(0);\n expect(result.digits).assertEqual(4);\n });\n });\n}",
      "model_output": "import {ArrayList} from '@kit.ArkTS';\n\nexport function countLettersAndDigits(input: string): [number, number] {\n  let letters = 0;\n  let digits = 0;\n  for (const char of input) {\n    if (char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z') {\n      letters++;\n    } else if (char >= '0' && char <= '9') {\n      digits++;\n    }\n  }\n  return [letters, digits];\n}",
      "test_passed": false
    },
    {
      "instruction": "Given two strings values representing times in the format HH:MM:SS (24-hour format), write a function calculateTimeDifference using ArkTS that returns a string representing the absolute difference between the two times in the same HH:MM:SS format. For example, inputting 08:30:00 and 09:45:30 should return 01:15:30. You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle invalid time formats or values (e.g., hours > 23, minutes/seconds > 59) by returning an empty string.",
      "code": "interface TimeDuration {\n sec: number;\n days: number;\n hours: number;\n minutes: number;\n seconds: number;\n}\n\n//time_difference_calculation_utility_function\nexport function calculateDuration (start: Date | string | number, end: Date | string | number): TimeDuration {\n //standardize_time_input\n const startDate = normalizeDate (start);\n const endDate = normalizeDate (end);\n\n //calculate_millisecond_difference\n const diffMs = Math.abs (endDate.getTime () - startDate.getTime ());\n\n //calculate_various_time_units\n const seconds = Math.floor (diffMs / 1000);\n const minutes = Math.floor (seconds / 60);\n const hours = Math.floor (minutes / 60);\n const days = Math.floor (hours / 24);\n return {\n days: days,\n hours: hours % 24,\n minutes: minutes % 60,\n seconds: seconds % 60,\n sec: seconds % 60\n };\n}\n\n//date_standardization_processing\nfunction normalizeDate (input: Date | string | number): Date {\n if (typeof input === 'string') {\n //process_string_format_date\n const standardized = input\n .replace (/[- 年月日]/g, '/')\n .replace (/[时分秒]/g, ':')\n .replace (/s+/g, ' ');\n return new Date (standardized);\n }\n\n if (typeof input === 'number') {\n //process_timestamp_(automatically_judge_seconds/milliseconds)\n const timestamp = input.toString ().length === 10 ? input * 1000 : input;\n return new Date (timestamp);\n }\n\n return input;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { calculateDuration } from '../main/ets/pages/TimeIntervalCalculator';\nexport default function timeIntervalTest() {\n describe('timeIntervalTest', () => {\n // test_cross-day_regular_scenario\n it('cross-day_calculation', { timeout: 5000 }, () => {\n const result = calculateDuration(\"2025-09-04 08:30:00\", new Date(2025, 8, 5, 12, 45, 15));\n expect(result.days).assertEqual(1);\n expect(result.hours).assertEqual(4);\n expect(result.minutes).assertEqual(15);\n expect(result.sec).assertEqual(15);\n });\n\n // test_start_time_later_than_end_time\n it('reverse_time_difference', { timeout: 5000 }, () => {\n const result = calculateDuration(\"2025-09-06 10:00:00\", \"2025-09-05 09:30:00\");\n expect(result.days).assertEqual(1);\n expect(result.hours).assertEqual(0);\n expect(result.minutes).assertEqual(30);\n });\n\n // test_exactly_coinciding_time_points\n it('zero_interval_scenario', { timeout: 5000 }, () => {\n const result = calculateDuration(\"2025-09-04 12:00:00\", \"2025-09-04 12:00:00\");\n expect(result.days).assertEqual(0);\n expect(result.hours).assertEqual(0);\n expect(result.minutes).assertEqual(0);\n expect(result.sec).assertEqual(0);\n });\n });\n}",
      "model_output": "import {calculateDuration} from '../main/ets/pages/TimeIntervalCalculator';\n\nexport function calculateTimeDifference(startTime: string, endTime: string): string {\n  try {\n    const [startHours, startMinutes, startSeconds] = startTime.split(':').map(Number);\n    const [endHours, endMinutes, endSeconds] = endTime.split(':').map(Number);\n    \n    if (startHours < 0 || startHours > 23 || endHours < 0 || endHours > 23 ||\n        startMinutes < 0 || startMinutes > 59 || endMinutes < 0 || endMinutes > 59 ||\n        startSeconds < 0 || startSeconds > 59 || endSeconds < 0 || endSeconds > 59) {\n      return '';\n    }\n    \n    let diffHours = endHours - startHours;\n    let diffMinutes = endMinutes - startMinutes;\n    let diffSeconds = endSeconds - startSeconds;\n    \n    if (diffSeconds < 0) {\n      diffSeconds += 60;\n      diffMinutes--;\n    }\n    \n    if (diffMinutes < 0) {\n      diffMinutes += 60;\n      diffHours--;\n    }\n    \n    if (diffHours < 0) {\n      return '';\n    }\n    \n    const formattedHours = diffHours.toString().padStart(2, '0');\n    const formattedMinutes = diffMinutes.toString().padStart(2, '0');\n    const formattedSeconds = diffSeconds.toString().padStart(2, '0');\n    \n    return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;\n  } catch (e) {\n    return '';\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Given two numbers representing running distance in kilometers (distance) and total time in seconds (totalTime), write a function calculatePaceAndLevel using ArkTS that returns a 2-element Array<any> where the first element is a string representing pace in the format MM:SS (minutes:seconds per kilometer) and the second element is a string indicating the performance level (one of Excellent, Good, Average, Needs Improvement). The pace is calculated as totalTime divided by distance, converted to minutes and seconds. The level criteria are: pace ≤ 3:30 → Excellent; 3:31-4:30 → Good; 4:31-6:00 → Average; >6:00 → Needs Improvement. You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle invalid inputs (e.g., non-positive distance or totalTime) by returning ['',' Invalid Input'].",
      "code": "interface GeneratedTypeLiteralInterface_1 {\n paceMinutes: number;\n paceSeconds: number;\n paceString: string;\n level: string;\n}\n\nexport function calculatePaceAndLevel(distance: number, timeMinutes: number): GeneratedTypeLiteralInterface_1 {\n // validate_input\n if (distance <= 0 || timeMinutes <= 0) {\n throw new Error(\"distance_and_time_must_be_positive_numbers\");\n }\n\n // calculate_total_seconds\n const totalSeconds = timeMinutes * 60;\n // calculate_total_seconds_per_kilometer\n const paceTotalSeconds = totalSeconds / distance;\n\n // convert_to_minutes_and_seconds\n const paceMinutes = Math.floor(paceTotalSeconds / 60);\n const paceSeconds = Math.round(paceTotalSeconds % 60);\n\n // determine_pace_level\n let level: string;\n if (paceTotalSeconds > 420) { // more_than_7_minutes_(420_seconds)\n level = \"amateur\";\n } else if (paceTotalSeconds > 300) { // 5-7_minutes_(300-420_seconds)\n level = \"advanced\";\n } else { // less_than_5_minutes_(under_300_seconds)\n level = \"professional\";\n }\n\n return {\n paceMinutes,\n paceSeconds,\n paceString: ${paceMinutes}minutes${paceSeconds}seconds/kilometer,\n level\n };\n}\n\n// display_result\nexport function displayResult(distance: number, timeMinutes: number) {\n try {\n const result = calculatePaceAndLevel(distance, timeMinutes);\n console.log(running_distance：${distance}kilometers，time_spent：${timeMinutes}minutes);\n console.log(pace：${result.paceString});\n console.log(pace_level：${result.level});\n } catch (e) {\n console.error(error：${e.message});\n }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { calculatePaceAndLevel } from '../main/ets/pages/RunningPaceCalculator';\nexport default function runningPaceTest() {\n describe('runningPaceTest', () => {\n // test_professional_level_pace\n it('professional_level_pace_scenario', { timeout: 5000 }, () => {\n const result = calculatePaceAndLevel(10, 50);\n expect(result.paceMinutes).assertEqual(5);\n expect(result.paceSeconds).assertEqual(0);\n expect(result.level).assertEqual(\"professional\");\n });\n\n // test_advanced_level_pace\n it('advanced_level_pace_scenario', { timeout: 5000 }, () => {\n const result = calculatePaceAndLevel(5, 30);\n expect(result.paceMinutes).assertEqual(6);\n expect(result.paceSeconds).assertEqual(0);\n expect(result.level).assertEqual(\"advanced\");\n });\n\n // test_abnormal_input_scenario\n it('illegal_parameter_detection', { timeout: 5000 }, () => {\n try {\n calculatePaceAndLevel(-5, 30);\n } catch (e) {\n expect(e.message).assertEqual(\"distance_and_time_must_be_positive_numbers\");\n }\n });\n });\n}",
      "model_output": "import {Array, Object} from '@kit.ArkTS';\n\nexport function calculatePaceAndLevel(distance: number, totalTime: number): [string, string] {\n  if (distance <= 0 || totalTime <= 0) {\n    return ['',' Invalid Input'];\n  }\n  \n  const paceSeconds = Math.floor(totalTime / distance);\n  const paceMinutes = Math.floor(paceSeconds / 60);\n  const paceSecondsRemaining = paceSeconds % 60;\n  \n  let paceString = `${paceMinutes}:${paceSecondsRemaining.toString().padStart(2, '0')}`;\n  \n  let level: string;\n  if (paceSeconds <= 210) {\n    level = \"professional\";\n  } else if (paceSeconds <= 270) {\n    level = \"advanced\";\n  } else if (paceSeconds <= 360) {\n    level = \"intermediate\";\n  } else {\n    level = \"beginner\";\n  }\n  \n  return [paceString, level];\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a string inputText (which can be empty), write a function convertToUpperCase using ArkTS that returns a new string where all lowercase letters (a-z) in the inputText are converted to uppercase letters (A-Z), while non-lowercase characters (such as uppercase letters, numbers, symbols, and spaces) remain unchanged. For example, inputting Hello World! 123 should return HELLO WORLD! 123. You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle an empty input string by returning an empty string, and ensure no modification to the original input string (i.e., implement it as a pure function).",
      "code": "export function convertToUppercase(text: string): string {\n // convert_using_built-in_toUpperCase()method\n return text.toUpperCase();\n}\n\n// manually_implement_conversion_logic(without_relying_on_built-in_methods)\nexport function manualConvertToUppercase(text: string): string {\n let result = \"\";\n for (let i = 0; i < text.length; i++) {\n const char = text.charAt(i);\n // check_if_it_is_a_lowercase_letter_(a-z)\n if (char >= 'a' && char <= 'z') {\n // convert_to_uppercase_letter_(ASCII_code_differs_by_32)\n result += String.fromCharCode(char.charCodeAt(0) - 32);\n } else {\n // directly_retain_non-lowercase_letters\n result += char;\n }\n }\n return result;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { convertToUppercase, manualConvertToUppercase } from '../main/ets/pages/LowercaseToUppercase';\nexport default function stringConversionTest() {\n describe('stringConversionTest', () => {\n // test_regular_lowercase_letter_conversion\n it('regular_conversion_scenario', { timeout: 5000 }, () => {\n const input = \"hello world\";\n expect(convertToUppercase(input)).assertEqual(\"HELLO WORLD\");\n expect(manualConvertToUppercase(input)).assertEqual(\"HELLO WORLD\");\n });\n\n // test_scenario_containing_special_characters\n it('special_character_scenario', { timeout: 5000 }, () => {\n const input = \"a1b@test.com\";\n expect(convertToUppercase(input)).assertEqual(\"A1B@TEST.COM\");\n expect(manualConvertToUppercase(input)).assertEqual(\"A1B@TEST.COM\");\n });\n\n // test_empty_string_scenario\n it('empty_value_detection_scenario', { timeout: 5000 }, () => {\n expect(convertToUppercase(\"\")).assertEqual(\"\");\n expect(manualConvertToUppercase(\"\")).assertEqual(\"\");\n });\n });\n}",
      "model_output": "import {ArkTS} from '@kit.ArkTS';\n\nexport function convertToUppercase(inputText: string): string {\n  return inputText.toUpperCase();\n}\n\nexport function manualConvertToUppercase(inputText: string): string {\n  let result = '';\n  for (let i = 0; i < inputText.length; i++) {\n    const char = inputText.charAt(i);\n    const ascii = char.charCodeAt(0);\n    if (ascii >= 97 && ascii <= 122) {\n      result += String.fromCharCode(ascii - 32);\n    } else {\n      result += char;\n    }\n  }\n  return result;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a string inputStr and an integer indexN, write a function getNthCharacter using ArkTS that returns a string representing the nth character of the input string. Note that the index starts from 0 (i.e., indexN=0 refers to the first character of the string). For example, inputting inputStr=ArkTS and indexN=2 should return k. You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle invalid inputs (e.g., inputStr is empty, indexN < 0, or indexN >= inputStr.length) by returning an empty string.",
      "code": "export function convertToUppercase(text: string): string {\n // convert_using_built-in_toUpperCase()method\n return text.toUpperCase();\n}\n\n// manually_implement_conversion_logic(without_relying_on_built-in_methods)\nexport function manualConvertToUppercase(text: string): string {\n let result = \"\";\n for (let i = 0; i < text.length; i++) {\n const char = text.charAt(i);\n // check_if_it_is_a_lowercase_letter_(a-z)\n if (char >= 'a' && char <= 'z') {\n // convert_to_uppercase_letter_(ASCII_code_differs_by_32)\n result += String.fromCharCode(char.charCodeAt(0) - 32);\n } else {\n // directly_retain_non-lowercase_letters\n result += char;\n }\n }\n return result;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { getNthCharacter } from '../main/ets/pages/GetNthCharacter';\nexport default function characterIndexTest() {\n describe('characterIndexTest', () => {\n // test_regular_valid_index_scenario\n it('regular_index_scenario', { timeout: 5000 }, () => {\n expect(getNthCharacter(\"abcde\", 3)).assertEqual(\"c\");\n });\n\n // test_boundary_index_scenario\n it('boundary_value_detection', { timeout: 5000 }, () => {\n expect(getNthCharacter(\"hello\", 1)).assertEqual(\"h\");\n expect(getNthCharacter(\"hello\", 5)).assertEqual(\"o\");\n });\n\n // test_abnormal_parameter_scenario\n it('illegal_parameter_detection', { timeout: 5000 }, () => {\n expect(getNthCharacter(\"test\", 0)).assertNull();\n expect(getNthCharacter(\"test\", 5)).assertNull();\n expect(getNthCharacter(\"\", 1)).assertNull();\n });\n });\n}",
      "model_output": "import { GetNthCharacter } from '../main/ets/pages/GetNthCharacter';\n\nexport function getNthCharacter(inputStr: string, indexN: number): string {\n  if (inputStr === \"\" || indexN < 0 || indexN >= inputStr.length) {\n    return \"\";\n  }\n  return inputStr[indexN];\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a year (as a positive integer), a month (as a positive integer, ranging from 1 to 12), and a day (as a positive integer, ranging from 1 to the maximum valid day of the given month), write a function getDayOfYear using ArkTS that returns the day of the year corresponding to the input date (e.g., inputting 2024, 2, 29 should return 60, inputting 2023, 3, 1 should return 60). The function should handle leap years correctly (a year is a leap year if it is divisible by 4 but not by 100, unless it is also divisible by 400). You must use ArkTS-specific syntax and structures, including proper type annotations. If the input date is invalid (e.g., 2023, 2, 30), the function should return -1 to indicate an invalid date.",
      "code": "export function getDayOfYear(dateString: string): number {\n // directly_use_global_Date_object_to_parse_date\n const date = new Date(dateString);\n\n // get_the_year_of_the_current_date\n const year = date.getFullYear();\n\n // create_a_date_object_for_the_first_day_of_the_year\n const startOfYear = new Date(${year}-01-01);\n\n // calculate_the_time_difference_between_two_dates_in_milliseconds\n const timeDifference = date.getTime() - startOfYear.getTime();\n\n // convert_to_days_and_add_1_to_include_the_current_day\n const dayOfYear = Math.floor(timeDifference / (1000 * 60 * 60 * 24)) + 1;\n\n return dayOfYear;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { getDayOfYear } from '../main/ets/pages/getDayOfYear';\nexport default function getDayOfYearTest() {\n describe('getDayOfYear_Test', () => {\n it('2025-01-01_should_return_1', 0, () => {\n const result = getDayOfYear(\"2025-01-01\");\n expect(result).assertEqual(1);\n });\n it('2024-12-31_should_return_366', 0, () => {\n const result = getDayOfYear(\"2024-12-31\");\n expect(result).assertEqual(366);\n });\n it('2025-08-29_should_return_241', 0, () => {\n const result = getDayOfYear(\"2025-08-29\");\n expect(result).assertEqual(241);\n });\n it('2025-12-31_should_return_365', 0, () => {\n const result = getDayOfYear(\"2025-12-31\");\n expect(result).assertEqual(365);\n });\n });\n}",
      "model_output": "import {calendar} from '@kit.CalendarKit';\ntype DayOfYear = calendar.DayOfYear;\n\nexport function getDayOfYear(date: string): DayOfYear {\n  const parts = date.split('-');\n  if (parts.length!== 3) {\n    return -1;\n  }\n  const year = parseInt(parts[0]);\n  const month = parseInt(parts[1]);\n  const day = parseInt(parts[2]);\n  \n  if (isNaN(year) || isNaN(month) || isNaN(day)) {\n    return -1;\n  }\n  \n  if (month < 1 || month > 12 || day < 1) {\n    return -1;\n  }\n  \n  const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  if ((year % 4 === 0 && year % 100!== 0) || year % 400 === 0) {\n    daysInMonth[1] = 29;\n  }\n  \n  if (day > daysInMonth[month - 1]) {\n    return -1;\n  }\n  \n  let dayOfYear = day;\n  for (let i = 0; i < month - 1; i++) {\n    dayOfYear += daysInMonth[i];\n  }\n  \n  return dayOfYear;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a number num in scientific notation (e.g., \"1.23e5\" or -3.4e-2), write a function expandScientific in ArkTS that converts it to its full decimal representation as a string (e.g., \"123000\" or \"-0.034\"). The function should handle both positive and negative numbers and both positive and negative exponents. Use basic string and number manipulation without relying on libraries like BigDecimal.",
      "code": "export function fullNum(num: string | number): string {\n  const str = String(num).toLowerCase();\n  const numb = Number(num);\n  if (isNaN(numb)) return String(num);\n  if (!str.includes('e')) return String(num);\n  const isNegative = str.startsWith('-');\n  const parts = str.replace('-', '').split('e');\n  const base = parts[0];\n  const exponent = parts[1];\n  const expNum = Number(exponent);\n  const digits = base.replace('.', '');\n  const decimalPos = base.indexOf('.') === -1 ? digits.length : base.indexOf('.');\n  let result = '';\n  if (expNum >= 0) {\n    result = digits.padEnd(decimalPos + expNum, '0');\n  } else {\n    const absExp = Math.abs(expNum);\n    const zerosNeeded = absExp - decimalPos;\n    if (zerosNeeded > 0) {\n      result = '0.' + '0'.repeat(zerosNeeded) + digits;\n    } else {\n      const pointPos = decimalPos - absExp;\n      result = digits.slice(0, pointPos) + '.' + digits.slice(pointPos);\n    }\n  }\n  return isNegative ? '-' + result : result;\n}",
      "test": "import { fullNum } from '../main/ets/function/fun3'\nimport { describe, it, expect } from '@ohos/hypium';\nexport default function testfUllNum() {\n  describe('fullNum', () => {\n\n    it('should return original string if not a number', 0, () => {\n      const input = 'hello'\n      const result = fullNum(input)\n      expect(result).assertEqual('hello')\n    })\n\n    it('should format number with positive exponent correctly', 0, () => {\n      const input = '12e2'\n      const result = fullNum(input)\n      expect(result).assertEqual('1200')\n    })\n\n    it('should format number with negative exponent correctly', 0, () => {\n      const input = '-4.5e-2'  // -0.045\n      const result = fullNum(input)\n      expect(result).assertEqual('-0.045')\n    })\n  })\n}\n",
      "model_output": "import {fullNum} from '../main/ets/function/fun3'\n\nexport function expandScientific(num: string): string {\n  if (!num.includes('e')) {\n    return num\n  }\n  const [coeff, exponent] = num.split('e')\n  const exp = parseInt(exponent)\n  const sign = coeff[0] === '-'? '-' : ''\n  let decimal = coeff.replace('.', '').replace('-', '')\n  if (exp >= 0) {\n    decimal = decimal.padEnd(exp + decimal.length, '0')\n  } else {\n    decimal = decimal.padStart(decimal.length - exp, '0')\n    decimal = decimal.slice(0, decimal.length + exp)\n  }\n  const dotIndex = decimal.length - exp\n  if (dotIndex <= 0) {\n    return sign + '0.' + '0'.repeat(-dotIndex) + decimal\n  } else {\n    return sign + decimal.slice(0, dotIndex) + '.' + decimal.slice(dotIndex)\n  }\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a string content, write a function isPalindromicString using ArkTs code that returns a boolean indicating whether the string is a palindrome (reads the same forwards and backwards). The function should compare characters from the start and end moving towards the center, and return false as soon as a mismatch is found. Return true if no mismatches exist or the string is empty.",
      "code": "export function isPalindromicString(content: string): boolean {\n  let result: boolean = true\n  let i: number = 0\n  let j: number = content.length - 1\n  while (i <= j) {\n    if (content.charAt(i) != content.charAt(j)) {\n      result = false\n      break\n    }\n    i++\n    j--\n  }\n  return result\n\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { isPalindromicString } from '../main/ets/function/fun3';\n\nexport default function testIsPalindromicString() {\n  describe('isPalindromicString', () => {\n    it('should return true for palindrome string \"level\"', 0, () => {\n      const result = isPalindromicString('level');\n      expect(result).assertTrue();\n    });\n\n    it('should return false for non-palindrome string \"hello\"', 0, () => {\n      const result = isPalindromicString('hello');\n      expect(result).assertFalse();\n    });\n\n    it('should return true for empty string', 0, () => {\n      const result = isPalindromicString('');\n      expect(result).assertTrue();\n    });\n  });\n}\n",
      "model_output": "import { isPalindromicString } from '../main/ets/function/fun3';\n\nexport function isPalindromicString(content: string): boolean {\n  let left = 0;\n  let right = content.length - 1;\n  while (left < right) {\n    if (content.charAt(left)!== content.charAt(right)) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given two positive integers totalHeads (representing the total number of heads) and totalLegs (representing the total number of legs), write a function solveChickenRabbitProblem using ArkTS that returns a 2-element Array<number> where the first element is the number of chickens and the second element is the number of rabbits. The solution must satisfy the constraints: each chicken has 1 head and 2 legs, each rabbit has 1 head and 4 legs, and the total number of animals equals totalHeads. For example, inputting totalHeads=35 and totalLegs=94 should return [23, 12]. You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle invalid inputs (e.g., non-positive values, no valid solution) by returning [-1, -1].",
      "code": "interface GeneratedTypeLiteralInterface_1 {\n chickens: number;\n rabbits: number;\n valid: boolean;\n message: string;\n}\n\nexport function solveChickenRabbit(heads: number, feet: number): GeneratedTypeLiteralInterface_1 {\n // verify_input_validity\n if (heads <= 0 || feet <= 0) {\n return {\n chickens: 0,\n rabbits: 0,\n valid: false,\n message: \"the_number_of_heads_and_feet_must_be_positive_numbers\"\n };\n }\n\n if (feet % 2 !== 0) {\n return {\n chickens: 0,\n rabbits: 0,\n valid: false,\n message: \"the_number_of_feet_must_be_an_even_number\"\n };\n }\n\n if (feet < 2 * heads) {\n return {\n chickens: 0,\n rabbits: 0,\n valid: false,\n message: \"too_few_feet_unrealistic_situation\"\n };\n }\n\n if (feet > 4 * heads) {\n return {\n chickens: 0,\n rabbits: 0,\n valid: false,\n message: \"too_many_feet_unrealistic_situation\"\n };\n }\n\n // calculate_the_number_of_chickens_and_rabbits\n const rabbits = (feet - 2 * heads) / 2;\n const chickens = heads - rabbits;\n\n // verify_if_the_result_is_a_non-negative_integer\n if (rabbits >= 0 && chickens >= 0 && rabbits % 1 === 0 && chickens % 1 === 0) {\n return {\n chickens: chickens,\n rabbits: rabbits,\n valid: true,\n message: calculation_successful:_there_are_${chickens}_chickens_and_${rabbits}_rabbits\n };\n } else {\n return {\n chickens: 0,\n rabbits: 0,\n valid: false,\n message: \"no_valid_integer_solution\"\n };\n }\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { solveChickenRabbit } from '../main/ets/ChickenRabbitSolver';\nexport default function chickenRabbitTest() {\n describe('ChickenRabbitSolver', () => {\n // test_classic_chicken_rabbit_cage_problem\n it('normal_calculation', { timeout: 5000 }, () => {\n const result = solveChickenRabbit(10, 32);\n expect(result.valid).assertTrue();\n expect(result.chickens).assertEqual(4);\n expect(result.rabbits).assertEqual(6);\n });\n\n // test_abnormal_scenario_with_zero_heads\n it('invalid_number_of_heads', { timeout: 5000 }, () => {\n const result = solveChickenRabbit(0, 20);\n expect(result.message).assertContain(\"positive_numbers\");\n });\n\n // test_foot_count_exceeding_limit_scenario\n it('excessive_number_of_feet', { timeout: 5000 }, () => {\n const result = solveChickenRabbit(5, 30);\n expect(result.message).assertContain(\"too_many\");\n });\n });\n}",
      "model_output": "import {ChickenRabbitSolver} from '../main/ets/ChickenRabbitSolver';\n\nexport function solveChickenRabbit(totalHeads: number, totalLegs: number): {chickens: number, rabbits: number, valid: boolean, message?: string} {\n  if (totalHeads <= 0 || totalLegs <= 0) {\n    return {chickens: -1, rabbits: -1, valid: false, message: 'positive_numbers'};\n  }\n  \n  const chickens = (totalLegs - 2 * totalHeads) / 2;\n  const rabbits = totalHeads - chickens;\n  \n  if (chickens < 0 || rabbits < 0) {\n    return {chickens: -1, rabbits: -1, valid: false, message: 'too_many'};\n  }\n  \n  return {chickens, rabbits, valid: true};\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a string initialTime in the format \"HH:MM\" (24-hour format) and a non-negative integer minutesToAdd, write a function addMinutesToTime using ArkTS that returns a string representing the resulting time in the same \"HH:MM\" format after adding the specified minutes. For example, inputting initialTime=\"23:45\" and minutesToAdd=30 should return \"00:15\". You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle invalid initialTime formats (e.g., hours > 23, minutes > 59) by returning an empty string.",
      "code": "export function addMinutesToTime(initialTime: string, minutesToAdd: number): string {\n if (!/^\\d{1,2}:\\d{2}\\(/.test(initialTime)) {\n    throw new Error(\"time_format_must_be_HH:MM\");\n  }\n\n  const timeParts = initialTime.split(':');\n  if (timeParts.length !== 2) {\n    throw new Error(\"time_string_needs_to_contain_a_single_colon_separator\");\n  }\n  const hoursStr: string = timeParts[0] as string;\n  const minutesStr: string = timeParts[1] as string;\n  \n  const hours = parseInt(hoursStr, 10);\n  const minutes = parseInt(minutesStr, 10);\n\n  if (isNaN(hours) || hours < 0 || hours > 23) {\n    throw new Error(\"invalid_hour_value_(range:_0-23)\");\n  }\n\n  if (isNaN(minutes) || minutes < 0 || minutes > 59) {\n    throw new Error(\"invalid_minute_value_(range:_0-59)\");\n  }\n\n  if (minutesToAdd < 0) {\n    throw new Error(\"minutes_cannot_be_negative\");\n  }\n  \n  let totalMinutes = hours * 60 + minutes + minutesToAdd;\n  totalMinutes = totalMinutes % (24 * 60);\n  \n  const newHours = Math.floor(totalMinutes / 60);\n  const newMinutes = totalMinutes % 60;\n\n  return `\\){String(newHours).padStart(2, '0')}:${String(newMinutes).padStart(2, '0')}`;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { addMinutesToTime } from '../main/ets/pages/TimeCalculator';\nexport default function timeCalculatorTest() {\n describe('TimeCalculator', () => {\n // test_normal_time_addition\n it('regular_time_calculation', { timeout: 5000 }, () => {\n const result = addMinutesToTime('12:30', 40);\n expect(result).assertEqual('13:10');\n });\n\n // test_cross_midnight_scenario\n it('cross_24-hour_calculation', { timeout: 5000 }, () => {\n const result = addMinutesToTime('23:45', 30);\n expect(result).assertEqual('00:15');\n });\n\n // test_whole_hour_carryover\n it('whole_hour_carryover', { timeout: 5000 }, () => {\n const result = addMinutesToTime('10:00', 60);\n expect(result).assertEqual('11:00');\n });\n\n // test_invalid_input_scenario\n it('invalid_minute_value_check', { timeout: 5000 }, () => {\n try {\n addMinutesToTime('09:30', -10);\n } catch (err) {\n expect(err.message).assertContain(\"negative\");\n }\n });\n });\n}",
      "model_output": "import { TimeCalculator } from '@kit.ArkTS';\n\nexport function addMinutesToTime(initialTime: string, minutesToAdd: number): string {\n  const timeParts = initialTime.split(':');\n  const hours = parseInt(timeParts[0], 10);\n  const minutes = parseInt(timeParts[1], 10);\n\n  if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {\n    return '';\n  }\n\n  const totalMinutes = (hours * 60) + minutes + minutesToAdd;\n  const newHours = Math.floor(totalMinutes / 60);\n  const newMinutes = totalMinutes % 60;\n\n  const formattedHours = newHours < 10? `0${newHours}` : `${newHours}`;\n  const formattedMinutes = newMinutes < 10? `0${newMinutes}` : `${newMinutes}`;\n\n  return `${formattedHours}:${formattedMinutes}`;\n}",
      "test_passed": false
    },
    {
      "instruction": "Given a non-negative integer n (where n = 0 corresponds to the first term of the Fibonacci sequence), write a function getNthFibonacci using ArkTS that returns a number representing the nth term of the Fibonacci sequence. The Fibonacci sequence follows the rule: F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1. For example, inputting n=5 should return 5 (since the sequence is 0, 1, 1, 2, 3, 5...). You must use ArkTS-specific syntax and structures, including proper type annotations. The function should handle invalid inputs (e.g., negative n) by returning -1.",
      "code": "export function fibonacci(n: number): number {\n // input_validation\n if (n < 0) {\n throw new Error(\"n_must_be_a_non-negative_integer\");\n }\n\n // base_cases\n if (n === 0) return 0;\n if (n === 1) return 1;\n\n // iterative_calculation\n let prevPrev = 0; // (n-2)th_term\n let prev = 1; // (n-1)th_term\n let current = 0; // current_term\n\n for (let i = 2; i <= n; i++) {\n current = prevPrev + prev;\n prevPrev = prev;\n prev = current;\n }\n\n return current;\n}",
      "test": "import { describe, it, expect } from '@ohos/hypium';\nimport { fibonacci } from '../main/ets/pages/Fibonacci';\nexport default function fibonacciTest() {\n describe('Fibonacci', () => {\n // test_basic_sequence_calculation\n it('basic_term_verification', { timeout: 5000 }, () => {\n expect(fibonacci(0)).assertEqual(0);\n expect(fibonacci(1)).assertEqual(1);\n });\n\n // test_normal_sequence_calculation\n it('regular_term_calculation', { timeout: 5000 }, () => {\n expect(fibonacci(5)).assertEqual(5);\n });\n\n // test_large_number_calculation\n it('large_number_verification', { timeout: 5000 }, () => {\n expect(fibonacci(10)).assertEqual(55);\n });\n\n });\n}",
      "model_output": "import {fibonacci} from '../main/ets/pages/Fibonacci';\n\nexport function getNthFibonacci(n: number): number {\n  if (n < 0) {\n    return -1;\n  }\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  let a = 0;\n  let b = 1;\n  let c = a + b;\n  for (let i = 2; i <= n; i++) {\n    a = b;\n    b = c;\n    c = a + b;\n  }\n  return c;\n}",
      "test_passed": false
    }
  ]
}